TCP/IP   指南

[TOC]

------



## 第二节、TCP/IP 底层核心协议

TCP/IP协议套件在很大程度上是根据构成它的协议来定义的；本指南中涵盖了几十个协议。该套协议的大多数关键协议在OSI参考模型的较低层发挥作用：第2、3和4层，对应于TCP/IP模型结构中的网络接口、互联网和传输层。这里包括第3层的重要的互联网协议（IP）和第4层的传输控制协议（TCP），它们共同构成了TCP/IP的名称。

由于这些协议和其他低层的TCP/IP协议的重要性，这是《TCP/IP指南》中最大的一章。它包含四个小节。第一部分描述了位于网络接口层的两个TCP/IP协议，即OSI模型的第2层。PPP和SLIP。第二部分描述了在结构上位于第2和第3层之间的几个 "特殊 "协议：ARP和RARP。第三部分涵盖了TCP/IP互联网层（OSI网络层，第3层），包括IP和其他几个相关和支持的协议。第四部分介绍了TCP/IP传输层协议TCP和UDP。

**背景资料:** 关于TCP/IP协议套件的高层部分对其进行了一般性描述，并阐述了其架构和关键协议。如果你还没有读过它，我强烈建议你在进行这里的内容之前考虑这样做。

### **第一章、TCP/IP网络接口层（OSI数据链路层）协议**

OSI参考模型的最低层是物理层，它负责在网络上将信息从一个地方传输到另一个地方的 "细枝末节 "的细节。在物理层之上的一层是数据链路层，在TCP/IP架构模型中称为网络接口层或只是链路层。它的主要工作是在本地实现网络，并在面向硬件的物理层和更抽象的、面向软件的网络层及其上面的功能之间建立接口。

在本节中，我将对TCP/IP协议套件中位于数据链路或网络接口层的两个协议进行描述。这两个协议是串行线互联网协议（SLIP）和点对点协议（PPP）。它们都将在本节下面的一个小节中讨论。(本节只包含一个小节的原因是，TCP/IP指南是一个更大的网络参考资料的一部分，它包含了这一层的更多技术和协议的内容）。

#### 1.1 TCP/IP 串行线路互联网协议 (SLIP) 和点对点协议 (PPP)

TCP/IP协议套件是围绕着互联网协议（IP）构建的。IP在OSI参考模型的第三层运行，并假定它将被分层在现有的第二层技术之上。然而，存在某些类型的连接，不包括IP可以运行的第二层协议。为了使TCP/IP能够在这些类型的链接上运行，已经创建了两个特殊的TCP/IP数据链接层协议。

在本节中，我描述了专门用于实现TCP/IP网络的数据链路层连接的协议。我首先简要介绍了用于在第二层连接设备的两个协议，以及它们是如何融入整个TCP/IP协议套件的。然后，我有一个单独的主题，描述了相当简单的串行线互联网协议（SLIP）的操作，以及一个关于能力更强的点对点协议（PPP）的综合章节。

**背景信息:** 我想再次强调，IP实际上是TCP/IP协议套件的基础，尽管SLIP和PPP处于较低的结构层。出于这个原因，我强烈建议在进行本节内容之前，至少要对互联网协议有一个基本的了解。如果你打算同时阅读IP和SLIP/PPP，我建议先阅读IP。

##### 1.1.1 SLIP和PPP概述及在TCP/IP中的作用（第1-2部分）

TCP/IP协议套件通常被设计为提供从网络层（第三层）及以上的网络堆栈的实现。TCP/IP的核心协议在OSI模型的第三和第四层运行，对应于TCP/IP架构模型的互联网层和主机到主机传输层。其他支持协议也定义在这两层，许多应用协议也在这里运行，并在协议栈的上层运行。

然而，TCP/IP架构模型还定义了网络接口层，它相当于OSI方案中的数据链路层（第二层）。在大多数经典网络中，TCP/IP并没有定义任何在这一层操作的协议。**TCP/IP假定第二层的功能是由广域网或局域网技术提供的，如以太网、令牌环或IEEE 802.11。这些技术负责经典的第二层功能：物理层寻址、媒体访问控制，特别是对从第三层收到的数据报进行第二层构架。**

**注意：**我现在忽略了ARP和RARP协议，因为它们属于 "灰色地带"，我在涉及它们的章节中讨论。

**为什么TCP/IP需要网络接口层协议？** 关于IP可以运行在现有的第二层协议之上的假设有一个问题：有时并没有一个协议。有一些技术只在物理层建立基本的、低层次的连接。这方面最常见的例子是两个设备之间建立的简单串行连接。几年前，两台计算机只是使用串行端口连接，而不是使用成熟的局域网协议，这是相当普遍的。今天，我们看到这种情况要少得多，但有另一种类型的串行连接非常流行：串行拨号网络。当你使用调制解调器连接到互联网服务提供商的调制解调器时，调制解调器协商的连接在结构上只存在于物理层。

由于互联网协议假定某些服务将在第二层提供，因此没有办法使它直接在串行线或其他物理层连接上运行。至少需要的最重要的第二层功能是为传输的IP数据报建立一些机制，即提供必要的数据包装，让数据报在物理层网络上传输。没有这一点，IP数据报就不能在链路上发送。

**TCP/IP网络接口层协议。SLIP和PPP** 我们需要一些东西来 "填补 "第三层的IP和第一层的物理连接之间的空白。为此，我们定义了一对特殊的协议，它们在第二层运行，并提供IP运作所需的服务。这些协议是

- 串行线互联网协议（SLIP）:一个非常简单的第二层协议，只为IP提供基本框架。
- 点对点协议（PPP）:一个更复杂、功能齐全的数据链路层协议，提供成帧以及许多提高安全和性能的附加功能。

**ppp 或者以太网协议来处理二层通信**

**比较SLIP和PPP**

SLIP和PPP都是为两个设备之间的连接而设计的；因此PPP被称为 "点对点 "协议。它们用于端口拓扑结构的LAN或WAN连接，是最简单的类型。由于只有两个设备，即A和B，通信是直接的。由于它们只处理简单的两台设备的连接，它们不必担心复杂的问题，如媒体访问控制，或碰撞，或独特的寻址方案，像以太网等技术必须这样做。如前所述，这些协议的主要重点是为第三层提供成帧服务，以及根据需要提供额外功能。

在[点对点链路](https://zh.wikipedia.org/wiki/点对点协议)中不使用ARP，实际上在点对点网络中也不使用MAC地址，因为在此类网络中分别已经获取了对端的IP地址。

为什么有两个协议？它们都能完成工作；区别在于它们如何完成工作。SLIP非常简单，容易实现，但缺乏PPP的功能，如认证、压缩、错误检测等。PPP功能齐全，但要复杂得多。

打个比方，SLIP是一辆基本结实的十年前的紧凑型轿车，而PPP是一辆闪亮的新豪华SUV。两者都能让你从这里到奶奶家，但SUV会更安全、更舒适，更能处理路上可能出现的问题。如果它们的购买和运营成本相同，你可能会选择SUV。SLIP和PPP的成本差不多，而且与SUV不同的是，PPP不会造成空气污染，也不耗费汽油。由于这个原因，PPP是今天大多数串行线路连接的选择，并且已经完全取代了SLIP。

**关键概念:** SLIP和PPP为直接在物理层链接上运行的TCP/IP实现提供了第二层连接，而没有第二层技术。SLIP很简单，几年前更常用，但今天PPP因其许多特性和功能而受到青睐。

**SLIP和PPP是TCP/IP的 "真正 "组成部分吗？** 顺便说一下，我应该提到有一些人甚至不认为SLIP和PPP是 "真正的 "TCP/IP协议套件的一部分。他们认为，TCP/IP实际上是在OSI模型的第三层及以上定义的，而IP本身是TCP/IP第三层的基础。因此，SLIP和PPP只是在TCP/IP下可以使用的 "额外 "协议。为了支持他们的论点，他们指出PPP可以用于IP以外的协议（这是事实）。就其本身而言，SLIP是如此简单，它可以承载任何第三层协议，但我不相信它已经为IP以外的网络层协议实现。

坦率地说，我认为这些都是 "一根针的头上有多少个天使 "式的争论。就我而言，SLIP和PPP是TCP/IP的一部分，因为它们最初是为了让TCP/IP在第一层链路上运行的特定目的而设计。它们也是通过正常的互联网RFC过程来定义的。不管它们是否是TCP/IP的一部分，它们每天都被数以百万计的人用来使TCP/IP网络运行，因此值得在本指南中占有一席之地。

##### 1.1.2 串行线互联网协议（SLIP）（部分：1 2 3）

在TCP/IP的开发过程中，很早就发现了需要数据链路层协议来让IP在串行链路上运行。研究互联网协议的工程师需要一种通过串行连接将计算机连接在一起发送IP数据报的方法。为了解决这个问题，他们创建了一个非常简单的协议，将帧IP数据报通过串行线传输。该协议称为串行线路互联网协议（Serial Line Internet protocol，简称SLIP）。

**SLIP概述和历史**

SLIP不同于大多数TCP/IP协议，因为它从未被定义为正式标准。它是在20世纪80年代早期非正式创建的，在RFC文档中描述它之前，它的使用已经作为事实上的标准传播开来。甚至当它最终于1988年出版时，就明确决定SLIP不会被指定为官方互联网标准。描述它的文章RFC 1055的作者将其命名为“串行线路上IP数据报传输的非标准：SLIP”，以确保没有人会忽视这一点。

**网上**：这只是IETF工程师们展现幽默感的几个地方之一。有关另一个有趣的示例，请参阅RFC 1313.J

为什么SLIP被指定为“非标准”而不是标准？嗯，它是作为一种非常基本的“权宜之计”来开发的，用于在需要时提供第二层框架。它如此简单，以至于没有太多东西需要标准化。此外，该协议有太多缺陷，IETF显然不希望它处于正式标准的状态。RFC 1055特别提到了SLIP的问题（我们将在下面看到），以及当时已经在进行工作，以定义一个更强大的SLIP（PPP）后继者。

SLIP有多简单？它如此简单，是本指南中为数不多的技术之一，我几乎可以完全描述它，而不必抱怨它很复杂，或者诉诸于告诉您“有关详细信息，请参阅定义文档”。SLIP只执行一个功能：传输数据的帧。它没有其他作用。

**关键概念**：SLIP为IP数据报提供第二层帧服务，没有其他特性或功能。

**SLIP基本数据成帧方法和一般操作**

以下是SLIP成帧的工作方式。一个IP数据报被传递给SLIP，SLIP将其分解成字节并在链路上一个一个地发送。在数据报的最后一个字节之后，会发送一个特殊的字节值，告诉接收设备数据报已经结束。这被称为SLIP END字符，其字节值为十进制192（十六进制C0，二进制11000000）。基本上就是这样：把整个数据报，一个字节一个字节地发送，然后发送192字节来限定数据报的结束。

对这一基本操作的一个小改进是在数据报的前面加上一个END字符。这样做的好处是，它将数据报的开始与之前的任何内容明确分开。为了理解为什么需要这样做，假设在某一特定时间我们只有一个数据报要发送，即数据报#1。因此，我们发送#1，然后发送END字符来限定它。现在，假设在下一个数据报出现之前有一个停顿。在这段时间里，我们没有发送，但如果有线路噪音，其他设备可能会在这里和那里接收到虚假的字节。如果我们后来收到第2号数据报并开始发送它，接收设备可能会认为噪声字节是第2号数据报的一部分。

以END字符开始的数据报#2告诉接收者，在这个END字符和前一个字符之间收到的任何东西都是一个单独的数据报。如果这只是噪音，那么这个 "噪音数据报 "就只是胡言乱语，会在IP层被拒绝。同时，它不会破坏我们希望发送的真正数据报。如果在数据报之间的线路上没有发生噪音，那么收件人将只看到数据报#2开头的END，紧接着#1结尾的END，并将忽略两者之间的 "空数据报"。

**转移特殊字符** SLIP只处理一个其他问题。如果END字符是十进制的192，如果字节值192出现在数据报本身，会发生什么？如果 "按原样 "传输，会使接收者认为数据报过早结束。为了避免这种情况，定义了一个特殊的Escape字符（ESC），它的十进制值为219（十六进制为DB，二进制为11011011）。术语 "逃逸 "意味着这个符号传达的意思是 "这个字节和下一个字节有特殊含义"。当数据报中出现192的值时，发送设备会用ESC字符（219的十进制）替换它，然后是220的十进制值。因此，单个 "192 "变成 "219 220"（或十六进制的 "DB DC"）。接收者将 "219 220 "翻译回 "192"。

**注意**：SLIP的ESC字符与ASCII的ESC字符不一样。它们都执行一个 "转义 "操作，但在其他方面是不相关的。

这就留下了最后一个问题：如果转义字符本身在原始数据报中会怎样？也就是说，如果要发送的IP数据报中有一个219的字节值怎么办？这可以通过一个类似的替换来处理：我们用 "219 "代替 "219 221"。

因此，综上所述，这基本上是SLIP所做的一切:

- 将IP数据报分成字节。

- 在数据报的最后一个字节之后发送END字符（值为 "192"）；在更好的实现中，在第一个字节之前也发送END字符。

- 如果数据报中要发送的任何字节是 "192"，则用 "219 220 "代替。

- 如果要发送的任何字节是 "219"，用 "219 221 "代替。
  
  **图22显示了一个使用模拟IP数据报的SLIP工作原理的例子，包括特殊字符的转义。**

![](file://D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\slip.png?msec=1668749952807)

IP数据包在第二层被传递到SLIP软件（这里显示的是一个只有五个字节的简化数据包）。在那里，它们被用END字符（十六进制值C0h，显示为橙色）包围起来。十六进制值为DBh和C0h的特殊字符被两个字节的序列取代。请注意，括号内END字符的存在迫使接收设备将噪声字节（03h，红色）视为一个单独的IP数据报，而不是真实数据报的一部分。当传递到IP层时，它将被拒绝。

**SLIP的问题和局限性**

SLIP听起来很好，对吗--漂亮而简单？不幸的是，这种简单的代价是，SLIP并没有提供我们在现代串行链路上真正需要的许多特性和功能。SLIP的一些最重要的问题包括，它在以下所有方面都存在缺陷。

- 标准化的数据报大小规范：SLIP支持的最大数据报大小没有标准化，取决于实现。通常的默认值是1006字节，它成为链路的最大传输单位（MTU）。如果使用不同的大小，必须在IP层编程。
- 错误检测/纠正机制：SLIP不提供任何检测或纠正传输错误的方法。虽然这种保护是通过IP头校验和其他机制在高层提供的，但这是一项 "传统上 "在第二层完成的工作。原因是，依靠这些高层意味着只有在整个数据报被发送并在接收方的堆栈中传回后才能检测到错误。错误纠正只能以重新发送任何被破坏的数据报的形式出现。这是低效的，特别是考虑到串行链路通常比正常的LAN链路慢得多。
- 控制信息传递:SLIP没有为两个设备提供通信控制信息的方法，以管理链接。
- 类型识别：由于SLIP不包括它自己的报头，所以不可能识别它所发送的协议。虽然是为IP开发的，但你可以看到，没有理由不使用SLIP来发送其他第三层协议。然而，如果没有类型识别，就没有办法在同一链路上混合来自两个或多个三层协议的数据报。
- 地址发现方法: 由于连接的点对点性质，在第二层不需要寻址--只有两个设备，所以每个消息的目标收件人是显而易见的。然而，设备确实需要某种方式来了解彼此的IP地址，以便在第三层进行路由。SLIP没有提供这方面的方法。
- 对压缩的支持： 压缩将提高串行线路的性能，与其它技术相比，串行线路也很慢。SLIP没有提供压缩功能。然而，请注意，调制解调器通常在第一层支持压缩，用于使用它们的串行连接。还有一个SLIP的变种，叫做压缩SLIP或CSLIP，是在20世纪80年代末创建的，但它没有像普通SLIP那样广泛部署。
- 安全特性: SLIP没有提供连接认证或数据加密的方法，这意味着甚至连基本的安全都没有提供。

听起来很糟糕，不是吗？SLIP的许多缺点导致大多数实现者从SLIP转向较新的点对点协议（PPP），这是一个更丰富的直接连接的数据链路协议，解决了上面列出的问题。SLIP现在已经过时了，有些人甚至认为它是一个历史性协议。尽管如此，SLIP仍然在许多地方被使用。简单是有吸引力的，而计算机人员的惰性是出了名的：如果某个东西已经实施并且运行良好，许多人将拒绝改变，除非他们被迫这样做。

##### 1.1.3 点对点协议（PPP）

甚至当SLIP在RFC 1055中被记录为 "非标准 "时，也在进行一项更新的协议的工作，以便在成对设备之间的直接链接上提供全功能的IP传输。结果是点对点协议（PPP），它为使用串行线或其他物理层的设备之间强大的数据链路连接定义了一个完整的方法。它包括许多能力和特性，包括错误检测、压缩、认证、加密和更多。

尽管PPP被称为 "协议"，尽管它被认为是TCP/IP的一部分--取决于你问谁--它实际上是一个协议套件，而不是一个特定的协议。正如我们将在本节中看到的那样，PPP的操作是基于许多单独协议中定义的程序。因此，PPP可以被认为是一个 "协议套件中的协议套件"。另外，其组件可以被视为PPP中的 "子协议"。

在本节中，我分四个小节全面介绍了点对点协议的运作。第一部分描述了PPP的基本原理，包括其历史、标准和一般操作的概述。第二部分解释了负责建立PPP链接和基本操作的 "核心 "协议。第三部分涵盖了用于实现PPP中各种特殊功能的协议，如压缩和加密。最后一个小节提供了关于PPP协议所使用的各种帧格式的详细信息。

**注意：**PPP的组件协议通常只被称为 "协议"，而不是 "子协议"。这很容易混淆，所以在网络文献中要注意这一点。在本节中，我试图一致地将PPP称为一个套件，但请记住，它确实经常只是统称为 "协议"。

**注意：**正如我们在本节中所看到的，PPP可以用来承载许多在第三层和以上层运行的协议的帧。然而，它最有名的是与IP一起使用，这也是本节描述的假设，除非另有说明。

**相关信息:** PPP与高层数据链路控制（HDLC）协议有关，而HDLC又是同步数据链路控制（SDLC）协议系列的一部分。我在解释PPP时避免了对SDLC协议的依赖，因为PPP的重要性和广泛使用，我认为它值得独立描述。

###### 1.1.3.1 PPP基础与操作

串行线互联网协议的问题是它太简单，没有包括足够的功能。俗话说，"小心你所希望的"，特别是当抱怨太简单的时候。J 点对点协议（PPP）纠正了SLIP缺乏功能的问题，但你不用真正尝试就可以知道代价是什么：明显地更加复杂。SLIP的操作可以用几段话来解释，而PPP则要复杂得多，包括一些需要解释的具体过程。

在讨论构成PPP的各个协议之前，我想先高屋建瓴地看看这个协议套件。我从概述、历史和讨论PPP的好处开始。我对PPP套件的主要组件进行了高层次的分解，并对PPP的运行方式进行了一般性描述。然后，我描述了设置和配置链接所涉及的步骤，以及PPP链接在其 "生命周期 "中所经历的阶段。最后，我对定义PPP功能不同方面的标准进行了分类和列表。

**注意：**我在定义PPP的标准之前描述了PPP的操作，这与本指南中大多数其他章节的顺序不同。我觉得在这种情况下，用于列出标准的分组在描述PPP套件组件及其整体运行之后会更有意义。

###### 1.1.3.1.1 PPP概述、历史和优点（第1 2 3部分）

阿尔伯特-爱因斯坦被认为有以下一句话。"一切都应该尽可能简单--但不能更简单"。串行线互联网协议（SLIP）是这个格言的一个很好的例子。它为IP提供了基本的第二层框架，但对于许多用途来说，它实在是太简单了。因为它所做的只是对每个数据报的末端进行成帧，它没有提供我们在串行链路上进行可靠、安全和高性能操作所真正需要的许多功能。当大多数串行连接不是短的LAN电缆，而是相对较长距离的拨号WAN连接时，这一点尤其真实。

**PPP的发展和标准化** SLIP基本上是一个 "黑客"，以满足一个特定的需要：在第三层的IP和第一层的串行链接之间架起桥梁。它 "完成了工作"，但没有提供我们在设备间直接链接的强大协议中真正想要的任何功能。开发PPP是为了成为一个完整的协议套件，使二层连接功能齐全，不仅支持IP，还支持其他网络层协议的传输。

PPP的历史可以追溯到20世纪80年代末，当时SLIP是串行IP实现的事实上的标准。IETF第一个与PPP有关的正式文件是1989年发表的RFC 1134。这个RFC不是标准本身，而是对最终被定义为第一个主要PPP标准的建议，即1990年的RFC 1171。这个早期的文件已经被多次修订，并增加了其他几个文件，这些文件定义了构成整个PPP套件的各种协议。本节后面将介绍PPP标准。

IETF在不重新发明轮子方面总是很聪明。与其尝试从头开始开发PPP，不如决定以ISO高级数据链路控制（HDLC）协议为基础，该协议最初由IBM开发。HDLC是同步数据链路控制（SDLC）协议的衍生产品。PPP的开发者从HDLC协议中调整了其框架结构和一些一般操作。

**PPP的一般功能和结构**

PPP是一个面向连接的协议，可以通过各种不同的物理层连接实现第二层链接。它支持同步和异步线路，并能以半双工或全双工模式运行。它被设计为承载IP流量，但其通用性足以允许任何类型的网络层数据报通过PPP连接发送。顾名思义，它适用于两个设备之间的点对点连接，并假定帧的发送和接收顺序相同。

PPP适合TCP/IP模型中的网络接口层（链接层），如图23所示。PPP的操作遵循一般操作主题中描述的特定顺序，包括一个多步骤的链接建立阶段，其中可能包括可选的认证。

![](file://D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ppplayers.png?msec=1668749952807)

 **图23:TCP/IP体系结构中的PPP位置**

PPP充当Internet协议和物理链接（如串行线或拨号网络连接）之间的接口。这对应于OSI参考模型中的第二层。

**PPP的优势和好处**

PPP的优点列表很像SLIP的缺点列表，我在关于SLIP的专题中详细解释过。与SLIP相比，PPP的一些具体优点包括。

- 与SLIP的单一END字符相比，PPP有一个更全面的成帧机制。
- 封装协议的规范，允许多个第三层协议在一个链接上复用。
- 通过在每个帧头中使用CRC码，对每个传输帧进行错误检测。
- 一个强大的机制，用于协商链路参数，包括允许的最大帧大小。
- 一种在数据报传输前测试链路的方法，并监测链路质量。
- 支持使用多种认证协议对连接进行认证。
- 支持额外的可选功能，包括压缩、加密和链路聚合（允许两个设备使用多个物理链路，就像它们是一个单一的、更高性能的链路）。

串行链路的扩散，特别是用于拨号互联网接入，导致了PPP的广泛使用。它现在是网络世界中最流行的第二层广域网技术之一，并且已经取代了SLIP，成为除传统实施方式外的所有串行连接的标准。虽然最常与拨号调制解调器的使用联系在一起，但PPP可以在任何类似类型的物理层链接中运行。例如，它经常被用来在ISDN B通道上提供第二层功能。

**关键概念：**PPP是为使用TCP/IP的设备提供的一个完整的链路层协议套件，它提供成帧、封装、认证、质量监控和其他功能，使TCP/IP在各种物理层连接上稳定运行。

**PPP的可扩展性** PPP的一个关键优势是它是一个可扩展的协议套件。多年来，新的协议已被添加到该套件中，以提供额外的特性或能力。例如，PPP的设计不是只使用一个单一的认证协议，而是允许选择为此目的使用的协议。

PPP的成功甚至导致了衍生协议的发展，如PPP over Ethernet（PPPoE）和PPP over ATM（PPPoA）。这些协议实际上是在现有的数据链路层技术上将PPP分层，这表明PPP的功能是多么有价值--即使第二层技术已经在使用，在上面应用PPP为DSL等服务提供认证和管理优势。

###### 1.1.3.1.2 PPP组件和一般操作（第12部分）

PPP是点对点协议的缩写，但即使是定义PPP的标准也立即开始描述组成它的协议，这就是为什么我认为它是一个协议套件。在最高层次上，PPP的功能可以被分解成几个组成部分。其中每一个都包含了PPP功能的一般类别，并由套件中的一个协议或一组协议来代表。

**主要的PPP组件** PPP标准本身描述了PPP的三个 "主要 "组成部分。

- PPP封装方法：PPP的主要工作是接收高层信息，如IP数据包，并对其进行封装，以便在底层物理层链接上传输。为此，PPP根据HDLC协议中使用的构架，定义了一种特殊的帧格式，用于封装数据进行传输。PPP帧被特别设计为尺寸小，只包含简单的字段，以最大限度地提高带宽效率和处理速度。
- 链接控制协议（LCP）：PPP链路控制协议（LCP）负责设置、维护和终止设备间的链接。它是一个灵活的、可扩展的协议，允许交换许多配置参数，以确保两个设备就如何使用链接达成一致。
- 网络控制协议（NCPs）：PPP支持对许多不同的第三层数据报类型进行封装。其中一些需要在激活链路前进行额外的设置。在用LCP完成一般链路设置后，控制权被传递给PPP网络控制协议（NCP），具体到PPP链路上承载的第三层协议。例如，当IP通过PPP传输时，使用的NCP是PPP互联网协议控制协议（IPCP）。其他NCP被定义为支持IPX协议、NetBIOS Frames（NBF）协议等。

PPP封装方法和LCP在主PPP标准和一些支持标准中定义；NCP在单独的标准文件中描述，每个NCP一个。

**其他PPP功能组** 虽然上述三个组件确实构成了PPP的大部分总包，但我想在标准中的组件列表中增加两个额外的功能组。这些代表了许多额外的协议，这些协议随着时间的推移被添加到套件中，以支持或增强PPP的基本操作。

- LCP支持协议：在PPP套件中包括几个协议，这些协议在链路协商过程中使用，或者用于管理它，或者用于配置选项。例子包括认证协议CHAP和PAP，它们被LCP在可选认证阶段使用。
- LCP可选功能协议：多年来，一些协议被添加到基本的PPP套件中，以增强其在链路建立和数据报在设备间传递后的操作。例如，PPP压缩控制协议（CCP）允许压缩PPP数据，PPP加密控制协议（ECP）允许对数据报进行安全加密，PPP多链路协议（PPP MP）允许在多个物理链路上运行一个PPP链接。使用这些功能往往还需要在链路协商期间进行额外的设置，因此有几个定义了扩展（如额外的配置选项），作为LCP的一部分进行协商。

这些附加协议中的每一个通常由不同的标准文件定义。你可以在PPP标准专题中找到其中一些协议的清单。

**PPP的通用操作**

PPP套件包括几十种协议，这一事实常常使人觉得它必须是一种非常复杂的技术。事实上，PPP的一般操作真的是非常简单的。所有这些PPP协议的存在使PPP具有灵活性和可扩展性，支持许多高层数据报类型和各种功能。

然而，底线是，PPP的操作只涉及三个基本步骤。从设备之间没有PPP链路的状态开始，这些是PPP中发生的操作（也在图24中说明）。

1. 链接设置和配置。在两台设备可以交换信息之前，它们必须进行接触，并在它们之间建立一个链接。在链路设置过程中，两个设备就管理链路运行所需的所有参数达成一致。LCP开始这个过程，并在需要时调用支持协议的帮助，以进行认证等选项。在链路的总体设置完成后，适当的NCP会被调用，以完成链路上的第三层技术的设置。
2. 链接操作。链路上的设备用它来发送数据报。每个设备通过采取第三层数据报进行传输，对其进行封装并将其下发到第一层进行传输。每个设备通过接收从自己的物理层发送上来的PPP帧，剥去PPP头并将数据报传递到第三层。在适当的地方，这里使用了可选的功能协议，如用于压缩的CCP。
3. 链接终止。当任何一个设备决定它不再想进行通信时，它就会终止链路。当然，如果需要，链路可以重新建立。

![](file://D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\pppoverview.png?msec=1668749952807)

 **图24：PPP运营概述**

 简单地说，PPP只包含三个基本步骤：链路设置、链路操作和链路终止。

链路设置是这些常规步骤中最复杂的，因为它涉及用于协商链路参数和选项的几个子步骤。下一主题描述链接设置中的步骤，并讨论链接在设置、使用和最终终止时所经历的阶段。

###### 1.1.3.1.3 PPP链接设置和阶段（部分：1 2 3）

在PPP连接上交换数据之前，必须在两台设备之间建立一个链接。作为这个设置任务的一部分，要进行一个配置过程，在这个过程中，两台设备要配置链路，并就它们之间如何传递数据的参数达成一致。只有在这一过程完成后，帧才能在链路上实际传递。

PPP链接配置协议（LCP）通常负责设置和维护PPP链接。当PPP被配置为使用认证时，LCP可以调用一个认证协议（PAP或CHAP）。在LCP链路被打开后，PPP为链路上传输的第三层协议调用一个或多个网络控制协议（NCPs）。这些协议在链路可以传输特定的网络层协议之前，执行任何网络层的特定配置。

PPP链路的运行可以被描述为具有某种 "生命"。就像人类出生、成长、有一个成年人的寿命，然后死亡一样，PPP链接的建立、配置、使用和最终终止。在PPP标准中，建立、使用和关闭PPP链接的过程被描述为一系列的阶段或状态。这是一种有限状态机（FSM），一种用于解释协议运行的工具。

**背景信息：**有限状态机背后的一般概念在关于传输控制协议（TCP）有限状态机的专题中有所描述。

**PPP链路阶段** 当我们谈论PPP链路的整体时，我们谈论的是两个设备之间的LCP连接的状态；同样，LCP制约着PPP的整体状态。一旦一个LCP链接被打开，链接上使用的每个NCP都可以独立于整个PPP（LCP）链接而被打开或关闭。我们马上就会看到这一点是如何运作的。

理解PPP如何工作的一个很好的方法是看这些阶段，以及在链接的有效期内从一个阶段过渡到另一个阶段的过程。为了清楚起见，本描述是基于一个例子，即设备A是一台PC，与远程主机B进行拨号网络连接（见图25）。

![](file://D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\pppphases.png?msec=1668749952807)

 **图25：PPP阶段**

两个设备之间的PPP连接从链路失效状态开始，经过三个中间阶段，直到链路完全打开，如左侧流程图所示。在终止之前，它一直处于稳定的链路打开阶段。紫色方框显示了在相位之间进行转换时PPP链接状态的相应变化。

**链接死亡阶段**

根据设计，PPP链接总是在这个阶段开始和结束。这个阶段代表了两个设备之间没有建立物理层链接的情况。它一直停留在这里，直到物理层链接建立起来，这时链接会进入链接建立阶段。

在我们的例子中，当A第一次打开时，它和B之间没有物理层连接（调制解调器连接）。 一旦连接建立起来，链路就可以进入第二阶段。（注意，在直接连接中，如连接两台PC的串行电缆，链路可能只在链路死区阶段停留几分之一秒，直到物理层连接被检测到）。

**链接建立阶段** 现在物理层已经连接，LCP执行链接的基本设置。设备A通过物理链路向设备B发送一个LCP配置请求消息，指定它希望使用的参数。如果设备B同意，它就以确认的方式回复。如果B不同意，它会发回一个否定的确认或拒绝，告诉设备A它不接受什么。然后，设备A可以用新的参数尝试一个不同的配置请求，希望设备B能接受。这个过程将在涉及LCP的主题中详细描述。

希望A和B最终会达成协议。如果是这样，链接的状态被认为是LCP开放，并将进入认证阶段。如果他们不能达成协议，物理链路就会终止，我们就会回到链路死亡阶段。

**认证阶段** 在许多情况下，一个设备在允许连接另一个设备之前可能需要认证。(当PPP用于拨号时，通常是这种情况。)然而，认证在PPP中不被认为是强制性的。当它被使用时，将采用适当的认证协议（CHAP或PAP）。

认证成功后，链接进入网络层协议阶段。如果认证不成功，链接就会失败，并过渡到链接终止阶段。

**网络层协议阶段** 一旦基本链路被配置并完成认证，LCP链路的一般设置就完成了。现在，适当的网络层协议的具体配置是通过调用适当的NCP来完成的，如IPCP、IPXCP等。

每个特定的网络层协议，其NCP被成功配置，被认为在LCP链路上是开放的。在一个特定的PPP链路上可以打开一个以上的NCP，当不再需要时，每个NCP可以独立关闭。在所有必要的NCP被调用后，链路会进入链路打开状态，即使没有成功打开。

注意：一些PPP功能需要两个设备之间协商额外的选项，就像各种网络层协议那样。这些可能在网络层协议阶段执行它们自己的链接建立过程。例如，PPP压缩控制协议（CCP）以这种方式设置了数据压缩。

**链接开放阶段** 在这种状态下，LCP链路和一个或多个NCP链路是开放的、可操作的。对于每个已成功设置的NCP，数据可以被传递。

由于各种原因，任何一个设备都可以在任何时候终止该链接。这些原因可能包括用户要求（当你想注销你的拨号会话时，你按下了 "断开 "按钮）；链接质量问题（调制解调器由于线路噪音而挂断）；或其他一些原因（你在浴室花了太多时间，你的ISP的空闲计时器把你注销了J）。当任何这些情况发生时，LCP链路就会中断，链路就会过渡到链路终止阶段。

**链路终止阶段** 终止链路的设备发送一个特殊的LCP终止帧，另一个设备确认它。然后，链路回到链路死亡阶段。在终止是通过请求而物理层连接仍然有效的情况下，PPP实现应该专门向物理层发出信号以终止第一层连接。

**区分LCP和NCP链接**

请记住，基本链接是由LCP建立的，而NCP链接是在LCP链接中设置的。关闭一个NCP链接不会导致LCP链接的关闭。即使所有的NCP都关闭了，LCP链接仍然开放。(当然，在重新建立适当的NCP链路之前，不能传递任何数据；要求设备丢弃收到的包含任何没有开放NCP的第三层协议的帧）。要终止PPP连接，只需要在链接终止阶段终止LCP链接；不需要明确关闭NCP。

**PPP链接设置和阶段总结** PPP阶段的总结可以在表24中找到。在表中，LCP链路状态和NCP链路状态列显示了该阶段开始时链路的状态。

![](file://D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\Snipaste_2022-10-06_11-44-25.jpg?msec=1668749953003)

###### 1.1.3.1.4 PPP标准（第1 2 3部分）

PPP不是一个单一的协议，而是一个由许多协议组成的套件。PPP的基本结构也被设计为允许它通过向该套件添加协议而轻松扩展。由于这两个原因，PPP的操作不是在一个单一的标准中而是在许多不同的标准中定义是有意义的。像所有的TCP/IP标准一样，PPP协议被描述在一系列的RFC中。由于需要对PPP的不同组成部分进行修改，以及新技术的加入，这些标准会定期更新。

虽然在不同的标准中涵盖PPP的不同部分是有意义的，但这确实使学习PPP的工作方式比所有东西都在一个规范中要难得多。更糟糕的是，并不是只有几个PPP标准；实际上有几十个RFC，涵盖了PPP的主要操作、各种协议和其他相关问题。你可以通过查阅RFCs的主列表并搜索 "PPP "这个字符串来找到它们中的大多数，但这样你会按数字（RFC号码）顺序找到它们，这对协议的使用情况来说意义不大。你还必须区分哪些是最新的，哪些是已经被淘汰的。

下面我描述了与PPP有关的最重要和/或最有趣的RFC。为了更容易看清RFC的内容，我把它们分成了几组。这些组大致上与我在一般操作主题中讨论的组件组相对应。在每个组中，RFC都按数字顺序排列，这也是日期顺序。只列出了最新的RFC，而没有列出被淘汰的早期的RFC（RFC 1334除外；见该条目下的注释）。

尽管这些表格的规模很大，但我甚至还没有接近列出所有与PPP有关的定义标准。顺便提一下，为了不使它变得更大（也更混乱），我没有在这里列出个别的压缩和加密算法；你可以在压缩和加密的主题中找到它们。

你可以在接下来的两节中找到关于前述表格中大多数协议的更多信息。

**基本PPP标准**

表25显示了一般性描述PPP的“主要”文件。它们涵盖了PPP的基本操作，包括PPP链路控制协议（LCP）和数据报的封装。

![](file://D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ppp-1.jpg?msec=1668749953121)

**LCP 支持协议**

这些协议（如表 26 所示）支持 LCP 的基本操作。目前我放在这个组中的唯一协议是那些在链接启动期间提供身份验证服务的协议。

![](file://D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ppp-2.jpg?msec=1668749953004)

**网络控制协议 (NCP)**

这些是协商特定于通过 PPP 承载的各种第 3 层协议的参数的协议。它们在表 27 中进行了描述。

![](file://D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ppp-3.jpg?msec=1668749953147)

**功能协议**

这些协议定义了与 PPP 一起使用的可选特性，例如压缩和加密（表 28）。

![image20221006121256340](file://C:%5CUsers%5Czy%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20221006121256340.png?msec=1668749953004)

**应用和杂项**

这些协议描述了如何调整 PPP 以在特定类型的链路上运行，或者实际上不适合上述任何其他组。它们如表 29 所示。

![](file://D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ppp-4.jpg?msec=1668749953123)

###### 1.1.3.2 PPP核心协议：链路控制、网络控制和认证

PPP协议套件由几十个协议组成，涵盖了其运行的各个方面。在这些协议中，有几个协议可以被认为是最重要的，或者说是该套件的 "核心"。并不是说其他协议不重要，请注意。但这一小组负责PPP的基本运作。特别是，它们共同实现了相对复杂的链路协商过程，这是PPP的一个重要部分。

在本节中，我描述了负责PPP链路设置和基本操作的协议。我首先描述了关键的链路控制协议（LCP）。然后我描述了不同的网络控制协议（NCP），用于为不同的第三层协议配置PPP。最后，我讨论了两个PPP认证协议，即PAP和CHAP，用于在链接设置期间提供认证。

相关信息。这些协议的帧格式在关于PPP帧和帧格式的单独章节中详细介绍。

###### 1.1.3.2.1 PPP链路控制协议（LCP）（部分：1 2 3 )

在所有不同的PPP套件协议中，最重要的一个协议是PPP链接控制协议（LCP）。LCP是PPP的 "老大"；它负责PPP的整体成功运行，并 "监督"（某种程度上）其他协议的行动。

PPP是关于链接的，而LCP是关于控制这些链接的。正如我在PPP基础部分所讨论的，PPP链路的运行可以被认为是通过各种 "生命阶段 "进行的，就像一个生物体一样。链接的生命有三个主要阶段，LCP在每个阶段都发挥着关键作用。

- 链接配置：设置和协商链路参数的过程。
- 链接维护：管理一个开放的链接的过程。
- 链接终止：当不再需要一个现有链路时（或当底层物理层连接关闭时），关闭该链路的过程。

这些功能中的每一个都与PPP链路的一个 "生命阶段 "相对应。链路配置是在链路的初始链路建立阶段进行的；链路维护发生在链路开放时，当然，链路终止发生在链路终止阶段。图26表示LCP链路的摘要，显示了LCP在PPP连接的这些不同生命阶段所执行的不同消息交换。

![](file://D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ppplcp.png?msec=1668749952809)

 **图26: PPP链路控制协议（LCP）消息交换**

该图提供了LCP在PPP连接的不同阶段所执行的许多消息交换的概述。链路配置在此显示为配置请求和配置应答的简单交换。在使用其他PPP协议验证和配置一个或多个NCP的后续交换之后，链接进入链接开放阶段。在这个例子中，首先使用Echo-Request和Echo-Reply消息来测试链路，然后由两个设备发送和接收数据。有一条数据信息由于无效的代码字段而被拒绝。最后，使用Terminat-Request和Terminat-Ack消息终止链接。

**LCP帧** 设备使用LCP来控制PPP链路，在它们之间的物理链路上发送特殊的LCP消息。这些消息被称为LCP包和LCP帧；虽然标准使用了 "包"，但术语 "帧 "是首选，因为第二层消息通常被称为帧。在PPP主文件中定义了11种不同的LCP帧类型，它们被分为三组，与上述三个链接 "生命阶段 "相对应。四个LCP帧类型用于链路配置，五个用于维护，两个用于终止。帧格式本身在关于LCP帧的主题中有所描述。下面我将分别讨论LCP的三个主要功能，以及每个功能中如何使用帧。

**关键概念:** PPP链路控制协议（LCP）是PPP套件中最重要的协议。它负责配置、维护和终止整个PPP链路。使用PPP的两个设备采用一套LCP帧来进行LCP操作。

**LCP链路配置**

链接配置可以说是LCP在PPP中做的最重要的工作。在链接建立阶段，LCP帧被交换，使两个物理连接的设备能够协商链接运行的条件。图27显示了整个过程，我们现在将详细研究这个过程。

这个过程开始于发起设备（我们称它为设备A，是的，这不是很有创意吗）创建一个配置请求帧，其中包含它希望在链路上设置的可变数量的配置选项。这基本上是设备A的 "愿望清单"，即它希望如何创建链接。

![](file://D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ppplcpnegotiation.png?msec=1668749952809)

 **图27: PPP LCP链路配置过程**

该流程图更详细地显示了为通过LCP配置链路而进行的协商过程。这个过程在PPP链路进入链路建立阶段时开始。成功配置后，连接过渡到认证阶段。

主要的PPP文件（RFC 1661）定义了一些不同的配置选项，发起人可以在这个请求中指定这些选项。这些选项中的任何一个都可以包括在内，如果是这样，就用设备A对该选项的要求所对应的值来填写。如果没有，这意味着设备A既不请求也不指定该选项。这六个选项是

1. 最大接收单位（MRU）。让设备A指定它希望链路能够承载的最大数据报尺寸。
2. 认证协议（Authentication-Protocol）。设备A可以指出它希望使用的认证协议的类型（如果有的话）。
3. 质量协议。如果设备A想在链路上启用质量监测，那么要使用什么协议（虽然目前只有一个定义：LQR）。
4. 神奇的数字。用于检测回环链接或连接中的其他异常情况。
5. 协议-字段-压缩。允许设备A指定它想在PPP数据帧中使用 "压缩的"（8位）协议字段，而不是正常的16位协议字段。这为每个PPP帧提供了少量但免费的节省（一个字节）。请注意，这与CCP提供的压缩功能没有关系。有关该功能的更多信息，请参见PPP通用帧格式主题。
6. 地址和控制字段压缩（ACFC）：与上面的选项相同，但用于压缩地址和控制字段，也是为了节省少量带宽。更多内容请参见PPP通用帧格式主题。

其他选项也可以由可选功能协议添加到这个列表中。例如，多链路PPP增加了几个必须在链路设置期间协商的选项。

另一个设备（我们称它为......设备B ）收到配置请求并处理它。然后，它有三个选择，即如何回应。

如果其中的每一个选项在各方面都可以接受，设备B会发回一个Configure-Ack（"确认"）。协商就完成了。

如果设备A发送的所有选项都是设备B认可的有效选项，并且有能力进行协商，但它不接受设备A发送的值，那么设备B就会返回一个Configure-Nak（"否定确认"）帧。该消息包括B发现不可接受的每个配置选项的副本。

如果A发送的任何选项不被B识别，或者代表了B认为不仅不可接受而且甚至不能协商的链接使用方式，那么它就会返回一个包含每个反对选项的Configure-Reject。 Configure-Nak和Configure-Reject之间的区别是，前者就像设备B说 "我不接受你的条款，但我愿意讨价还价"，而后者是设备B基本上说 "没门，Jose"。例如，如果设备A试图要求PAP作为认证协议，但设备B想使用CHAP，它将发送一个Configure-Nak。如果设备B根本不支持认证，它将发送一个配置-拒绝。

**注意：**即使在收到拒绝后，设备A也可以用新的配置请求重试协商。

**LCP链路维护**

一旦链路被协商好，LCP就会将控制权传递给适当的认证和/或NCP协议，这在PPP链路设置和阶段主题中讨论过。最终，链路设置将完成并进入开放状态。然后，LCP消息可以被任何设备用来管理或调试链路。

- 代码-拒绝和协议-拒绝。这些帧类型用来提供反馈，当一个设备收到一个无效的帧，由于未被识别的LCP代码（LCP帧类型）或一个坏的协议标识符。
- Echo-Request, Echo-Reply和Discard-Request。这些帧可用于测试链路。

**LCP链路终止** 最后，当链路准备关闭时，LCP会终止它。发起关闭的设备（可能不是首先发起链路的设备）发送一个Terminate-Request消息。另一个设备用一个Terminate-Ack来回复。终止请求表明，发送请求的设备需要关闭链接。就像一个四岁的孩子告诉你他 "现在要走了，糟糕！"，这是一个不能拒绝的请求。J

**其他LCP消息** 标准RFC 1570，PPP LCP扩展，也定义了两种新的LCP消息类型。识别消息用于允许设备向其链路上的对等体识别自己。剩余时间（Time-Remaining）消息让一个设备告诉另一个设备当前会话还有多少时间。

**LCP与其他PPP协议的关系**

请注意，PPP中使用的许多其他协议是以LCP为模型的。它们使用相同的基本技术来建立协议连接，并发送和接收LCP消息类型的一个子集。它们也以类似的方式交换配置选项。下一个主题显示了网络控制协议（NCP）是如何基于LCP的。在研究CCP、ECP等功能协议时，你会看到同样的情况。

###### 1.1.3.2.2 PPP网络控制协议（IPCP、IPXCP、NBFCP和其他）（部分：1 2 3）

PPP是如此强大的技术，其原因之一是它具有灵活性和可扩展性。尽管它最初是以携带IP数据报的想法而创建的，但PPP的设计者认识到，如此狭隘的想法是短视的。PPP可以很容易地携带许多类型的网络层协议的数据，在一些网络上，让它同时携带来自不同的第三层协议的数据报甚至可能是有利的。

允许PPP支持多个网络层协议需要它了解每个协议的特异性。如果我们只使用LCP进行链路配置，它就需要知道每个三层协议的所有独特要求。这也要求LCP随着新的三层协议的定义和现有协议的新参数的定义而不断更新。

PPP没有采用这种不灵活的设计，而是采用了一种 "模块化 "方法来建立链接。LCP执行基本的链路设置，并在（可选择的）认证之后，调用网络控制协议（NCP），该协议是特定于将在链路上传输的每个三层协议的。NCP对特定网络层协议所特有的任何参数进行协商。每个LCP链路可以运行一个以上的NCP；如何完成这个过程以及NCP链路和LCP链路之间的关系可以在PPP链路设置和阶段的主题中看到。

每种常见的网络层技术都有一个单独的RFC为其定义的PPP NCP。这些文件通常以这种模式命名。"PPP<第三层协议名称>控制协议"。最常见的是《PPP互联网协议控制协议》（IPCP）、《PPP互联网分组交换控制协议》（IPXCP）和《PPP NetBIOS Frames控制协议》（NBFCP）。这些是分别用于IP、IPX和NBF（也称为NetBEUI）的NCP。还为IP版本6定义了一个单独的NCP，即PPP IP版本6控制协议（IPv6CP）。

**PPP网络控制协议的操作**

每个NCP的操作都非常像LCP的 "精简版"，你可以通过查看图28（并与图26相比较，后者显示了LCP的信息传递）看到。与LCP一样，每个NCP都执行链路设置、维护和终止的功能，只是它处理的是其特定类型的NCP链路，而不是 "整体 "的LCP链路。每个NCP都使用LCP中定义的七个消息类型的子集，并且使用它们的方式与LCP中使用相同名称的消息类型的方式基本相同。

- 链接配置。设置和协商特定NCP链路参数的过程（一旦建立了LCP链路）是使用Configure-Request、Configure-Ack、Configure-Nak和Configure-Reject消息完成的，就像LCP主题中描述的那样，只不过这些消息是针对NCP的。配置选项当然是不同的；它们是正在协商的网络层协议参数。
- 链接维护。可以发送 "代码拒绝 "消息，以指示无效的代码值（NCP帧类型）。
- 链路终止。一个NCP链路可以通过Terminat-Request和Terminat-Ack来终止。(记住，NCP链接是在LCP链接中设置的；可以有一个以上的NCP链接打开，而且关闭NCP链接不会终止LCP链接）。另外，当一个LCP链接被终止时，NCP链接不需要被关闭）。

![](file://D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\pppipcp.png?msec=1668749952809)

 **图28: PPP IP控制协议（IPCP）消息交换**

IPCP等NCP的整体操作与LCP的操作非常相似。在LCP配置（包括认证）完成后，IPCP的Configure-Request和Configure-Ack消息被用来建立IPCP链接。然后，IP数据可以通过该链接发送。如果不再需要IPCP连接，它可以被终止，此后LCP链路仍然开放，以便传输其他类型的数据。然而，在终止LCP连接之前，没有必要明确地终止IPCP连接。

**关键概念：**在使用LCP建立主要PPP链接后，通过该链接传输的每个网络层协议都需要建立适当的NCP链接。其中最重要的是PPP互联网协议控制协议（IPCP），它允许在PPP上承载IP数据包。

**一个NCP的例子：互联网协议控制协议（IPCP）。**

让我们来看看IP的NCP，IPCP。当PPP被设置为传输IP数据报时，IPCP在网络层协议阶段（PPP阶段之一）被调用，以在两个设备之间建立一个IP NCP链接。设置是使用四个 "配置 "消息进行的。对于IP，有两个配置选项可以在IPCP配置请求中指定。

- IP-压缩-协议。允许设备协商使用称为 "Van Jacobson TCP/IP头压缩 "的东西。这可以压缩TCP和IP头的大小以节省带宽。因此，这与LCP中的协议-字段-压缩和地址-控制-字段-压缩（ACFC）选项的概念相似。
- IP-地址。允许发送配置请求的设备指定一个它想用来在PPP链路上进行IP路由的IP地址，或者要求其他设备为它提供一个地址。这最常用于拨号网络链接。

同样，接收设备可以发回IPCP配置-Ack、IPCP配置-Nak或IPCP配置-Reject，就像它们在LCP中工作一样。其他NCP也类似，但使用不同的配置选项。配置完成后，可以为与协商的NCP相对应的第三层协议发送数据。这可以通过在包含三层数据的PPP数据帧中使用适当的协议字段值来表示。

**注：**作为一个旁证，IP的NCP的完整扩展名称是 "点对点协议互联网协议控制协议"。一个名字中有三个 "协议"。这必须是某种记录

###### 1.1.3.2.3 PPP认证协议。密码认证协议（PAP）和挑战握手认证协议（CHAP）（部分：1 2 3）

PPP被设计用来在各种串行链路和其他物理层技术上提供第二层连接，其中一些技术比其他技术更关心安全问题。例如，假设你用串行电缆将计算机实验室中的两台机器连接起来，并想在它们之间运行PPP。当其中一台启动与另一台的PPP链接时，你真的不需要担心 "谁在打电话 "的问题。另一方面，考虑到互联网服务提供商为远程拨入用户使用PPP。他们一般只想让他们的客户连接，而不是随便什么人。

PPP协议套件的设计包括使用一个可选的认证协议，用于认证重要的链接。在LCP的基本链接设置期间，设备可以协商使用认证协议。如果他们同意，在LCP链路建立后，将发送一系列认证信息以验证启动链路的设备的身份。只有当认证成功时，链路配置才能继续进行。

PPP套件最初定义了两种不同的认证协议：密码认证协议（PAP）和挑战握手认证协议（CHAP）。

**注意：**顺便说一下，除了PAP和CHAP之外，还可以使用专有的认证方案。这需要将适当的配置选项值编入LCP，放置在认证协议配置选项中。

**密码认证协议（PAP）**

PAP是一个非常直接的认证方案，只包括两个基本步骤，如图29所示。

1. 认证请求。发起设备发送一个包含姓名和密码的认证请求消息。
2. 认证回复。响应设备查看名称和密码，决定是否接受发起设备并继续建立链接。如果是这样，它就会发回一个Authenticate-Ack。否则，它将发送一个Authenticate-Nak。

![](file://D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ppppap.png?msec=1668749952809)

 **图29: PPP密码认证协议（PAP）认证**

PAP的工作原理是简单地交换一个包含姓名和密码信息的请求，以及一个表明认证是否成功的答复。

简单:现在，还记得爱因斯坦关于简单的说法吗？PAP是另一个例子，它太简单了，不适合它自己。它的主要缺陷是，它在链接中以明文传输用户名和密码。这是安全协议中的一个大 "禁区"，因为它意味着任何窃听者都可以得到密码并在将来使用它。PAP也没有提供对各种安全攻击的保护。例如，一个未经授权的用户可以简单地无限期地尝试不同的密码，并希望他或她最终找到一个有效的密码。PAP还将认证的控制权完全放在启动设备（通常是客户机）的肩上，这被认为是不可取的。

**挑战握手认证协议（CHAP）**

PAP和CHAP之间最重要的区别是，CHAP不在链路上传输密码。现在你可能想知道--如果是这样，密码是如何被验证的？嗯，这样想吧。PAP的工作原理是发起者告诉验证者 "这是我知道的密码，看看是否与你的相符"。CHAP是通过让每个设备使用密码来进行加密计算，然后检查它们是否得到相同的结果。如果他们这样做，他们就知道他们有相同的密码。

**CHAP认证程序** 在CHAP中，在发起者（呼叫客户）和认证者（一般是决定是否授予认证的服务器）之间建立一个基本的LCP链接。然后，认证者负责认证过程，使用一种称为三方握手的技术。这是一个相当常见的一般认证程序；例如，在IEEE 802.11共享密钥认证中使用了相同的基本技术。

三向握手的步骤如下（如图30所示）。

- 挑战：验证者产生一个称为挑战的帧，并将其发送给发起者。该帧包含一个简单的文本信息（有时称为挑战文本）。该信息没有内在的特殊含义，所以如果有人拦截它也没有关系。重要的是，在收到挑战书后，两个设备都有相同的挑战信息。
- 响应。发起者使用其密码（或其他一些验证者也知道的共享 "秘密"）对挑战文本进行加密。然后，它将加密后的挑战文本作为 "响应 "发送给认证者。
- 成功或失败。认证者对挑战文本执行与发起者相同的加密。如果认证者在 "响应 "中得到与发起者相同的结果，认证者就知道发起者在进行加密时有正确的密码，因此认证者会发回一个成功消息。否则，它将发送一个失败消息。

![](file://D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\pppchap.png?msec=1668749952809)

 **图30: PPP挑战握手认证协议（CHAP）认证**

CHAP使用三方握手，从认证设备（通常是由主机访问的远程服务器）发出的挑战开始。该信息经过加密后返回给认证设备，由其检查试图认证的设备是否使用了正确的密码（或其他 "共享秘密"）。

**CHAP的好处** 你可以看到这样做的好处：它验证了两个设备有相同的 "共享秘密"，但不要求通过链接发送秘密。响应 "是根据密码计算的，但 "响应 "的内容是加密的，因此，更难从中得出密码。CHAP还提供了对重放攻击的保护，即未经授权的用户捕获了一个信息，并试图在以后再次发送。这是通过改变每个信息中的标识符和改变挑战文本来实现的。另外，在CHAP中，服务器控制认证过程，而不是启动链接的客户端。

**关键概念:** PPP支持两种认证协议。PAP和CHAP。PAP是一个简单的请求/回复认证协议，被广泛认为是不充分的，因为它以明文形式发送用户名和密码，对许多安全问题几乎没有保护。CHAP使用一个三方握手程序，在大多数实施中比PAP更受欢迎。

CHAP本身并不完美，但它比PAP更接近完美。事实上，IETF在修订描述PAP和CHAP的原始RFC时，在这方面做出了相当强烈的声明，并在新标准中只包括CHAP。尽管如此，PAP仍然在一些应用中被使用，因为它很简单。而且，有些人认为他们比爱因斯坦更聪明。J 说真的，PAP在安全不是大问题的情况下可以很好，但CHAP要好得多，而且仍然不是那么复杂。

###### 1.1.3.3 PPP功能协议

PPP是通过串行链路进行数据链路层连接的标准，因为它的核心协议提供了坚实的操作基础，正如我们在上一节看到的那样。然而，PPP的受欢迎程度不仅仅是基于其高能力的链接建立和管理功能。它还有一些非常有用的功能，为网络用户提供重要的安全和性能优势。

在本节中，我描述了实现PPP中几个最常见的 "额外 "功能的协议。我首先讨论了PPP链路质量监控。我描述了用于配置和实现数据压缩和数据加密的协议集。然后我讨论了PPP多链路协议（MP，MLPPP），它允许PPP将多个低速链路捆绑成一个高速链路。我还介绍了BAP和BACP协议，它们用于管理多链路PPP的运行。

###### 1.1.3.3.1 PPP链路质量监测/报告（LQM/LQR）（部分：1 2 )

PPP包括可选的认证，以确认PPP可能运行的许多不同种类的链接的不同安全需求。这些链接在质量方面也有很大不同。正如当两台机器用短电缆连接时，我们不需要担心认证问题，我们也可以非常自信地认为在它们之间发送的数据将完整无缺地到达。现在，将其与通过长途电话建立的PPP会话进行对比。就这一点而言，使用模拟移动电话进行拨号的PPP又如何呢？

PPP在其基本包中包括检测发送帧中的错误的规定（CRC字段），而像TCP这样的高层协议也包括在嘈杂线路上提供稳健性的方法。这些技术允许链路容忍问题，但对链路的状态提供的有用信息很少。在某些情况下，设备可能希望能够跟踪链路的工作情况，并可能对其采取行动。例如，一个在拨号连接上遇到太多错误的设备可能想切断并重试一个新的呼叫。在某些情况下，如果当前的物理链接工作得不好，设备可能想尝试另一种连接方法。

认识到这一需要，PPP套件包括一个允许设备分析它们之间链接质量的功能。这被称为PPP链路质量监测或LQM。PPP的通用设置允许使用任何数量的不同监测功能，但目前只有一个，称为链路质量报告（LQR）。LQR的工作方式是让设备请求其对等设备（链接上的其他设备）跟踪链接的统计数据，并定期发送报告。

**LQR设置** 在使用LQR之前，必须进行设置，这由LCP完成，作为链路建立阶段中基本链路参数协商的一部分。开通链路的设备通过在其Configure-Request帧中包括Quality-Protocol配置选项来请求链路监测。同样，LQR是目前唯一定义的质量协议。该配置选项还指定了一个报告期，表明请求设备希望在接收报告之间的最长时间段。

**LQR计数器**

假设协商成功，LQR将被启用。设置一些计数器来跟踪各种链路统计数据，以及一个用于调节通过链路发送质量报告的定时器。每次定时器过期，都会生成一份特殊的链路质量报告，并通过链路在PPP帧中发送。这些报告是使用特殊的PPP协议字段十六进制值0xC025发送的。

每个计数器持有关于使用链路的不同统计信息。这些计数器中的每一个都在LQR设置时被重置为零，然后在每次进行传输或发生与该计数器有关的事件时被递增。跟踪的统计数据包括以下内容。

- 发送/接收的帧数。
- 所有发送/接收的帧中的八位数（字节）。
- 已发生的错误数量。
- 不得不丢弃的帧的数量。
- 产生的链路质量报告的数量。

这些计数器只在链路开始时重置，因此它们包含在连接过程中累计保持的数字。这些计数器可以在绝对意义上使用，也就是说，计数器的值本身就被报告了。另外，它们可以表示为相对值（或德尔塔值），表示自上次报告以来的变化。当收到报告时，只需用当前报告中的数字减去上一次报告中的数字即可完成。

**使用链接质量报告** LQR规定了质量报告机制，但没有规定链路质量的具体标准，因为这些标准与实施有关。根据这些报告中的数字，设备可以自行决定对链路质量得出什么结论，并反过来采取什么行动（如果有的话）。举例来说。

- 一些设备可能决定关闭一个链接，如果在任何报告中看到的错误的绝对数量达到一定的阈值。
- 有些设备可能会查看连续报告期的趋势，并在检测到某些趋势时采取行动，例如丢弃帧率的增加。
- 有些设备可能只是记录信息，根本不采取任何行动。

请注意，LQR汇总其在特定链路上传输的所有高层协议的统计数据。它不单独跟踪不同高层协议的统计数据（这是有道理的，因为链接的质量不应该从一个高层协议到下一个协议而变化）。

###### 1.1.3.3.2 PPP压缩控制协议（CCP）和压缩算法（部分：1 2 3 4）

当然，PPP主要用于为物理串行链路提供数据链路层的连接。与许多其他类型的第一层连接相比，串行链路的最大问题之一是它们相对较慢。考虑到虽然按照现代局域网标准，10Mbps的普通以太网被认为是缓慢的，但它实际上比用于广域网连接的大多数串行线路要快得多，后者可能要慢10倍、100倍甚至1000倍。

提高串行链路性能的一种方法是对通过该线路发送的数据进行压缩。根据传输的数据，与未压缩的传输相比，这可以使性能提高一倍，在某些情况下甚至可以做得比这更好。出于这个原因，许多硬件设备包括在物理层压缩数据流的能力。这方面最好的例子可能是模拟调制解调器上使用的一套压缩协议。

有些物理链路不提供任何压缩功能，但仍然可以从中受益。为此，为PPP创建了一个可选的压缩功能。它是通过两个不同的协议组件实现的。

- PPP压缩控制协议（CCP）。该协议负责协商和管理PPP链路上压缩的使用。
- PPP压缩算法。一组执行数据实际压缩和解压的压缩算法。其中有几种是在互联网标准（RFC）中定义的。此外，如果两个设备想使用公共标准没有定义的压缩方法，它们也可以协商使用专有的压缩方法。

**关键概念:**PPP包括一个可选的压缩功能，它可以提高慢速物理链路的性能。支持各种不同的压缩算法。要启用压缩功能，PPP链路上的两个设备都使用PPP压缩控制协议（CCP）来协商使用的压缩算法。然后，该压缩算法被用来压缩和解压PPP数据帧。

**CCP操作。压缩设置**

当大多数人谈到PPP中的压缩时，他们会提到CCP，它被认为是PPP的 "压缩协议"。然而，CCP实际上只是用来配置和控制压缩的使用；真正进行压缩和解压工作的是算法。这种 "权力分离 "提供了灵活性，因为它允许每个实施方案选择他们希望使用的压缩类型。

CCP类似于网络控制协议（NCP），后者是在链接上发送的网络层协议的特定参数的协商。NCP让两个设备决定它们将如何传输第三层流量，例如IPCP让设备决定如何传输IP。CCP让两个设备决定它们将如何压缩数据，其基本方式相同。

同样，正如每个NCP就像LCP的一个 "精简 "版本一样，CCP也像LCP的一个 "精简 "版本。它用于在两个设备之间的LCP链路中建立一个称为CCP链路的压缩连接。一旦建立，压缩帧就可以在两个设备之间发送。CCP还提供了管理和最终终止CCP链路的信息传递功能，这与每个网络层协议在LCP内建立NCP链路的方式非常相似。CCP链接的维护独立于任何NCP链接。

CCP使用与NCP相同的七个LCP消息类型子集，并增加了两个额外的类型。这些消息在CCP链接的每个 "生命阶段 "的使用情况如下，如果你已经读过NCP和LCP本身的工作原理，就会觉得非常熟悉。

- 链接配置。与NCP一样，压缩配置在CCP进入网络层协议阶段后完成。设置压缩和协商参数的过程使用Configure-Request、Configure-Ack、Configure-Nak和Configure-Reject消息完成，就像LCP主题中描述的那样，只不过配置选项是针对CCP的。
- 链接维护。可以发送代码拒绝消息以指示CCP帧中的无效代码值。两种新的消息类型是Reset-Request和Reset-Ack，它们用于在检测到解压失败时重置压缩（CCP链接）。
- 链接终止。CCP链路可以通过Terminat-Request和Terminat-Ack来终止。同样，请记住，像NCP链路一样，CCP链路是在LCP链路中设置的，关闭它并不终止控制PPP整体的LCP链路。

**CCP配置选项和压缩算法**

CCP配置选项只用于一个目的：协商两个设备要使用的压缩类型，以及如何使用该算法的具体细节。发起协商的设备发送一个配置请求，为其支持的每种压缩算法提供一个选项。另一个设备将这个选项列表与它所理解的算法进行比较。它还检查与选项相关的任何具体细节，看它是否同意应如何使用该算法。然后，它发回适当的回复（Ack、Nak或Reject），接着进行协商，直到两个设备得出一个双方都能理解的共同算法。如果是这样，压缩就被打开；否则就不启用。

CCP配置选项以一个表示压缩算法的类型值开始。当Type值为0时，表示该选项包含了一个特殊的、专有的压缩算法的信息，该算法没有被任何RFC标准所涵盖，如果两台设备都能理解它，就可以使用。从1到254的几个值表示已经定义好的用于CCP的压缩算法。表30显示了Type字段最常见的值，包括每个值所对应的压缩算法和定义它的RFC的编号。

 **表30: PPP压缩控制协议（CCP）的压缩算法**

![](file://D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ppp-9.jpg?msec=1668749952880)

**压缩算法的操作。压缩和解压数据**

一旦成功协商了一种算法，压缩算法就会在传输前用于压缩数据，并在收到数据后进行解压。为了进行压缩，发送设备将通常放在未压缩的PPP帧的信息字段中的数据，通过压缩算法运行。为了表示一个帧已被压缩，特殊值0x00FD（十六进制）被置于PPP协议字段中。当压缩被用于多个链路且链路被独立压缩时，会使用一个不同的值。0x00FB。回顾一下，在普通的未压缩帧中，协议字段表示数据来自哪一层的协议；因为我们仍然需要知道这一点，所以在压缩前，原始的协议值实际上被预加到数据中。当数据被解压缩时，这个值被用来恢复原来的协议字段，所以接收设备知道数据属于哪一层。

例如，如果我们使用IPCP将IP数据封装在PPP中，未压缩的帧在协议字段中的值为0x8021（十六进制）。这个值（0x8021）将被放置在要压缩的数据的开头。压缩后的数据将被放入一个协议值为0x00FD的PPP帧。接收设备将看到协议字段中的0x00FD值，识别出该帧为压缩帧，将其解压并恢复原始帧，并将0x8021作为协议值。PPP通用帧格式主题更详细地介绍了这一点。

从理论上讲，压缩算法可以将一个以上的PPP数据帧放入一个压缩的PPP数据帧。尽管如此，许多甚至大多数算法都保持着一对一的对应关系，将每个PPP数据帧放入一个压缩帧。请注意，LCP帧没有被压缩，用于其他协议的控制帧也没有被压缩。例如，携带IP流量的数据帧会被压缩，但IPCP（IP的网络控制协议）的控制帧则不会被压缩。

压缩可以与加密相结合；在这种情况下，压缩在加密之前进行。

**注意：**CCP进行的压缩与作为LCP的一部分可以协商的头压缩选项没有关系。这种类型的 "压缩 "并不涉及使用压缩算法来压缩数据流，而是当链接的两端都同意这样做时，以一种简单的方式来节省报头中的空间。

###### 1.1.3.3.3 PPP加密控制协议（ECP）和加密算法（部分：1 2 3 4 ）。

PPP认证协议PAP和CHAP可用于确保只有授权设备才能建立PPP连接。一旦这样做了，PPP通常不会为正在传输的数据提供其他安全保障。特别是，所有的数据通常是以 "透明"（未加密）的方式发送的，这使得截获数据的人很容易读取。对于必须保持安全的重要数据，在传输之前进行加密是一个好主意。这可以在更高层次上使用IPSec之类的东西来完成，但PPP也提供了一个可选的功能，允许在数据链路层本身对数据进行加密和解密。

注意：本主题在结构和内容上与前面涉及PPP压缩的主题非常相似，因为这些功能是以非常相似的方式实现的。为了方便那些可能不按顺序阅读的人，我在本专题中提供了一个独立的描述，而不假定你已经阅读了前面的压缩专题。这意味着如果你刚读过CCP的主题，这个主题可能看起来几乎是 "似曾相识"。

PPP数据加密是通过两个协议组件实现的。

- PPP加密控制协议（ECP）。该协议负责协商和管理PPP链路上加密的使用。
- PPP加密算法。一系列的加密算法，执行数据的实际加密和解密。其中有几种是在互联网标准（RFC）中定义的，如果两个设备想使用公共标准中没有定义的加密方法，也可以协商一种专有的加密方法。

在讨论PPP中的加密时，ECP通常是唯一提到的部分。事实上，ECP只是用来配置和控制加密的使用；真正起作用的是算法。这种技术允许每个实施方案选择他们希望使用的加密类型。最初的ECP只定义了一种加密方法，后来又增加了其他几种。

**关键概念。**PPP包括一个可选的加密功能，它为通过PPP传输的数据提供隐私。支持一些加密算法。要启用加密功能，PPP链路上的两个设备使用PPP加密控制协议（ECP）来协商使用哪种算法。然后，所选算法被用来加密和解密PPP数据帧。

**ECP操作。压缩设置**

与CCP一样，ECP类似于网络控制协议（NCP），后者是协商在链路上发送的网络层协议的特定参数，但处理的是设备如何加密数据，而不是如何传输第三层流量。这也意味着，与NCP一样，ECP是LCP的 "精简版"，其工作方式基本相同。一旦协商好ECP链路，加密的帧就可以在设备之间发送。当不再需要时，ECP链接可以被终止。

ECP使用与NCP相同的七个LCP消息类型的子集，并增加了两个。这些消息在ECP链路的每个 "生命阶段 "的使用情况如下。

- 链接配置。与NCP一样（当然也与CCP一样），加密配置是在ECP进入网络层协议阶段后完成的。设置加密和协商参数的过程使用Configure-Request、Configure-Ack、Configure-Nak和Configure-Reject消息完成，就像LCP主题中描述的那样，只不过配置选项是ECP特有的。
- 链接维护。可以发送 "代码拒绝 "消息以指示ECP帧中的无效代码值。两种新的消息类型是Reset-Request和Reset-Ack，用于在检测到解密失败的情况下重置加密（ECP链接）。
- 链接终止。ECP链路可以通过Terminate-Request和Terminate-Ack来终止。同样，请记住，像NCP链路一样，ECP链路是在LCP链路中设置的，所以关闭它并不终止LCP链路。

**ECP配置选项和加密算法**

ECP配置选项仅用于协商两个设备将使用的加密算法类型，以及如何使用该算法的具体细节。发起协商的设备发送一个配置请求，为其支持的每种加密算法提供一个选项。另一设备将此选项列表与它所理解的算法进行比较。它还检查与选项有关的任何细节，看它是否同意应如何使用该算法。然后，它发回适当的回复（Ack、Nak或Reject），随后进行协商，直到两个设备得出一个双方都能理解的共同算法。如果是这样，加密就会被启用，否则就会被关闭。

ECP配置选项以一个表示加密算法的类型值开始。当类型值为0时，这表明该选项包含了一个特殊的、专有的加密方法的信息，没有被任何RFC标准所涵盖，如果两个设备都能理解它，就可以使用。在1到254的范围内的值表示已经定义的用于ECP的加密算法；目前，只有两个被定义。表31显示了Type字段的值，包括每种对应的加密算法和定义它的RFC的编号。

 **表31: PPP加密控制协议（ECP）的加密算法**

![](file://D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ppp-11.jpg?msec=1668749952809)

注意：类型值1用于原始的DES算法，定义于RFC 1969，在RFC 2419中被DES版本2取代。

**密算法的操作，加密和解密数据**

加密算法协商成功后，它被用来在传输前加密数据，并对收到的数据进行解密。为了加密，发送设备将通常放在未加密的PPP帧的信息字段中的数据，通过加密算法运行。为了表明帧已被加密，特殊值0x0053（十六进制）被置于PPP协议字段中。当对多个链路进行加密，并且链路独立加密时，会使用不同的值。0x0055. 回顾一下，在普通的未加密帧中，协议字段表示数据来自哪一个三层协议；因为我们仍然需要知道这一点，所以在加密之前，原始的协议值实际上被预置到数据中。当数据被解密时，这个值被用来恢复原来的Protocol字段，所以接收设备知道数据属于哪一层。

例如，如果我们使用IPCP将IP数据封装在PPP中，未加密的帧在协议字段中的值为0x8021（十六进制）。这个值（0x8021）将被放置在要加密的数据的开头。加密后的数据将被放入协议值为0x0053的PPP帧中。接收设备将看到协议字段中的值0x0053，识别出该帧是加密的，将其解密并恢复原始帧，将0x8021作为协议值。

每个加密的PPP数据帧正好携带一个PPP数据帧。请注意，与我们在压缩中看到的不同，LCP帧和用于其他协议的控制帧可以被加密。压缩可以与加密相结合；在这种情况下，压缩是在加密之前进行的。

###### 1.1.3.3.4 PPP多链路协议（MP/MLP/MLPPP）（部分：1 2 3 )

大多数情况下，两个设备之间只有一个物理层的连接。然而，在某些情况下，同一对设备之间实际上可能有两个第一层连接。这可能看起来很奇怪，为什么任何一对机器之间会有一个以上的链接？

事实上，有许多情况下会出现这种情况。一个常见的情况是在一对设备之间故意放置两个链接。这样做通常是为了通过在两个设备之间 "拓宽管道 "来提高性能，而不需要采用更新、更昂贵的技术。例如，如果两台机器使用普通的模拟调制解调器相互连接，而且速度太慢，一个相对简单的解决方案就是直接使用两对模拟调制解调器连接机器，使带宽加倍。

当多路复用在两个设备之间形成相当于几个物理层的 "通道 "时，会出现稍微不同的情况，即使它们之间只有一条硬件链接。以ISDN为例，考虑到ISDN。最常见的ISDN服务形式（ISDN基本速率接口或BRI）在一对设备之间创建两个64,000 bps的B通道。这些B信道经过时分复用，与D信道一起在一对铜线上传输，但对设备来说，它们就像设备之间有两条物理层链路，每条链路传输64kbps的数据。而ISDN主速率接口（PRI）实际上创造了23个甚至更多的通道，都在同一对硬件设备之间。

在我们有多条链路的情况下，我们当然可以只在每条连接上独立建立PPP。然而，这远不是一个理想的解决方案，因为这样我们就必须在连接它们的两个（或更多）通道或链接上手动分配我们的流量。如果你想连接到互联网，你将不得不建立单独的连接，然后选择每个动作使用哪一个。这并不是一个有趣的配方，更糟糕的是，你永远无法将所有的带宽用于一个目的，例如下载最新的100兆的微软安全补丁。

我们真正想要的是一个解决方案，它可以让我们结合多个链接，并把它们当作一个高性能链接来使用。一些硬件设备实际上允许在硬件层面本身就能做到这一点；在ISDN中，这种技术在第一层完成时有时被称为绑定。对于那些不提供这种能力的硬件设备，PPP以PPP多链路协议（MP）的形式将其提供。该协议最初在RFC 1717中描述，并在RFC 1990中更新。

**注意：**PPP多链路协议的正确缩写是 "MP"，但经常看到有许多其他的缩写用于它。其中许多实际上是将名称中的单词顺序改为 "多链路PPP"，所以你会经常看到它被称为 "ML PPP"、"MLPPP"、"MPPP"、"MLP "等等。这些在技术上是 "不正确的"，但被广泛使用，特别是 "MLPPP"。我在本指南中使用正确的缩写。

**PPP多链路协议体系结构**

MP是PPP的可选功能，因此必须设计为无缝集成到常规PPP操作中。为了实现这一点，MP被实现为PPP中的一个新的架构“子层”。本质上，MP子层被插入到“常规”PPP机制和使用PPP的任何网络层协议之间，如图31所示。这允许MP获取通过PPP链接发送的所有网络层数据，并将其传播到多个物理连接，而不会导致正常PPP机制或PPP的网络层协议接口“中断”。![](file://D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\pppmplayers.png?msec=1668749952810)

图31: 多链路PPP架构

左边一栏显示了TCP/IP模型架构与相应的OSI参考模型层号。中间一栏显示正常的PPP层架构。当使用多链路PPP时，有单独的PPP实现在两个或多个物理链路的每一个上运行。从结构上看，多链路PPP位于这些链路和通过这些链路传输的任何网络层协议之间。(在此图中只显示了IP，因为它是最常见的，但事实上多链路PPP可以与多个网络层协议一起工作，每个协议都通过每个物理链路发送）。

**关键概念：**PPP多链路协议（MP）允许PPP捆绑多个物理链路，并像一个单一的、高容量的链路一样使用它们。它必须在链路配置期间启用。一旦启用，它的工作方式是将整个PPP帧分割成碎片，并通过不同的物理链路发送这些碎片。

**PPP多链路协议的设置和配置**

要使用MP，两个设备都必须将其作为PPP软件的一部分来实施，并且必须协商其使用。这是由LCP完成的，作为链路建立阶段基本链路参数协商的一部分（就像链路质量报告）。定义了三个新的配置选项，通过协商来启用MP。

- 多链路最大接收重构单元。提供基本指示，表明开始协商的设备支持MP并希望使用它。该选项包含一个值，指定其支持的PPP帧的最大尺寸。如果收到该选项的设备不支持MP，它必须用配置-拒绝LCP消息来回应。
- Multilink Short Sequence Number Header Format: 允许设备为MP帧协商使用较短的序列号字段，以提高效率。(更多内容请参见MP帧专题）。
- 端点辨别器。对系统进行唯一的识别；用于允许设备确定哪些链路通向哪些其他设备。

在使用MP之前，必须在两个设备之间的每个链路上至少成功协商多链路最大接收重构单元选项。一旦这样做了，并且每个物理链路都存在一个LCP链路，那么LCP链路就会形成一个虚拟捆绑，MP就会被启用。

**PPP多链路协议操作** 如上所述，MP基本上位于网络层和常规PPP链接之间，充当 "中间人"。以下是它对通信的每个 "方向 "所做的工作。

- 传输。MP接受从使用适当的NCP配置的任何网络层协议中收到的数据报。它首先将它们封装成常规PPP帧的修改版本。然后，它采用该帧并决定如何在多个物理链路上传输它。通常情况下，这是通过将帧分成片段来完成的，这些片段均匀地分布在一组链路上。然后，这些片段被封装并在物理链路上发送。然而，也可以实施另一种策略，如在链接之间交替使用全尺寸的帧。此外，较小的帧通常不被分割，控制帧也不被分割，如用于链接配置的帧。
- 接收。MP从所有物理链路接收碎片，并将它们重新组合成原始PPP帧。然后，该帧像任何PPP帧一样被处理，通过查看其协议字段并将其传递给适当的网络层协议。 MP中使用的片段在概念上与IP片段相似，但当然这些是在不同层运行的不同协议。对PPP或MP来说，IP碎片只是一个像其他一样的IP数据报。

MP中的数据片段引入了协议必须处理的一些复杂问题。例如，由于片段是大致同时发送的，我们需要用一个序列号来识别它们，以方便重新组装。我们还需要一些控制信息来识别第一个和最后一个片段。一个特殊的帧格式用于MP片段，以携带这些额外的信息，我在PPP帧格式一节中描述了这一点。该主题还包含了更多关于如何完成片段的信息，以及演示其工作原理的插图。

相关信息:我还建议阅读下一个主题，它描述了在MP之后定义的两个协议，以更好地控制其工作方式。BAP和BACP。

###### 1.1.3.3.5 PPP带宽分配协议（BAP）和带宽分配控制协议（BACP）（零件：1 2 )

上一主题中描述的PPP多链路协议（MP）允许一对设备之间的多个链路，无论是物理的还是虚拟通道的形式，都可以组合成一个 "胖子管道"（高容量通道）。这为许多PPP用户提供了巨大的优势，因为它使他们能够最佳地利用所有的带宽，特别是对于互联网连接等应用。因此，MP已经成为PPP最受欢迎的功能之一，这并不奇怪。

定义MP的原始标准基本上假定多个链接将被组合成一个单一的捆绑。例如，如果你有两个调制解调器链接，它们都将被连接，然后合并，或者ISDN链接中的两个B通道将被合并。在MP设置后，该捆绑物可供任何设备完整使用。

这个系统有一个缺点："胖子管道 "总是被启用，在许多情况下，一直这样设置是很昂贵的。连接两条或更多的第一层链路往往比一条链路的成本更高，而且并不总是需要。例如，一些ISDN服务对任何一个B通道的呼叫按分钟收费。在调制解调器拨号的情况下，世界上的一些地方也按分钟收费。即使在普通电话 "免费 "的地方，也会有占用电话线的成本。考虑到在许多应用中，所需的带宽量随时间而变化。

如果我们能对MP进行设置，使其在需要时能动态地将链接添加到包中，例如当我们决定下载一些大文件时，然后在不再需要时自动放弃它们，那就更好了。对基本MP包的这种增强是以RFC 2125中描述的一对新协议的形式提供的。

- 带宽分配协议（BAP）。描述了一种机制，通过第一层链路的MP包进行通信的任何设备都可以请求将一个链路添加到包中或从包中删除。
- 带宽分配控制协议（BACP）。允许设备配置它们要如何使用BAP。

**关键概念：** BAP和BACP用于对PPP多链路协议的功能提供动态控制。

**BACP操作。配置BAP的使用**

让我们从BACP开始，因为它是用于初始设置该功能的协议。BACP与所有其他名称中带有 "控制 "的PPP协议，如LCP、NCP系列、CCP和ECP在总体概念上非常相似，但实际上更加简单。它只在链路配置中用于设置BAP。就像LCP主题中描述的那样，使用Configure-Request、Configure-Ack、Configure-Nak和Configure-Reject消息完成。在BACP中协商的唯一配置选项是一个叫做Favored-Peer的选项，它用于确保链路上的两个设备在各自试图同时发送相同的请求时不会被 "卡住"。

如果两个设备都支持BAP，那么BACP协商将成功，BAP将被激活。

BAP操作。添加和删除链接 BAP定义了一套特殊的消息，可以在设备之间发送，以添加或删除当前PPP捆绑的链接。BAP特别有趣的是，它包括必要的工具，可以让设备在需要更多带宽时实际启动不同类型的物理层连接（如为捆绑的模拟链接拨号调制解调器或启用一个额外的ISDN通道），然后在不再需要时关闭它们。

**对BAP消息类型的简要描述。**

- 呼叫-请求和呼叫-响应。当链路上的一个设备想在捆绑中增加一个链路并自己启动新的物理层链路时，它发送一个Call-Request帧来告诉另一个设备，后者用Call-Response来回复。
- Callback-Request和Callback-Response。这些就像上面的两种消息类型，但是当一个设备希望它的同伴（链路上的另一个设备）发起呼叫以增加一个新的链路时使用。因此，如果设备A说 "我需要更多的带宽，但我想让你给我打电话，而不是我给你打电话"，它就向设备B发送一个Callback-Request。
- Call-Status-Indication和Call-Status-Response。在一个设备试图将一个新的链路添加到束中后（在发送一个呼叫-请求或收到一个回叫-请求后），它使用呼叫-状态-指示帧报告新链路的状态。另一个设备则用呼叫状态回复。
- Link-Drop-Query-Request和Link-Drop-Query-Response。这些消息是由一个设备用来请求放弃一个链路，另一个设备用来响应这个请求。

我还应该指出，何时增加或删除链接的决定不是由这些协议作出的。它是由特定的实现来决定的。

###### 1.1.3.4 PPP协议帧格式

PPP协议套件包括一些不同的协议，用于以不同方式发送数据和控制信息。这些协议中的每一个都将信息打包成称为帧的信息，每一个都遵循一种特定的帧格式。PPP以一般的帧格式开始，包括在链接上发送的所有帧，然后包括用于不同目的的更具体的格式。了解这些格式不仅使诊断PPP问题更容易，也有助于更清楚地了解关键PPP协议的功能。

在本节中，我说明了用于在PPP上发送数据和控制信息的最常见的帧格式。我首先解释了用于所有PPP帧的总体格式。我还描述了用于各种控制协议的一般格式和大多数协议使用的选项格式。(PPP的好处之一是许多协议都使用具有共同格式的控制帧。)

然后我特别列出了用于链接控制协议（LCP）和认证协议（PAP和CHAP）的帧。我还描述了PPP多链路协议（MP）用于在捆绑链路上传输数据片段的特殊格式。

**注意：**由于PPP中不同协议的数量太多（几十个），而且许多协议有自己独特的选项，我不能在这里详细描述每个协议的所有具体帧格式和选项格式。如果你需要比本节提供的更多细节，请参考相应的RFCs（在PPP标准专题中显示）。

###### 1.1.3.4.1 PPP通用帧格式（部分：1 2 3 4 )

使用PPP发送的所有信息都可以被认为是数据或控制信息。数据 "一词描述了我们在第二层试图传输的高层数据报；这就是我们的 "客户 "给我们发送的东西。控制信息是用来管理PPP本身的各种协议的运行的。即使PPP套件中的不同协议使用许多类型的帧，但在最高层次上，它们都适合于一个单一的通用帧格式。

在PPP的概述中，我提到该套件的基本操作是基于ISO高级数据链路控制（HDLC）协议。当我们看一下PPP帧的整体结构时，这一点就非常明显了--它们使用与HDLC相同的基本格式，甚至包括某些对PPP本身来说并不严格必要的字段。唯一的主要变化是增加了一个新的字段来指定封装数据的协议。PPP帧的一般结构在RFC 1662中定义，这是PPP主要标准RFC 1661的 "伴侣"。

表32描述了PPP的一般帧格式，显示了HDLC构架如何应用于PPP，并在图32中作了说明。

 **表32: PPP通用帧格式**

![](file://D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ppp-12.jpg?msec=1668749953186)

![](file://D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ppp-131.jpg?msec=1668749952810)

 **图 32：PPP 通用帧格式**

所有 PPP 帧都建立在上面显示的一般格式之上。前三个字节的值是固定的，后跟一个指示帧类型的两字节协议字段。可变长度信息字段以多种方式格式化，具体取决于 PPP 帧类型。可以将填充应用于帧，该帧以 2 或 4 字节的 FCS 字段（此处显示 2 字节）和尾随标志值 0x7E 结束。有关如何应用此格式的示例，请参见图 33。

图 33 显示了 PPP 通用帧格式的一种常见应用：携带数据。Protocol 字段中的值 0x0021 将其标记为 IPv4 数据报。这个示例也有一个字节的 Padding 和一个 2 字节的 FCS。 （很明显，真实的 IP 数据报比这里显示的 23 个字节长！这些字节是任意的，并不代表真实的数据报。）请参见图 43，了解如何对同一数据帧进行格式化，然后将其分段以通过多个链路传输使用 PPP 多链路协议。

![](file://D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ppp-14.jpg?msec=1668749952810)

 **图 33：示例 PPP 数据帧**

此示例 PPP 数据帧在 Protocol 字段中的值为 0x0021，表示它是一个 IP 数据报（尽管实际数据是组成的，而不是真正的 IP 消息。）

**协议字段的范围**

协议字段是接收帧的设备的主要 "帧类型 "指标。对于数据帧，这通常是创建数据报的网络层协议，而对于控制帧，是创建控制信息的PPP协议。对于修改数据的协议，如使用压缩（CCP）或加密（ECP）时，该字段确定数据被压缩或加密，在信息字段被解压缩/解密后，将提取原始协议值。

有几十种网络层协议和PPP控制协议，相应地也有大量的协议值。PPP主标准定义了四个范围来组织这些值，如表33所示。

 **表33: PPP协议字段范围**

![](file://D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ppp-15.jpg?msec=1668749953162)

该标准还规定，协议值的分配必须使第一个八位数是偶数，第二个八位数是奇数。因此，例如，0x0021是一个有效的值，但0x0121和0x0120则不是。(这方面的原因很快就会明白）。还有一些块是保留的，不使用。

**协议字段值**

PPP协议值的完整列表由互联网号码分配机构（IANA）维护，与互联网标准的所有其他不同保留号码一起。表34显示了一些比较常见的值。

 **表 34：PPP 帧中携带的常用协议和协议字段值**

![](file://D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ppp-31.jpg?msec=1668749953125)

![](file://D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ppp-32.jpg?msec=1668749953005)

![](file://D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ppp-33.jpg?msec=1668749952882)

**PPP字段压缩**

PPP使用HDLC基本成帧结构，其中包括两个在HDLC中需要但在PPP中不需要的字段，因为后者的操作方式：地址和控制字段。为什么要麻烦地发送两个字节，这两个字节在每个帧中都有相同的值，而且没有任何用途？最初它们是为了兼容而保留的，但这降低了效率。

为了避免在每一帧中浪费两个字节，在最初的链路设置中，链路上的两个设备可以使用LCP选项协商一个叫做地址和控制字段压缩（ACFC）的功能。当启用时，该功能只是导致这两个字段不被发送至大多数PPP帧（但不包括LCP控制帧）。事实上，该功能最好被命名为 "地址和控制字段抑制"，因为这些字段只是被抑制：压缩到没有。

现在，即使设备同意使用字段压缩，它们仍然必须能够接收 "压缩的 "和 "未压缩的 "帧。它们通过查看初始Flag字段后的前两个字节来区分两者。如果它们包含值0xFF03，它们必须是地址和控制字段；否则，这些字段被抑制了。(值0xFF03不是一个有效的协议字段值，所以不存在模糊的可能性）。

同样，链路上的两个设备也有可能协商压缩协议字段，因此它只需要一个字节而不是两个字节。这通常是通过放弃第一个字节（如果它是零）来实现的，这个过程称为协议字段压缩（PFC）。回顾一下，第一个字节必须是偶数，第二个是奇数。因此，接收设备检查每个帧中协议字段的第一个字节的偶数。如果它是奇数，这意味着协议字段中前导字节的零已经被抑制，因为完整的两字节协议值的第一个字节必须是偶数。

**注意：**这种 "字段压缩"（实际上是抑制）与使用PPP的压缩控制协议（CCP）和压缩算法的数据压缩没有关系。

###### 1.1.3.4.2 PPP通用控制协议帧格式和选项格式（部分：1 2 3 4）

一个通用的帧格式用于PPP协议套件中定义的所有许多帧类型。在该格式中，信息字段携带封装的第三层用户数据，或封装的控制信息。这些控制信息包含特定的信息，用于配置、管理和中断PPP链路，并实现构成PPP的各种功能。

正如我们在前面的章节中所看到的，有许多不同的PPP控制协议，通常可以通过其名称中出现的 "控制 "一词来加以区分。这些协议包括主要的PPP链路控制协议（LCP）、网络控制协议（NCP）系列，如IPCP、IPXCP等，还有实现功能的控制协议，如CCP和ECP。认证协议PAP和CHAP的名称中缺少 "控制"，但也属于这个类别。

控制协议各自以稍微不同的方式使用控制信息，但其中许多信息之间也有很大的共同点。这是因为，正如我在描述PPP协议的主题中所解释的那样，大多数控制协议，如NCP系列、CCP和ECP，是作为链路控制协议的功能的 "子集 "来实现的。它们执行许多相同的功能，因此PPP设计者明智地将LCP信息传递系统 "改编 "为这些其他控制协议。

这都意味着控制协议帧本身有一个共同的格式，适合在PPP的整体通用帧格式中。即使像PAP和CHAP这样不基于LCP的协议也使用这种通用的控制帧格式，这在表35中有描述。 **表35: PPP控制信息格式**

![](file://D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ppp-34.jpg?msec=1668749953127)

这整个结构成为 PPP 帧的有效载荷，这意味着它适合 PPP 帧的信息字段，如图 34 所示。因此，长度字段的大小与 PPP 帧中的信息字段的大小相等。控制帧的协议字段设置为与生成控制帧的协议相匹配。例如，对于 LCP 帧，它将是 0xC021。

![](file://D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ppp-35.jpg?msec=1668749952810)

 **图 34：PPP 控制消息格式**

PPP 控制消息格式的四个字段适合 PPP 通用帧格式的信息字段。随后用特定于控制消息类型的数据填充数据字段。

**PPP控制信息和代码值**

代码字段表示特定控制协议中的控制帧类型。一些协议有一套仅由该特定协议使用的独特代码；例子包括认证协议（PAP和CHAP）和带宽分配协议（BAP）。由于NCP和许多功能控制协议（如CCP和ECP）都是基于LCP的，因此它们使用一套通用的消息代码和类型。表36显示了这些常见的消息代码，以及表明哪些控制协议使用这些代码的交叉参考表。

 **表36: PPP控制消息、代码值和PPP协议使用情况**

![](file://D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ppp-36.jpg?msec=1668749952883)

**注：**我在关于LCP、NCP、CCP和ECP的各个专题中描述了这些帧类型的具体使用方法。

数据字段的内容完全取决于控制信息的类型。在某些情况下，根本不需要发送额外的数据，在这种情况下，数据字段可以省略。在其他控制信息中，它携带与信息类型相关的信息。例如，代码拒绝消息在数据字段中携带被拒绝的帧的副本。

**PPP控制消息选项格式**

各种Configure-消息被用来协商LCP和其他控制协议的配置选项。在其数据字段中，它们携带一个或多个选项，这些选项也是使用它们的协议所特有的。例如，LCP对整个链路使用一套配置选项；CCP使用选项来协商压缩算法，MP使用它来设置多链路捆绑，等等。图35显示了这些长度不一的选项是如何放在PPP控制信息的数据字段中的（这又是嵌套在一般PPP帧格式中）。

![](file://D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ppp-37.jpg?msec=1668749952810)

 **图35: 携带选项的PPP控制信息**

该图显示了一个在数据字段中携带选项的PPP控制消息样本。任何数量的选项都可以包括在内，并且/或者与其他数据混合，这取决于消息的需要。

同样，这里有一个共同点；虽然每个选项都不同，但它们都使用相同的基本格式，如表37所述和图36所示。

 **表37: PPP控制消息选项格式**

![](file://D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ppp-38.jpg?msec=1668749953006)

配置选项在各个协议主题中进行了简要描述。我没有显示每个选项的具体内容，因为它们太多了。这些在 RFC 中。

![](file://D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ppp-39.jpg?msec=1668749952811)

 **图 36：PPP 控制消息选项格式**

出现在任何 PPP 控制消息类型中的每个选项都由这三组类型、长度和数据组成。

**PPP控制信息格式的总结**

现在......我在这个主题中的意图是向你展示不同控制协议的一般格式，因为它们是如此相似，我没有时间或空间来单独描述每个协议的框架。我承认，这样做的结果可能是混乱多于启迪，因为可能很难看到PPP在格式上是如何从一般走向具体的。如果有帮助的话，这里有一个简单的总结。

PPP通用帧格式用于所有帧，包括所有控制帧。它的信息字段包含有效载荷，对于控制帧，有效载荷中包含整个控制信息。

控制帧的结构采用我在本主题开始时给出的一般格式。代码值表示每个控制协议的控制帧的类型。数据字段长度可变，包含该控制帧的数据，在某些情况下可能包括一个或多个配置选项。

对于配置控制帧，如Configure-Request和Configure-Ack，数据字段包含一个封装好的选项集，使用本主题中第二个表格的一般结构。每个选项都有自己的数据子字段，包含该选项的特定数据。 为了让大家更清楚地了解这一点，接下来的两个主题为LCP和认证协议的帧格式提供了更具体的例子。

###### 1.1.3.4.3 PPP链路控制协议（LCP）帧格式

上一个主题描述了PPP中交换控制信息的各种协议所使用的一般格式。在PPP的许多控制协议中，链路控制协议（LCP）是最重要的，因为它负责PPP链路的基本设置和操作。它也是作为许多其他控制协议的 "模板 "使用的协议。

由于它是PPP的核心，而且许多其他协议都使用类似的信息传递系统，我想通过展示每个LCP控制帧使用的具体帧格式，使上一页中看到的一般帧格式更加 "具体"。然而，有十三个不同的，由于它们有许多共同的字段，我不想把十三个看起来几乎一样的表格放在这里。

为了节省空间和显示信息的不同，我把它们放在一个大的汇总表里，而不是做13个小表。表38显示了十三种LCP框架类型中每个字段的内容和含义。

 **表38: PPP链路控制协议（LCP）帧类型和字段**

![](file://D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ppp-51.jpg?msec=1668749953172)

![](file://D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ppp-52.jpg?msec=1668749953172)

![](file://D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ppp-54.jpg?msec=1668749953164)

**注意：**LCP 帧类型 5、6、9、10、11、12 和 13 允许在数据字段中包含额外数量的数据，协议未严格描述其用途。 PPP 标准表示，这可能是零个或多个八位字节，“包含供发送者使用的未解释数据”并且“可能包含任何二进制值”。包含这个“未解释的数据”被保留为一个依赖于实现的选项

所有 LCP 控制帧都被封装到一个 PPP 帧中，方法是将帧结构放入其信息字段中，如上一主题中所述。 LCP 的协议字段设置为 0xC021。有关如何使用帧的说明，请参阅 LCP 的操作说明。

###### 1.1.3.4.4 PPP认证协议（PAP、CHAP）帧格式（部分：1 2 3 )

对于安全很重要的链路，PPP提供了两个可选的认证协议。这些协议在链路控制协议（LCP）的初始链路设置期间被用来拒绝PPP连接到未经授权的设备。这两个认证协议是密码认证协议（PAP）和挑战握手认证协议（CHAP）。

PAP和CHAP是控制协议，因此使用本节前面描述的相同的基本控制协议帧格式。然而，由于它们的目的与LCP和其他许多控制协议非常不同，它们使用了一套独特的帧，有自己独特的代码值。我想看看PAP和CHAP的帧是如何构成的可能会有帮助。PAP使用三种不同的控制帧类型，而CHAP使用四种。为了节省空间并显示帧之间的比较，我将在每个协议的一个表中显示它们，而不是七个表。

**PPP PAP控制帧格式**

让我们从PAP开始。其三个控制帧的结构如表39所示。验证请求使用一种格式，如图37所示，而其他两种帧类型使用一种不同的格式，如图38所示。

![](file://D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ppp-61.jpg?msec=1668749953007)

![](file://D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ppp-62.jpg?msec=1668749952884)

**PPP CHAP控制帧格式**

四种CHAP帧类型的格式如表40所示。正如你在该表中看到的，挑战和响应帧使用一种消息格式，如图39所示，而成功和失败帧使用另一种格式，如图40所示。

 **表40: PPP挑战握手认证协议（CHAP）的格式**

![](file://D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\PPP-65.jpg?msec=1668749953007)

![](file://D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\PPP-66.jpg?msec=1668749952885)

###### 1.1.3.4.5 PPP多链路协议（MP）帧格式（部件：1 2 3 4 ）

有些设备不是通过单一的物理层连接，而是通过两个或更多的连接。这些可能是多个物理连接，如两对相连的调制解调器，或复用的虚拟一层连接，如ISDN B通道。在这两种情况下，PPP多链路协议（MP，也有几个别名，如MLPPP和MLP）可以用来聚合这些物理链路的带宽，以创建一个单一的高速捆绑。我在关于MP的操作专题中描述了如何做到这一点。

 **表41: PPP多链路协议片段帧格式**

![](file://D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\PPP-71.jpg?msec=1668749952885)

在MP被配置并开始工作后，它通过采用一种策略，在构成MP捆绑的许多单独的物理链路中分割常规PPP帧来运行。这通常是通过将PPP帧切成称为片段的碎片，并将这些碎片分散到物理链路上来完成的。这使得物理链路上的流量很容易被平衡。

**PPP多链路协议的帧分片过程**

为了完成这个分片过程，需要遵循一个三步过程。

1. 创建原始PPP帧。要发送的数据或其他信息首先被格式化为一个 "完整的 "PPP帧，但以一种修改过的形式，如下所述。
2. 分片。全尺寸的PPP帧被MP切成碎片。
3. 封装。每个片段都被封装在一个新的PPP MP片段帧的信息字段中，同时还有控制信息，以使片段被接收者重新组装起来。

如果该帧将被分割并放入其他PPP多链路帧中，那么通常出现在 "整个 "PPP帧中的几个字段是不需要的，因此当片段发生时，为了提高效率，在构建原始PPP帧时将省略它们。具体而言。

- 开头和结尾的Flag字段仅用于传输的成帧，在被分割的逻辑帧中不需要。
- FCS字段是不需要的，因为每个片段都有自己的FCS字段。
- 在创建这个原始帧时，对任何PPP帧都可以使用的特殊 "压缩 "选项。地址和控制域压缩（APCP）和协议域压缩（PFC）。这意味着帧中没有地址或控制字段，而协议字段只有一个字节大小。请注意，这本质上限制了片段只携带某些类型的信息。

这些变化在每个PPP帧上节省了整整八个字节的碎片。因此，原始PPP帧有一个非常小的头，仅由一个字节的协议字段组成。每个片段的协议值被设置为0x003D，以表示一个MP片段，而原始帧的协议字段成为第一个片段中 "数据 "的第一个字节。

**关键概念:** PPP多链路协议通常通过创建一个去除不必要头的原始PPP帧，然后将其划分为片段帧，在物理链路之间划分数据。每个片段都包括特殊的标头，以允许接收设备重新组装原始帧。

PPP多链路协议片段帧格式

每个片段的信息字段使用一个子结构，包含一个四字段的MP头以及一个原始PPP帧的片段，如表41所示。

![](file://D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\PPP-81.jpg?msec=1668749952885)

![](file://D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ppp-83.jpg?msec=1668749952886)

正如你所看到的，MP帧格式有两个版本：长格式使用4字节的头，而短格式只需要2字节。默认的MP头格式使用24位序列号，有6个保留位，如图41所示。在设置MP时，有可能让设备协商多链路短序列号头格式配置选项。如果这样做成功了，就会使用更短的12位序列号。四个保留位也被截断，以节省每个帧的两个字节，如图42所示。(考虑到12位仍允许每个PPP帧有超过4000个片段，这通常是绰绰有余的！）。

片段数据字段包含要发送的实际片段。由于原始PPP头（包括协议字段）是在原始PPP帧的开始，这将出现在第一个片段的开始。其余的片段将只有原始PPP帧的信息字段的部分内容。最后一个片段将以原始PPP帧的最后字节结束。

接收设备将收集每个PPP帧的所有片段，从每个片段中提取片段数据和MP头。它将使用序列号来重新组合片段，然后处理产生的PPP帧。

**PPP多链路协议分片演示**

在图43中可以看到对PPP数据帧进行分片的演示。顶部是图33中所示的同一个PPP数据帧。灰色的八个字节是帧被分割时不使用的字节。因此，用于MP的PPP帧有24个字节长，如左边较小的表格所示（注意，这8个字节没有被创建和删除，我只是在上面的表格中显示它们以便说明）。这个帧被分割成8字节的小块，每个小块都在一个MP片段的片段数据字段中携带。注意片段帧中的连续序列号（"Seq"）值。另外，请注意，开始片段字段只为第一个片段设置，结束片段只为最后一个片段设置。

![](file://D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ppp-84.jpg?msec=1668749953022)

该图显示了一个PPP帧如何被分割成三个较小的片段，以及如何为每个片段设置控制字段。

### **第二章、TCP/IP网络接口/互联网 "层连接 "协议**

OSI参考模型的第二层是数据链接层；它与TCP/IP网络接口层相对应。大多数局域网、广域网和无线局域网技术都是在这里定义的，如以太网和IEEE 802.11。第三层是网络层，在TCP/IP模型中也称为互联网层，在这里定义了网络协议，其中最引人注目的是互联网协议。这两层是密切相关的，因为在网络层发送的信息必须在数据链路层的各个物理网络上传输。它们执行不同的任务，但作为协议栈中的邻居，必须相互合作。

有一套协议为连接这两层的重要任务服务，并允许它们一起工作。它们的问题是决定它们到底应该住在哪里！它们有点像 "害群之马"。它们有点像网络世界的 "害群之马"--没有人否认它们的重要性，但它们总是认为自己属于 "其他人 "的层。例如，由于这些协议在第二层网络上传递数据，处理第二层技术的人说它们属于第三层。但那些处理第三层协议的人认为这些 "低级 "协议为第三层提供服务，因此把它们列为第二层的一部分。

那么，它们该去哪里呢？嗯，在某种程度上，这其实并不重要。即使它们是 "害群之马"，我也认为它们有些特殊，所以我给了它们自己的家。欢迎来到 "网络层地狱"，也被称为 "OSI二层半"。J 这里描述了几个协议，作为数据链路和网络层之间的 "胶水"。这里执行的主要工作是地址解析，或提供第二层和第三层地址之间的映射。这种解析可以在任何方向进行，由两个TCP/IP协议ARP和RARP代表（尽管它们有相似之处，但在实践中用于相当不同的目的）。

**背景资料:** 我建议在继续学习之前熟悉第二层和第三层的基础知识。特别是，对IP寻址的一些理解是有帮助的，尽管不是绝对必要的。一般来说，如果你打算阅读有关IP的内容，你最好在进入本节之前先了解这些材料。

#### 2.1 地址解析和TCP/IP地址解析协议（ARP）

互联网上的通信是通过使用网络层地址在第三层发送数据来完成的，但该数据的实际传输是在第二层使用数据链路层地址进行的。这意味着每一个具有完全指定的网络协议栈的设备都有一个二层和一个三层地址。有必要定义一些能够将这些地址联系起来的方法。通常情况下，这是由网络层地址和确定数据链路层地址来完成的。这个过程被称为地址解析。

在这一节中，我将从概念和实践两个层面来探讨地址解析的问题，重点是如何在重要的TCP/IP协议套件中完成这一工作。我首先用一个章节概述了地址解析的一般情况，并描述了该过程中涉及的问题。然后我描述了TCP/IP地址解析协议（ARP），这可能是最著名和最常用的地址解析技术。我还简要介绍了IP中多播地址的地址解析方式，以及新的IP版本6中使用的方法。

##### 2.1.1 地址解析的概念和问题

由于TCP/IP在网络世界中的突出地位，大多数关于地址解析的讨论都直接跳到TCP/IP地址解析协议（ARP）。这个协议确实很重要，我们将在下一节对其进行讨论。然而，地址解析的基本问题并不是任何处理它的特定实现所独有的，例如TCP/IP的ARP。为了更好地理解数据链路层和网络层之间的地址解析，并支持我们对ARP的研究，我认为从更普遍的角度来看待这个问题是个好主意。

为此，我在这里提供了一些关于地址解析的背景信息，从总体上探讨了与该技术有关的各种概念和问题。我首先讨论了一般意义上的地址解析的必要性。然后我描述了解决地址解析问题的两种主要方法：直接映射和动态解析。我还讨论了在实际的动态地址解析中涉及的一些效率问题，重点是缓存的重要性。

###### 2.1.1.1 地址解析需求（第1 2 3部分）

我可以想象，有些人可能会对地址解析的概念以及对执行这一功能的协议的需要表示异议。在我关于OSI参考模型的章节中，我广泛地谈到了拥有概念层的全部意义是为了分离逻辑功能，并允许高层协议隐藏在低层的细节中。既然如此，为什么我们还需要把协议和层联系在一起的地址解析协议呢？

我确实说过，层是有区别的，没错。但是，我也试图说明，OSI参考模型正是一个模型。经常会有一些实际问题出现，需要有严格意义上不符合层模型的解决方案。当模型不适合现实时，模型必须屈服。在处理地址解决的问题上也是如此。

<u>**第二层和第三层的寻址问题**</u>
当我们考虑OSI参考模型的七个层时，有两个层处理寻址问题：数据链路层和网络层。严格来说，物理层根本不涉及寻址问题，只是在比特层面进行发送。网络层以上的各层都使用网络层地址。

因此，下一个明显的问题是：为什么要在两个不同的层进行寻址？答案是，它们是非常不同类型的地址，用于不同的目的。第二层地址（如IEEE 802 MAC地址）用于可以直接通信的硬件设备之间的本地传输。它们被用来实现基本的LAN、WLAN和WAN技术。相比之下，第三层地址（最常见的是互联网协议或IP地址）用于内部联网，在网络层创建相当于一个巨大的 "虚拟 "网络。

这些类型的地址之间最重要的区别是第二层和第三层本身的区别：第二层处理直接连接的设备（在同一个网络上），而第三层处理间接连接的设备（以及直接连接）。比如说，你想连接到Web服务器，网址是http://www.tcpipguide.com。这是一个在服务器上运行的网站，服务器上有一个以太网卡，用于连接到其互联网服务提供商的网站。然而，即使你知道它的MAC地址，你也不能用它来直接与这台服务器对话，使用你家里PC中的以太网卡，因为这些设备在不同的网络上--事实上，它们可能在不同的大陆上！你必须在第三层进行通信。

相反，你在第三层进行通信，使用互联网协议和更高层次的协议，如TCP和HTTP。你的请求从你的家用机器出发，通过一连串的路由器，到达《TCP/IP指南》的服务器，然后响应被送回给你。从逻辑上讲，通信是在第三层及以上；你发送的请求不是给服务器网卡的MAC地址，而是给服务器的IP地址。

然而，虽然我们可以在第三层虚拟连接设备，但这些连接实际上只是概念上的。当你使用IP发送一个请求时，它是一次一跳地从一个物理网络发送到下一个物理网络。在每一跳中，在物理层和数据链路层发生实际的传输。当你的请求被发送到第三层的本地路由器时，实际的请求被封装在一个帧中，使用你物理连接到路由器的任何方法，并使用路由器的数据链路层地址传递给它。同样的情况发生在随后的每一步，直到最后，离目的地最近的路由器使用其数据链路（MAC）地址发送给了目的地。这在图44中得到了说明。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\arpresolutionneed.png)

​                                                                    <u>**图44: 为什么地址解析是必要的**</u>

在这个例子中，本地网络的一个客户正在访问互联网上的某个服务器。从逻辑上讲，这种连接可以在客户和服务器之间 "直接 "进行，但实际上它是第二层的一系列物理链接。在这种情况下，有六个这样的链接，其中大部分是位于客户端和服务器之间的路由器。在每个步骤中，根据第三层地址决定将数据发送到哪里，但实际传输必须使用路由中下一个预定收件人的第二层地址进行。

<u>**将第三层地址转换为第二层：地址解析**</u>

基本的问题是，IP地址对于网络上的物理硬件来说太高级了，它们不明白它们是什么。当你的请求出现在连接到《TCP/IP指南》的路由器上时，它可以看到http://www.tcpipguide.com 服务器的IP地址，但这并没有帮助：它需要发送服务器的MAC地址。

即使在局域网上的设备之间的通信也存在同样的问题。即使Web服务器与客户坐在同一张桌子上，通信在逻辑上是在IP层，但也必须在数据链路层完成。这意味着我们需要一种在这两层的地址之间进行转换的方法。这个过程被称为地址解析。

关键概念: 之所以需要地址解析，是因为网络设备在逻辑上使用第三层地址进行通信，但设备之间的实际传输是使用第二层（硬件）地址进行的。

<u>**一般地址解析方法**</u>

事实上，我们不仅需要有进行这种转换的方法，我们还需要关注进行转换的方式。由于路由转发发生在互联网上发送的每个数据报的每一跳，所以这个过程的效率是非常重要的。我们不希望使用一种占用大量网络资源的解析方法。

地址解析可以通过两种基本方式完成。

- 直接映射P:P用一个公式将上层地址映射到下层地址。这是更简单、更有效的技术，但有一些限制，特别是关于数据链路层地址的大小与网络层地址相比。

- 动态解析: 使用一种特殊的协议，允许只有一个IP地址的设备确定相应的数据链路层地址，即使它们的形式完全不同。这通常是通过询问本地网络上的一个或多个其他设备来确定什么数据链路层地址对应于一个给定的IP地址。这比直接映射更复杂，效率更低，但更灵活。

接下来的两个主题将更详细地探讨这两种方法。

你应该记住，出于需要，不可能有一个完全通用的地址解析方法，它可以自动工作。因为它处理的是将数据层地址与网络层地址联系起来的问题，所以实现起来必须针对这些层中所使用的技术。唯一可以真正被认为是通用的方法是使用静态的、手动更新的表格，即 "将这个三层地址链接到这个二层地址"。当然，这不是自动的，并带来手动配置的所有限制。

###### 2.1.1.2 通过直接映射进行地址解析（部分：1 2 3）

在每个数据报通过互联网络传输期间，网络层地址必须多次解析为数据链路层地址。因此，我们希望该过程尽可能简单和高效。实现这一点的最简单方法是在两种类型的地址之间进行直接映射。

直接映射背后的基本思想是为第 2 层和第 3 层地址选择一种方案，以便您可以使用简单的算法确定其中一个。这使您能够获取第三层地址，并按照一个简短的过程将其转换为第二层地址。本质上，只要您拥有第三层地址，您就已经拥有第二层地址。

直接映射的最简单示例是，如果我们对数据链路和网络层地址使用相同的结构和语义。这通常是不切实际的，因为这两种类型的地址服务于不同的目的，因此基于不兼容的标准。但是，如果我们能够灵活地创建足够大的第三层地址，以便在其中编码完整的数据链路层地址，我们仍然可以执行直接映射。然后，确定第二层地址是选择第三层地址的特定部分的简单问题。

例如，考虑一个简单的 LAN 技术，如 ARCNet。它使用一个短的 8 位数据链路层地址，有效值为 1 到 255，可由管理员分配。通过采用 C 类（或 /24）网络并使用 ARCNet 数据链路层作为最后一个八位字节，我们可以轻松地在这样的 LAN 上建立 IP 网络。因此，例如，如果我们的网络是 222.101.33.0/24，我们可以为 ARCNet 地址 #1 的设备分配 IP 地址 222.101.33.1，ARCNet 地址 #29 的设备将是 222.101.33.29，依此类推，如如图 45 所示。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\arpdirectmapping.png)

​                                                            **图 45：通过直接映射的地址解析**

当硬件地址较小时，很容易定义一个直接对应于第三层地址的一部分的映射。在本例中，一个 8 位 MAC 地址（例如用于 ARCNet 的 MAC 地址）被映射到设备 IP 地址的最后一个字节，从而使地址解析变得轻而易举。

这个系统的吸引力是显而易见的。从概念上讲，理解起来非常简单——要获取设备的硬件地址，只需使用 IP 地址的最后八位。对设备进行编程也非常简单，而且效率很高，根本不需要在网络上交换数据。

**关键概念**：当第二层地址小于第三层地址时，可以定义它们之间的直接映射，从而可以直接从网络层地址确定硬件地址。这使得地址解析非常简单，但降低了地址分配方式的灵活性。

<u>**大型硬件地址无法进行直接映射**</u>

不幸的是，直接映射仅在可以将数据链路层地址表示为网络层地址的函数时才有效。请考虑在以太网上运行的相同 IP 地址 222.101.33.29。在这里，数据链路层地址被“硬连线”到硬件本身（它们有时可以被覆盖，但通常不会这样做）。更重要的是，MAC 地址是 48 位宽，而不是 8 位。这意味着第二层地址大于第三层地址，无法进行直接映射，如图 46 所示。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\arpdirectmappingnogo.png)

​                                                **图 46：大硬件地址大小的地址解析问题**

当第二层地址的大小大于第三层地址时，不可能在它们之间定义可用于地址解析的映射。

注意：在硬件地址大小超过网络层地址大小的情况下，我们可以做一个“部分映射”。例如，我们可以使用 IP 地址来获取 MAC 地址的一部分，并希望我们没有使用的位没有重复。这种方法不太适合常规传输，但实际上用于将 IPv4 中的多播地址解析为以太网地址。

那么，一般来说，当第三层地址小于第二层地址时，直接映射是不可能的。考虑到以太网是第二层最流行的技术并使用 48 位地址，而 IP 是第三层最流行的技术并使用 32 位地址。这就是为什么直接映射是一种不仅没有被广泛使用而且大多数人都不知道的技术的原因之一！

<u>**直接映射的不灵活性**</u>

现在让我们考虑下一代，IP 版本 6？ IPv6 支持海量 128 位地址。此外，甚至使用一种方法来定义常规（单播）地址，该方法使用特殊映射从数据链路层地址创建它们。这在理论上允许 IPv6 使用直接映射来解析地址。

但是，决定让 IPv6 像 IPv4 一样使用动态解析。一个原因可能是历史原因，因为 IPv4 使用动态分辨率。然而，更大的原因可能是由于直接映射的一个缺点：它的不灵活性。动态解析是一种更通用的解决方案，因为它允许数据链路层和网络层地址独立，并且它的缺点可以通过仔细实施来消除，正如我们将看到的。

事实上，这一点的证据可以从我们刚刚使用的示例 ARCNet 上实际上定义 IP 的动态分辨率这一事实中看出。我们可以在那里进行直接映射，但它限制了我们使用某种 IP 寻址模式，从而降低了灵活性。

###### 2.1.1.3 动态地址解析

直接映射提供了一种将网络层地址解析为数据链路层地址的简单且高效的方法。不幸的是，在大多数情况下，我们不能或不应该使用这种技术。当数据链路层地址的大小大于网络层地址的大小时，我们不能使用它。我们在需要灵活性的时候不应该使用它，因为直接映射需要我们使第三层和第二层地址对应起来。

直接映射的替代方法是一种称为动态地址解析的技术。为了理解这是如何工作的，我们可以考虑一个简单的类比。我敢肯定你见过豪华轿车司机在机场等着接一个他们不认识的人。 （嗯，你在电影里见过，不是吗？）这与我们的问题类似：他们知道他们必须运送的人的姓名，但不知道该人的脸（一种“本地地址”）一种说话方式！）为了找到那个人，他们举起一张印有那个人名字的卡片。除了那个人之外，其他人都忽略了这张卡，但希望被寻找的人能认出它并接近司机。

我们对网络中的动态地址解析做同样的事情。假设设备 A 想要发送到设备 B，但只知道设备 B 的网络层地址（它的“名称”），而不知道它的数据链路层地址（它的“面孔”）。它会广播一个包含设备 B 的第三层地址的第二层帧——这就像举起上面写着某人名字的卡片一样。 B 以外的设备不识别这个第三层地址并忽略它。然而，设备 B 知道它自己的网络层地址。它在广播帧中识别到这一点，并将直接响应发送回设备 A。这告诉设备 A 设备 B 的第二层地址是什么，并且解析完成。图 47 说明了该过程。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\arpdynamic.png)

​                                                                            **图 47：动态地址解析**

设备 A 需要向设备 B 发送数据，但它只知道它的 IP 地址（“IPB”），而不知道它的硬件地址。 A 广播请求，要求使用 IP 地址“IPB”发送设备的硬件地址。 B 直接用硬件地址回复 A。

**关键概念**：动态地址解析通常使用特殊协议实现。一个只知道另一个设备的网络层地址的设备可以使用这个协议来请求另一个设备的硬件地址。

直接映射非常简单，但正如您所见，动态分辨率并不完全是火箭科学。这是一种非常简单的技术，很容易实现。此外，它消除了与直接映射相关的限制。网络层地址和数据链路层地址之间不需要任何特定的关系；它们可以具有完全不同的结构和大小。

但是，有一个烦人的问题：效率问题。在直接映射涉及快速计算的情况下，动态解析要求我们使用协议通过网络发送消息。幸运的是，我们可以采用一些技术来通过仔细实施来消除这种成本的一些影响。

###### 2.1.1.4 动态地址解析缓存和效率问题（第12部分）

动态地址解析消除了我们在看直接映射时看到的限制，并允许我们轻松地关联任何大小或结构的第二层和第三层地址。它的唯一问题是，每次地址解析都需要我们发送一个额外的信息，而在直接映射中是不需要的。更糟糕的是，由于我们不知道接收者的第二层身份，我们必须使用广播消息（或至少是组播），这意味着本地网络上的许多设备必须占用资源来检查数据帧，并检查哪个IP地址正在被解析。

当然，多发一条信息似乎不是什么大问题，而且帧不必很大，因为它只包含一个网络层地址和一些控制信息。然而，当我们必须为每一跳数据报传输做这件事时，开销就真的增加了。由于这个原因，虽然上一主题中描述的基本动态地址解析是简单和实用的，但它通常是不够的。我们必须为地址解析的实现添加一些智能，以减少持续的地址解析对性能的影响。

<u>**缓存的好处**</u>
考虑到本地网络上的大多数设备只向一小部分其他物理设备发送信息，而且往往是反复发送。这是一种被称为参考定位的现象，在计算领域的各种不同领域都可以观察到。如果你从你的办公室电脑向一个互联网网站发送请求，它将需要首先进入你公司网络的本地路由器，所以你将需要解决路由器的第二层地址。如果你后来点击该网站上的一个链接，该请求也需要转到路由器上。事实上，你在本地网络上做的几乎所有事情，都可能首先进入同一台路由器（通常称为默认网关）。每次都要重新解决是很愚蠢的。这就像每次你想打电话问候时，都要查找你最好的朋友的电话号码（让我想起《周六夜现场》中那个没有短期记忆的家伙的短剧，但我想说的是）。

为了避免被指责为制定了愚蠢的地址解析协议，设计者总是包括一个缓存机制。在一个设备的网络层地址被解析为数据链路层地址之后，两者之间的联系被保存在设备的内存中一段时间。当它下次需要第二层地址时，设备只需在其缓存中进行快速查找。这意味着我们不用对每个数据报进行广播，而只需对整个数据报序列进行一次广播。

缓存是迄今为止动态解析中最重要的性能提升工具。它把本来非常浪费的过程变成了一个在大多数情况下效率不低于直接映射的过程。然而，它确实增加了复杂性。缓存表条目必须被维护。还有一个问题是，表中的信息可能会随着时间的推移而变得陈旧；如果我们改变了一个设备的网络层地址或数据链路层地址，会发生什么？由于这个原因，缓存条目必须被设置为定期过期。关于TCP/IP ARP协议中的缓存的话题显示了如何处理这些问题的一些具体细节。

<u>**对动态分辨率的其他改进**</u>

对于基本的动态解析方案，也可以进行其他的改进。让我们再考虑一下我们向互联网发送请求的例子。我们发送了一个需要发送到本地路由器的请求，所以我们解析了它的地址并将请求发送给它。过了一会儿，回复又回到了路由器上，要发送给我们，所以路由器需要我们的地址。因此，它将不得不对我们进行动态解析，尽管我们只是交换了帧。同样：愚蠢。相反，我们可以通过交叉解析来提高效率；当设备A解析设备B的地址时，设备B也将设备A的条目添加到它的缓存中。

也可以进行另一种改进。如果你想一想，本地网络上的设备会相当频繁地相互交谈，即使它们现在没有在聊天。如果A正在解析B的网络层地址，它将广播一个帧，C、D、E等设备都会看到。为什么不让他们也用他们看到的解析信息来更新他们的缓存表，以便将来使用？

**这些和其他的改进都有助于减少动态地址解析的效率问题。它们结合在一起，使动态解析在整体能力上接近于直接映射，以至于没有充分的理由不使用它。**再一次，你可以在描述TCP/IP ARP协议的缓存功能的主题中看到更多的细节。

顺便提一下，在这个讨论中，还有一个提高性能的想法有时会被提出来：与其在数据报传输之前为地址解析增加一个广播步骤，为什么不直接广播数据报就完事了呢？我们实际上可以这样做，如果数据报足够小的话，会更有效率。但通常情况下，数据报是很大的，而解析帧可能相当紧凑；做一个小的广播，然后做一个大的单播，而不是一个大的广播，是有意义的。另外，假设我们真的广播了这一个数据报：那么下一个数据报和之后的数据报呢？每一个都需要广播。当我们做一个决议时，有了缓存，我们只需要偶尔广播一次，而不是持续地广播。

##### 2.1.2 TCP/IP地址解析协议（ARP）

到目前为止，世界上使用最广泛的网络层协议是TCP/IP互联网协议。因此，最重要的地址解析协议是与该技术本身同名的TCP/IP协议：地址解析协议（ARP），这并不奇怪。ARP是一个全功能的动态解析协议，用于将IP地址与底层数据链路层地址相匹配。它最初是为以太网开发的，现在已被普及到允许IP在各种二层技术上运行。

在本节中，我描述了ARP的操作和特点。我首先概述了该协议，并讨论了其定义的标准和历史。我简要概述了ARP中如何指定地址和它的一般操作，并描述了ARP消息使用的消息格式。然后，我转向了ARP中的缓存这一重要问题，以及如何利用它来提高性能。最后，我讨论了ARP中的代理问题，这对于支持特殊的网络连接情况是必要的。

**背景资料: ** 关于地址解析的一般解释，什么是地址解析，以及它是如何工作的，可以在前面的地址解析概念部分找到。除了在概述的开始部分进行简要回顾外，我假定你对这些概念已经很熟悉了。

**注意**：这里描述的地址解析协议是用于解析互联网协议第4版中的单播地址。**IPv4下的组播地址使用的是直接映射方法**，在另一个主题中描述。IPv6使用新的邻居发现协议而不是ARP；这将在IPv6地址解析的概述中讨论。

**相关信息:** 关于有移动IP设备的网络中ARP相关问题的讨论，请参见移动IP部分。

**相关信息:** 软件应用程序 "arp "用于管理主机上的TCP/IP ARP实现，在TCP/IP实用程序一节中以自己的主题进行讨论。

###### 2.1.2.1 ARP概述、标准和历史

物理网络在OSI参考模型的第一和第二层运作，并使用数据链路层地址。相比之下，网络协议在第三层发挥作用，将这些物理网络相互连接起来，形成一个可能由使用网络层地址的设备组成的巨大网络。地址解析是将网络层地址解析为数据链路层地址的过程，以允许数据在国际网络中一跳一跳地发送。我在前面的概念部分详细描述了地址解析。

在TCP/IP协议套件的开发过程中，地址解析的问题从一开始就很明显。IP的早期发展大部分是在当时刚刚起步的以太网局域网技术上进行的；这甚至是在以太网被正式标准化为IEEE 802.3之前。有必要定义一种将IP地址映射到以太网地址的方法，以允许在以太网网络上进行通信。

有两种基本的解析方法可以用来完成这种地址的关联：直接映射或动态解析。然而，以太网地址是48位的，而IP地址只有32位，这就立即排除了直接映射。此外，IP的设计者希望通过使用动态解析模型获得灵活性。为此，他们开发了TCP/IP地址解析协议（ARP）。这个协议在最早的互联网RFC中被描述，至今仍在普遍使用。RFC 826，一个以太网地址解析协议，发表于1982年。

这个名字清楚地表明，ARP最初是为以太网开发的。因此，它代表了最流行的第二层局域网协议和最流行的第三层互联网协议之间的联系--即使在20年后也是如此。然而，从一开始就很明显，即使以太网是一种非常普遍的传输IP的方式，它也不会是唯一的方式。因此，ARP被做成了一个通用协议，不仅能够将地址从IP解析到以太网，而且能够解析到许多其他数据链路层技术。

ARP的基本操作包括在一个广播信息中对预期接收者的IP地址进行编码。它在本地网络上发送，以允许IP数据报的预期接收者以其数据链路层地址回应源。这是用一个简单的请求/回复方法完成的，在下面关于一般操作的主题中描述。ARP消息使用了一种特殊的格式，它被传递到本地数据链路层进行传输。

**关键概念:**  ARP是为了促进IP和以太网之间的动态地址解析而开发的，现在也可以在其他第二层技术上使用。它的工作原理是允许一个IP设备在本地网络上发送一个广播，要求同一本地网络上的另一个设备响应其硬件地址。

这一基本操作由提高性能的方法来补充。由于从一开始就知道，对每个数据报使用广播进行解析是非常低效的，因此ARP一直使用缓存，它在本地网络上保持IP地址和数据链路层地址之间的绑定。随着时间的推移，各种技术已经被开发出来，以改进用于维护缓冲区条目的方法。完善和额外的功能，如支持成对设备的交叉解析以及代理ARP，也在这些年被定义并添加到基本的ARP功能集中。

###### 2.1.2.2  ARP地址规范和一般操作（第12部分）

当 IP 网络上的源设备有一个 IP 数据报要发送时，地址解析协议事务就开始了。它必须首先确定目标设备是在本地网络上还是在远程网络上。如果是前者，它将直接发送到目的地；如果是后者，它会将数据报发送到物理网络上的其中一个路由器进行转发。无论哪种方式，它将确定需要成为其 IP 数据报在本地网络上的直接目的地的设备的 IP 地址。打包数据报后，它会将其传递给其 ARP 软件进行地址解析。

ARP 的基本操作是本地网络上的请求/响应对传输。源（需要发送 IP 数据报的那个）传输包含有关目的地（数据报的预期接收者）信息的广播。目的地然后将单播响应回源，告诉源目的地的硬件地址。

**ARP 消息类型和地址指定**

源和目的地这两个术语在整个交易过程中适用于相同的设备。但是，在 ARP 中发送了两种不同的消息，一种是从源到目标，另一种是从目标到源。对于每条 ARP 消息，发送方是发送消息的一方，目标方是接收方。因此，每条消息的发送者和目标的身份都会发生变化：

- 请求：对于初始请求，发送者是源，要发送IP数据报的设备，目标是目的地。
- 回复：对于ARP请求的回复，发送者为目的地；它回复源，它成为目标。

这有点令人困惑，但你会习惯的。 J 任何消息中的两方都有两个地址（第二层和第三层）需要关注，因此每条消息中涉及四个不同的地址：

- 发送方硬件地址：ARP 报文发送方的第二层地址。
- 发送者协议地址：ARP 消息发送者的第三层 (IP) 地址。
- 目标硬件地址：ARP 报文目标的第二层地址。
- 目标协议地址：目标的第三层 (IP) 地址。

这些地址在 ARP 消息格式中都有一个位置。

<u>**ARP一般操作**</u>

有了这样的背景，让我们看看ARP事务中遵循的步骤（图48中的插图也以图形方式显示了这些步骤）：

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\arpoperation.png)

​                                                                                <u>**图48: 地址解析协议（ARP）交互过程**</u>

这张图显示了一个典型的ARP事务所遵循的步骤顺序，以及源设备和目的设备之间的信息交换，还有缓存检查和更新功能。(那些小柱子应该是硬盘，而不是汤罐！J)

1. 源设备检查缓存。源设备将首先检查其缓存，以确定它是否已经有目标设备的分辨率。如果是，它就可以跳到这个过程的最后一步，即第9步。

2. 源设备生成ARP请求消息。源设备生成一个ARP请求消息。它将自己的数据链路层地址作为发送方硬件地址，将自己的IP地址作为发送方协议地址。它填入目的地的IP地址作为目标协议地址。(它必须把目标硬件地址留空，因为这是它试图确定的内容！）。

3. 源设备广播ARP请求信息。源设备在本地网络上广播ARP请求消息。

4. 本地设备处理ARP请求信息。本地网络上的每个设备都会收到该消息。它被处理，每个设备都在寻找目标协议地址的匹配。那些不匹配的设备将放弃该消息，不采取进一步行动。

5. 目标设备产生ARP回复信息。IP地址与信息的目标协议地址内容相匹配的设备将产生一个ARP回复信息。它从ARP请求报文中获取发送方硬件地址和发送方协议地址字段，并将其作为回复的目标硬件地址和目标协议地址的值。然后，它填入自己的第二层地址作为发送方硬件地址，填入其IP地址作为发送方协议地址。其他字段的填写与描述ARP消息格式的主题中的解释相同。

6. 目的地设备更新ARP缓存。如果源端现在需要向目的端发送一个IP数据报，那么目的端可能很快就需要向源端发送一个响应。(毕竟，网络上的大多数通信都是双向的。）那么，作为一种优化，目的地设备将在自己的ARP缓存中添加一个条目，包含发送ARP请求的源的硬件和IP地址。这使目的地设备以后不需要再做不必要的解析循环。

7. 目的地设备发送ARP回复信息。目的地设备发送ARP回复信息。然而，这个回复是以单播方式发送给源设备的，因为不需要广播。

8. 源设备处理ARP回复消息。源设备处理来自目的地的回复。它将发送者硬件地址存储为目的地的第二层地址，以用于发送其IP数据报。

9. 源设备更新ARP缓存。源设备使用发送方协议地址和发送方硬件地址来更新其ARP缓存，以便将来向该设备传输时使用。

<u>**关键概念:**</u> ARP是一个相对简单的请求/回复协议。源设备广播一个ARP请求，根据其IP地址寻找一个特定的设备。该设备在ARP回复信息中以其硬件地址进行回复。

**注意，**这个描述有点超出了地址解析的基本步骤，因为提到了两个增强功能。一个是缓存，它在自己的主题中描述，但不得不在这里提到，因为它是这个过程的第一步，原因显而易见。另一个是交叉解析（在动态解析中的缓存问题概述中描述），这是该过程的第6步。这就是为什么源设备在请求中包括其IP地址。其他原因其实并不需要，所以你可以看到这个功能从一开始就被内置到ARP中。

###### 2.1.2.3 ARP消息格式

使用ARP的地址解析是通过寻求执行解析的源设备和响应它的目的设备之间的消息交换来完成的。与其他协议一样，使用一种特殊的消息格式，其中包含解析过程的每一步所需的信息。

ARP消息使用一种相对简单的格式。它包括一个描述消息类型的字段（其操作代码或操作码）以及第二层和第三层地址的信息。为了支持可能具有不同长度的地址，该格式规定了第二层和第三层使用的协议类型以及在每一层使用的地址长度。然后，它包括我们在上一主题中看到的所有四个地址组合的空间。

表42对ARP消息使用的格式进行了全面描述，并在图49中作了说明。
                                        **表42: 地址解析协议（ARP）消息格式**

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\arp-1.jpg)

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\arp-2.jpg)

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\arp-3.jpg)

​                                                                      **图49：地址解析协议（ARP）消息格式**

ARP消息格式旨在容纳不同大小的第二层和第三层地址。此图显示了最常见的实现，它使用32位表示第三层（“协议”）地址，48位表示第二层硬件地址。当然，这些数字对应于以太网使用的互联网协议版本4和IEEE 802 MAC地址的地址大小。

ARP消息组成后，向下传递到数据链路层进行传输。消息的全部内容成为网络上实际发送的消息的有效负载，例如以太网帧。注意，ARP消息的总大小是可变的，因为地址字段的长度是可变的。然而，通常情况下，这些消息非常小：例如，对于IEEE 802 MAC地址中承载IPv4数据报的网络，它们只有28个字节。

###### 2.1.2.4 ARP缓存（部分：12）

ARP是一个动态解析协议，这意味着每次解析都需要在网络上交换信息。每次设备发送ARP消息时，都会占用本地网络，消耗网络带宽，无法用于 "真正的 "数据流量。ARP消息并不大，但如果要为每个IP数据报的每一跳都发送ARP消息，将对网络的性能造成不可接受的影响。与更简单的直接映射解决方法相比，它还浪费了时间。除此之外，ARP请求消息是广播式的，这意味着本地网络上的每个设备都必须花费CPU时间来检查每个消息的内容。

解决动态解析的效率问题的一般方法是采用缓存，我在地址解析概念一节中对缓存进行了一般性描述。除了减少网络流量外，缓存还能确保常用地址的解析速度，使整体性能与直接映射相当。出于这个原因，缓存功能从一开始就被内置到ARP中。

<u>**静态和动态ARP缓存条目**</u>
ARP缓存的形式是一个包含匹配的硬件和IP地址集的表。网络上的每个设备都管理着自己的ARP缓存表。有两种不同的方式可以将缓存条目放入ARP缓存中。

- 静态ARP缓存条目。这些是手动添加到设备的缓存表中的地址决议，并永久保存在缓存中。静态条目通常使用一个工具来管理，如arp软件工具。

- 动态 ARP 缓存条目。这些是硬件/IP地址对，由于成功完成了过去的ARP决议，所以由软件本身添加到缓存中。它们只在缓存中保留一段时间，然后被删除。

一个设备的ARP缓存可以包含静态和动态条目，每一种都有优点和缺点。然而，动态条目最常被使用，因为它们是自动的，不需要管理员干预。

静态ARP条目最好用于特定设备必须定期进行通信的设备。例如，一台工作站可能为其本地路由器和文件服务器有一个静态ARP条目。由于该条目是静态的，它总是在ARP事务过程的第1步中被发现，因此不需要为该条目中的目的地发送解析信息。缺点是这些条目必须手工添加，如果条目中的任何硬件或IP地址发生变化，也必须进行更改。另外，每个静态条目都会占用ARP缓存的空间，所以你不希望 "过度使用 "静态条目。例如，为网络上的每一个设备都设置静态条目并不是一个好主意。

<u>**缓存条目过期**</u>

动态条目是在 "需要 "的基础上自动添加到缓存中的，因此它们代表了某一设备正在积极使用的主机和路由器的映射。它们不需要被手动添加或维护。然而，同样重要的是要认识到，动态条目不能被添加到高速缓存中并永远留在那里。其原因是，由于网络的变化，长期留在那里的动态条目会变得陈旧。

考虑一下设备A的ARP缓存，它包含了设备B的动态映射，设备B是网络上的另一台主机。如果动态条目永远留在缓存中，可能会出现以下情况。

- 设备硬件变化。设备B可能遇到硬件故障，需要更换其网络接口卡。设备A的缓存中的映射将变得无效，因为条目中的硬件地址已经不在网络上了。

- 设备IP地址改变。同样，如果设备B的IP地址发生变化，设备A的缓存中的映射也会变得无效。

- 设备移除。假设设备B被从本地网络中移除。设备A将不再需要在数据链路层向其发送信息，但映射将保留在设备A的缓存中，浪费空间并可能占用搜索时间。

为了避免这些问题，动态缓存条目必须被设置为在一段时间后自动过期。这是由ARP实现自动处理的，典型的超时值是10或20分钟。在一个特定的条目超时后，它被从缓存中删除。下一次需要地址映射时，将进行新的解析以更新缓冲区。这比静态条目的效率略低，但每10或20分钟发送两个28字节的信息并不是什么大问题。

正如在ARP操作概述中提到的，动态缓存条目不仅在设备发起解析时被添加，而且在它是目标设备时也被添加。这是另一项改进，可以减少不必要的地址解析流量。

<u>**额外的缓存功能**</u>
其他的增强功能通常也会落实到位，这取决于实现方式。标准ARP要求，如果设备A用广播发起解析，网络上的每个设备都应该为设备A更新自己的缓存条目，即使它们不是设备A试图到达的设备。然而，在这种情况下，这些 "第三方 "设备并不需要为A创建新的缓存条目。

这里的问题是一个权衡：创建一个新的缓存条目可以使这些设备在不久的将来不需要解析设备A的地址。然而，这也意味着网络上的每一个设备都会很快有一个ARP缓存表，其中充满了网络上大多数其他设备的地址。这在较大的网络中可能是不可取的。即使在较小的网络中，这种模式也可能没有意义，因为现代计算在本质上是客户/服务器，局域网上的对等设备可能不经常直接通信。一些设备可能会选择创建这样的缓存条目，但将其设置为在很短的时间内过期，以避免填充缓存。

每个ARP实现还负责维护缓存所需的任何其他 "内务管理"。例如，如果一个设备在一个有许多主机的本地网络上，它的缓存表太小了，可能有必要删除旧的、不经常使用的条目，以便为新条目腾出空间。理想情况下，缓存应该足够大，以容纳网络上所有与设备定期通信的其他设备，以及一些偶尔与之交谈的设备的空间。

###### 2.1.2.5 代理ARP（部分：12）

ARP被设计成由本地网络上直接连接的设备使用。网络上的每个设备都应该能够直接向其他设备发送单播和广播传输。通常情况下，如果设备A和设备B被一个路由器隔开，它们就不会被认为是彼此的本地设备。设备A不会直接向B发送，反之亦然；它们会在第二层向路由器发送，并在第三层被视为 "相隔两跳"。

<u>**为什么需要代理ARP**</u>
与正常情况不同的是，在一些网络中，可能有两个物理网段通过路由器连接，它们处于同一个IP网络或子网络中。换句话说，设备A和设备B可能在数据链路层的不同网络上，但在同一个IP网络或子网。当这种情况发生时，A和B在寻找发送IP数据报时，都会认为对方在本地网络上。

在这种情况下，假设A想向B发送数据报，但它的缓存中没有B的硬件地址，所以它开始进行地址解析。然而，当它广播ARP请求消息以获得B的硬件地址时，它将很快遇到一个问题：B实际上不在A的本地网络上。他们之间的路由器不会把A的广播传到B的那部分网络上，因为路由器不传硬件层的广播。B永远不会收到这个请求，因此A也不会收到包含B的硬件地址的回复。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\arpproxy.png)

​                                                                                    **图50：ARP代理操作** 

在这个小型网络中，一台路由器连接了两个位于同一IP网络或子网的LAN。路由器不会传递ARP广播，但已被配置为ARP代理。在这个例子中，设备A和设备D各自试图向对方发送一个IP数据报，因此各自广播了一个ARP请求。路由器响应设备A发出的请求，就像它是设备D一样，给A自己的硬件地址（不传播设备A的广播），它将把A发出的信息转发给D网络上的D。同样地，它响应设备D，就像它是设备A一样，给出自己的地址，然后把D发给它的东西转发到A所在的网络。

代理ARP为网络提供了灵活性，在这些网络中，主机实际上并不都在同一个物理网络上，但在网络层上被配置成好像它们都在同一个物理网络上。它可以用来在设备不能直接响应ARP消息广播的其他特殊情况下提供支持。当为安全目的配置了防火墙时，可以使用它。一种代理也被用作移动IP协议的一部分，以解决移动设备远离其家庭网络时的地址解析问题。

**关键概念：** 由于ARP依靠广播进行地址解析，而广播不会传播到物理网络之外，因此ARP不能在不同物理网络上的设备之间发挥作用。当需要这种操作时，可以将一个设备，如路由器，配置为ARP代理，代表不同网络上的设备响应ARP请求。

<u>**代理的优点和缺点**</u>
代理的主要优点是，它对不同物理网段的主机是透明的。但这种技术也有一些缺点。首先，它引入了额外的复杂性。第二，如果有一个以上的路由器使用相同的网络ID连接两个物理网络，可能会出现问题。第三，它引入了潜在的安全风险；因为它本质上意味着一个路由器 "冒充 "设备，充当它们的代理，提高了一个设备欺骗另一个设备的可能性。由于这些原因，如果可能的话，重新设计网络，使路由在由路由器分隔的物理网络之间完成，可能会更好。

##### 2.1.3 用于IP多播地址的TCP/IP地址解析（部分：1 2 )

像大多数关于地址解析的讨论一样，前面的章节都集中在单播通信上，即数据报从一个源设备发送到一个目标设备。无论使用直接映射还是动态解析来解析网络层地址，当数据报只有一个目标接收者时，解析地址是一个相对简单的事情。TCP/IP使用ARP作为其动态解析方案，该方案仅设计用于单播解析。

然而，互联网协议也支持数据报的多播，正如我在IP多播和IP多播寻址主题中所解释的那样。在这种情况下，数据报必须发送给多个接收者，这使问题变得相当复杂。我们需要在IP多播组地址和数据链路层的设备地址之间建立某种关系。我们可以通过在数据链路层将IP组播数据报转换为单独的单播传输来做到这一点，每个都使用ARP进行解析，但这将是非常低效的。

<u>**IEEE 802组播MAC地址的直接映射技术**</u>
在可能的情况下，IP利用底层网络的多播寻址和传输能力，在物理网络上传输多播数据报。也许令人惊讶的是，尽管ARP采用了动态解析，但多播地址的解析是通过直接映射技术的一个版本完成的。通过定义IP组播组和数据链路层组播组之间的映射，我们使物理设备能够知道何时关注组播数据报。

最常用的支持组播的数据链路寻址方案是IEEE 802寻址系统，它在以太网中的使用最为著名。这些数据链路层地址有48位，被安排成两个24位的块。上面的24位被安排在一个叫做组织唯一标识符（OUI）的块中，为各个组织分配不同的值；然后下面的24位被用于特定的设备。

互联网指定号码管理机构（IANA）本身有一个OUI，它用于将组播地址映射到IEEE 802地址。这个OUI是 "01：00：5E"。为了形成以太网的映射，这个OUI使用了24位，第25位（48位中的）总是零。这就使原来48位中的23位被用来编码组播地址。为了进行映射，组播地址的低阶23位被用作以太网地址的最后23位，以 "01:00:5E "开始，用于发送组播信息。这个过程如图51所示。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\arpmulticast.png)

​                                                                **图51: 多播IP地址与IEEE 802多播MAC地址的映射**

IP组播地址由位串 "1110 "和28位组播地址组成。为了创建一个48位的IEEE 802（以太网）组播地址，前24位被填入IANA的组播OUI，01-00-5E，第25位为零，组播组的底部23位被放入MAC地址的底部23位。这就留下了5位（粉色显示）没有映射到MAC地址，这意味着32个不同的IP地址可能有相同的映射的组播MAC地址。

**关键概念:**   IP组播地址被解析为IEEE 802（以太网）MAC地址，使用直接映射技术，使用IP组播地址中28位中的23位。

<u>**处理多个IP地址映射到一个组播硬件地址的问题**</u>

当然，IP组播地址中有28个唯一的位，所以这是一个 "位 "的问题。J它的意思是，IP组播地址和以太网组播地址之间没有唯一的映射。由于组播组的28位中有5位不能在以太网地址中编码，所以32（25）个不同的IP组播地址映射到每个可能的以太网组播地址上。在理论上，这将是一个问题，但在实践中，它不是。在一个网络上，任何两个IP组播地址同时映射到同一个以太网组播地址的机会是相当小的。

不过，在同一个物理网络中，有可能出现两个IP组播组，并可能映射到同一个数据链路层组播地址。由于这个原因，设备不能认为它们收到的所有组播消息都是为它们的组准备的；它们必须把消息上传到IP层，检查完整的IP组播地址，以确保它们真的应该得到它们收到的组播数据报。如果他们不小心收到的是为他们不属于的多播组准备的数据报，他们就会丢弃它。这种情况不常发生，所以相对缺乏效率并不是一个大问题。

##### 2.1.4 用于IP版本6的TCP/IP地址解析 (Parts: 1 2 )

TCP/IP地址解析协议（ARP）是一个相当通用的协议，用于将网络层地址动态地解析为数据链路层地址。尽管它是为IP版本4设计的，但其信息格式允许在硬件和网络层上使用可变长度的地址。这种灵活性意味着理论上可以将其用于新的IP版本--第6版，即IPv6--这是在我们的未来。可能需要做一些小的改动，但技术可能是相同的。

然而，IPv6的设计者选择不这样做。改变IP是一项已经进行了多年的大工程，是改变TCP/IP各方面的一个难得机会。IETF决定利用IPv6的变化，不仅对IP本身进行大修，而且还对许多 "支持 "或 "协助 "IP的协议进行大修。在IPv6中，ARP的地址解析工作已经与原TCP/IP套件中ICMP执行的若干功能相结合，并补充了额外的功能，定义为新的邻居发现（ND）协议。

IPv6中的 "邻居 "一词只是指本地网络中的设备，顾名思义，ND负责与邻居之间的信息交流有关的任务（包括其他方面）。我在自己的章节中简要描述了ND，包括对它所执行的各种任务的讨论。在这里，我想特别关注ND如何执行地址解析。

<u>**基本的IPv6地址解析方法**</u>
IPv6 ND中地址解析的基本概念与IPv4 ARP中的地址解析并没有什么不同。解析仍然是动态的，并且是基于使用一个缓存表来维护IPv6地址和硬件地址的配对。物理网络上的每个设备都会为其邻居跟踪这一信息。当一个源设备需要向本地网络邻居发送IPv6数据报，但没有其硬件地址时，它就会启动解析过程。为了使文字更清晰，我们假设，像往常一样，设备A试图向设备B发送。

A没有发送ARP请求消息，而是创建了一个ND邻居请求消息。现在，这里可以看到ARP的第一个大变化。如果底层数据链路协议支持组播，像以太网那样，邻居请求消息就不是广播。相反，它被发送到我们试图解决其IPv6地址的设备的被请求节点地址。因此，A不会广播该消息，它将多播到设备B的请求节点多播地址。

设备B将收到邻里请求，并以邻里广告回应设备A。这类似于ARP回复，告诉设备A B的物理地址。为了提高效率，像IPv4地址解析一样支持交叉解析。这是通过让设备A在邻居请求中包括它自己的第二层地址来实现的，假设它知道这个地址。设备B将把它和A的IP地址一起记录在B的邻居缓冲区。

<u>**使用被请求的节点多播地址进行解析**</u>

征求节点多播地址是一个特殊的映射，由支持多播的网络上的每个设备从其单播地址中创建；它在IPv6多播地址的主题中有所描述。征求节点地址对每个IPv6地址来说都不是唯一的，但在一个特定的网络中，任何两个邻居拥有相同地址的几率很小。每个收到组播邻居请求的设备仍然必须检查，以确保它是源试图解决的地址的设备。(这与IPv4中处理组播的方式类似，32个不同的IP地址可能共享一个组播MAC地址）。

如果设备仍然需要检查每条信息，为什么还要这样做呢？很简单：组播最多只会影响少数设备。如果是广播，本地网络上的每一个设备都会收到消息，而使用征求的节点地址意味着最多只有几个设备需要处理它。其他设备甚至根本不需要费心检查邻居请求消息。

**关键概念:** IPv6的地址解析使用新的邻居发现（ND）协议，而不是地址解析协议。试图发送IPv6数据报的设备发送一个邻居请求消息，以获得另一个设备的地址，该设备以邻居广告作为回应。在可能的情况下，为了提高效率，该请求是使用一种特殊类型的组播地址而不是广播来发送的。

这实际上是对IPv6中解析工作的一个相当简化的解释--邻居发现协议是相当复杂的。邻居请求和广告还用于其他功能，如测试节点的可达性和确定是否有重复的地址在使用。有许多特殊情况和问题，ND解决这些问题是为了确保在地址解析过程中不产生问题。ND还支持代理的地址解析。

**注意：**尽管我把这个话题放在了靠近其他地址解析讨论的地方，但邻居发现协议确实不是一个 "层连接 "或像ARP那样的 "低层 "协议。它的作用和功能类似于ICMP，而且事实上使用了ICMP(v6)消息。这种结构变化的一个好处是，对物理网络特性的依赖性较小，所以解决的方式与其他网络支持活动更相似。因此有可能利用可以应用于所有IP数据报传输的设施，如IP安全功能。关于ND的部分包含了更多关于这个问题的信息。

#### 2.2 反向地址解析和TCP/IP反向地址解析协议（RARP）（第1 2 3 4部分）

TCP/IP地址解析协议（ARP）用于当一个设备需要确定其他设备的第二层（硬件）地址，但只有其第三层（网络，IP）地址。它广播一个硬件层请求，目标设备用与已知的IP地址相匹配的硬件地址作出回应。在理论上，也有可能以完全相反的方式使用ARP。如果我们知道一个设备的硬件地址，但不知道它的IP地址，我们可以广播一个包含硬件地址的请求，得到一个包含IP地址的响应。

<u>**反向地址解析的动机**</u>
当然，显而易见的问题是：我们为什么需要这样做？因为我们正在处理IP网络上的通信，我们总是会知道我们需要发送的数据报的目的地的IP地址--它就在数据报本身中。我们也知道我们自己的IP地址。或者说我们知道吗？

在传统的TCP/IP网络中，网络上的每台正常主机都知道自己的IP地址，因为它被储存在机器的某个地方。当你打开你的电脑时，TCP/IP协议软件从一个文件中读取IP地址，这使你的电脑能够 "学习 "并开始使用它的IP地址。然而，有一些设备，如无盘工作站，没有任何办法将IP地址储存在可以轻易检索的地方。当这些设备通电时，它们只知道自己的物理地址（因为它被连接到硬件中），但不知道自己的IP地址。

我们在这里需要解决的问题是在计算机行业中通常被称为引导的问题。这是指从零状态开始的概念；它类似于 "用你自己的靴带把自己拉起来"。这似乎是不可能的，正如使用TCP/IP协议来配置TCP/IP通信所需的IP地址似乎是自相矛盾的。然而，通过利用广播，确实可以做到这一点，即使在目标地址不知道的情况下，也可以进行本地通信。

<u>**反向地址解析协议（RARP）**</u>

为解决TCP/IP中的引导问题而设计的第一个方法是我上面提到的ARP的逆向使用。这项技术在1984年发表的RFC 903《反向地址解析协议》（RARP）中被正式确定。ARP允许设备A说 "我是设备A，我有设备B的IP地址，设备B请告诉我你的硬件地址"，RARP被设备A用来说 "我是设备A，我正在用我的硬件地址发送这个广播，谁能告诉我我的IP地址？"RARP的两步操作见图52。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\rarptrans.png)

​                                                                    <u>**图52: 反向地址解析协议（RARP）的操作**</u>

顾名思义，RARP的工作方式与ARP类似，但却是反向的，所以这张图与图47类似。在这里，不是设备A提供另一个设备的IP地址并询问其硬件地址，而是它提供自己的硬件地址并询问一个它可以使用的IP地址。在这种情况下，答案是由设备D提供的，它是作为这个网络的RARP服务器。

那么下一个问题是：如果设备A不知道，谁知道A的IP地址？答案是，必须配置一个特殊的RARP服务器来监听RARP请求并对其发出回复。每个使用RARP的物理网络必须至少有一台机器上运行RARP软件。

RARP不仅与ARP非常相似，它基本上就是ARP。我的意思是，RFC 903并没有从头定义一个全新的协议，它只是描述了一种使用ARP来执行与其正常功能相反的新方法。RARP使用与ARP完全相同格式的ARP消息，但使用不同的操作码来完成其反向功能。就像在ARP中一样，在一个交换中使用了请求和回复。地址字段的含义也是一样的：发送方是发送消息的设备，而目标方是接收消息的设备。

**关键概念:** 反向地址解析协议（RARP）是最早和最简单的协议，旨在让设备获得一个IP地址，以便在TCP/IP网络上使用。它直接以ARP为基础，工作方式基本相同，但是是反向的：一个设备发送一个包含其硬件地址的请求，一个被设置为RARP服务器的设备用该设备分配的IP地址进行回馈。

<u>**RARP的一般操作**</u>

以下是RARP 交互中遵循的步骤（如图53所示）。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\rarpoperation.png)

​                                                                   **图53: 反向地址解析协议（RARP）操作**

RARP使用一个简单的请求/回复交换来允许设备获得一个IP地址。

1. 源设备生成RARP请求消息。源设备产生一个RARP请求消息。因此，它在消息中使用操作码的值为3。它把自己的数据链路层地址作为发送方硬件地址和目标硬件地址。它把发送者协议地址和目标协议地址都留空，因为它不知道这两个地址。

2. 源设备广播RARP请求信息。源设备在本地网络上广播ARP请求消息。

3. 本地设备处理RARP请求消息。本地网络上的每个设备都会收到该消息并进行处理。没有被配置为RARP服务器的设备会忽略该消息。

4. RARP服务器生成RARP回复消息。网络上任何被设置为RARP服务器的设备都会对源设备的广播做出响应。它使用一个4的操作码生成一个RARP回复，它将发送者硬件地址和发送者协议地址设置为自己的硬件和IP地址，当然，因为它是回复的发送者。然后，它将目标硬件地址设置为原始源设备的硬件地址。它在一个表中查找源设备的硬件地址，确定该设备的IP地址分配，并将其放入目标协议地址字段。

5. RARP服务器发送RARP回复信息。RARP服务器将RARP回复消息单播给希望被配置的设备。

6. 源设备处理RARP回复消息。源设备处理来自RARP服务器的回复。然后，它使用RARP服务器提供的目标协议地址中的IP地址进行自我配置。

如果在任何本地网络上配置了两个或更多的RARP服务器，可能会有一个以上的RARP服务器响应任何请求。源设备通常会使用第一个响应，而丢弃其他的。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\rarp1.jpg)

![image-20221009181243017](C:\Users\zy\AppData\Roaming\Typora\typora-user-images\image-20221009181243017.png)

### **第三章、TCP/IP互联网层（OSI网络层）协议**

OSI参考模型的前两层，即物理层和数据链路层，主要处理物理网络细节问题。各种局域网、无线局域网和广域网协议主要在这两层发挥作用，连接设备以创建网络，并执行物理连接和信令、媒体访问控制和同一网络上设备之间的本地数据传输等功能。在这几层之上，我们超越了网络的硬件方面，而更接近于与软件相关的网络功能的更抽象的领域。

OSI的第三层是网络层。当然，我们在本指南中讨论的是网络，而以这个名字命名的层是理解网络功能的最重要的层之一，这并不是巧合。正是在这里，我们找到了将网络连接在一起以创建国际网络的协议，也是执行跨网络寻址和路由的地方。在TCP/IP模型中，网络层也被称为互联网层。

在本节中，我提供了各种TCP/IP协议的细节，这些协议在结构上位于TCP/IP互联网层/OSI网络层。这里的重点是所有重要的互联网协议；涵盖IP的部分包括IP版本4、IP版本6和IP相关协议，如IPSec、移动IP和IP网络地址转换（NAT）的广泛覆盖。接下来的三个小节涵盖了IP支持协议，如互联网控制消息协议（ICMP）和IPv6邻居发现（ND）协议，以及整套IP路由协议。

#### 3.1 互联网协议（IP/IPv4、IPng/IPv6）和IP相关协议（IP NAT、IPSec、移动IP）

如果你仔细想想，在网络中把任何一个协议挑出来比其他协议更重要的想法是毫无意义的。这些协议和技术作为一个团队来完成整个网络通信的目标。像任何团队一样，没有一个成员能单独完成工作，不管他们有多优秀。尽管如此，如果我们试图在网络世界中挑选一个 "最有价值的球员"，我们可以提出一个很好的理由，在这一节中，我们有这样一个球员：TCP/IP互联网协议（IP）。

尽管它在TCP/IP协议套件的名称中是 "次要的"，但实际上IP是TCP/IP的 "主力"。它实现了关键的网络层功能，包括寻址、数据报处理和路由，并且是其他TCP/IP协议建立的基础。即使是TCP/IP架构中较低的协议，如ARP和PPP，当你知道IP是如何工作的时候，也会更容易理解。除了IP协议本身实现的主要功能外，多年来还开发了几个协议，我称之为 "IP相关"，因为它们是基于IP的，但为特殊目的增加了新的功能或能力。

在本节中，我对TCP/IP互联网协议以及与IP密切相关的几个协议进行了大量的介绍。我在一节中首先对IP概念进行了概括性的介绍，并对IP的工作方式进行了概述。然后，我有一大部分内容是关于IP版本4的，这是目前在各地TCP/IP网络上使用的协议版本。之后，我又看了看IP的 "下一代"，即IP版本6。然后，我提供了涉及三个与IP有关的协议的章节：IP网络地址转换协议（IP NAT），IP安全协议集（IPSec），以及IP对移动设备的适应（移动IP）。

**注意：**本节的主要重点是当前的IP版本，即IPv4，因为它是目前使用最广泛的版本。因此，我建议在阅读IPv4部分之前，先阅读这里的其他分节，除非你已经熟悉它。为了避免重复，关于IP版本6的部分在结构上主要是说明IPv6与IPv4的不同之处。同样，关于IP NAT、IPSec和移动IP的部分也是建立在IPv4部分的一些概念之上。

**背景信息:** 如果你还没有读过介绍TCP/IP的介绍性章节，在继续阅读之前，你可能会发现它对你有帮助。

##### 3.1.1 互联网协议的概念和概述

IP是国际网络中一个非常重要的协议；如果说不能很好地理解IP就不能真正理解现代网络，这一点也不夸张。不幸的是，IP可能有些难以理解。这可能是因为由于它的重要性，多年来大量的复杂性已经与该协议相关联，以使它能够满足对它的许多要求。

在深入研究IP如何工作的细节之前，我认为值得对IP和它的作用进行一次高层次的考察。在本节中，我对与互联网协议有关的基本概念和它的工作方式进行了简要的研究。我首先概述了IP，它是如何在基本条件下运作的，以及它是如何完成工作的最重要特征。然后，我通过描述互联网协议的主要功能来扩展这一讨论，这可以作为其余部分的介绍，这些部分对IP进行了相当详细的解释。最后，我简要介绍了IP的发展历史、版本，以及它如何催生了几个与IP有关的协议的发展。

###### 3.1.1.1 IP概述和主要运行特征（部分：1 2）

互联网协议（IP）是TCP/IP协议套件的核心，是其在网络层的主要协议。网络层主要关注的是数据的传递，不是在同一物理网络上的设备之间，而是在可能处于不同网络上的设备之间，这些设备以任意的方式相互连接：一个国际网络。IP是在TCP/IP网络上发送这些数据的机制。(当然，它也得到了网络层其他协议的帮助！）。

让我们来看看TCP/IP层模型，并从架构的角度考虑IP的作用。作为第三层协议，它为TCP/IP协议栈中的第四层提供服务，主要由TCP和UDP协议代表。这项服务是接收由TCP或UDP打包的数据，对其进行必要的处理，并将其发送出去。这项服务有时被称为网络数据报传送，如图54所示。正如我们将看到的，这项服务究竟是如何完成的，有许多细节，但总的来说，这就是IP的作用：通过连接的网络组成的国际网络将数据从A点发送到B点。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipdelivery.png)

​                                                                            <u>**图54: IP的主要功能：网络数据报传输**</u>

互联网协议的基本工作是在互联网上将数据报从一个设备传送到另一个设备。在这个通用的例子中，远方的客户和服务器通过一系列互连网络传递IP数据报来相互通信。

**关键概念：** 虽然互联网协议有许多功能和特点，但它可以归结为一个主要目的：在互联网络中传递数据报。

<u>**IP的主要特点**</u>
当然，为了完成这一任务，可以有无数种方式来实现IP。为了了解TCP/IP的设计者是如何使IP发挥作用的，让我们来看看用于描述IP的关键特征以及它的一般运行方式。据说互联网协议是这样的

- 通用地址: 为了从A点向B点发送数据，有必要确保设备知道如何识别哪个设备是 "B点"。IP定义了网络的寻址机制，并使用这些地址进行传输。

- 底层协议独立: IP被设计为允许在任何类型的底层网络中传输数据，这些网络被设计为与TCP/IP堆栈一起工作。它包括允许它适应各种低级协议的要求的规定，如以太网或IEEE 802.11(无线)。IP还可以运行在为其创建的特殊数据链接协议SLIP和PPP上。一个重要的例子是，IP有能力将大的数据块分割成较小的数据块，以符合物理网络的大小限制，然后让接收者根据需要重新组合这些数据块。

- 无连接地传送: IP是一个无连接协议。这意味着，当A想向B发送数据时，它不会首先与B建立连接，然后再发送数据--它只是制作数据报并发送。有关这方面的更多信息，请参见网络基础知识部分中的面向连接和无连接协议的主题。

- 传输不可靠: 据说IP是一个 "不可靠的协议"。这并不意味着有一天你的IP软件会决定去钓鱼而不是运行你的网络。J 它确实意味着，当数据报从设备A发送到设备B时，设备A只是发送了每一个，然后继续发送下一个。IP并不跟踪它所发送的那些数据。它不提供可靠性或服务质量能力，如它所发送的数据的错误保护（尽管它在IP头上有）、流量控制或丢失数据报的重传。

- 由于这个原因，IP有时被称为 "尽力而为 "协议。它尽其所能把数据送到它需要去的地方，但 "不保证 "数据会真正到达那里。

- 在没有确认的情况下交付：与其不可靠的性质类似，IP不使用确认。当设备B从设备A收到一个数据报时，它不会发回一个 "感谢信 "来告诉设备A已经收到了数据报。可以说，它让设备A "蒙在鼓里"。

<u>**IP的成功尽管有其局限性**</u>

前面列表中的最后三个特征可能足以让你感到害怕，认为把你的数据交给IP有点像把一辆新车交给你16岁的儿子。如果我们要围绕这个协议建立我们的整个网络，为什么要把它设计成在没有连接的情况下工作，不能保证数据会到达那里，而且没有确认收到数据的方法？

原因很简单：建立连接、保证交付、检查错误和类似的 "保险 "功能都有一个成本：性能。执行这些任务需要时间、计算机资源和网络带宽，而且它们并不总是每个应用都需要的。现在，考虑到IP承载了TCP/IP网络上几乎所有的用户流量。在IP中建立这种复杂性将使所有的流量都承担这种开销，不管它是否需要。

TCP/IP的设计者所采取的解决方案是利用分层的力量。如果应用程序需要诸如连接、错误检查或保证交付等服务质量特性，它们将在传输层（或可能在应用层）提供。另一方面，不需要这些功能的应用程序可以避免使用它们。这实际上是两个TCP/IP传输层协议之间的主要区别。TCP和UDP。TCP功能齐全，但比UDP慢一点；UDP功能简陋，但比TCP快。这个系统是真正的 "两全其美"。而且，与你那拥有闪亮的新执照的青少年不同，它已被证明在现实世界中运行良好。J

那么，数据报传输是如何通过IP完成的呢？在下面的主题中，我将更详细地讨论IP为 "完成工作 "所执行的主要功能，可以这么说。

###### 3.1.1.2 IP的功能

在上一主题中，我描述了IP的一般操作，并将其主要工作归结为网络数据报的传送。我还解释了IP如何完成这项工作的最重要特点。有了这个基础，现在让我们更深入地研究一下，IP是如何 "完成工作 "的。做到这一点的一个好方法是检查互联网协议包括的各种功能。

IP功能的确切数量取决于你在某些活动之间 "划线 "的位置。然而，出于解释的目的，我认为IP有四个基本功能（或更准确地说，功能集）。

- 寻址: 为了完成传送数据报的工作，IP必须知道把它们传送到哪里去！因此，IP包括了一个机制，以确保数据报的安全。出于这个原因，IP包括一个主机寻址的机制。此外，由于IP在国际网络上运行，它的系统被设计为允许在任意大的网络上对设备进行独特的寻址。它还包含一个结构，以便在需要时将数据报路由到遥远的网络。

- 由于大多数其他TCP/IP协议都使用IP，因此了解IP寻址方案对理解TCP/IP中的许多内容至关重要。

- 数据封装和格式化/包装: 作为TCP/IP的网络层协议，IP接受来自传输层协议UDP和TCP的数据。然后，它在传输前用一种特殊的格式将这些数据封装成一个IP数据报。

- 分片和重新组合: IP数据报被传递到数据链路层，在本地网络上传输。然而，使用IP的每个物理/数据链路网络的最大帧大小可能是不同的。出于这个原因，IP包括将IP数据报分割成碎片的能力，以便它们可以在本地网络上各自传输。接收设备使用重新组装功能，再次重新创建整个IP数据报。

- **注意：**有些人认为分片和重组是不同的功能，但显然它们是互补的，我认为它们是同一功能的一部分。

- 路由/间接传送: 当一个IP数据报必须被发送到同一本地网络的目的地时，可以使用网络的底层LAN/WLAN/WAN协议，使用有时被称为直接交付的方式轻松完成。然而，在许多（如果不是大多数）情况下，最终的目的地是在一个不直接连接到源的遥远的网络上。在这种情况下，数据报必须被间接传送。这是通过将数据报通过中间设备（路由器）进行路由来实现的。IP与其他协议（包括ICMP和TCP/IP网关/路由协议，如RIP和BGP）的支持共同完成这一任务。

当你继续阅读本节的IP内容时，你会发现，我已经在这些一般功能的基础上，对提供更多细节的主要IP版本和IP相关协议的子章节进行了编排。

###### 3.1.1.3 IP历史、标准、版本和密切相关的协议（部分：1 2）

由于互联网协议实际上是整个TCP/IP套件的架构基础，人们可能会期望它首先被创建，而其他协议则建立在它之上。毕竟，这通常是建立一个结构的方式。然而，IP的历史则要复杂一些。它所执行的功能在协议诞生时就被定义了，但在协议套件被定义的最初几年里，IP本身并不存在。

我在概述整个协议套件的章节中探讨了TCP/IP的早期情况。关于IP的发展，值得注意的是，其功能最初是传输控制协议（TCP）的一部分。作为一个正式的协议，IP是在20世纪70年代为现代互联网的前身开发的早期版本的TCP被拆分为第四层的TCP和第三层的IP时 "诞生 "的。互联网协议发展的关键里程碑是1981年9月发布的RFC 791《互联网协议》。这一标准是对前一年类似的RFC 760的修订，定义了过去20年中广泛使用的IP的核心功能和特点。

<u>**IP版本和版本号**</u>
RFC 791中定义的IP是互联网协议的第一个广泛使用的版本。然而，有趣的是，它不是IP的第1个版本，而是第4个版本! 这当然意味着该协议在某一时刻还有更早的版本。然而，有趣的是，实际上并没有。正如我在上面提到的，IP是在其功能从早期版本的TCP中分离出来时创建的，它结合了TCP和IP的功能。TCP经历了三个早期版本的演变，并在第四版中被拆分为TCP和IP。为了保持一致性，该版本号同时适用于TCP和IP。

**关键概念**: 互联网协议的第4版实际上是被广泛部署的第一个版本，也是目前被广泛使用的版本。

因此，当你今天使用IP时，你正在使用IP版本4，也经常缩写为IPv4。除非另有规定，否则可以认为 "IP "是指 "IP版本4"--至少在未来几年内是如此！这个版本号在相应的文件中都有。这个版本号在所有IP数据报的相应字段中，如讨论IP数据报格式的专题中所述。

鉴于它最初是为一个只有我们目前互联网规模一小部分的国际网络而设计的，IPv4已经证明了它的能力是惊人的。随着时间的推移，对IP的使用方式进行了各种补充和改变，特别是在寻址方面，但核心协议基本上是在20世纪80年代初的样子。这是有原因的：改变像IP这样基本的东西需要大量的开发工作，而且在过渡期间也会引入复杂的问题。

尽管IPv4为我们服务得很好，但人们认识到，由于各种原因，最终需要一个新的IP版本。由于进行这样一个重要的改变所带来的困难，这个新版本的IP的开发实际上从90年代中期就已经开始了。这个新版本的IP被正式称为互联网协议版本6（IPv6），有时也被称为IP下一代或IPng。我在本指南的IPv6部分详细讨论了开发IPv6的原因以及它与IPv4的不同之处。

当然，这时一个很自然的问题是：IP的第5版怎么了？答案是：它已经不存在了。虽然这看起来令人困惑，但事实上版本5是有意跳过的，以避免混淆，或至少是为了纠正它。版本5的问题与一个实验性的TCP/IP协议有关，该协议称为互联网流协议，版本2，最初在RFC 1190中定义。这个协议最初被一些人看作是TCP/IP结构中互联网层的IP的对等物，在其标准中，这些数据包被分配为IP版本5，以区别于 "正常 "IP数据包（版本4）。这个协议显然没有进展，但为了绝对确保不会出现混乱，版本5被跳过，而采用了版本6。

<u>**与IP相关的协议**</u>

除了我们的 "旧 "和 "新 "版本的IP，还有几个协议，我称之为IP相关协议。它们不是IP本身的一部分，而是在特殊情况下增加或扩展IP功能的协议。这些协议是

- IP网络地址转换（IP NAT / NAT) : 该协议提供IP地址转换功能，允许私人网络以灵活的方式与公共网络对接。它允许共享公共IP地址，并通过使公共网络上的主机更难获得未经授权的主机访问来提高安全性。它通常只被称为 "NAT"，但它在IP地址上工作，所以我认为 "IP NAT "更清楚。

- IP安全（IPSec）: 定义了一组子协议，为使用IP安全传输数据提供了一种机制。IPSec作为一种安全协议正在迅速普及，以实现虚拟私人网络（VPN）。

- 移动IP：一种协议，解决了在经常从一个网络移动到另一个网络的计算机上使用IP的一些困难。它提供了一种机制，允许数据自动路由到移动主机（如笔记本电脑），而不要求设备的IP地址不断被重新配置。

对IP的其余讨论分为五个部分，分别对应IPv4、IPv6、IP NAT、IPSec和移动IP。

##### 3.1.2 互联网协议第4版（IP，IPv4）

尽管这个名字似乎意味着它是关键的互联网协议的第四次迭代，但第四版IP是第一个被广泛用于现代TCP/IP的版本。IPv4，有时被称为IPv6，以区别于较新的IPv6，是目前互联网上使用的互联网协议版本，该协议的实施在数以亿计的计算机上运行。它提供了基本的数据报传输能力，所有的TCP/IP功能都依赖于此，并且在二十多年的使用中证明了其质量。

在这一节中，我提供了关于当前版本的互联网协议（IPv4）的操作的广泛细节。有四个主要小节，代表了IP的四个主要功能。第一小节对IP寻址进行了全面的讨论。第二节讨论了数据如何被编码和格式化为IP数据报进行传输。第三小节描述了数据报的大小问题，以及如何利用分片和重组来在旨在传输小帧的网络上传输大数据报。最后一个小节涵盖了与IP数据报的传送和路由有关的事项。在这四个主要的小节之后，我以对IP组播的概述来结束我们对IPv4的研究，组播用于将一个数据报传递给一个以上的接收者。

**相关信息:** 正如本节的标题所暗示的那样，我们在这里的内容仅限于IP版本4；版本6以及与IP有关的协议将在其单独的章节中介绍。也就是说，这里的一些原则也将以有限的方式适用于IPv6、IP NAT、IPSec或移动IP。为了简单起见，在本节中，我使用更简单的名称 "IP "而不是 "IPv4"，除非为了清楚起见需要使用较长的缩写。

###### 3.1.2.1 IP寻址

IP的主要工作是在设备之间传递信息，像任何好的传递服务一样，如果不知道收件人的位置，它就不能很好地完成工作。很明显，互联网协议最重要的功能之一就是寻址。IP地址不仅用于唯一地识别IP地址，而且还用于促进IP数据报在国际网络上的路由。它们在TCP/IP网络中被广泛地使用和提及。

在本节中，我对与IP寻址有关的问题和技术进行了全面的解释。共有五个小节。第一部分提供了一个IP寻址概念和问题的概述。第二部分讨论了原始的基于类（"classful"）的IP寻址方案以及不同的类是如何工作的。第三和第四小节专门讨论IP子网和子网寻址。这包括对子网概念的讨论，也包括对实际的分步子网的彻底说明。最后一个小节介绍了新的无类别寻址系统，有时也称为 "超网"。

**注意**：本节包含30多个小节和单个主题。这个讨论的规模之大可能会让你吃惊；当我着手组织它时，它当然会让我吃惊。 有两个主要原因，我觉得这么多细节是必要的。第一个原因是，真正理解IP寻址的概念和实践是对整个TCP/IP操作有任何实质性理解的关键，所以我不想吝啬任何东西。第二是IP寻址已经变得有些复杂。IP网络的配置方式不止一种，要想全面了解这一主题，就必须对它们进行探讨。

###### 3.1.2.1-1 IP编址的概念和问题

尽管最初的IP寻址方案相对简单，但随着时间的推移，它已经变得复杂，因为人们对它进行了修改，使它能够处理各种寻址要求。更高级的IP寻址方式，如子网和无类寻址，是现代网络中使用最多的。然而，它们可能有点令人困惑，难以理解。为了帮助理解它们，我们必须从一开始就讨论IP寻址的基本原理。

在本节中，我将通过解释IP寻址背后的关键概念和问题，开始我们对IP寻址的更大探索。我首先对IP寻址进行了概述，并讨论了它的一般含义。我描述了IP地址的大小，其 "地址空间 "的概念和通常用于IP地址的符号。我提供了关于IP地址结构的基本信息，以及它如何被划分为网络标识符和主机标识符。然后，我描述了不同类型的IP地址和附加信息，如子网掩码和默认网关，这些信息通常伴随着大型网络中的IP地址。我简要描述了有时多个地址是如何分配给单个设备的以及为什么。最后，我描述了公共IP地址的注册和管理过程，以及为全球互联网做这项工作的组织。

**背景资料:** 如果你不熟悉二进制数字工作的基本原理，也不熟悉如何在二进制和十进制数字之间进行转换，我建议你在继续阅读数据表示和计算数学的背景部分。你可能不需要这些知识就能完成这一部分，但当我们进行子网划分时，你还是会需要这些知识，所以你现在不妨熟悉一下。

**注意:** 记住，大多数操作系统都有一个包含科学功能的计算器程序，包括二进制、十进制和十六进制数字之间的转换。

###### 3.1.2.1-1-1 IP编址概述和基础知识 (部分: 1 2 3 )

在本节的介绍中，我提到了IP寻址的重要性，因为它促进了互联网协议的主要功能--在国际网络中传递数据报文。要更详细地了解这一点，需要我们研究与IP及其地址如何运作有关的几个不同但重要的问题。

<u>**IP地址的功能。识别和路由**</u>
值得注意的第一点是，IP地址实际上有两种不同的功能。

- 网络接口识别: 像街道地址一样，IP地址为设备和网络之间的接口提供唯一的识别。这是为确保数据报传递给正确的接收者所必需的。

- 路由: 当一个IP数据报的源头和目的地不在同一个网络上时，数据报必须通过中间系统 "间接 "传递，这个过程称为路由选择。IP地址是用于路由数据报的系统的一个重要部分。

你可能已经注意到这个简短的列表中有几件事。其一是我说IP地址识别了网络接口，而不是它识别了设备本身。这个区别很重要，因为它强调了这样一个概念：IP是围绕着与第三层的大型 "虚拟网络 "的连接，它可以跨越多个物理网络。一些设备，如路由器，将有一个以上的网络连接：它们必须从一个网络获取数据报并将其路由到另一个网络。这意味着它们也将有一个以上的IP地址，每个连接一个。

你可能也会觉得奇怪，我说IP地址有利于路由。它怎么能做到这一点呢？答案是，寻址系统被设计成一种结构，可以被解释为允许路由器根据地址中的值来决定对数据报做什么。与IP地址相关的数字，如使用子网时的子网掩码，支持这一功能。

现在让我们看一下与 IP 地址相关的其他一些重要问题和特征。

<u>**每个设备的IP地址数量**</u>

任何在网络层有数据发送到它的设备都至少有一个IP地址：每个网络接口一个。正如我在上面提到的，这意味着正常的主机，如计算机和具有网络功能的打印机，通常得到一个IP地址，而路由器则得到一个以上的IP地址。一些特殊的主机可能有一个以上的IP地址，如果它们是多宿主--连接到一个以上的网络。

较低级别的网络互连设备，如中继器、网桥和交换机不需要IP地址，因为它们根据第二层（数据链路层）地址传递流量。由网桥和交换机连接的网段形成一个单一的广播域，其上的任何设备都可以直接向对方发送数据，而无需路由。对互联网协议来说，这些设备是 "看不见的"，它们并不比连接设备的电线更重要（有几个例外）。然而，这些设备可以选择有一个IP地址用于管理。在这方面，它们的行为就像网络上的普通主机。见图55的说明。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipinterfaces.png)

​                                                                      **图55: 普通网络设备的IP接口**

该图以小青色圆圈的形式显示了一些常见的局域网设备的IP接口。每台普通主机有一个接口，而为这个局域网服务的路由器有三个，因为它连接到三个不同的网络。注意，局域网交换机没有IP接口；它在第二层连接主机和路由器。另见图59，该图显示了更复杂配置中设备的IP接口。

<u>**地址的唯一性**</u>
单个互联网上的每个IP地址必须是唯一的。这一点似乎很明显（尽管在IPv6中也有例外，那就是特殊的任意广播地址！）

<u>**IP地址的网络专用性**</u>
由于IP地址代表网络接口并用于路由，因此IP地址对其所连接的网络是特定的。如果设备移动到一个新的网络，IP地址通常也要改变。完整的原因，见基本IP地址结构的讨论。这个问题是创建移动IP的一个主要动机。

<u>**IP地址和数据链路层地址的对比**</u>
IP地址用于网络层数据在互联网上的传递。这使得IP地址与设备的数据链路层地址（如以太网MAC地址）完全不同。(在TCP/IP术语中，这些有时被称为物理地址或硬件地址）。在网络层，一个单一的数据报可能被发送 "从设备A到设备B"。然而，如果A和B不在同一个网络上，数据报的实际传递可能需要经过十几个物理设备。

还有必要提供一种功能，在IP和数据链路层地址之间进行映射。在TCP/IP中，这就是地址解析协议（ARP）的工作。

<u>**IP地址数据报交付问题**</u>

在诸如以太网的物理网络中，MAC地址是在设备之间发送数据所需的全部信息。相反，IP地址只代表数据报的最终交付点。所采取的路线取决于源和目的设备之间的网络路径的特点。甚至有可能在任何两个设备之间没有路由，这意味着两个设备即使知道对方的地址，也不能交换数据。

<u>**私人和公共IP网络地址**</u>
有两种不同的方式可以用IP地址建立网络。在私有网络中，一个组织控制着所有设备的地址分配；只要每个地址是唯一的，他们就有绝对的控制权，可以随意选择数字。相比之下，在公共网络上，需要一种机制来确保各组织不使用重叠的地址，同时也能在各组织之间有效地进行数据路由。这方面最有名的例子当然是互联网，公共IP注册和管理设施已被创建来解决这个问题。现在还有一些先进的技术，如IP网络地址转换，允许使用私人地址的网络与公共TCP/IP网络对接。

<u>**IP地址配置**</u>
有两种基本的方法可以配置IP地址。在静态配置设置中，每个设备都被手动配置了一个不改变的IP地址。这对小型网络来说很好，但在大型网络中，当需要改变时，很快就会成为管理的噩梦。另一种方法，即动态配置，允许将IP地址分配给设备，并在软件控制下改变。两种主机配置协议，即BOOTP和DHCP，就是为了满足这后一种功能。

<u>**单播、多播和广播寻址**</u>
在IP寻址方案中包括所有三种基本寻址类型的规定。

**关键概念：** IP地址具有设备识别和路由的双重功能。每个网络接口需要一个IP地址，这是网络特有的。IP地址可以是静态或动态分配的，并有单播、多播和广播三种形式。

本节后面的主题，以及我们讨论IP的其他章节，将对这些概念进行更详细的阐述。

###### 3.1.2.1-1-2 IP地址大小、地址空间和 "点分十进制 "符号（部分：1 2 3 )

现在我们已经了解了与 IP 地址相关的一般问题和特征，是时候跳过介绍并深入研究 IP 地址讨论的“内容”了。让我们从查看 IP 地址的物理结构和大小以及如何引用和使用它开始。

**IP 地址大小和二进制表示法**
最简单的说，IP 地址只是一个 32 位二进制数：一组 32 个 1 或 0。在最低级别的计算机总是以二进制工作，这也适用于网络硬件和软件。虽然我们很快就会看到地址中的不同位具有不同的含义，但地址本身就是这个 32 位二进制数。

人类不太擅长处理二进制数，因为它们又长又复杂，而且仅使用两位数使得它们难以区分。 （快速，哪个更大：11100011010100101001100110110001 或 11100011010100101001101110110001？J）因此，当我们使用 IP 地址时，除非绝对必要，否则我们不会以二进制形式使用它们。

人类对一长串比特自然会做的第一件事是将其分成四个八位八位字节（或字节，即使两者在技术上并不相同），以使其更易于管理。因此，11100011010100101001101110110001 将变为“11100011 - 01010010 - 10011101 - 10110001”。然后，我们可以将这些八位字节中的每一个转换为更易于管理的两位十六进制数，得到以下结果：“E3 - 52 - 9D - B1”。这实际上是用于 IEEE 802 MAC 地址的符号，除了它们是 48 位长，因此它们有六个两位数的十六进制数字，并且它们通常用冒号分隔，而不是我在这里使用的破折号。

<u>**IP地址的 "点分十进制 "记法**</u>

大多数人仍然觉得十六进制有点难以操作。因此，IP地址的表达方式通常是将每个八位数转换为十进制数字，八位数之间用句号（一个 "点"）隔开。因此，上面的例子将变成227.82.157.177，如图56所示。由于相当明显的原因，这通常被称为点状十进制记数法。IP地址中的每个八位数都可以从0到255（不是1到256，注意！），所以理论上最低值是0.0.0.0，最高值是255.255.255.255。

**关键概念:** IP地址是32位二进制数字，可以用二进制、十六进制或十进制形式表示。最常见的是，它们的表达方式是将32位分为四个字节，并将每个字节转换为十进制，然后用点将这些数字分开，形成点分十进制符号。

点分十进制符号为人类之间交流时使用IP地址提供了一种方便的方式。永远不要忘记，对计算机来说，IP地址始终是一个32位的二进制数字；当我们在下一主题中研究IP地址如何被逻辑地划分为各个组成部分时，以及当我们研究操纵IP地址的技术（如子网划分）时，就会发现这一点的重要性。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ip-add-1.jpg)

​                                               **图56: IP地址的二进制、十六进制和带点十进制表示法**

IP地址的二进制、十六进制和十进制表示法都是等同的。

 <u>**IP地址空间**</u>

由于IP地址是32位宽，这为我们提供了232个理论上的地址空间，即4,294,967,296个地址。这似乎是一个相当多的地址! 在某些方面确实如此。然而，正如我们将看到的，由于IP地址的结构和分配方式，并不是每一个地址都能被实际使用。IP最初是在一个相当小的互联网上创建的，其不幸的遗留问题之一是做出了 "浪费 "了许多地址空间的决定。例如，所有第一个八位位组中以 "127 "开头的IP地址都被保留给环回功能。仅仅这一个决定就使地址总数的256分之一，即16,277,216个地址不再可用。还有其他一些没有 "保留 "IP地址空间的方式，随着互联网规模的扩大，这也造成了困难。我们将在 "类 "寻址一节中看到更多关于这方面的内容。

**关键概念:** 由于IP地址的长度为32位，IPv4的总地址空间为232或4,294,967,296个地址。然而，由于各种原因，并非所有这些地址都能被使用。

这个IP地址空间决定了每个IP网络中可寻址接口数量的限制。因此，如果你有一个私人网络，理论上你可以有40多亿个地址。然而，在公共网络中，如互联网，所有设备必须共享可用的地址空间。诸如CIDR（"supernetting"）和网络地址转换（NAT）的技术，部分是为了更有效地利用现有的互联网IP地址空间。当然，IP版本6将IP地址的大小从32位一直扩展到128位，这使地址空间增加到一个大得离谱的数字，并使整个地址空间大小问题变得毫无意义。

###### 3.1.2.1-1-3 IP基本地址结构和主要组成部分。网络ID和主机ID (部分: 1 2 3 )

正如我在IP寻址概述中提到的，IP地址的使用方式之一是促进IP互联网中数据报的路由。这是由于IP地址的结构方式，以及网络路由器对该结构的解释，使之成为可能。

<u>**互联网IP地址结构**</u>
正如我们刚才所看到的，每个版本4的IP地址是32位长。当我们提到IP地址时，我们使用点状十进制符号，而计算机将其转换为二进制。然而，即使这些32位的集合被认为是一个单一的 "实体"，它们有一个内部结构，包含两个组成部分。

- 网络标识符（网络ID）:一定数量的比特，从最左边的比特开始，用于识别主机或其他网络接口所在的网络。这有时也被称为网络前缀，甚至只是前缀。

- 主机标识符（Host ID）: 其余的位用于识别网络中的主机。

**注意**：按照惯例，为了简单起见，IP设备通常被称为主机，我在本指南中也是如此。即使每台主机通常有一个IP地址，但请记住，IP地址是与网络层的网络接口严格相关的，而不是物理设备，因此一个设备可能有一个以上的IP地址。

正如你在图57中所看到的，这确实是一个相当简单的概念；它与北美的电话号码的结构是一样的想法。电话号码（401）555-7777是一个十位数的号码，通常被称为一个 "电话号码"。然而，它有一个结构。特别是，它有一个区号（"401"）和一个本地号码（"555-7777"）。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ip-22.jpg)

​                                                                 **图57: 基本的IP地址划分。网络ID和主机ID**

IP地址的位数的基本划分是分为网络ID和主机ID。这里，网络ID是8位，以青色显示，而主机ID的长度是24位。

<u>**在 IP 地址中包含网络 ID 的含义**</u>

当地址已知时，网络标识符包含在 IP 地址中的事实部分地促进了 IP 数据报的路由。路由器首先查看 IP 地址的网络部分，以确定目标 IP 地址是否与主机 IP 地址在同一网络上。然后根据路由器保存的有关各种网络所在位置的信息做出路由决策。同样，这在概念上类似于电话网络中的“路由器”等价物如何使用区号来切换电话呼叫。地址的主机部分由网络本地部分的设备使用。

由于 IP 地址可以分为网络 ID 和主机 ID 组件，因此也可以根据上下文单独使用其中一个或另一个。这些地址被赋予了特殊的含义。例如，如果网络 ID 与所有的主机 ID 一起使用，这表示向整个网络广播。类似地，如果主机 ID 单独使用，网络 ID 全为零，这意味着发送到“本地网络”上该 ID 的主机的 IP 地址，无论它可能是什么。

正是网络标识符包含在网络上每个主机的 IP 地址中，导致 IP 地址是网络特定的。如果您将设备从一个网络移动到另一个网络，则网络 ID 必须更改为新网络的 ID。因此，IP 地址也必须更改。这是一个不幸的缺点，在处理移动设备时最常出现。

<u>**网络ID和主机ID之间的分界点位置**</u>

IP地址和电话号码之间的一个区别是，用于识别网络的比特和识别主机的比特之间的分界点并不固定。它取决于地址的性质、正在使用的寻址类型和其他因素。让我们以上一个话题的例子为例，227.82.157.177。有可能将其分为 "227.82 "的网络标识符和 "157.177 "的主机标识符。另外，网络标识符可能是 "227"，而该网络中的主机标识符是 "82.157.177"。

为了将网络和主机标识符表示为32位地址，我们添加零来代替缺少的 "碎片"。在上面的例子中，网络的地址是 "227.0.0.0"，主机的地址是 "0.82.157.177"。(在实践中，这种网络地址通常会加上零；而网络ID则不经常以32位的形式出现。)

为了避免你从这些例子中认为分割必须总是在地址的整个八位数之间进行，也有可能在一个八位数的中间进行分割。例如，我们可以分割IP地址227.82.157.177，这样就有20位网络ID和12位主机ID。这个过程是相同的，但确定带点的十进制ID值更加棘手，因为在这里，"157 "被 "分割 "成两个二进制数字。结果是网络ID为 "227.82.144.0"，主机ID为 "0.0.13.177"，如图58所示。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipnethostmiddle.png)

​                                                                             **图58: 八位数中间的IP地址划分**

由于IP地址通常表示为四个点分十进制数字，教育资源通常显示网络ID和主机ID之间的划分发生在一个八位数的边界上。然而，必须记住，分界点往往出现在这些八位数的中间位置。在这个例子中，网络ID为20位，主机ID为12位。这导致原始IP地址的第三个数字157被分割成144和13。

为了让路由器等设备知道如何解释地址，必须知道网络ID和主机ID之间 "划线 "的地方。这一信息是以隐式或显式方式传达的，这取决于使用的IP寻址类型。我在下面的主题中对此进行描述。

**关键概念:** IP地址的基本结构由两部分组成：网络ID和主机ID。32位地址的分界点不是固定的，而是取决于许多因素，可以出现在不同的地方，包括在点分十进制的中间。

###### 3.1.2.1-1-4 IP地址类别（有类、有子网和无类）和IP地址附属物（子网掩码和默认网关）（部分：1 2）

前面的主题说明了IP地址中32位的基本划分，即网络标识符（网络ID）和主机标识符（主机ID）。网络ID用于路由的目的，而主机ID则唯一地识别网络上的每个网络接口。为了让设备知道如何在网络上使用IP地址，它们必须能够分辨出每个ID使用了哪些位。然而，"分界线 "不是预先定义的。它取决于网络中使用的寻址类型。

<u>**IP寻址方案类别**</u>
了解了这些ID是如何确定的，我们就可以对IP寻址方案的三个主要类别进行更大的讨论。每种方案都使用一个稍有不同的系统来表明在IP地址中找到主机ID的位置。

<u>**传统的（"分类"）寻址方案**</u>
原始的IP寻址方案是这样设置的：分界线只出现在几个位置中的一个：八位数边界上。三个主要的地址类别，A、B和C，是根据网络ID和主机ID使用多少个字节来区分的。例如，C类地址将24位用于网络ID，8位用于主机ID。这种类型的寻址现在经常被称为 "classful"，以区别于较新的 "classless "方案。

这种最基本的寻址类型使用最简单的方法来划分网络和主机标识符：类别以及划分点被编码到每个地址的前几位。路由器可以从这些位数中看出哪些八位数属于哪个标识符。

<u>**子网的 "类 "寻址**</u>
在子网寻址系统中，通过从A类、B类或C类主机ID中抽取一些比特，并将其用于子网标识符，使IP地址的两级网络/主机划分成为三级系统。网络ID是不变的。子网ID用于构成完整网络的不同子网内的路由，为管理员提供额外的灵活性。例如，考虑一个C类地址，通常使用前24位作为网络ID，剩余8位作为主机ID。主机ID可以分成，例如，3位为子网ID，5位为主机ID。

这个系统是基于原来的 "类 "方案，所以网络ID和 "完整 "主机ID之间的分界线和以前一样是基于地址的前几个比特。子网ID和 "子主机 "ID之间的分界线由一个叫做子网掩码的32位数字表示。在上面的例子中，子网掩码是27个1和5个0，0表示地址的哪一部分是主机。在点状十进制符号中，这将是255.255.255.224。

<u>**无类编址**</u>

在无类别系统中，原始IP寻址方案的类别被抛出窗外。网络ID和主机ID之间的划分可以发生在一个任意的点上，而不是像 "有类 "方案中那样只在八位数的边界上。

分割点是通过把用于网络ID的位数，即前缀长度，放在地址后面来表示的（记得网络ID位有时也被称为网络前缀，所以网络ID大小就是前缀长度）。例如，如果227.82.157.177是一个网络的一部分，前27位用于网络ID，该网络将被指定为227.82.157.160/27。从概念上讲，"/27 "与255.255.255.224子网掩码相同，因为它有27个1比特，后面有5个0。

**关键概念:** 决定如何解释一个IP地址的一个基本因素是它所使用的寻址方案。这三种方法按年代、复杂性和灵活性的递增顺序排列，分别是 "classful "寻址、subnetted "classful "寻址和无classless寻址。

我刚才是不是把你搞糊涂了？对不起，不要担心。我只是在介绍 "类"、子网和无类寻址的概念，并向你展示它们如何影响IP地址的解释方式。这意味着我在这里大大地总结了重要的概念，这是必然的。所有这三种方法都在各自的章节中进行了详细的解释。

<u>**IP地址的辅助工具：子网掩码和默认网关**</u>
正如你所看到的，在最初的 "类 "方案中，网络ID和主机ID之间的划分是隐含的。然而，如果使用子网或无类寻址，则需要子网掩码或 "斜线号 "来完全限定地址。这些数字被认为是IP地址的附属品，通常与地址本身 "同声 "提及，因为没有它们，就不可能知道网络ID的结束和主机ID的开始。

另外一个经常与设备的IP地址一起被指定的数字是默认网关标识符。最简单地说，这就是为某一设备提供默认路由功能的路由器的IP地址。当一个IP网络上的设备想把数据报发送到它在本地IP网络上看不到的设备时，它就把数据报发送到负责路由功能的默认网关上。如果没有这个功能，每个IP设备也必须了解路由功能和路线，这将是低效的。更多信息请参见路由概念和TCP/IP路由协议部分。

###### 3.1.2.1-1-5 IP地址的数量和多重归属 (部分: 1 2 )

IP网络上的每个网络接口都有一个单独的IP地址。在传统网络中，每台普通的计算机，通常被称为主机，正好只在一个地方连接到网络，所以它只有一个IP地址。这是我们大多数人在使用IP网络时熟悉的情况（这也是为什么大多数人使用 "主机 "这个术语，而他们真正的意思是 "网络接口"）。

如果一个设备有一个以上的网络接口，它将有一个以上的IP地址。最明显的情况是路由器，它将不同的网络连接在一起，因此必须为每个网络的接口提供一个IP地址。然而，主机也有可能拥有一个以上的IP地址。这样的设备有时被称为 "多宿主"。

<u>**多宿主方法**</u>
有两种方法可以使一台主机成为多主机。

- 两个或多个接口到同一个网络：由于性能和/或可靠性的原因，服务器或高功率工作站等设备可能配备了两个物理接口到同一个网络。它们将在同一网络上有两个具有相同网络ID的IP地址。

- 连接两个或更多不同网络的接口：设备可能有通往不同网络的多个接口。IP地址中通常会有不同的网络ID。

图59显示了两种类型的多宿主设备的例子。当然，这些可以结合起来，一台主机有两个连接到一个网络，第三个连接到另一个网络。还有一些其他的 "特殊情况"，例如，一台拥有单一网络连接的主机拥有多个IP地址别名。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipmultihomed.png)

​                                                       **图59: IP互联网上的多宿主设备**

这个网络由两个局域网组成，A（紫色显示）和B（蓝色显示）。局域网A有一个多宿主工作站，用两个IP网络接口 "圆圈 "表示。这两个局域网通过一个多主机的共享服务器连接在一起，该服务器已被配置为在它们之间路由流量。请注意，该服务器还处理LAN B和互联网之间的所有流量（因为互联网连接只在LAN A中。）

**注意：**当使用子网时，同样可以区分多宿主是在同一子网还是在不同子网。

<u>**使用多宿主主机作为路由器**</u>

现在，让我们考虑第二种情况。如果一台主机有两个或多个不同网络的接口，那么它能不能在它们之间传递IP数据报呢？当然，它当然可以，如果它有合适的软件在上面运行的话。如果它这样做了，这不就使主机成为了某种意义上的路由器吗？事实上，情况正是如此。一台有两个网络接口的多主机可以使用软件来作为路由器。这有时被称为软件路由。

与硬件路由器相比，使用主机作为路由器有一定的优势和劣势。一个多宿主的服务器可以执行路由功能，同时也可以作为一个服务器。一个专门的硬件路由器是为路由工作而设计的，通常会比在主机上运行的软件程序更有效率。

关键概念: 拥有一个以上的IP网络接口的主机被称为多宿主。一个多宿主设备可以有多个连接到同一个网络或不同的网络，或两者都有。一台连接到两个网络的主机可以被配置成一个路由器的功能。

<u>**多接口主机**</u>
多接口属曾经被认为是一个相当 "深奥 "的应用，但近年来已变得越来越普遍。在不同的网络上使用软件路由的多主机也是如此。事实上，你可能正在你的家里这样做而没有意识到!

假设你有两台电脑联网，用一条电话线连接到互联网。一台电脑拨号到你的互联网服务提供商，并运行诸如微软的互联网连接共享（ICS）等软件，让另一台电脑访问互联网。数以百万计的人每天都在这样做--他们有一个多主机系统（连接到互联网的那台电脑和其他电脑），ICS扮演着软件路由器的角色（当然，ICS和真正的路由器之间有一些技术上的区别。）

###### 3.1.2.1-1-6 IP地址管理和分配方法及权限（部分：1.2）

如果你告诉别人你住在翻斗大街翻斗花园102 室，而当那个人转到你的路上时，发现有四座不同的房子，上面都有 "102 "这个数字，会发生什么？他们可能最终会找到你的地方，但不会太高兴。你和你的邮递员也不会这样做。而你们所有人都比电脑聪明得多。我想说的是，就像街道地址一样，IP地址必须是唯一的，才能发挥作用。

<u>**集中注册IP地址的必要性**</u>
由于IP数据报只在IP网络的范围内发送，因此它们在每个网络内必须是唯一的。如果你是一家拥有自己的私人网络的公司，这其实并不是一个大问题。负责维护网络的人，会保留一份清单，记录哪些号码在哪里被使用过，并确保没有两个设备被赋予相同的地址。然而，在一个有许多不同组织的公共网络中会发生什么？在这里，必须对各组织的IP地址空间进行管理，以确保它们使用不同的地址。让每个组织与其他组织协调其活动是不可行的。因此，需要某种集中的管理机构。

在我们需要有人确保地址分配没有冲突的同时，我们也不希望网络的每个用户在每次需要对他们的网络进行改变时都要去找这个中央机构。更有意义的是，让权威机构根据他们想要连接到网络的设备数量，以块或块的形式向组织分配号码。这些组织可以按照他们认为合适的方式来管理这些区块，而权威机构的工作也变得更容易，因为它处理的是区块而不是数十亿的单个地址和机器。

<u>**原有的IP地址管理机构。IANA**</u>

互联网当然是 "大的 "IP互联网，需要为全球数百万的组织执行这一协调任务。管理互联网上IP地址分配的工作最初由一个组织完成：互联网号码分配机构（IANA）。IANA负责分配IP地址，以及其他重要的集中协调功能，如管理用于TCP/IP协议的通用参数。在20世纪90年代末，一个名为互联网名称与数字地址分配机构（ICANN）的新组织成立了。ICANN现在负责监督IANA的IP地址分配任务，以及管理DNS名称注册等其他任务。

<u>**现代IP地址注册和主管部门**</u>
IP地址最初是直接分配给组织的。最初的IP寻址方案是基于类别的，因此IANA会在A类、B类和C类区块中分配地址。今天，寻址是无类的，使用CIDR的分层寻址方案。IANA并不直接分配地址，而是将其委托给区域互联网注册机构（RIRs）。它们是APNIC、ARIN、LACNIC和RIPE NCC。每个RIR又可以将地址块委托给较低级别的注册机构，如国家互联网注册机构（NIRs）和地方互联网注册机构（LIRs）。

最终，地址块由互联网服务提供商（ISP）获得，分配给最终用户组织。有些ISP的客户是 "最终用户 "组织，但其他客户是（较小的）ISP本身。他们可以反过来使用或 "委托 "他们区块中的地址。这种情况可以以分层的方式持续几个阶段。这种安排有助于确保IP地址以最有效的方式被分配和使用。关于如何运作的更多信息，见CIDR部分。

IANA、ICANN和RIRs负责的不仅仅是IP地址的分配，但由于明显的原因，我在这里集中讨论IP地址。关于IANA、ICANN、APNIC、ARIN、LACNIC和RIPE NCC的更多一般信息，请尝试一罐字母汤......或关于互联网注册机构的专题。

###### 3.1.2.1-2  IP "分类"（传统）寻址

前面关于IP寻址概念的部分描述了TCP/IP中分配IP地址的三种不同方式。最初的寻址方法是将IP地址空间划分为不同大小的块，称为类，并根据组织的规模和要求，从这些类中分配地址块给组织。在20世纪80年代初，当互联网处于起步阶段时，这种传统的系统确实没有名字；今天，为了与较新的 "无类 "寻址方案形成对比，它通常被称为 "有类 "IP寻址系统。

在本节中，我描述了用于IP寻址的第一个方案：所谓的 "有类 "IP寻址。我首先概述了不同类别的概念和一般描述。我讨论了与不同类别相关的网络和主机ID以及地址范围。我讨论了每个常用类的 "容量"，即每个类属于多少个网络，每个网络可以包含多少个主机。我讨论了分配给某些IP地址模式的特殊含义，以及为私有IP地址、环回功能和多播保留的特殊范围。最后，我讨论了这种寻址方式的问题，这导致它最终被放弃，转而采用子网，并最终采用无类别的IP地址空间分配。

我应该注意到，"有类 "的寻址方案现在已经在互联网上被本节后面描述的较新的无类寻址系统取代。然而，我认为理解这个原始系统是如何运作的仍然很重要，因为它构成了建立更复杂的寻址机制的基础。只要记住，类系统在互联网上并没有真正使用。

我还应该指出，"classful "这个词有时也被看作是 "classfull"。这将是一个拼写错误，除了，嗯，"classful "实际上根本不是一个英语单词。这就是为什么我总是把 "classful "这个词放在双引号里。事实上，我必须承认，我非常讨厌这个词。它听起来像是一个小学生编出来的，因为他不知道 "无阶级性 "这个词的反义词。(正确的词是classed，如果有人关心的话）。

我的妻子建议用 "有品位 "这个词会比 "有品位 "听起来更漂亮。她是对的，但IP地址不穿燕尾服。

当然，从来没有人问过我对这个问题的看法。甚至我的妻子也没有。

###### 3.1.2.1-2-1 IP "分类 "寻址概述和地址类别（部分：1 2）

当互联网的第一个前身被开发出来时，互联网网络的一些要求，包括现在和未来，很快就被意识到了。互联网开始时很小，但最终会增长。它将被许多组织所共享。由于互联网上的所有IP地址必须是唯一的，因此必须建立一个系统来划分可用的地址，并在这些组织之间共享。为此，必须建立一个中央机构，并为其制定一个方案，以有效地分配地址。

IP的开发者认识到，组织有不同的规模，因此在互联网上需要不同数量的IP地址。他们设计了一个系统，将IP地址空间划分为不同的等级，每个等级包含总地址的一部分，专门用于特定用途。一些地址专门用于互联网上的大型网络，而另一些则用于较小的组织，还有一些则为特殊目的保留。

由于这是最初的系统，它没有名称；它只是""IP寻址系统。今天，参照它对类的使用，它被称为 "有类 "寻址方案，以区别于较新的无类方案。正如我在本节介绍的结尾所说，"classful "并不是一个真正的词，但它是每个人都在使用的。

<u>**IP地址类**</u>
在 "有类 "系统中，有五个类，它们被赋予字母A到E。表43提供了一些关于类的一般信息，它们的预期用途和其他关于它们的一般特征。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ip-4.jpg)

查看此表（以及图 60），您可以看到前三个类 A、B 和 C 构成了总地址空间的大部分（占总地址空间的 7/8）。这些是用于单播 IP 寻址的类，这意味着将消息发送到单个网络接口。 （这些块还包括这些网络的相关广播地址。）这就是我们通常认为的“正常”IP 地址。您可以将 A、B 和 C 类视为传统 IP 寻址的“爸爸熊”、“妈妈熊”和“熊宝宝”。它们允许 Internet 为少数非常大的网络、中等数量的中型组织和大量小型公司提供寻址。这大致反映了现实世界中组织规模的分布，尽管每个地址类允许的最大主机数量的巨大差距导致不灵活和问题。

如您所见，这些类在网络 ID 和它们所包含的地址的主机 ID 部分之间绘制“分界线”的地方有所不同。然而，在每种情况下，除法都是在八位字节边界上进行的：在有类寻址中，除法不会发生在一个八位字节内。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipclassfulsplit.png)

​                                                                   **图 60：将 IPv4 地址空间划分为类**

​                                                                    （这个不用我解释了吧？J）

D 类和 E 类是特殊的——以至于许多人甚至没有意识到它们的存在。 D 类用于 IP 多播，而 E 类保留用于“实验用途”。我将在本节后面讨论 IP 多播寻址。

<u>**建立 "分类 "地址的理由**</u>

虽然今天人们经常讨论 "分类 "系统的缺点（这也包括我自己，在本节后面），但重要的是要记住这个系统开发时互联网的规模--它很小，32位的地址空间与它的创造者在未来几年设想的机器数量相比似乎也很巨大。记住25年前开发的 "分类 "系统的许多优势才是公平的。

- 简单性和明确性: 只有几个等级可供选择，而且非常容易理解地址是如何划分的。类别之间的区别是清晰而明显的。A、B和C类中网络ID和主机ID的划分是以八位数为界的，因此很容易分辨出任何地址的网络ID是什么。

- 合理的灵活性: 三个级别的 "颗粒度 "与大、中、小型组织的规模相当匹配。最初的系统提供了足够的容量来处理当时互联网的预期增长速度。

- 路由的便利性: 我们很快就会看到，地址的类别被直接编码到地址中，使路由器很容易知道任何地址的哪部分是网络ID，哪部分是主机ID。不需要 "附属 "信息，如子网掩码。

- 保留地址: 某些地址是为特殊目的保留的。这不仅包括D类和E类，还包括用于 "私人 "寻址的特殊保留地址范围。

当然，事实证明，原始IP寻址方案中的一些决定是令人遗憾的，但这是事后诸葛亮的好处。虽然现在看来，为 "实验性使用 "保留整整1/16的地址空间是一种浪费，但请记住，互联网目前的规模甚至在十年前都没有预料到，更不用说二十五年了。此外，在任何稀缺资源中保留一部分供未来使用是很好的做法。(此外，如果我们要玩周一早上的四分卫游戏，回过头来看，真正应该改变的决定是选择32位地址而不是48位或64位！）。

**关键概念**：. "类 "IP寻址方案将IP地址空间划分为五个大小不同的类，A到E。A、B和C类是最重要的，指定用于传统的单播地址，占地址空间的8分之7。D类为IP组播保留，E类为实验性使用。

###### 3.1.2.1-2-2 IP "类 "地址网络和主机识别和地址范围（部分：1 2 3）

相对简单的 "类 "方案的好处之一是，关于类的信息被直接编码到IP地址中。这意味着我们可以事先确定哪些地址范围属于每个类。这也意味着相反的情况是可能的：我们可以通过检查地址的几个比特来确定哪个类别与任何地址相关。

后者的好处是最初创建 "类 "系统的主要动机之一，正如我们在上一主题中看到的那样。

**“有类”寻址类确定算法**
当TCP/IP首次创建时，与目前的状态相比，计算机技术仍处于起步阶段。路由器需要能够快速做出关于如何移动IP数据报的决定。IP地址空间被分成几类，只看任何IP地址的前几位就可以告诉路由器在网络ID和主机ID之间 "划线"，从而决定如何处理数据报。

路由器需要查看的位数可能少到1位，也可能多到4位，这取决于它在开始查看时发现了什么。所用的算法与用于划分地址空间的系统相对应；它涉及四个非常基本的步骤（见图61）。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipbitalgorithm.png)

​                                                                               **图 61：“分类”IP 地址的分类确定算法**

从用于确定地址类别的非常简单的算法中可以看出“分类”IP 寻址的简单性。

1. 如果第一位是 "0"，它就是一个A类地址，我们就完成了。(一半的地址空间的第一位是 "0"，所以这就是为什么A类地址占用了一半的地址空间）。如果是 "1"，继续进行第二步。

2. 如果第二位是 "0"，它就是一个B类地址，我们就完成了。(剩下的非A类地址的一半，或总数的四分之一。) 如果是 "1"，继续第三步。

3. 如果第三位是 "0"，它就是一个C类地址，我们就完成了。(如果是 "1"，继续到第四步。

4. 如果第四位是 "0"，就是D类地址。(余下的一半，即十六分之一的地址空间。) 如果是 "1"，就是E类地址。(另一半，十六分之一)。
   基本上就是这样了。

<u>**从第一个八位数的比特模式确定地址类别**</u>

当然，作为人类，我们通常用十进制点阵而不是二进制来处理地址，但很容易看到对应于类别的范围。例如，考虑B类，第一个八位数的前两个比特是 "10"。其余的位可以是1和0的任何组合。这通常表示为 "10xx xxxx"（为了便于阅读，显示为两组四位）。因此，第一个八位数的二进制范围可以从 "1000 0000 "到 "1011 1111"。这在十进制中是128到191。因此，在 "类 "方案中，任何第一个八位数在128到191（包括）之间的IP地址都是B类地址。

在表44中，我显示了五个类别中每个类别的比特模式，以及计算第一个八位字节范围的方法。第一栏是IP地址第一个八位字节的格式，其中 "x "可以是0或1。然后我以二进制显示每个等级的最低值和最高值（"固定 "的几个位被突出显示，这样你就可以看到它们不会发生变化，而其他位会发生变化）。然后我还显示了第一个八位数在十进制中的相应范围。

表44: IP地址类别的比特模式、第一个八位字节的范围和地址范围

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ip-5.jpg)

**关键概念:** 在 "类 "IP寻址方案中，通过查看地址的前一个、两个、三个或四个比特来确定IP地址的类别。这可以由处理这些地址的人和做出路由决定的路由器来完成。这些比特模式的使用意味着不同等级的IP地址属于特定的地址范围，允许通过查看其点状十进制地址的第一个字节来确定地址的等级。

<u>**地址类别的地址范围**</u>

我还在表44中显示了每个类别的理论最低和最高IP地址范围。这意味着所显示的地址范围只是每个类别中可能的二进制数字的全部跨度的结果。在现实中，有些数值是无法正常使用的。例如，即使192.0.0.0至192.0.0.255在技术上属于C类，但它是保留的，实际上不被互联网上的主机使用。

此外，还有一些IP地址不能使用，因为它们有特殊含义。例如，你不能使用255.255.255.255的IP地址，因为这是一个保留的 "全一 "广播地址。类似地，注意A类的范围是1到126，而不是像你想象的那样0到127。这是因为A类网络0和127是保留的；127是包含IP环回地址的网络。这些特殊和保留的地址将在本节后面讨论。

现在，回忆一下，A、B和C类在网络ID和主机ID的分界线上有所不同。A类的网络ID为1，主机ID为3，B类的网络ID为2，C类的网络ID为3，主机ID为1。根据这种划分，我突出了A、B和C类的IP地址范围的网络ID部分。图62以图形方式显示了五类中每一类的比特使用情况。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipclasses.png)

​                                                             <u>**图62: IP地址类位分配和网络/主机ID大小**</u>

该图显示了32位的IP地址是如何分配给五个IP地址类别中的每一个的。A、B和C类是用于常规单播地址的 "正常 "类；每个类在网络ID和主机ID之间有一个不同的分界点。D类和E类是特殊的，没有以这种方式划分。

咻，我想是时候再举个例子了。我们来看看C类。最低的IP地址是192.0.0.0，最高的是223.255.255.255。前三个八位字节是网络ID，范围从192.0.0到223.255.255。对于该范围内的每个网络ID，主机ID的范围可以从0到255。

**注意：**通常看到资源提到 "类 "地址的网络ID只包括 "重要 "位，即只包括该类所有网络不通用的那些位。例如，你可能会看到一个B类网络ID在图中显示为14位，而开始所有此类网络的 "10 "位被单独显示，好像它不是网络ID的一部分。请记住，网络ID也包括这些比特；A类是8个完整的比特，B类是16个比特，C类是24个比特。在D类地址的情况下，所有32个比特都是地址的一部分，但只有低28个比特是组播组地址的一部分；更多内容请参见组播寻址专题。

###### 3.1.2.1-2-3 IP地址A、B和C类的网络和主机容量

在前面的主题中，我介绍了 IP 地址类的概念，并展示了这些类与 IP 地址范围的关系。在这五个等级中，D 和 E 专门用于特殊用途，所以我暂时不考虑它们。 A、B 和 C 类实际上是为 IP 互联网上的正常（单播）寻址目的而分配的，因此是我们持续关注的主要焦点。

正如我们所见，与主机 ID 相比，它们在用于网络 ID 的位数（和八位字节）方面有所不同。每个类别中可能的不同网络的数量是分配给网络 ID 的位数的函数，同样，每个网络中可能的主机数量取决于为主机 ID 提供的位数。我们还必须考虑 IP 地址中的一位、两位或三位用于指示类别本身的事实，因此在确定网络数量时有效地“排除”了它（尽管同样，它是仍然是网络 ID 的一部分）。

基于这些信息，我们可以计算每个类中的网络数量，以及每个类中每个网络的主机 ID 数量。表 45 显示了计算结果。

​                                                                **表 45：IP 地址类网络和主机容量**

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ip-7.jpg)

让我们看一下这张表的一行，看看它是如何工作的。我会坚持使用 B 类，因为它“在中间”。基本划分为 16 位网络 ID 和 16 位主机 ID。但是，所有 B 类地址的前两位必须是“10”，因此只剩下 14 位来唯一标识网络 ID。这给了我们总共 214 或 16,384 个 B 类网络 ID。对于每个，我们有 216 个主机 ID，减去两个，总共 65,534 个。

为什么少了两个？对于每个网络 ID，不能使用两个主机 ID：全 0 的主机 ID 和全 1 的 ID。这些是具有“特殊含义”的地址，如以下主题中所述。您还会注意到从 A 类的网络 ID 数量中减去了 2。这是因为 A 类网络 ID 中的两个（0 和 127）被保留。实际上，我在此处未显示的所有三个类中都预留了其他几个地址范围。它们列在关于保留地址、私有地址和环回地址的主题中。 （从 A 类中排除 0 和 127 可能是最知名的地址范围保留，这就是为什么我在上表中明确指出的原因。）

**关键概念：**在“分类”IP 寻址方案中，A 类网络包含大约 1600 万个网络接口的地址； B类约65,000；和 C 类，254。

如您所见，每个类中每个网络的可用主机数量存在很大差异。如果一个组织需要 1,000 个 IP 地址会怎样？他们必须使用四个 C 类或一个 B 类（这样做会浪费 B 类网络中 90% 以上的可能地址。）请记住，全球只有大约 16,000 个 B 类网络 ID 可用，而您开始理解“分类”寻址的一大问题。

###### 3.1.2.1-2-4  具有特殊含义的IP地址 (部分: 1 2 )

大多数 IP 地址都具有我在本节前面的主题中描述的“通常”含义：它们指的是 TCP/IP 网络上设备的接口。但是，某些 IP 地址并不以这种方式直接引用特定的硬件设备。相反，它们用于“间接”指代一个或多个设备。为了与语言进行类比，大多数 IP 地址都指代专有名词，例如“John”或“角落里的红色桌子”。但是，有些人更多地使用我们使用代词的方式，例如“this one”或“that group over there”。我用特殊的含义称呼这些 IP 地址。

<u>**特殊网络ID和主机ID地址模式**</u>
特殊 IP 地址是通过用两种特殊模式之一替换 IP 地址中的正常网络 ID 或主机 ID（或两者）来构造的。这两种模式是：

- 全零：当网络 ID 或主机 ID 位被一组全零替换时，特殊含义相当于代词“this”，指代被替换的任何内容。它也可以解释为“默认”或“当前”。因此，例如，如果我们将网络 ID 替换为全零但不保留主机 ID，则生成的地址表示“在此网络上具有给定主机 ID 的设备”。或者，“在默认网络或当前网络上指定主机 ID 的设备”。

- 全1：当网络ID或主机ID位被一组全1替换时，这具有“全”的特殊含义。因此，将主机 ID 替换为全 1 意味着 IP 地址指的是网络上的所有主机。这通常用作向“所有人”发送消息的广播地址。

关键概念：当 IP 地址的网络 ID 或主机 ID 被替换为全 1 或全 0 的模式时，结果是具有特殊含义的地址。此类地址的示例包括“所有主机”广播地址，以及引用特定主机或整个网络的地址。

<u>**具有特殊含义的特定 IP 地址模式**</u>

由于有很多网络 ID 和主机 ID，因此也有很多这样的“特殊”地址。一小部分在整个 TCP/IP 网络中是通用的，而其他的则存在于每个网络 ID 或主机 ID 中。由于有两种“特殊模式”可以应用于网络 ID、主机 ID 或两者，因此产生了六种可能的组合，每一种都有自己的特殊含义。其中，使用了五个。

表 46 描述了这些特殊含义。在表中，我还提供了三个示例，分别来自 A、B 和 C 类。这显示了如何将每个常见类中的 IP 地址修改为每种“特殊含义”形式。 （第一行以正常形式显示示例，以供参考。）

​                                                                **表 46：具有特殊含义的 IP 地址模式**

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ip-8.jpg)

注意：缺少的组合来自

表 46 是网络 ID 全为 1 且主机 ID 正常的情况。从语义上讲，这指的是“所有网络上具有特定 ID 的所有主机”，这在实践中并不真正意味着任何有用的东西，因此没有使用它。另请注意，理论上，网络 ID 全为零且主机 ID 全为 1 的特殊地址与全为限制广播地址具有相同的含义。然而，后者被使用，因为它更通用，不需要知道网络 ID 和主机 ID 之间的划分位置。

<u>**由于特殊含义模式导致的 IP 地址限制**</u>

由于全零和全一模式是为这些特殊含义保留的，因此它们不能用于常规 IP 地址。这就是为什么当我们查看每个类中每个网络的主机数量时，我们必须从理论最大值中减去两个：一个用于全零情况，一个用于全一情况。

同样，网络 ID 也不能全为零。但是，这不需要特定的排除，因为在第一个八位字节 (0.x.x.x) 中带有“0”的整个地址块是保留的 IP 地址集之一。这些保留地址（在下一个主题中描述）进一步限制了 IP 地址空间中某些地址的“常规”使用。

###### 3.1.2.1-2-5 IP保留、回环和私有地址（部分：1 2 3）

在前面的主题中，我展示了某些 IP 地址如何不能用于常规网络设备，因为它们是具有“特殊含义”的地址。这些特殊地址减少了“分类”寻址方案中可能的网络总数，以及每个网络中可用的主机总数。

除了这些无法使用的号码之外，还有其他几组 IP 地址被预留用于各种特殊用途，这些 IP 地址无法用于正常的地址分配。这些 IP 地址范围通常分为以下三类：保留地址、环回地址和私有地址。

<u>保留地址</u>

几个地址块被指定为“保留”，但没有具体说明它们的保留用途。它们可能已被留作未来的实验，或用于内部管理互联网，或用于其他目的。 （一般来说，将任何有限资源的一部分留出用于意外需求是一个好主意！）在三个主要类别（A、B 和 C）中的每一个中都有几个这样的块，出现在开头和每节课结束。 （从某种意义上说，所有 D 类和 E 类也是“保留的”，因为它们不用于常规寻址，尽管“保留”一词通常用于指代 A、B 和 C 类的不可用部分.

<u>环回地址</u>

通常，当 TCP/IP 应用程序想要发送信息时，该信息会沿协议层向下传输到 IP，然后封装在 IP 数据报中。然后，该数据报向下传递到设备物理网络的数据链路层，以便在到达 IP 目的地的途中传输到下一跳。

但是，为回送功能预留了一个特殊的地址范围。这是 127.0.0.0 到 127.255.255.255 的范围。主机发送到 127.x.x.x 环回地址的 IP 数据报不会向下传递到数据链路层进行传输。相反，它们在 IP 级别“环回”到源设备。本质上，这代表了普通协议栈的“短路”；数据由设备的第三层 IP 实现发送，然后立即被设备接收。

环回范围的目的是测试主机上的 TCP/IP 协议实现。由于较低层是短路的，因此发送到环回地址可以有效地测试较高层（IP 及以上），而不会出现较低层出现问题的机会。 127.0.0.1 是最常用于测试目的的地址。

**关键概念：**IP 地址空间的一部分留作保留、私有和环回地址。

<u>**专用/未注册/不可路由地址**</u>

回想一下，在IP地址概述中，我对比了私有IP地址和公共IP地址。IP网络上的每个IP地址都必须是唯一的，如果是公共IP网络，则使用中央机构分配地址，以确保没有重叠。相反，如果你建立了私人网络，你可以使用任何你想要的地址；这是你的showtime ，没有人对你做什么有发言权。

因此，如果是这样，为什么不为您的专用网络选择任意一个随机的A类、B类或C类地址块并使用它呢？嗯，你可以；因为你没有连接到互联网，所以你可以使用A类网络18.x.x.x，它是麻省理工学院（MIT）在互联网上保留的。既然你与麻省理工学院没有联系，那又有什么关系呢？

在过去，有人选择这样做，但最终后悔了这个决定。随着互联网重要性的增加，他们后来会决定，这些私人网络毕竟需要连接到公共互联网。如果发生了这种情况，并且你使用了18.x.x.x地址，你会发现自己必须重新编号所有设备，以避免让一大群极客真正生气。（事实上，曾使用其他公司的IP地址空间的公司意外地将这些机器连接到互联网，在这一过程中引发了少量骚动。）

从更普通的角度来看，拥有MIT IP地址的内部设备是一种困惑。让许多不同的公司为其专用网络“借用”IP地址并不是一个好主意。

另外，RFC 1918（取代RFC 1597）定义了一组专用地址块，这些地址块仅用于专用地址。这些地址在公共互联网上根本不存在。任何人都可以使用它们，无需联系任何权威机构获得许可。同时，它们无法连接到全球互联网，因为路由器没有设置条目，无法将这些地址范围的流量转发到本地组织之外。RFC 1918实际上是为了鼓励使用这些私有块，以减少公共互联网上真正不需要公开访问的设备的数量。这是为了满足节约公共广播空间的需要。

为了使用专用地址将网络连接到公共互联网，需要使用额外的硬件和/或软件。网关机器可用作公共网络和专用网络之间的接口。IP网络地址转换（NAT）等技术通常与专用IP地址结合使用，以允许这些主机在公共IP网络上通信。

**关键概念：**创建专用地址块是为了允许使用保证不会与公共IP地址冲突的地址创建专用IP互联网。它们通常用于未连接到全球互联网的互联网；使用它们的设备也可以通过NAT访问全球互联网。

<u>**保留、环回和专用地址块**</u>

表47以数字顺序显示了正常IP地址空间之外的所有特殊块，并简要说明了每个块的使用方式：

​                                                                     <u>**表47: 保留、回环和私有IP地址**</u>

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ip-0.jpg)

我同时显示了代表这些块的 "有类 "和无类的符号。这既是因为互联网现在使用无类地址，也因为一些私有块并不对应于单一的A、B或C类网络。特别注意从192.168.0.0到192.168.255.255的私有地址块。这是一个B类网络的大小，但它不是 "classful "方案中的B类，因为 "192 "的第一个八位数使它处于地址空间的C类部分。事实上，它是256个连续的C类网络。

你可能还注意到特殊的B类（/16）区块169.254.x.x，这是为自动私有IP地址（APIPA）保留的。被配置为使用该功能的系统将自动从该块分配系统地址，以使它们能够进行通信，即使使用DHCP找不到 "正确的 "IP地址分配的服务器。这将在描述DHCP的章节中的一个特殊主题中描述。

###### 3.1.2.1-2-6 IP组播地址（部分：1 2）

IP互联网上的绝大多数流量都是单播的：一个源设备发送到一个目标设备。IP还支持多播，其中源设备可以发送到一组设备。目前，在整个互联网上，多播没有被大量使用，主要是因为缺乏广泛的硬件支持，所以我们在研究IP时主要关注的是单播。然而，在某些情况下，多播是有用的，特别是作为广播的一种更有效的替代方法。我包括一个关于多播的总结主题供您阅读，并且还想在此简要讨论与多播相关的IP寻址问题。

“类”IP寻址方案为多播地址预留了整整十六分之一的地址空间：D类。多播地址由前四位中的模式“1110”标识，对应于224到239的第一个八位字节。因此，多播地址的完整范围是从224.0.0.0到239.255.255.255。由于多播地址代表一组IP设备（有时称为主机组），因此它们只能用作数据报的目的地；而不是源头。

<u>**多播地址类型和范围**</u>

IP地址中前导“1110”后的28位定义多播组地址。因此，D类多播地址空间的大小为228或268435456个多播组。没有定义这28个钻头用途的子结构；没有a类、B类和C类中的网络ID和主机ID的具体概念。但是，地址空间的某些部分被预留用于特定用途。表48和图63显示了D类地址空间的一般分配。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ip-10.jpg)

我同时显示了代表这些块的 "有类 "和无类的符号。这既是因为互联网现在使用无类地址，也因为一些私有块并不对应于单一的A、B或C类网络。特别注意从192.168.0.0到192.168.255.255的私有地址块。这是一个B类网络的大小，但它不是 "classful "方案中的B类，因为 "192 "的第一个八位数使它处于地址空间的C类部分。事实上，它是256个连续的C类网络。

你可能还注意到特殊的B类（/16）区块169.254.x.x，这是为自动私有IP地址（APIPA）保留的。被配置为使用该功能的系统将自动从该块分配系统地址，以使它们能够进行通信，即使使用DHCP找不到 "正确的 "IP地址分配的服务器。这将在描述DHCP的章节中的一个特殊主题中描述。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ip-11.png)

​                                                             <u>**图63：IP多播地址范围和使用**</u>

所有多播地址以“1110”开头，如图所示。“已知”组的多播组地址的前20位为零，8位可用于定义255个特殊多播地址。以“1110 1111”开头的多播地址是本地作用域；所有其他地址都是全局范围的（这包括以“1110 0000”开头的地址，而不是255个“已知”地址。）

相关信息：多播地址范围的概念在IPv6中有了更完整的定义，我在IPv6多播地址的讨论中对其进行了更详细的讨论。

**众所周知的多播地址**

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ip-12.jpg)

**注意**：还有一些其他预定义组也指使用特定路由器的路由器

**路由协议**；我没有费心把它们都列出来，因为信息会比较多。

由于存在多个接收者，IP 多播流量的传递比单播流量更复杂。代替通过用于单播数据报的 ARP 协议的正常解析方法，在 IP 多播组和硬件多播组之间执行特殊映射。

###### 3.1.2.1-2-7 分类 "IP地址的问题（部分：1 2 3）

"classful "有类寻址系统是为大型IP网络定义通用寻址方法的第一次重要尝试。该系统有一些优点，正如我在 "类 "方案的概述中提到的那样，考虑到它是在几十年前为一个规模有限的网络开发的，它在很长一段时间内出色地完成了工作。

没有人想到互联网会如雨后春笋般发展到接近其目前的规模。随着互联网的发展，"类 "IP寻址机制的问题变得很明显--起初是缓慢的，但随着增长的速度越来越快。在我对这种寻址方式的解释中，我已经暗示了其中的一些问题，但是为了帮助对更新的寻址类型进行讨论，我认为更详细地看一下这个问题是有用的。

**“有类”解决问题总结**
"有类 "寻址有三个主要的问题，它们在某种程度上是相互关联的（使得它们有点难以解释）。让我们先快速总结一下这些问题是什么。

- 缺少内部地址的灵活性：大的组织被分配大的、"单一的 "地址块，与他们的基础内部网络结构不相匹配。

- 地址空间的使用效率低下:只有三种块大小（A、B和C类）的存在导致了有限的IP地址空间的浪费。

- 路由器表项的激增:随着互联网的发展，路由器需要越来越多的条目来处理IP数据报的路由，这导致了路由器的性能问题。试图减少低效的地址空间分配会导致更多的路由器表条目。

**解决僵化问题**
问题 #1 主要是因为在“分类”系统中，大公司被分配了相当大（B 类）或真正巨大（A 类）的地址块，所有这些都被 Internet 路由器视为单个“网络”和一个“网络 ID”。现在，假设您正在经营一家拥有 5,000 台计算机的大中型公司，并且为您的网络分配了一个 B 类地址。您真的有 5,000 台计算机都连接到一个网络吗？我当然希望你不要！然而，您将被迫尝试在原始“分类”方法中将所有这些放入单个 IP“网络”。没有办法创建地址的内部层次结构。

**类的关键问题：低粒度**

问题 #2 和 #3 彼此之间的关系比问题 #1 更密切，并且都是“分类”系统中的“粒度”太低而无法在大型互联网中实用这一事实的结果。我的意思是，可用网络规模的选择太少了。三种规模在原则上似乎很好，但规模之间的差距是巨大的，而且规模与现实世界中组织的分布并不完全匹配。考虑 C 类和 B 类网络之间的规模差异——从 254 台主机一路跃升至超过 65,000 台！有很多很多公司需要超过 254 个 IP 地址但少于 65,000 个。那么A类呢？有多少公司需要 1600 万个 IP 地址，即使是真正的大公司？如果您考虑一下，可能没有，但这只是那里 IP 地址空间的一半。

再考虑一下我们公司有 5000 台计算机——他们应该使用什么级别的网络？如图 64 所示，“分类”方案根本无法很好地满足该公司的需求。过去，他们可能会被分配到 B 类网络。但是，将 B 类授予“仅”拥有 5,000 台计算机的公司意味着 90% 以上的 IP 地址被浪费了。当互联网还很年轻时，这没什么大不了的，但随着它的发展，这些低效率很快就开始变得严重。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipclassfulproblem.png)

​                                                                             **图 64：“分类”寻址的主要问题**

在这个比例图中，每个方块代表 50 个可用地址。由于 C 类地址只有 254 个地址，而 B 类地址包含 65,534 个地址，因此拥有 5,000 台主机的组织“夹在中间”。它只能选择要么浪费 90% 的 B 类地址，要么使用 20 个不同的 C 类网络。

浪费所有这些 IP 地址的替代方法是给公司而不是一个 B 类地址，而是一堆 C 类地址。但是，正如您所看到的，他们需要其中的 20 个。这在地址空间的使用方面更有效，但会导致问题 #3：Internet 上的每个路由器都用 20 个 C 类路由器条目替换单个 B 类路由器表条目。现在将其乘以几千家“中型”公司，您会发现这种方法会显着增加路由器表的大小。随着 Internet 的扩展，路由器表已经快速增长。这些表越大，路由器做出路由决策所需的时间就越多。

<u>**应对“分类”解决困难的策略**</u>

这些问题是通过我在其他部分中讨论的三个增强或改进来解决的。第一个主要解决问题#1，是子网的开发。第二个是转向无类寻址和路由，它用更高粒度的新方法取代了“类”系统。这解决了问题#2和#3，允许根据实际组织需求分配地址，而不需要为每个组织指定多个路由表条目。第三个改进是新的IP版本6协议，它最终消除了32位IP地址空间的限制，取而代之的是庞大的128位IP地址。

其他支持技术也有助于延长IP版本4的使用寿命。我在上一个主题中讨论了一个重要的技术，即结合IP网络地址转换（NAT）使用私有寻址，以允许多个设备共享公共地址。仅此一项就延长了IPv4寻址系统的寿命。

###### 3.1.2.1-3 IP子网地址（"子网划分"）概念

最初的 "类 "IP寻址方案在概念上将一个大的互联网划分为一个简单的两级层次结构：许多不同规模的网络，每个网络包含一些主机。该系统对小型组织来说效果很好，因为它们可能在一个网络中连接所有的机器。然而，对于经常有许多子网络或子网的大型组织，它缺乏灵活性。为了更好地满足大型组织的管理和技术要求，"classful "IP寻址系统通过一种被称为子网寻址的技术得到了加强，或者更简单地说，子网化。

在本节中，我描述了与IP子网寻址相关的概念和一般技术。我首先概述了子网的情况，包括对该系统的动机及其优点的讨论。我讨论了传统的划分IP地址的 "两级 "方法如何成为子网划分的 "三级"。我谈论了子网掩码以及它们如何被用于寻址和路由的计算中。我讨论了在子网环境中用来表示 "类 "A、B和C类网络的默认子网掩码，然后讨论了如何为A、B和C类使用定制的子网掩码，然后讨论了子网标识符和在子网环境中确定子网和主机地址的一般概念。我提供了A类、B类和C类网络子网的汇总表。最后，我简要讨论了可变长度子网掩码（VLSM），这是 "传统 "子网划分的一个改进，进一步提高了其灵活性。

注意：我提供了大量关于子网划分的内容，因为了解它是学习IP地址如何工作的重要部分，因此也是学习TCP/IP功能的重要部分。然而，我需要强调的是，太少的参考资料提到：这项技术今天被认为主要是历史性的。原因是子网划分仍然基于 "classful "寻址，在互联网上已经被无类寻址取代。子网和子网掩码的概念当然没有完全消失，但被分配一个A类、B类或C类互联网地址块，然后明确地对其进行子网划分的想法已不再适用。

相关信息。这是专门讨论IP地址子网的两节中的第一节。第二节紧随其后，用实例描述了子网划分的逐步过程。如果你在阅读完这一概念部分后发现你不太理解子网划分，可以尝试阅读基于实例的部分，你可能会发现它有助于使这一切变得 "简单"。另一方面，如果你对子网划分已经比较熟悉，你可能会发现你可以跳过这个概念部分，而只是通过一步步的例子。在那一节中，你会发现更多关于子网掩码、子网地址和主机地址计算的 "血腥细节"。把实用的细节放在这里，可以使本节集中于概念，而不至于在数字上过于纠结。

**背景信息:** 理解子网划分需要对二进制数字和它们的操作方式有一定的熟悉程度。这包括使用布尔运算符（如AND）来 "屏蔽 "二进制数字的概念。如果读到最后一句话，你会觉得 "啊？" 我强烈建议你在继续阅读之前先回顾一下计算数学的背景部分。

###### 3.1.2.1-3-1 IP子网地址概述、动机和优势（部分：1 2 3 )

IP 寻址最初是围绕互联网网络严格的两级层次结构的假设设计的。第一层是网络，第二层是主机。每个组织通常由一个网络标识符表示，该标识符指示专用于它们的 A、B 或 C 类块。在该网络中，他们必须将所有想要连接到公共 IP 网络的设备放入其中。

**子网寻址的动机**

“分类”计划被开发出来后不久，它的严重不足之处就引起了人们的注意，尤其是大型组织。原因在于，虽然将大型互联网络划分为包含主机的网络在概念上很简单，但它并不总是能很好地匹配构成互联网的每个网络的结构。拥有数千台计算机的大公司不会将它们构建成一个庞大的物理网络。试图在没有任何形式的内部逻辑结构的情况下为组织的整个网络分配和管理 IP 地址是非常困难的。

不幸的是，在最初的“分类”寻址方案下，这个问题没有很好的解决方案。当时最常用的替代方案是用一大块地址（例如 B 类地址）换取一堆 C 类地址。但是，这导致了其他问题：

- 它促成了 IP 路由表规模的爆炸式增长。
- 每次需要更多地址空间时，管理员都必须申请新的地址块。
- 对公司网络内部结构的任何更改都可能影响组织外部的设备和站点。
- 跟踪所有这些不同的 C 类网络本身就有点让人头疼。

<u>**子网寻址的发展**</u>

为了充分解决这个问题，需要对 "有类 "寻址方案进行改进。这一变化在RFC 950中被概述，它定义了一个新的寻址程序，称为子网寻址或子网。(这个RFC是在1985年发表的，这让一些人感到惊讶！）。

子网寻址的基本思想是在解释IP地址的方式中增加一个额外的层次。网络的概念保持不变，但在网络中不再只有 "主机"，而是创建了一个新的两级层次结构：子网和主机。每个子网都是一个子网络，其功能与传统的有类寻址中的完整网络差不多。因此，一个三层的层次结构被创造出来：网络，它包含子网，每个子网又有若干个主机。

因此，一个组织不必以非结构化的方式将其所有的主机放在该网络下，而是可以将主机组织成反映内部网络结构方式的子网。这些子网符合分配给该组织的网络标识符，就像以前所有 "无组织 "的主机一样。

<u>**子网寻址的优点**</u>
从本质上讲，子网寻址允许每个组织拥有自己的 "互联网中的互联网"。就像真正的互联网只看网络和主机一样，是一个两级的层次结构，每个组织现在也可以在其网络中拥有子网和主机。与旧系统相比，这一变化提供了许多优势。

- 与物理网络结构更好地匹配。主机可以被分组到子网中，以反映它们在组织的物理网络中的实际结构方式。

- 灵活性。子网的数量和每个子网的主机数量可以为每个组织定制。每个组织可以决定自己的子网结构，并根据需要进行改变。

- 对公共互联网不可见。子网的实施是为了使网络的内部划分只在组织内部可见；对于互联网的其他部分，组织仍然只是一个大的、扁平的 "网络"。这也意味着，对内部结构所做的任何改变在组织外部是不可见的。

- 不需要申请新的IP地址。组织不必像使用多个小型C类区块那样，不断申请更多的IP地址。

- 没有路由表项的扩散。由于子网结构只存在于组织内部，组织外的路由器对它一无所知。该组织仍然为其所有的设备维护一个（或几个）路由表项。只有组织内部的路由器需要担心子网之间的路由问题。

<u>**子网划分对寻址和路由的影响**</u>

子网的变化影响到IP网络的寻址和路由。寻址当然会发生变化，因为我们不再只有网络ID和主机ID，现在还有一个子网ID需要关注。每个网络的子网ID的大小可能不同，所以需要额外的信息来补充IP地址，以表明地址的哪部分是子网ID，哪部分是主机ID。这就是一个32位的数字，通常称为子网掩码。该掩码既用于计算子网和主机地址，也被路由器用于确定如何在子网网络中移动IP数据报。

由于层次结构的增加，路由发生了变化。在常规的 "类 "寻址中，当路由器收到一个IP数据报时，它只需要决定目的地是在同一网络还是不同的网络。在子网下，它还必须查看目的地的子网ID，并做出三个选择之一：同一子网、同一网络的不同子网或不同网络。同样，这是用子网掩码完成的。为了处理子网和子网掩码，还需要改变路由协议，如路由信息协议（RIP）。

**关键概念:** 子网寻址通过将一个组织的IP网络划分为子网，为如何解释IP地址增加了一个额外的层次。这使得每个组织可以构建其地址空间，以匹配其内部物理网络，而不是被迫将其视为一个平面块。这解决了原来的 "有类 "寻址方案的一些问题，但需要改变寻址和路由的工作方式，以及对几个TCP/IP协议进行修改。

有趣的是，与旧的寻址方案相比，子网的主要缺点更多的是与理解子网的工作方式有关，而不是与技术本身有关! 在子网环境中处理寻址和路由需要更多的努力，管理员必须学会如何将他们的网络细分为子网并正确分配地址。这对于一个刚接触子网的人来说，可能会有点困惑。然而，今天的技术已经相当完善，所以即使是这样也没有什么问题。对于新手来说，有一本像这样的方便的参考指南肯定会有帮助。J

###### 3.1.2.1-3-2 IP子网划分。"三层 "分层的IP子网寻址

IP地址的最简单划分是包含两个元素的结构：网络ID和主机ID。在解释这个概念时，我打了个比方，就像北美的电话号码是十位数，但被分解成三位数的区号和七位数的本地号码。

正如我在前面的话题中提到的，子网为IP寻址中使用的结构层次增加了一个层次。为了支持这一点，IP地址必须被分成三个元素，而不是两个。这是通过单独保留网络ID和将主机ID分成子网ID和主机ID来实现的。这些子网ID位被用来识别网络中的每个子网。主机以对该网络最合理的方式被分配到子网中。

有趣的是，我们之前使用的电话号码的比喻在子网世界中仍然成立，并显示了子网是如何改变IP地址的解释方式的。像(401)555-7777这样的号码有一个区号（"401"）和一个本地号码（"555-7777"），正如我之前所说。然而，本地号码本身可以分解成两部分：交换机（"555"）和本地分机（"7777"）。这意味着电话号码实际上是由三个层次的部分组成的，就像IP地址在子网中一样。

当然，IP地址的位数是固定的，为32位。这意味着，在将主机ID分成子网ID和主机ID时，我们减少了地址的主机ID部分的大小。从本质上讲，我们是从主机ID中 "偷 "出了比特，用于子网ID。A类网络有24个比特用于分割子网ID和主机ID：B类网络有16个，而C类网络只有8个。

**关键概念:** 一个 "类 "网络通过分割其主机ID部分来划分子网，留下一些比特用于主机ID，而将其他比特分配给一个新的子网ID。然后，这些位被用来识别网络中的各个子网，并将主机分配到这些子网中。

现在，记得当我们看每个主要类别的大小时，我们看到对于每个类别，网络的数量和每个网络的主机数量是我们为每个类别使用多少比特的函数。这同样适用于我们对主机ID的拆分。由于我们处理的是二进制数字，子网的数量是子网ID字段大小的2次方。同样，每个子网的主机数量是主机ID字段大小的2次方（对于排除的特殊情况减去2）。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipsubnet.png)

​                                                                                   **图65：子网A、B类网络**

我们从B类网络154.71.0.0开始，它的主机ID块中有16位，如顶部所示。然后，我们通过将主机ID分为子网ID和主机ID来对该网络进行子网划分。在这种情况下，5位分配给子网ID，11位留给主机ID。

让我们举一个简单的例子来看看这是如何工作的。想象一下，我们从B类网络154.71.0.0开始。16位用于网络ID（154.71），16位用于主机ID。在常规的“类”寻址中，没有子网（一个“子网”即整个网络，但不用担心），总共有65534台主机。为了将该网络分为子网，我们可以决定分割这16位，但我们认为这最适合我们网络的需要：1位用于子网ID，15位用于主机ID，或者2和14，3和13，依此类推。只要总数是16，大多数组合都会起作用，如5和11，如图65所示。我们从主机ID“窃取”的更多位用于子网上ID，我们可以拥有的子网越多，但每个子网可以拥有的主机越少。

在设置子网IP网络时，决定如何进行此选择是最重要的设计考虑因素之一。子网的数量通常根据整个组织网络中的物理子网数量确定。每个子网的主机数不得超过我们所做的特定子网选择所允许的最大值。选择如何将原始主机ID位划分为子网ID位和主机ID位有时称为自定义子网，本节稍后将对此进行详细描述。

###### 3.1.2.1-3-3 IP子网掩码、符号和子网计算（部分：1 2 3 4）

子网划分将一个组织的网络划分为子网和主机的两层结构。这种划分完全是内部的，对互联网上所有其他组织都是隐藏的。这样做的许多好处之一是，每个组织可以自己选择如何将 "classful "主机ID划分为子网ID和主机ID。

在非子网的 "classful "环境中，路由器使用IP地址的第一个八位数来确定地址的类别，并由此知道哪些位是网络ID，哪些是主机ID。当我们使用子网时，这些路由器还需要知道该主机ID如何被划分为子网ID和主机ID。然而，对于每个网络来说，这种划分可以是任意的。此外，仅仅通过查看IP地址，是无法知道每个人属于多少位的。

在子网环境中，关于哪些比特属于子网ID，哪些属于主机ID的额外信息必须传达给解释IP地址的设备。这些信息以32位二进制数字的形式给出，称为子网掩码。术语 "掩码 "来自二进制数学概念，称为位掩码。这是一种技术，一个特殊的1和0的模式可以与布尔函数（如AND和OR）结合使用，以选择或清除一个数字中的某些位。我在二进制数字和数学的背景部分解释了位掩码。

<u>**子网掩码的功能**</u>
关于子网掩码，有一些东西似乎让人们的头发都竖起来了，特别是如果他们对二进制数字不是那么熟悉的话。然而，它们背后的想法是相当直截了当的。子网掩码是一个32位数字，就像IP地址是一个32位数字一样。子网掩码中的每一个32位都对应于数字中相同位置的IP地址中的位。在任何给定的子网网络中，掩码的位被选择，以便用于网络ID或子网ID的位是1，而用于主机ID的位是0。

**关键概念:** 子网掩码是一个32位的二进制数字，伴随着IP地址。它的创建是为了使IP地址中属于其网络ID或子网ID的每个对应位都有一个1，而IP地址的主机ID的每个位都有一个0。因此，掩码告诉TCP/IP设备，该IP地址中的哪些位属于网络ID和子网ID，哪些是主机ID的一部分。

为什么要对一个32位的二进制数字进行这样的处理呢？答案是布尔逻辑的魅力。我们通过在子网掩码和IP地址之间应用布尔和函数来使用它。对于IP地址和子网掩码中的32个 "位对"，我们采用AND函数，只有当两个位都是1时，其输出才是1。这意味着在实际操作中，32个比特中的每一个都是这样的。

- 子网位是1：在这种情况下，我们将IP地址中的0或1与1相加。如果IP地址位是0，相加的结果就是0，如果是1，相加的结果就是1。换句话说，当子网位为1时，IP地址将被保留不变。

- 子网位为0：在这里，我们与0相加，所以无论IP地址是什么，结果都是0。因此，当子网位为0时，IP地址位总是被清除为0。

因此，当我们在一个IP地址上使用子网掩码时，网络ID和子网ID的位被保留下来，而主机ID的位被删除。就像一个面具挡住了你脸的一部分，但让其他部分露出来一样，子网掩码挡住了一些地址位（主机位），而让其他位单独存在（网络和子网位）。执行这一功能的路由器留下的是子网的地址。由于它从网络的类别中知道哪一部分是网络ID，所以它也知道该地址在哪个子网。

**关键概念:** 为了使用子网掩码，设备在子网掩码的每个位和IP地址的每个对应位之间进行布尔和操作。产生的32位数字只包含地址的网络ID和子网ID，主机ID被清除为零。

<u>**子网掩码的符号**</u>

像IP地址一样，子网掩码总是被计算机作为一个32位的二进制数字使用。和IP地址一样，将它们作为32位二进制数字使用对人类来说是很困难的。因此，为了方便起见，它们通常被转换为点分十进制符号，就像IP地址一样。

让我们举个简单的例子来说明这到底是怎么一回事。假设我们有一个B类网络154.71.0.0，我们决定用5位的子网ID和11位的主机ID对其进行子网。在这种情况下，子网掩码将有16个1用于网络部分（因为这是B类），然后是5个1用于子网ID，11个0用于主机ID。这就是二进制的 "1111111 11111111 11111000 00000000"，其中与子网ID相对应的位高亮显示。转换成点阵十进制，子网掩码将是255.255.248.0。图66说明了这个过程。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipsubnetmask.png)

​                                                                               <u>**图66: 确定子网网络的子网掩码**</u>

图65中的B类网络显示在顶部，其中5位分配给子网ID，11位留给主机ID。为了创建子网掩码，我们填写一个32位数字，每个网络ID和子网ID位为 "1"，每个主机ID位为 "0"。然后我们可以将其转换为点阵十进制。

<u>**应用子网掩码。一个例子**</u>

现在，让我们看看子网掩码是如何使用的。假设我们在这个网络上有一台主机，IP是154.71.150.42。路由器需要弄清这个地址在哪个子网。这是通过执行表50和图67所示的屏蔽操作来完成的。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ip-13.jpg)

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipsubnetmasking.png)

​                                                            **图67: 通过子网掩码确定一个IP地址的子网ID**

子网屏蔽包括在子网掩码中的每个相应位和IP地址之间进行布尔运算。子网掩码可以比作一个物理掩码；其中的每一个1可以让IP地址的相应位 "显示出来"，而每一个0则阻止相应的IP地址位。通过这种方式，地址的主机ID位被剥离，因此设备可以确定地址所属的子网。

这个结果，154.71.144.0，是154.71.150.42所属的子网的IP地址。没有必要明确区分网络ID位和子网ID位，因为我们仍然在使用 "类 "地址。任何路由器都可以看到，由于地址的前两个比特是 "10"，这是一个B类地址。因此，网络ID是16位，这意味着子网ID必须是第17到21位，从左边开始数。在这里，子网是上面强调的部分。"10010"，或子网#18。(我将在关于自定义子网的章节中更好地解释这个问题）。

**关键概念:** 为方便起见，子网掩码通常用点分十进制符号表示，但计算机使用的是二进制数，通常必须用二进制表示，以了解掩码的工作原理和它所代表的子网ID比特数。

<u>**子网掩码表示法的原理**</u>

因此，实际上，子网掩码只传递一条信息：在子网ID和主机ID之间画线的位置。您可能会想，在这种情况下，为什么要费心使用一个大的32位二进制数，而不是只指定发生除法的位号？与其随身携带255.255.248.0的子网掩码，为什么不说“在第21位之后划分IP地址”？即使设备要执行遮罩操作，它们是否可以不根据需要创建遮罩？

这是一个很好的问题。有两个历史原因：效率考虑和对非连续掩码的支持。

<u>**效率**</u>

子网掩码表达式非常有效，因为它允许路由器执行快速屏蔽操作来确定子网地址。这提高了性能；请记住，在开发这个系统时，计算机速度要慢得多。今天，这并不是一个真正的问题。

**支持非连续掩码**

RFC 950 实际上规定，在将主机 ID 中的位拆分为子网 ID 和主机 ID 时，可以将其拆分到多个位置！在上面的示例中，我们可以将 16 位拆分为 5 位用于子网 ID 和 11 位用于主机 ID，而是将其分为 2 位用于子网 ID，然后 4 位用于主机 ID，然后再将 3 位用于子网 ID，最后还有 7 位主机 ID。这将由这 16 位的子网掩码模式“11000011 10000000”表示（在网络 ID 的 16 位之后）。

为什么要这样做，而不是像以前那样将子网 ID 分成 5 位，然后将主机 ID 分成 11 位？我不知道。 J 事实上，大多数其他人也不知道。尝试以这种方式进行子网划分会使地址分配变得非常混乱。出于这个原因，虽然它在技术上是合法的，但不建议使用非连续子网掩码，并且在实践中也没有这样做。

鉴于不使用不连续的掩码，并且今天的计算机效率更高，现在经常使用仅用单个数字表示掩码的替代方法。我们可以直接说“154.71.150.42/21”，而不是指定“IP 地址为 154.71.150.42，子网掩码为 255.255.248.0”。这有时称为斜线表示法或 CIDR 表示法。它更常用于可变长度屏蔽 (VLSM) 环境，顾名思义，它也是在 CIDR 寻址方案下指定无类别地址的标准。但是，有时也会在常规子网划分讨论中看到它。

**注意：**由于这些奇怪的掩码从未真正使用过，一些资源说子网掩码必须始终是连续的，但这不是真的——最初，它是合法的，但“建议不要”。后来这种做法变得如此不受欢迎，以至于许多硬件设备都不支持它。如今，既然无类别寻址和 CIDR 已成为标准，那简直是非法的。

如果您以前从未进行过子网划分，那么尽管我们查看了一个示例，但这个主题可能会让您头晕目眩。不用担心。随着您按照本节的其余部分对子网划分更加熟悉，这一切都会变得更加清晰。还请记住，我已经包含了一个完整的部分，该部分显示了如何逐步进行子网划分，包括确定子网掩码。

###### 3.1.2.1-3-4 地址类别A、B和C的IP默认子网掩码

子网划分是将A类、B类或C类网络划分为子网的过程，我们在前面的主题中已经看到了。为了更好地理解这种 "整体的划分 "是如何完成的，值得先看看 "整体 "的A、B、C类网络在子网环境中是如何表示的。这也是有价值的，因为在有些情况下，你可能需要用子网的符号来定义一个非子网的网络。

这可能看起来是一个奇怪的概念--如果你不打算费力地创建子网，为什么你需要考虑老式的类在子网化下是如何使用的？答案是，在子网变得流行之后，大多数操作系统和网络硬件和软件都是在假定会使用子网的情况下设计的。即使你决定不采用子网，你也可能需要用子网掩码来表达你的非子网网络。

从本质上讲，非子网的A、B或C类网络可以被认为是更一般的、自定义子网的网络的 "默认情况"。具体来说，就是我们选择划分主机ID的情况，这样零位用于子网ID，所有的位都用于主机ID。我意识到，这似乎有点像语义游戏。然而，这种默认情况是我们将在下一主题中研究的更实用的子网划分的基础。

就像一直以来的情况一样，一个默认的、没有子网的A、B或C类网络的子网掩码中，用于网络ID或子网ID的每个位都是1，而主机ID位是0。当然，我们刚刚说过我们没有划分子网，所以没有子网ID位！因此，该网络的子网掩码为0。因此，这种默认情况下的子网掩码中，网络ID部分为1，主机ID部分为0。这被称为每个IP地址类别的默认子网掩码。

由于A、B和C类在八位数边界上将网络ID和主机ID分开，子网掩码在一个八位数中总是有所有的1或所有的0。因此，默认的子网掩码在用十进制符号表示时，总是有255个或0个。表51总结了每个类别的默认子网掩码；它们也在图68中显示。

​                                                  **表51: A类、B类和C类网络的默认子网掩码**

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ip-15.jpg)

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipsubnetdefaultmasks.png)

因此，A类的三个默认子网掩码分别为255.0.0.0、255.255.0.0和255.255.255.0。还有少量自定义子网也按八位字节边界划分。这些是：

255.255.0.0:，这是B类的默认掩码，但也可以是使用8位子网ID划分a类网络的自定义子网掩码（为主机ID保留16位）。

255.255.255.0：这是C类的默认子网掩码，但可以是16位的自定义a类子网ID，也可以是8位的B类子网标识。

**关键概念：**三个IP单播/广播地址类（A、B和C）中的每一个都定义了一个默认子网掩码，该掩码对类的网络ID的每一位都有一个，对其主机ID的每一位都有零位，并且没有子网ID位。三个默认子网掩码分别为255.0.0.0（A类）、255.255.0.0（B类）和255.255.255.0（C类）。

###### 3.1.2.1-3-5 IP自定义子网掩码 (部分: 1 2 3 4 )

了解什么是默认子网掩码以及它们如何工作是很重要的。然而，一个默认的子网掩码并不真正代表子网划分，因为它是我们为子网ID分配零位的情况。要进行 "真正的 "子网划分，我们必须将预先划分好的主机ID中的至少一个比特用于子网ID，如介绍子网掩码的主题中的例子所示。

由于我们有能力定制子网ID和主机ID之间的分界点的选择，以适应我们网络的需要，这有时被称为定制子网。我们在创建自定义子网时使用的子网掩码，又被称为自定义子网掩码。自定义子网掩码被网络硬件用来确定我们在网络中决定如何将子网ID与主机ID进行划分。

<u>**决定使用多少子网位**</u>
定制子网的关键决定是，从IP地址的主机ID部分取多少位放到子网ID中。回顾一下，我们网络上可能的子网数量是我们用来表达子网ID的比特数的2次方，而每个子网可能的主机数量是主机ID剩余比特数的2次方（减去2，我将在本主题的后面解释）。

因此，决定子网ID和主机ID各使用多少位代表了子网寻址的一个基本权衡。

- 从主机ID中取出的每一个比特用于子网ID，都会使网络中可能存在的子网数量增加一倍。

- 从主机ID中取出的每一个比特用于子网ID（大约）将网络中每个子网中可能存在的主机数量减半。

<u>**子网位分配选项**</u>
让我们举一两个简单的例子来看看这是如何工作的。想象一下，我们从一个网络地址为154.71.0.0的B类网络开始，由于这是B类网络，16位是网络ID（154.71），16位是主机ID。在默认情况下，没有子网（好吧，一个 "子网 "就是整个网络），共有65,534台主机。要对这个网络进行子网，我们有很多选择。

我们可以决定使用1比特作为子网ID，15比特作为主机ID。如果我们这样做，那么子网的总数是21或2：第一个子网是0，第二个是1。每个子网可用的主机数是215-2或32,766。

我们可以用2位作为子网ID，用14位作为主机ID。在这种情况下，我们将子网的数量增加一倍：我们现在有22个或4个子网。00、01、10和11（子网0、1、2和3）。但现在的主机数量只有214-2或16,382个。

我们可以使用其他任何加起来为16的位的组合，只要它们允许我们每个子网至少有2个主机。4和12，5和11，以此类推。

<u>**权衡位分配以满足子网要求**</u>

我们如何决定如何将“类”主机ID划分为子网ID和主机ID位？这是子网中的关键设计决策。我们必须根据我们对网络中存在的子网数量的要求，以及需要分配给网络中每个子网的主机的最大数量来进行选择。例如，假设我们的B类网络总共有10个子网。我们需要4位来表示这一点，因为24是16，23是8。这为主机ID留下了12位，每个子网最多有4094台主机。

然而，假设我们有20个子网。如果是这样，子网ID的4位就不够了：我们需要5位（25=32）。这意味着我们现在只有11位主机ID，每个子网最多2046台主机。实际子网示例的第2步更详细地讨论了这些决策。

现在，如果我们有20个子网，并且每个子网最多需要3000台主机，会发生什么情况？嗯，我们有一个问题。我们需要5位来表示20个不同的子网。然而，我们需要12位来表示主机ID的数字3000，这太多了17位。解决方案？我们也许可以改组我们的物理网络，这样我们只有16个。如果不能，我们需要第二个B类网络。

同样重要的是要认识到，在常规子网中，为子网ID使用多少位的选择对于整个网络来说是固定的。不能有大小不同的子网，它们必须是相同的。因此，最大子网中的主机数将决定主机ID需要多少位。这意味着，在上面的情况下，如果您有一个奇怪的配置，其中19个子网每个只有100个主机，而第20个子网有3000个主机，那么您会遇到问题。如果是这种情况，您可以通过将一个超大的子网划分为两个或多个较小的子网来轻松解决问题。创建了一个名为可变长度子网掩码（VLSM）的子网增强功能，在很大程度上消除了这一限制。

**注意：**我已经包含了一些汇总表，这些表显示了A类、B类和C类中每个子网的权衡，以及每个选项的子网掩码。

**关键概念：**子网中的基本权衡：每次向子网ID添加一个位（因此，从主机ID中减去该位），子网的数量将加倍，每个子网中主机的数量大约减半。每次从子网ID中减去一位（以及将该位添加到主机ID中）都会执行相反的操作。

<u>**IP 自定义子网掩码**</u>

**确定自定义子网掩码**

一旦我们确定了要为子网 ID 和主机 ID 分配多少位，我们就可以计算出子网掩码。现在我们了解了子网划分的工作原理，这很容易做到。我们从我们网络的适当类别的二进制默认子网掩码开始。然后，我们从该掩码中最左边的零开始，并将我们专用于子网 ID 的位数更改为 1。然后我们可以用点分十进制形式表示子网掩码。图 69 显示了如何为 C 类网络的每个子网划分选项确定自定义子网掩码，包括二进制和十进制。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipsubnetcustom.png)

​                                             **图 69：C 类网络的自定义子网掩码**

由于 C 类网络地址中有 8 个主机 ID 位，因此可以通过六种不同的方式对网络进行子网划分。每个对应一个不同的自定义子网掩码，它是通过将分配的子网 ID 位从零更改为一来创建的。

因此，以该图中的示例为例，考虑 C 类网络 200.13.94.0。原始主机 ID 中有 8 位，这为我们提供了六个不同的子网划分选项（我们不能使用 7 位或 8 位作为子网 ID，原因我们稍后会讨论。）假设我们使用其中三个作为子网 ID剩下五个用于主机 ID。要确定自定义子网掩码，我们从 C 类默认子网掩码开始：

然后我们将前三个零更改为一，以获取自定义子网掩码：

11111111 11111111 11111111 **111**00000

在点分十进制格式中，这是 255.255.255.224。

**关键概念：**一旦选择了如何划分子网，就可以简单地确定自定义子网掩码，方法是从网络的默认子网掩码开始，并将每个子网 ID 位从 0 更改为 1。

<u>**从每个子网和（可能）每个网络的子网的主机数中减去两个**</u>

关于分为子网ID和主机ID，还有一个问题需要解释。我们已经看到，在常规的“类”寻址中，我们必须从每个网络中允许的主机数中减去2。这是必要的，因为每个子网中的两个主机ID具有“特殊含义”：全零主机ID表示“此网络”，而全一主机ID是对“网络上的所有主机”的广播。这些限制也适用于子网下的每个子网，这就是为什么我们必须继续从每个子网的主机数中减去2。（这也是为什么将C类网络的8个主机ID位划分为7个用于子网ID的位和1个用于主机ID的位不仅愚蠢，而且实际上毫无意义：每个子网留下2^1-2=0个主机。这并不特别有用。）

子网ID也会出现类似的问题。当子网最初在RFC 950中定义时，该标准明确排除了使用全零和全一子网。这是因为担心路由器可能会被这些情况弄糊涂。后来的一个标准RFC 1812（IP版本4路由器的要求）在1995年取消了这一限制。所以，现代硬件现在对全零或全一子网并没有问题，但一些非常旧的硬件可能仍然对此犹豫不决。

**关键概念**：每个子网中允许的主机数是子网后剩余主机ID位数的二进制幂，减去2。之所以会减少2，是因为每个子网中的所有零和所有一主机ID都保留给两个“特殊含义”地址：**即子网本身及其本地广播地址**。**在某些实现中，子网的数量也减少了两个，因为最初不允许使用全零和全一子网ID**。

因此，您有时会看到关于排除这些情况的子网的讨论。完成此操作后，您将丢失两个潜在子网：全零子网和全一子网。如果这样做，那么为子网ID选择1位将不再有效，因为它会产生21-2=0个子网。如果需要2个子网，则必须选择2位。

**注：**在本指南中，我假设我们处理的是现代硬件，不排除所有零和所有一子网，但我确实试图在相关的地方明确说明这一事实。

###### 3.1.2.1-3-6 IP子网标识符、子网地址和主机地址 (部分：1 2 )

传统的没有子网的 "有类 "寻址的主要优势是它的简单性。即使我们已经看到，在一个单一的B类网络中如何管理数以千计的设备可能存在问题，例如，在网络内如何分配地址几乎没有什么复杂性。它们都是凑在一起的，所以在主机ID内可以使用任何位的组合（除了全零和全一，这是特殊的）。

然而，当我们进行子网时，我们在 "有类 "主机ID中创建了一个两层结构--子网ID和主机ID。这意味着我们必须更谨慎地选择设备的IP地址。从理论上讲，我们选择子网是为了对应组织内的物理网络，所以我们要以一种与物理网络结构一致的方式来分配IP地址。

**子网标识符**
一旦我们决定了要有多少个子网，我们就需要识别子网并确定子网的地址是什么。让我们先看一下子网标识符。这只是我们网络中任何一个子网的子网标识。子网的编号从0开始，一直增加到比子网的最大数量少一个，这是子网ID中多少位的函数。(如果按照RFC 950的规定，排除全零和全一的子网ID，那么第一个子网标识符就是1）。

当然，我们可能不需要理论上可以定义的所有子网。例如，如果我们有20个子网，我们需要5位的子网标识符，理论上最多可以有32个子网。我们将只使用子网0到19；20到31将被保留给未来使用。这些子网可以用十进制表示（0、1、2......至19），也可以用二进制表示（00000、00001、00010......至10011）。

<u>**子网地址**</u>
对于每个子网，我们也可以确定子网地址。要做到这一点，我们从整个网络的IP地址开始，在 "类 "主机ID字段（8位、16位或24位）中回忆所有的零。然后，我们将特定子网的子网标识符插入指定的子网位。

作为一个例子，让我们回到图66所示的B类网络的子网划分，154.71.0.0，。我们在那里使用了五个子网ID位。我们从下面的网络IP地址开始，子网ID位突出显示。

​        10011010 01000111 00000000 00000000
要找到例如11号子网的地址，我们要用 "01011 "来代替这些位，让主机ID位为零。

​        10011010 01000111 01011000 00000000
然后，我们可以将其从二进制形式转换为点分十进制，结果是子网地址为154.71.88.0。

**关键概念:** 一个子网的子网标识符只是其子网ID。一个子网的子网地址是通过将其子网ID代入整个网络地址的子网位来确定的。

<u>**子网地址公式**</u>

在观察子网寻址时注意到，当你依次替换子网ID时，一个模式立即变得清晰可见。第一个子网地址总是整个网络的地址，因为子网ID都是0。然后，第二个子网地址以十进制的形式，通过在其中一个八位数上添加一个特定的2的倍数来找到。然后通过在第二个地址上加上这个相同的数字来找到第三个地址，以此类推。

事实上，我意识到每个子网地址的十进制值可以用一个公式来表示，基于原始网络的等级和被用于子网ID的比特数。例如，考虑一个总体地址为 "x.y.0.0 "的B类网络（对于我们的目的，"x "和 "y "是什么并不重要）。现在，假设我们使用两个比特作为子网的ID。我们这里有四个子网地址。

1. 0号子网的地址将与网络地址相同：x.y.0.0.0。

2. 1号子网的地址将通过用 "01 "代替第三个八位数的前两个比特来找到。这样得到的地址是 "x.y.01000000.0000000"，或直十进制的 "x.y.64.0"。

3. 2号子网的地址是用 "10 "代替子网ID位，所以它是 "x.y.10000000.0000000"，或直十进制的 "x.y.128.0"。

4. 子网#3的地址将是 "x.y.192.0"。

因此，在这种情况下，N号子网的公式是 "x.y.N**64.0"。如果我们对子网使用5位，那么公式就是 "x.y.N**8.0"；正如我们在上面看到的，网络154.71.0.0中的子网#11的子网地址是154.71.88.0。我在子网划分汇总表中显示了所有子网ID和主机ID大小组合的公式。这些公式一开始可能有点混乱，但一旦你对子网划分更加熟悉，它们就能真正节省时间。

<u>**每个子网内的主机地址**</u>

一旦我们知道了特定子网的子网地址，分配 IP 地址就很容易了。我们只需将值插入剩余的主机 ID 位。当然，我们会跳过全零值，因此子网中的第一个主机的主机 ID 都是零，除了最右边的位位置是一个。然后下一个主机除了末尾的“10”（十进制的两位）之外全为零。我们可以一直做到这一点，直到比全一的值小一。同样，我们然后将每个 IP 地址从二进制转换为十进制。

更多示例肯定会帮助您更好地理解这些地址是如何确定的。这需要我们处理大量的细节和大量的二进制数。您可以在有关实际子网划分的部分中找到这些详细信息。

###### 3.1.2.1-3-7 A类、B类和C类网络的IP子网划分汇总表(部分：1 2 3 4 )

由于如何对A类、B类和C类网络进行子网划分只有几个选项，我在下面三个汇总表中列出了每个类别的选项。表52、表53和表54。这些表格可以帮助你快速决定子网ID和主机ID要用多少位，然后再决定它们的子网掩码是多少。它们也很好地总结了我们在本节中讨论的内容。

每张表的每一行都显示了该类的一个可能的子网选项，包括子网ID和主机ID的每个比特数，以及基于比特数的子网和主机的数量。然后，我以二进制和十进制的形式展示了子网掩码，以及CIDR的符号。最后，我包括在每个选项下计算每个子网的地址的公式。

<u>**关于三个子网概要表的说明**</u>
关于这些表格，有一些额外的解释说明。

- 每个网络的子网数量假设允许全零和全一的子网。如果不是，你必须从这些数字中减去2；这也意味着子网ID只使用一个比特的选项变得无效，子网地址公式不再如图所示。

- 每个子网的主机数确实不包括全零和全一的情况，所以它是主机ID位数的2次方，减去2。

- 每个表格的第一行显示了 "默认 "情况，即子网位数为零，因此子网掩码是该类的默认子网掩码。

- 在除了默认情况以外的所有选项的子网掩码中，为了清楚起见，我已经突出了子网掩码中与子网ID相对应的部分。这是对二进制掩码的每一个单独的位，以及掩码的点状十进制表示法中发现子网ID部分的每个八位数所做的。

- 你会看到，并非所有的划分在现实世界中都有很大的意义......尽管你可能会感到惊讶。例如，乍一看似乎很傻，我们可能想把B类主机ID的14位分配给子网ID，而把2位留给主机ID--什么样的真实网络有16384个子网，每个子网有2个主机？然而，一些较大的互联网服务公司在设置路由器之间的连接时，或者在其核心网络和客户之间的连接时，可能确实需要成千上万的小子网。

- 每个表格最后一列的子网地址公式显示了子网#N的地址（编号从0到比最大子网数少1）.请参阅逐步划分子网部分的步骤#4的结尾，以全面解释这些公式如何工作。

***Class A\***

​                                        **Table 52: Subnetting Summary Table For Class A Networks**

| **# of Subnet ID Bit** | **# of Host ID Bits** | **# of Subnets Per Network** | **# of Hosts Per Subnet** | **Subnet Mask****(Binary / Dotted Decimal)**                               | **Subnet Mask (Slash/ CIDR Notation)** | **Subnet Address #N Formula (N=0, 1, … # of Subnets-1)** |
| ---------------------- | --------------------- | ---------------------------- | ------------------------- | -------------------------------------------------------------------------- | -------------------------------------- | -------------------------------------------------------- |
| **0 (Default)**        | **24**                | 1                            | 16,277,214                | 11111111.00000000.0000000.00000000255.0.0.0                                | /8                                     | —                                                        |
| **1**                  | **23**                | 2                            | 8,388,606                 | 11111111.**1**0000000.0000000.00000000255.**128**.0.0                      | /9                                     | x.N*128.0.0                                              |
| **2**                  | **22**                | 4                            | 4,194,302                 | 11111111.**11**000000.0000000.00000000255.**192**.0.0                      | /10                                    | x.N*64.0.0                                               |
| **3**                  | **21**                | 8                            | 2,097,150                 | 11111111.**111**00000.00000000.00000000255.**224**.0.0                     | /11                                    | x.N*32.0.0                                               |
| **4**                  | **20**                | 16                           | 1,048,574                 | 11111111.**1111**0000.00000000.00000000255.**240**.0.0                     | /12                                    | x.N*16.0.0                                               |
| **5**                  | **19**                | 32                           | 524,286                   | 11111111.**11111**000.00000000.00000000255.**248**.0.0                     | /13                                    | x.N*8.0.0                                                |
| **6**                  | **18**                | 64                           | 262,142                   | 11111111.**111111**00.00000000.00000000255.**252**.0.0                     | /14                                    | x.N*4.0.0                                                |
| **7**                  | **17**                | 128                          | 131,070                   | 11111111.**1111111**0.00000000.00000000255.**254**.0.0                     | /15                                    | x.N*2.0.0                                                |
| **8**                  | **16**                | 256                          | 65,534                    | 11111111.**11111111**.00000000.00000000255.**255**.0.0                     | /16                                    | x.N.0.0                                                  |
| **9**                  | **15**                | 512                          | 32,766                    | 11111111.**11111111**.**1**0000000.00000000255.**255**.**128**.0           | /17                                    | x.N/2.(N%2)*128.0                                        |
| **10**                 | **14**                | 1,024                        | 16,382                    | 11111111.**11111111**.**11**000000.00000000255.**255**.**192**.0           | /18                                    | x.N/4.(N%4)*64.0                                         |
| **11**                 | **13**                | 2,048                        | 8,190                     | 11111111.**11111111**.**111**00000.00000000255.**255**.**224**.0           | /19                                    | x.N/8.(N%8)*32.0                                         |
| **12**                 | **12**                | 4,096                        | 4,094                     | 11111111.**11111111**.**1111**0000.00000000255.**255**.**240**.0           | /20                                    | x.N/16.(N%16)*16.0                                       |
| **13**                 | **11**                | 8,192                        | 2,046                     | 11111111.**11111111**.**11111**000.00000000255.**255**.**248**.0           | /21                                    | x.N/32.(N%32)*8.0                                        |
| **14**                 | **10**                | 16,384                       | 1,022                     | 11111111.**11111111**.**111111**00.00000000255.**255**.**252**.0           | /22                                    | x.N/64.(N%64)*4.0                                        |
| **15**                 | **9**                 | 32,768                       | 510                       | 11111111.**11111111**.**1111111**0.00000000255.**255**.**254**.0           | /23                                    | x.N/128.(N%128)*2.0                                      |
| **16**                 | **8**                 | 65,536                       | 254                       | 11111111.**11111111**.**11111111**.00000000255.**255**.**255**.0           | /24                                    | x.N/256.N%256.0                                          |
| **17**                 | **7**                 | 131,072                      | 126                       | 11111111.**11111111**.**11111111**.**1**0000000255.**255**.**255**.**128** | /25                                    | x.N/512.(N/2)%256.(N%2)*128                              |
| **18**                 | **6**                 | 262,144                      | 62                        | 11111111.**11111111**.**11111111**.**11**000000255.**255**.**255**.**192** | /26                                    | x.N/1024.(N/4)%256.(N%4)*64                              |
| **19**                 | **5**                 | 524,288                      | 30                        | 11111111.**11111111**.**11111111**.**111**00000255.**255**.**255**.**224** | /27                                    | x.N/2048.(N/8)%256.(N%8)*32                              |
| **20**                 | **4**                 | 1,048,576                    | 14                        | 11111111.**11111111**.**11111111**.**1111**0000255.**255**.**255**.**240** | /28                                    | x.N/4096.(N/16)%256.(N%16)*16                            |
| **21**                 | **3**                 | 2,097,152                    | 6                         | 11111111.**11111111**.**11111111**.**11111**000255.**255**.**255**.**248** | /29                                    | x.N/8192.(N/32)%256.(N%32)*8                             |
| **22**                 | **2**                 | 4,194,304                    | 2                         | 11111111.**11111111**.**11111111**.**111111**00255.**255**.**255**.**252** | /30                                    | x.N/16384.(N/64)%256.(N%64)*4                            |

***Class B\***

​                                   **Table 53: Subnetting Summary Table For Class B Networks**

| **# of Subnet ID Bit** | **# of Host ID Bits** | **# of Subnets Per Network** | **# of Hosts Per Subnet** | **Subnet Mask****(Binary / Dotted Decimal)**                       | **Subnet Mask (Slash/ CIDR Notation)** | **Subnet Address #N Formula (N=0, 1, … # of Subnets-1)** |
| ---------------------- | --------------------- | ---------------------------- | ------------------------- | ------------------------------------------------------------------ | -------------------------------------- | -------------------------------------------------------- |
| **0 (Default)**        | **16**                | 1                            | 65,534                    | 11111111.11111111.00000000.00000000255.255.0.0                     | /16                                    | --                                                       |
| **1**                  | **15**                | 2                            | 32,766                    | 11111111.11111111.**1**0000000.00000000255.255.**128**.0           | /17                                    | x.y.N*128.0                                              |
| **2**                  | **14**                | 4                            | 16,382                    | 11111111.11111111.**11**000000.00000000255.255.**192**.0           | /18                                    | x.y.N*64.0                                               |
| **3**                  | **13**                | 8                            | 8,190                     | 11111111.11111111.**111**00000.00000000255.255.**224**.0           | /19                                    | x.y.N*32.0                                               |
| **4**                  | **12**                | 16                           | 4,094                     | 11111111.11111111.**1111**0000.00000000255.255.**240**.0           | /20                                    | x.y.N*16.0                                               |
| **5**                  | **11**                | 32                           | 2,046                     | 11111111.11111111.**11111**000.00000000255.255.**248**.0           | /21                                    | x.y.N*8.0                                                |
| **6**                  | **10**                | 64                           | 1,022                     | 11111111.11111111.**111111**00.00000000255.255.**252**.0           | /22                                    | x.y.N*4.0                                                |
| **7**                  | **9**                 | 128                          | 510                       | 11111111.11111111.**1111111**0.00000000255.255.**254**.0           | /23                                    | x.y.N*2.0                                                |
| **8**                  | **8**                 | 256                          | 254                       | 11111111.11111111.**11111111**.00000000255.255.**255**.0           | /24                                    | x.y.N.0                                                  |
| **9**                  | **7**                 | 512                          | 126                       | 11111111.11111111.**11111111**.**1**0000000255.255.**255**.**128** | /25                                    | x.y.N/2.(N%2)*128                                        |
| **10**                 | **6**                 | 1,024                        | 62                        | 11111111.11111111.**11111111**.**11**000000255.255.**255**.**192** | /26                                    | x.y.N/4.(N%4)*64                                         |
| **11**                 | **5**                 | 2,048                        | 30                        | 11111111.11111111.**11111111**.**111**00000255.255.**255**.**224** | /27                                    | x.x.N/8.(N%8)*32                                         |
| **12**                 | **4**                 | 4,096                        | 14                        | 11111111.11111111.**11111111**.**1111**0000255.255.**255**.**240** | /28                                    | x.y.N/16.(N%16)*16                                       |
| **13**                 | **3**                 | 8,192                        | 6                         | 11111111.11111111.**11111111**.**11111**000255.255.**255**.**248** | /29                                    | x.y.N/32.(N%32)*8                                        |
| **14**                 | **2**                 | 16,384                       | 2                         | 11111111.11111111.**11111111**.**111111**00255.255.**255**.**252** | /30                                    | x.y.N/64.(N%64)*4                                        |

***Class C\***

​                                    **Table 54: Subnetting Summary Table For Class C Networks**

| **# of Subnet ID Bit** | **# of Host ID Bits** | **# of Subnets Per Network** | **# of Hosts Per Subnet** | **Subnet Mask****(Binary / Dotted Decimal)**               | **Subnet Mask (Slash/ CIDR Notation)** | **Subnet Address #N Formula (N=0, 1, … # of Subnets-1)** |
| ---------------------- | --------------------- | ---------------------------- | ------------------------- | ---------------------------------------------------------- | -------------------------------------- | -------------------------------------------------------- |
| **0 (Default)**        | **8**                 | 1                            | 254                       | 11111111.11111111.11111111.00000000255.255.255.0           | /24                                    | —                                                        |
| **1**                  | **7**                 | 2                            | 126                       | 11111111.11111111.11111111.**1**0000000255.255.255.**128** | /25                                    | x.y.z.N*128                                              |
| **2**                  | **6**                 | 4                            | 62                        | 11111111.11111111.11111111.**11**000000255.255.255.**192** | /26                                    | x.y.z.N*64                                               |
| **3**                  | **5**                 | 8                            | 30                        | 11111111.11111111.11111111.**111**00000255.255.255.**224** | /27                                    | x.y.z.N*32                                               |
| **4**                  | **4**                 | 16                           | 14                        | 11111111.11111111.11111111.**1111**0000255.255.255.**240** | /28                                    | x.y.z.N*16                                               |
| **5**                  | **3**                 | 32                           | 6                         | 11111111.11111111.11111111.**11111**000255.255.255.**248** | /29                                    | x.y.z.N*8                                                |
| **6**                  | **2**                 | 64                           | 2                         | 11111111.11111111.11111111.**111111**00255.255.255.**252** | /30                                    | x.y.z.N*4                                                |

###### 3.1.2.1-3-8 IP变长子网屏蔽（VLSM） (Part: 1 2 3 )

传统的子网掩码用更灵活的三级方法代替了两级 IP 寻址方案。由于它允许网络管理员根据主机在物理网络中的连接方式为主机分配 IP 地址，因此子网划分对于维护大型 IP 网络的人员来说是一个真正的突破。虽然它有自己的弱点，但仍有改进的余地。传统子网划分的主要弱点实际上是子网 ID 仅代表 IP 地址如何解释和用于路由的一个附加层次结构。

**单级子网的问题**

看着子网划分并说“什么，只有一个额外的级别”似乎“贪婪”？ J 然而，在大型网络中，将我们的整个网络划分为仅一级子网的需要并不代表我们的 IP 地址块的最佳使用。此外，我们已经看到，由于子网 ID 在整个网络中的长度相同，如果我们的子网中的主机数量非常不同，我们就会遇到问题——必须根据具有最大数量的子网来选择子网 ID主机数量，即使大多数子网的数量要少得多。即使在小型网络中，这也是低效的，并且可能导致需要使用额外的寻址块，同时浪费每个块中的许多地址。

例如，考虑一家拥有 C 类网络的相对较小的公司，201.45.222.0/24。他们的网络中有六个子网。前四个子网（S1、S2、S3 和 S4）相对较小，每个子网仅包含 10 个主机。但是，其中一个（S5）是他们的生产车间，有 50 台主机，最后一个（S6）是他们的开发和工程组，有 100 台主机。

因此，所需的主机总数为 196。如果没有子网划分，我们的 C 类网络中有足够的主机来处理它们。但是，当我们尝试进行子网划分时，我们遇到了一个大问题。为了有六个子网，我们需要使用 3 位作为子网 ID。这仅留下 5 位用于主机 ID，这意味着每个子网都具有相同的 30 台主机容量，如图 70 所示。这对于较小的子网来说已经足够了，但对于较大的子网来说还不够。传统子网划分的唯一解决方案，除了改组物理子网，是为两个大子网获取另一个 C 类块，并为四个小子网使用原始的。但这很昂贵，并且意味着浪费数百个 IP 地址！

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipvlsmconventionalsplit.png)

​                                                              **图 70：C 类 (/24) 网络分成八个常规子网**

使用传统的子网划分，所有子网的大小必须相同，这会在某些子网比其他子网大得多时产生问题。对比图 71。

**示例：使用VLSM的多级子网**

VLSM子网的方式与常规子网相同；它只是因为子网层次结构的额外级别而更加复杂。您将网络的初始子网划分为大型子网，然后根据需要进一步细分一个或多个子网。您可以将位添加到每个“子子网”和“子子网子网”的子网掩码中，以反映其较小的大小。在VLSM中，无类寻址的斜杠符号通常用来代替二进制子网掩码。VLSM在工作方式上与CIDR非常相似，所以我将使用它。

注意：在继续下面的VLSM示例之前，有一个建议：如果您对基本子网的工作方式感到不满意，那么您可能需要先阅读有关实际子网的部分。相信我。

让我们再来看看上面的例子，看看如何使用VLSM使一切都适合。我们从C类网络201.45.222.0/24开始。然后我们按如下方式创建三个子网（有关过程的说明，请参见图72）：

1. 我们首先使用一个位作为子网ID，为主机ID保留7个位，从而创建一个初始子网。这给了我们两个子网：201.45.222.0/25和201.45.222.128/25。每个子网最多可以有126个主机。我们为子网S6及其100台主机预留了其中的第一台。

2. 我们将第二个子网201.45.222.128/25进一步分为两个子网。我们通过从主机ID中剩下的7位中取一位来实现这一点。这将为我们提供子网201.45.222.128/26和201.45.222.192/26，每个子网可以有62台主机。我们为子网S5及其50台主机预留了其中的第一台。

3. 我们将第二个子网201.45.222.192/26进一步分为四个子网。我们从主机ID中剩下的6个字节中取2位。这给了我们四个子网，每个子网最多可以有14个主机。这些用于S1、S2、S3和S4。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipvlsm.png)

​                                                                           **图72：可变长度子网屏蔽（VLSM）示例**

此图说明了文本中描述的C类（/24）网络的示例，该网络使用三个分层级别进行划分。它首先分为两个子网；一个子网分为两个子网；一个子网分为四个子网。生成的六个子网以黑色粗边框显示，最大容量为126、62、14、14和14台主机。

好的，我确实选择了这个例子中的数字，这样它们就可以完美地计算出来，但你会明白的。VLSM极大地提高了子网的灵活性和效率。为了使用它，必须使用支持VLSM路由协议的路由器。VLSM还需要更加注意如何构造路由表，以确保在如何解释网络中的地址时没有歧义。

正如我之前所说，VLSM在概念上与执行无类寻址和路由（CIDR）的方式类似。VLSM和CIDR之间的差异主要是焦点之一。VLSM处理私有组织中单个网络的子网。CIDR将我们刚才在VLSM中看到的概念作为一个整体应用于互联网，通过将单层“类”层次结构替换为多层层次结构来改变组织网络的分配方式。

###### 3.1.2.1-4 IP子网划分: 实用子网设计和地址确定实例

当教育工作者问学生在学习网络时，他们认为什么是最令人困惑的方面时，许多人说这是IP地址子网。虽然子网在概念上并没有那么困难，但由于需要对二进制数进行操作，这可能有点令人难以置信。许多人理解子网背后的思想，但发现很难遵循将网络子网化所需的实际步骤。

因此，尽管我在上一节中详细解释了子网背后的概念，但我觉得有必要再看一节，逐步了解如何执行自定义子网。本节将子网划分为五个相对简单的阶段，包括确定需求、决定子网ID和主机ID使用多少位的设计决策，然后确定重要数字，如子网掩码、子网地址和主机地址。

我在本节的重点是展示子网的实际“如何”。这里的主题通过使用B类和C类示例网络的两个示例向您展示了子网是如何完成的，我明确地展示了所有内容是如何计算的。这意味着该部分有点“数字密集”。此外，我尽量不重复上一节中讨论的概念性问题，尽管确实存在一定程度的重叠。总的来说，如果您根本不熟悉子网的工作原理，那么您需要先阅读该部分。我在适当的时候会提到该部分的主题，特别是汇总表。顺便说一句，这里我只讨论传统的子网，而不是VLSM。

对于已经熟悉基本知识但只想回顾在子网中执行的步骤的人来说，本节可以作为一个有用的子网复习或总结。同样，请记住，子网基于旧的“类”IP寻址方案，而今天的Internet使用CIDR是无类的。

**背景信息：**如果你不熟悉二进制数、二进制到十进制的转换和屏蔽，并且你没有采纳我在前面几节中的建议，使用计算数学的背景解释来复习这些概念，那么你现在真的想这么做。

**注意**：如果在阅读本节时您发现自己想要进行二进制到十进制的转换或二进制数学，请记住大多数版本的Windows（和许多其他操作系统）都有一个包含科学函数的计算器程序。

###### 3.1.2.1-4-1 IP子网步骤1：需求分析（第1 2部分）

当您构建或升级整个网络时，第一步不是购买硬件，或者制定协议，甚至设计。它是需求分析，是确定网络需要做什么的过程。如果没有这一基础，您可能会面临实施一个可能与您的设计完美匹配但不能满足组织需求的网络的风险。同样的规则也适用于子网。在查看主机地址和子网掩码的详细信息之前，我们必须决定如何对网络进行子网划分。为此，我们必须了解网络的要求。

<u>**关键子网划分要求**</u>

分析子网的网络需求并不困难，因为我们只需要考虑几个问题。由于需求分析通常通过提问来完成，下面列出了分析子网需求时最重要的问题：

- 我们的IP地址块是什么级别的？

- 今天网络上有多少物理子网？（“物理子网”通常指LAN上的广播域；由路由器限定的物理网络上的一组主机。）

- 我们预计在久的将来会增加更多物理网络吗？如果会，会增加多少？

- 目前，我们最大的子网中有多少台主机？

- 在不久的将来，我们预计在最大的子网中有多少主机？

第一个问题很重要，因为子网中的所有内容都是围绕a类、B类或C类网络进行划分的，所以我们需要知道我们正在处理的是哪个网络。如果我们正在从头开始设计一个网络，并且还没有a类、B类或C类块，那么我们将根据组织的大致规模确定需要哪一个。然后，我们需要确定两个关键数字：我们有多少个物理子网，以及每个子网的最大主机数。

<u>**在需求分析期间评估未来需求**</u>

我们不仅需要分析当前网络的上述需求，还需要分析近期的需求。这两个数字的当前值代表了当前网络的设计方式。然而，只为现在设计并不是一个好主意。

假设我们现在的网络中正好有四个子网。理论上，我们只能使用两位作为子网ID，因为22是4。然而，如果我们的公司发展迅速，这将是一个糟糕的选择。当我们需要添加第五个子网时，我们会遇到问题！

同样，考虑子网中主机数量的增长。如果当前最大的子网有60台主机，则不需要6a位作为主机ID，因为这将限制为62台主机。您可以将大型子网划分为较小的子网，但这可能意味着不必要的额外工作。

那么，什么是“近期”？这个术语必然是模糊的，因为它取决于组织希望展望未来的多远。一方面，如果你有足够的IP地址，规划几年的增长是有意义的。另一方面，你不想计划得太远，因为短期内的变化可能会导致你完全重新设计你的网络。

**关键概念**：要成功地将网络分为子网，您必须首先了解网络的要求。要确定的最重要参数是所需的子网数量和每个子网所需的最大主机数量。数字不仅应基于当前的需求，还应基于近期的需求。

###### 3.1.2.1-4-2 IP子网步骤2：关键设计权衡：划分网络地址主机位（部分：1 2 3）

在我们完成简要的需求分析后，我们应该知道为了对网络进行子网划分而必须具备的两个关键参数：网络所需的子网数量，以及每个子网的最大主机数量。在使用这些数字来设计我们的子网网络时，我们将面临子网的关键设计决策：如何将 "类 "主机ID中的8、16或24位分为子网ID和主机ID。

**决定在子网ID和主机ID中使用多少个比特**

换句话说，我们需要决定从主机ID中 "偷 "出多少位来用于子网ID。正如我在关于自定义子网掩码的主题中所介绍的，选择这个数字的基本权衡如下。

- 从主机ID中提取的每一个比特用于子网ID，都会使网络中可能存在的子网数量增加一倍。
- 从主机ID中抽取的每一位作为子网ID（大约）将网络中每个子网中可能存在的主机数量减半。

对于C类网络来说，有六种可能的方式可以做出这个决定，如图73所示。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipsubnettradeoff.png)

​                                                          **图73: C类网络的子网设计权衡**

位与子网和主机的数量之间的关系如下。

- **网络中允许的子网数量是子网ID比特数的2次方。**
- **每个子网允许的主机数量是主机ID比特数的2次方，减去2。**

我们从每个子网的主机数中减去2，以排除主机ID为全零或全一的 "特殊含义 "情况。正如我在关于自定义子网的专题中所解释的，这种排除法最初也适用于子网ID，但在较新的系统中已不再适用。

现在，为了选择使用多少位的子网，我们可以使用试验和错误。我的意思是，我们可以首先尝试计算子网和主机的数量，当我们使用一个比特作为子网的ID，其余的留给主机的ID。然后，我们可以尝试用两个比特的子网ID，然后再尝试用三个比特，以此类推。然而，这样做是很愚蠢的，它很耗费时间，而且使我们难以选择最佳方案。有一个更简单的方法：我们可以使用子网划分汇总表。它们可以让我们查看所有的选项，通常可以立即看到最适合我们的选项。

**C类子网划分设计实例**

让我们举个例子。假设我们有一个C类网络，基本地址为211.77.20.0，总共有7个子网。每个子网的最大主机数是25。看一下C类的子网划分汇总表，答案马上就清楚了：我们需要3位的子网ID。为什么？这允许我们有8个子网，每个子网有30个主机。如果我们试图选择2位，我们就无法定义足够的子网（只有4个）。如图74所示，如果我们为子网ID选择4位，那么我们每个子网只能有14台主机。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipsubnettradeoffclassc.png)

​                                            **图74: C类子网的例子。一个 "简单的决定"**

在这个特殊的例子中，需要7个子网，最大的子网需要25个主机，只有一个子网ID大小的选择能满足要求。

**B类子网划分设计实例**

在某些情况下，特别是对于较大的网络，我们可能有多种选择。考虑一个更有趣的例子，较大的B类网络166.113.0.0，我们总共有15个子网，最大的子网有450个主机。检查B类网络的子网汇总表表明有四个可接受的选项，如图75所示。

  ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipsubnettradeoffclassb.png)

​                    **图75: B类子网划分实例。一个更困难的决定**

这个B类网络至少需要15个子网，每个子网必须允许多达450个主机。三个子网ID位太少了，8位意味着每个子网只有254个主机，这是不够的，但是有四个可接受的选项，所以我们必须明智地选择。J

在这四个中，子网的数量都等于15或更多，每个子网的主机数量超过450。那么，我们应该选择哪个选项呢？通常情况下，我们要在中间选一个。如果我们使用4位的子网ID，这就只能给我们提供最多16个子网，这就限制了子网数量的增长，因为我们已经有15个子网。同样的情况也适用于选择7位的子网ID，因为我们现在已经有450个主机在一个子网中，这限制了我们510个。因此，我们在这里可能想要5位或6位。如果我们预期最大的子网中的主机数量会有更多的增长，我们会选择5位；如果我们预期子网的数量会有更多的增长，我们会选择6位。如果不确定，可能最好是假设每个子网的主机数量增长更多，所以这里我们会选择5比特。

相反的问题也可能发生：你可能处于这样一个位置：表中没有任何行可以匹配。例如，如果我们的C类例子在最大的子网中有35个主机，而不是25个，我们就不走运了：没有任何子网ID和主机ID大小的组合可以使用。在我们的B类例子中也是如此，如果我们在那个大子网中有4500台主机而不是450台。在这种情况下，我们必须把大子网分成一个更小的子网，使用一个以上的IP地址块，或者升级到一个更大的地址块。

关键概念: 如果有一个以上的子网ID和主机ID大小的组合可以满足要求，尽量选择一个 "中庸 "的选项，最好能预测到未来的增长要求。如果没有一个组合能满足要求，那么要求就必须改变!

###### 3.1.2.1-4-3 IP子网步骤3：确定自定义子网掩码（部分：1 2）

一旦我们决定了多少位用于子网标识，多少位用于主机标识，我们就可以为我们的网络确定自定义子网掩码。现在，不要向我跑来躲避。很多人一提到子网掩码就眼花缭乱，但一旦我们在步骤2中做了设计决定的功课，就会发现它真的非常简单。事实上，有两种方法可以做到这一点；一种比另一种工作量小，但它们都很容易。我本来想把它们称为 "困难 "的方法和 "容易 "的方法，但现在我把它们称为 "容易 "和 "更容易"。

**计算自定义子网掩码**

让我们从 "简单 "的方法开始，根据我们已经掌握的网络信息，以二进制形式确定子网掩码，然后将掩码转换成十进制。为了恢复你的记忆并指导这个过程，请记住：子网掩码是一个32位的二进制数字，其中1代表网络ID或子网ID的每一位，而0代表主机ID的每一位。

**C类自定义子网掩码计算实例**

请回到上一主题中的C类例子。我们决定使用3个比特作为子网ID，留下5个比特作为主机ID。下面是我们将遵循的步骤，以确定该网络的自定义子网掩码（如图76所示）。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipsubnetmaskclassc.png)

​                                            **图76: 确定C类网络的自定义子网掩码**

1. 确定默认子网掩码：A、B和C类都有一个默认的子网掩码，它是子网划分前的网络子网掩码。它的每个网络ID位都是1，每个主机ID位都是0。对于C类，子网掩码是255.255.255.0。在二进制中，这就是。

​                 11111111 11111111 11111111 00000000

1. 将子网位中最左边的0改为1。我们已经决定使用3位子网ID。子网掩码中的每个网络ID或子网ID位都必须是1。在默认的子网掩码中，网络ID位已经是1了，所以，我们把默认子网掩码中最左边的3个0位从0改为1，如下图所示。这样，我们的网络就有了以下的自定义子网掩码。
2. 将子网掩码转换为点状十进制符号。我们把子网掩码中的每一个八位数转换为十进制。其结果是我们的自定义子网掩码，我们通常看到的形式是：255.255.255.224。
3. 用 "斜线符号 "表示子网掩码。另外，我们还可以用 "斜线符号 "来表达子网掩码。这只是一个斜线，后面跟着子网掩码中的1的数量。255.255.255.224相当于"/27"。

**B类自定义子网掩码的计算实例**

现在，让我们用B类网络（166.113.0.0）做同样的例子，子网标识为5位（这次叙述的内容少一点，见图77）。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipsubnetmaskclassb.png)

​                                                 **图77: 确定B类网络的自定义子网掩码**

1. 确定默认子网掩码。对于B类网络，子网掩码是255.255.0.0，用二进制表示。

​                 11111111 11111111 00000000 00000000

​            2. 确定默认子网掩码。对于B类网络，子网掩码是255.255.0.0，用二进制表示。

​                  11111111 11111111 **11111**000 00000000

​            3. 将子网掩码转换为点状十进制符号。我们把子网掩码中的每个八位数转换成十位数，得到一个自定义子网掩码    255.255.248.0。

4. 用 "斜线符号 "表达子网掩码。我们可以把子网掩码255.255.248.0表示为"/21"，因为它是21个1后跟11个0。换句话说，它的前缀长度是21。

**使用子网表确定自定义子网掩码**

现在，还有什么能比这更简单的呢？嗯，你可以简单地参考子网划分汇总表。找到相应类别的表格，然后找到你在上一步选择的与你要使用的子网ID位数相匹配的行。你可以在那里看到匹配的子网掩码。

(嘿，知道如何自己做是件好事！）。你可能不一定有表格可以参考！)

###### 3.1.2.1-4-4 IP子网步骤4：确定子网标识符和子网地址（部分：1 2 3 4 5）

分配给我们网络的网络ID适用于整个网络。这包括所有的子网和所有子网中的所有主机。然而，每个子网都需要用一个独特的子网标识符或子网ID来识别，因此它可以与网络中的其他子网区分开来。当然，这就是我们在子网划分中从主机ID位中提取的子网ID位的目的。在我们确定了每个子网之后，我们需要确定每个子网的地址，这样我们就可以用它来为主机分配具体的IP地址。

这是子网划分中的另一个步骤，其实并不难理解或做。理解如何确定子网ID和子网地址的关键是始终以二进制形式工作，然后再转换为十进制。我们还将研究一种直接用十进制确定地址的 "捷径"，这种方法更快，但概念上不那么简单。

让我们直接进入我们的例子，看看子网ID和地址是如何确定的。我们对子网进行编号，从0开始，然后是1、2、3，以此类推，直到我们需要的最高子网ID。

**注意：**在这个描述中，我假设我们将使用全零和全一的子网编号。在最初的RFC 950子网系统中，没有使用这两个子网，这就改变了下面的大部分计算方法。请看这里的解释。

我们确定子网ID和地址的方法如下

1. 子网ID。这只是子网编号，可以用二进制或十进制形式表示。

2. 子网地址。这是将网络的地址作为一个整体，并将（二进制）子网ID代入子网ID位而形成的地址。我们需要用二进制来做，但只适用于有子网ID位的八位数；只有网络ID位或只有主机ID位的八位数就不用管了。

看起来很复杂？让我们回到我们的例子中去，我们会发现其实并不复杂。

<u>**C类子网ID和地址的确定示例**</u>

回顾我们的C类网络，211.77.20.0。网络地址的二进制是：。

11010011 01001101 00010100 00000000
我们在子网中使用3位作为子网ID，留下5位作为主机ID。现在让我们看看网络地址，其中的子网位用粗体表示。

11010011 01001101 00010100 00000000
这些是我们用每个子网的子网ID所替代的位。注意，由于前三个八位字节包含网络ID位，而网络ID对每个子网都是一样的，所以它们永远不会改变。我们甚至不需要以二进制的形式来看待它们，尽管为了清楚起见我们会这样做。

下面是我们确定子网ID和地址的方法，还是从0开始（见图78）。

0号子网的子网ID为0，或二进制的000。为了找到地址，我们从二进制的网络地址开始，用 "000 "代替子网ID位。天哪，这些位子已经全部是0了！这意味着0号网的地址已经是0了。这意味着0号子网的地址与整个网络的地址相同：211.77.20.0。

情况总是这样：0号子网的地址总是与网络的地址相同。

- 1号子网的子网ID是十进制的1，或二进制的001。为了找到地址，我们用 "001 "代替子网ID位，得出以下结果。
- 11010011 01001101 00010100 00100000
- 转换为十进制，我们得到211.77.20.32。
- 2号子网的子网ID为2，或二进制的010。为了找到它的地址，我们用 "010 "代替子网ID位，得到。
- 11010011 01001101 00010100 01000000
- 这就是211.77.20.64的二进制。
- 3号子网的子网ID为011。我们可以看到，地址的前三个八位数总是211.77.20。这里的最后一个八位数是 "01100000"，在十进制中是96，所以整个地址是211.77.20.96

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipsubnetaddressesclassc.png)

​                                                                          **图78: 确定C类网络的子网地址**

该图显示了当我们在C类网络中使用3比特作为子网ID时，所创建的8个可能的子网中的每个。二进制子网ID被简单地替换为子网位，并将产生的32位数字转换为点阵十进制形式。

在这里开始看到一个模式了吗？是的，任何子网的地址都可以通过在前一个子网的最后一个八位数上添加32来找到。这种模式适用于所有的子网选择；增量取决于我们对子网ID使用多少位。这里，增量是32，也就是25；5是我们取了3个子网ID位后剩下的主机ID位数。

子网#4是100，地址是211.77.20.128。

子网#5是101，地址是211.77.20.160。

子网#6是110，地址是211.77.20.192。

子网#7是111，地址是211.77.20.224。

**关键概念：** 子网网络中的子网地址在数字上总是均匀间隔的，其间隔取决于子网ID位的数量。

在我们的例子中，我们只需要七个子网，#0到#6。7号子网将是一个备用的。注意到最后一个子网的最后一个八位数与我们网络的子网掩码相同吗？这是因为我们用 "111 "代替了子网ID位，就像我们在计算子网掩码时做的那样。

<u>**B类子网ID和地址确定示例**</u>

现在让我们来看另一个示例，B类网络166.113.0.0。以二进制表示：

​        0100110 01110001 00000000 00000000

我们使用5位作为子网ID，剩下11个主机ID位。突出显示子网ID位的网络地址为：

​        0100110 01110001 00000000 00000000

在这里，对于不同的子网，只有第三个八位字节会发生变化。前两个总是“166.113”，最后一个八位字节总是零。有32个可能的子网；我将列出前几个，以便您可以看到模式（也请参阅图79）：

0.子网#0的子网ID为00000。这意味着地址将为166.113.0.0，这是我们预期的网络地址。

子网#1的子网ID为00001。地址变为：

10100110 01110001 00001000 00000000

这是十进制的116.113.8.0。

子网#2的子网ID为00010，地址为116.113.00010000.0或116.113.16.0。

子网#3的子网ID为00011，子网地址为116.113.24.0

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipsubnetaddressesclassb.png)

​                                                                                   **图79：确定A类B网络的子网地址**

这与图78相同，但对于具有5个子网ID位的B类网络（出于明显原因，我没有显示所有32个子网！）

同样，这里的模式很明显：将8加到第三个八位字节上，就可以得到连续的地址。这里的最后一个子网是#31，它的子网地址为116.113.248.0，它的第三和第四个八位字节与我们的子网掩码255.255.248.0相同

<u>**使用子网地址公式来计算子网地址**</u>

由于子网地址形成了一个模式，而这个模式取决于子网ID位的数量，因此可以用一个公式来表达每个子网划分选项的子网地址。我在子网划分汇总表中为A、B和C类中的每一类显示了这些公式。这些公式可以用来直接计算子网#N的地址，其中N的编号从0到比子网总数少一个，正如我们上面所做的那样。

<u>**基本子网公式的计算**</u>
在这些公式中，网络ID位显示为 "x."，或 "x.y. "或 "x.y.z. "的三类。这只是意味着子网地址有作为这些八位数的数字，无论网络地址的这些八位数是什么。在我们的例子中，"x.y "将是B类网络的 "166.113"，而 "x.y.z "将是C类的 "211.77.20"。

当子网比特数为8或更少时，公式相对简单，只对一个八位数进行计算，作为N的乘法，如 "N**4 "或 "N**32"。通常是这样的，因为子网的数量通常少于256，我们的两个例子都是这样的。

在我们有3个子网ID位的C类网络中，表中的公式是 "x.y.z.N*32"。对于这个网络，所有的子网都是 "211.77.20.N*32 "的形式，N从0到7。 所以，5号子网是211.77.20.(5*32)，也就是211.77.20.160，正如我们之前看到的。同样，在我们的B类网络中，有5个子网ID位，公式是x.y.N*8.0。在这种情况下，"x.y "是166.113。26号子网的地址是166.113.(26*8).0，或者166.113.208.0。

这是非常简单的东西，使公式成为快速确定子网地址的一个很好的捷径，特别是在有许多子网的时候。它们也可以在电子表格中使用。唯一需要注意的地方是，当子网位数为9或更多时，使用公式需要谨慎。这意味着子网标识符跨越了一个八位数的边界，这导致公式变得更加复杂。因此，考虑本主题的其余部分是可选的，如果你不想让你的大脑变得复杂，可以跳过它。

<u>**超过8个子网位的子网公式计算**</u>

当子网位数大于8时，某些八位字节的形式为“N除以整数”，例如“N/8”。这是一个整数除法，意思是“将N除以8，保留整数部分，去掉小数部分或余数”。其他八位字节是根据N的模计算的，如“N%8”所示。这恰恰相反：它的意思是“N除以8，去掉整数，余数保留”。例如，在整数数学中，33/5是6（6的余数是3，去掉余数，或者，6.6，去掉分数）。33%5等于3（6，余数为3，去掉6，保留余数）。

让我们以B类网络为例，假设出于某种奇怪的原因，我们决定使用10位而不是5位作为子网ID。在这种情况下，公式是“x.y.N/4.（N%4）*64”。在这种情况下，子网#23的地址为“166.113.23/4。（23%4）*64。23/4变为5（小数点75去掉）。23模4为3，乘以64得到192。因此子网地址为“167.113.5.192”。子网#709为“116.113.709/4.（709%4）*64，即116.113.177.64。

<u>**超过16个子网位的子网公式计算**</u>

好了，现在开始真正的乐趣。如果使用超过16位的子网ID作为a类地址的子网，则会跨越两个八位字节边界，公式变得非常有趣，涉及整数除法和模。假设我们负责A类地址21.0.0.0，并选择将其子网。然而，我们在办公室假日聚会上喝了几杯烈性酒后，坐下来做了这件事，所以我们的判断力有点受损。我们决定为子网ID选择21位是个好主意，因为我们喜欢数字21。这给了我们几百万个子网。

在这种情况下，子网地址的公式为“x.N/8192.（N/32）%256.（N%32）*8”。诶呀嗯，这有点复杂，所以很长一段时间内，只需要取一个子网编号并用二进制表示可能会更容易。但让我们举个例子，看看它是如何工作的，比如说，子网#987654。第一个八位组当然是21。第二个八位元是987654/8192，整数除法。这是120。第三个八位字节是（987654/32）%256。除法的结果是30864（我们去掉分数）。然后，取30864%256，余数为144。第四个八位字节是（987654%32）*8。这是6*8或48。因此子网地址#987654是21.120.144.48。

（不要酒后驾车。也不要酒后开车。J）

###### 3.1.2.1-4-5 IP子网划分步骤#5：确定每个子网的主机地址（部分：1 2 3 )

一旦我们知道了网络中每个子网的地址，我们就使用这些地址作为为每个子网中的各个主机分配IP地址的基础。我们首先将子网基本地址与每个物理网络相关联（因为至少在理论上，我们的子网对应于我们的物理网络）。然后，我们在子网中顺序分配主机特定的IP地址（如果愿意，也可以用不同的方式！）

一旦我们知道子网地址，确定主机地址就非常简单。我们所做的只是用数字1、2、3……等替换子网地址中的主机ID位。当然，我们必须以二进制的形式完成这项工作，然后将地址转换为十进制形式。同样，一旦出现了地址分配的明显模式，我们可以做一些“捷径”。我们将在稍后的主题中讨论这些问题。

<u>**C类主机地址确定示例**</u>

让我们再次从C类示例211.77.20.0开始，我们使用3个子网位将其划分为8个子网。下面是地址的显示方式，突出显示子网位，突出显示主机ID位并加下划线

​        11010011 01001101 00010100 00000000

第一个子网是子网#0，这些子网位都为零，因此与整个网络的地址相同：211.77.20.0。我们用数字1、2、3等替换带下划线的位，以获得主机ID。（请记住，这里我们不以0开头，因为对于主机ID，所有零和所有一个二进制模式都有特殊的含义）。它是这样的：

1. 第一个主机地址的主机ID是数字1，或二进制的“00001”。因此，它是：

​                    11010011 01001101 00010100 00000001

​                    十进制表示为211.77.20.1。

2. 第二个主机地址的主机ID是数字2，或二进制的“00010”。其二进制值为：

​                    11010011 01001101 00010100 00000010

​                    以十进制表示，这是211.77.20.2

我相信你已经了解了；第三台主机将是211.77.20.3，第四台是211.7720.4，依此类推。如前所述，每个子网中最多有30台主机。因此，通过将主机ID位替换为30（二进制为11110），可以找到该子网中的最后一个主机，从而得到小数地址211.77.20.30。

我们可以对其他每个子网执行相同的操作；唯一改变的是子网ID位中的值。让我们以子网#6为例。它的子网位是“110”，而不是“000”。因此，其子网基址为211.77.20.192，或：

​        11010011 01001101 00010100 11000000

我们通过用00001、00010、00011替换主机ID位，将主机分配给该子网，如前所述：

1. 第一个主机地址是：

​                11010011 01001101 00010100 11000001

​                或211.77.20.193。

2. 第二个主机地址是：

​                11010011 01001101 00010100 11000010

​                或211.77.20.194。

以此类推，一直到子网中的最后一个主机，即211.77.20.222。图80以图形方式显示了如何计算此示例网络的子网和主机地址。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipsubnethostaddressesclassc.png)

​                                                                                                **图80：确定C类网络的主机地址**

此图显示了如何在两步过程中确定子网地址和主机地址。子网地址是通过用子网ID值（以红色显示）替换网络的子网ID位来找到的。然后，对于任何给定的子网地址，我们可以通过用主机号（以蓝色显示）替换该子网中的主机ID位来确定主机地址。因此，例如，子网#6中的主机#2的子网ID为“110”，主机ID为“00010”，最终的八位字节值为“11000010”或194。

我们可能希望计算的另一个地址是子网的广播地址。当然，这是一种特殊情况，可以将主机ID替换为所有的ID。对于子网#0，这将是211.77.20.31。对于子网上#6，这将为211.77.0.223。这几乎就是全部。

<u>**B类主机地址确定示例**</u>

当然，我们可以为我们的B级网络做同样的事情。该网络的地址是166.113.0.0。现在，假设我们要定义子网#13中的主机。我们用二进制（01101）中的13替换子网ID位，以获得以下子网地址，其中突出显示了子网ID位数，突出显示了主机ID位并加了下划线：

​        10100110 01110001 01101000 00000000

这是子网地址166.113.104.0。现在，我们有11位主机ID，因此最多可以有2046台主机。第一个是通过用“000 00000000 1”替换主机ID位来找到的，给出的地址为166.113.04.1。第二个主机是166.113.104.2，依此类推。最后一个是通过替换“111 1111111 0”找到的，得到的地址为66.113.111.254。请注意，由于主机ID位扩展到两个八位字节，随着主机ID的增加，两个八位元字节会发生变化，这与我们的C类示例不同。广播地址为166.113.111.255。

**关键概念：**在子网网络中，子网编号#S内主机#H的地址是通过插入网络子网ID位的二进制值S和子网主机ID位的进制值H来找到的。

<u>**快速计算主机地址的 "捷径"**</u>

正如你所看到的，定义主机ID实际上是非常简单的。如果你能替代比特并转换为十进制，你就拥有了你需要知道的一切。你还可以看到，与定义子网地址的情况一样，在定义主机ID和理解它们的工作方式时，你可以使用一些模式。这些模式通常定义了一些方法，我们可以通过直接使用十进制而不是费力地使用二进制替换来更快地确定某些主机地址。这在概念上有点复杂，所以只有在你觉得有点胆量的情况下才能进行。

下面是你在子网环境中确定主机IP地址时可以使用的一些 "捷径"。

1. 第一个主机地址。第一个主机地址总是子网地址，最后一个八位字节递增为1。因此，在我们的C类例子中，子网#3的基本地址是211.77.20.96。因此，子网#3中的第一个主机地址是211.77.20.97。

2. 后续的主机地址。在你找到第一个主机地址后，为了得到下一个地址，你只需在前一个地址的最后一个八位字节上加一个。如果这使得最后一个八位数变成256（只有在有超过8个主机ID位的情况下才会发生），你就把它 "绕 "到0，然后增加第三个八位数。

3. 直接计算主机地址。如果主机ID位的数量是8或更少，你可以通过在最后一个八位数的十进制值上加上 "N "来找到主机#N的地址。例如，在我们的C类例子中，子网#3的基本地址是211.77.20.96。因此，这个子网中的23号主机的地址是211.77.20.119。

4. 如果主机ID有8位以上，这只对前255个主机有效，之后你必须 "环绕 "并增加第三个八位的值。再考虑一下我们B类例子中的子网#13，它的基本地址是166.113.104.0。这个子网的214号主机的地址是166.113.104.0，但是314号主机不是166.113.104.314。它是166.113.105.58（主机#255是166.113.104.255，然后主机#256是166.113.105.0，我们再往上数58（314-256）就可以得到#314，166.113.105.58）。

```
主机地址的范围。任何子网的主机范围都是按以下方式确定的。
第一个地址。子网的基本地址，最后一个八位数递增1。
```

最后一个地址。这个子网之后的下一个子网的基本地址，减去最后一个八位字节中的两个（这可能需要将最后一个八位字节中的 "0 "改为 "254"，并将第三个八位字节的值减少1）。
例如，考虑我们B类例子中的子网#17。它的子网地址是166.113.136.0。子网#18的地址是166.113.144.0。所以，子网#17的主机范围是166.113.136.1到166.113.143.254。
广播地址。一个子网的广播地址总是比后续子网的基本地址少一个。或者说，比子网的最后一个 "真正的 "主机地址多一个。因此，在我们的B类例子中，子网#17的广播地址是166.113.143.255。
我刚才把你弄糊涂了吗？好吧，请记住，这些都是捷径，有时当你走捷径的时候，你会迷路。J 开个玩笑，一旦你玩了一会儿，这真的不是什么难事。

1. 最后，在子网环境中使用IP地址时，请记住以下的快速总结。

2. 网络ID对所有子网中的所有主机和网络中的所有子网都是一样的。

3. 子网ID对每个子网中的所有主机都是一样的，但对网络中的每个子网都是唯一的。

4. 主机ID在每个子网内是唯一的。每个子网都有相同的一组主机ID。

子网划分很有趣!

###### 3.1.2.1-5  IP无类寻址: 无类域间路由（CIDR）/"超级网络"

随着早期互联网开始急剧增长，最初的 "分类 "寻址方案出现了三个主要问题。这些困难通过子网寻址得到了部分解决，子网寻址为互联网上各个网络的管理员提供了更多的灵活性。然而，子网并没有真正解决一般意义上的问题。由于使用了类，即使是子网，其中的一些问题仍然存在。

虽然在20世纪90年代中期开始开发IP版本6及其宽敞的128位寻址系统，但人们认识到，要想广泛部署IPv6，还需要很多年。为了延长IP版本4的寿命，直到更新的IP版本6能够完成，有必要采取一种新的方法对IPv4设备进行寻址。这个新系统要求完全消除地址类别的概念，创建一个新的无类别寻址方案，有时被称为无类别域名间路由（CIDR）。

在这一节中，我描述了现代无类IP寻址。我首先概述了无类寻址背后的概念和 "超网 "背后的想法，包括为什么创建它以及它的优点和缺点是什么。然后，我定义了CIDR，并更详细地描述了该系统如何工作，包括用于地址块的符号。我列出了每个CIDR地址块的大小，并说明它们与旧的A、B和C类网络的关系。最后，我举了一个CIDR寻址的例子，这与本节之前的实用子网划分部分类似，但重点是CIDR，而且更加浓缩。

**背景信息:** 无类别IP寻址代表了IP寻址的最新发展，紧随子网和前面章节中描述的原始 "类别 "寻址系统之后。理解无类别IP寻址和路由至少需要对这些旧的IP寻址方法有一定的了解。如果你没有阅读前面关于 "有类 "寻址和子网划分的章节就来到这一节，我强烈建议你先阅读这些章节。如果你了解子网划分，但不熟悉可变长度子网掩码（VLSM）的工作原理，那么阅读VLSM的主题是一个好主意，因为CIDR在许多方面与VLSM相似。

###### 3.1.2.1-5-1 IP 无类别寻址和“超网”概述、动机、优点和缺点（部分：1 2 3）

子网寻址是IP寻址演变中的一个重要发展，因为它解决了传统的、基于两级类别的寻址方案的一些重要问题。子网对简化IP寻址的贡献是允许每个网络有自己的两级层次结构，给每个网络的管理员提供了相当于 "互联网中的互联网"。

当我们研究子网的优点时，我们看到其中一个优点是，子网在每个组织内是本地的，对其他组织是 "看不见的"。这是一个优势，因为它可以让每个组织定制自己的网络，而其他团体不必担心如何完成的细节。不幸的是，这种 "不可见性 "也代表了子网 "分类 "寻址的一个关键缺点：它不能纠正与这种寻址类型相关的基本低效率，因为组织仍然是根据类别来分配地址块。

<u>**有类 "寻址的主要问题**</u>
常规子网的一个关键弱点是 "颗粒度 "低。一个B类地址块包含非常多的地址（65,534），但一个C类地址块只有相对较少的数量（254）。有成千上万的 "中型 "组织需要超过254个IP地址，但其中只有一小部分需要65,534个或甚至接近这个数字。(图64说明了与拥有5000台主机的中型组织缺乏良好的匹配)。当建立他们的网络时，这些公司和团体会倾向于申请B类地址块，而不是C类地址块，因为他们需要超过254个，而不考虑65000多个地址中他们真正会使用多少。

现在，由于旧系统的类别是如何设计的，有超过200万个C类地址块，但只有16384个B类。虽然16,384个乍看起来很多，但全世界有数百万的组织和公司。B类的分配被快速消耗，而较小的C类网络则相对未被使用。

发放互联网地址的人需要一种方法来更好地利用地址空间，这样它就不会在过渡到IP版本6之前耗尽。子网对这个问题没有很大的帮助。为什么呢？因为它只在 "类 "地址块中发挥作用。如果一个需要2000个IP地址的组织要求一个B类区块，他们可以使用子网划分来更有效地管理他们的区块。然而，子网划分不能解决这个问题，即这个组织永远不会使用其块中的62,000个地址--约占其分配地址空间的97%。

唯一的解决办法是说服--或者在最坏的情况下，强迫公司使用许多较小的C类区块，而不是 "浪费 "大部分的B类分配。由于涉及的复杂性，许多组织抵制这种做法，这就造成了子网划分没有纠正的另一个主要问题：互联网路由表的增长。用10个C类网络取代一个B类网络，意味着路由器需要跟踪的条目数量是原来的十倍。

一个更好的解决方案: 消除地址类别

很明显，只要只有三种规模的网络，分配效率问题就不可能得到适当的纠正。解决办法是完全取消类别，而采用无类别的分配方案。这个系统将解决 "有类 "寻址的两个主要问题：地址空间使用效率低下，以及路由表的指数增长。

这个系统在20世纪90年代初被开发出来，并在1993年被正式写入RFCs 1517、1518、1519和1520。该技术被称为无类别域间路由（CIDR）。尽管有这个名字，但该方案同时处理了寻址和路由问题，因为它们是密不可分的。

CIDR背后的理念是将单一网络的子网概念适用于整个互联网。那么，从本质上讲，无类别寻址意味着，我们可以将一个特定的网络分解成子网，而不是将网络聚合成更大的 "超级网"。由于这个原因，CIDR有时被称为超级网：它将子网的原则应用于更大的网络。正是这种将网络聚合成超级网的做法使CIDR解决了互联网路由表不断增长的问题。

当然，如果我们要将子网的概念应用于整个互联网，我们需要能够有不同大小的子网。毕竟，这也是我们消除类的主要目标之一。因此，更准确地说，CIDR是一个互联网范围内的应用，不是普通的单级子网，而是可变长度子网掩码（VLSM）。就像VLSM让我们随心所欲地分割一个网络以创建子网、"子子网 "和 "子子网 "一样，CIDR让我们在整个互联网上随心所欲地做这件事。

关键概念: 无类域间路由（CIDR）是一种IP寻址和路由系统，它通过消除固定的地址类别，而采用灵活的、多层次的、不同规模的网络分层结构，解决了 "有类 "寻址的许多问题。

<u>**无类别寻址和路由的许多好处**</u>

**CIDR与“有类”寻址方案相比具有许多优点，无论是否使用子网：**

- 高效地址空间分配：在CIDR下，地址不是以固定大小的低粒度块分配地址，而是以任意二进制倍数的大小分配。因此，一家需要5000个地址的公司可以分配一个8190块，而不是65534块，如图81所示。或者，换个角度来看，可以在8家需要8190个或更少IP地址的公司之间共享等效于单个B类网络的网络。

- 消除类不平衡：不再有A类、B类和C类网络，因此地址空间的某些部分被广泛使用而其他部分被忽略是没有问题的。

- 高效路由条目：CIDR的多级分层结构允许少量路由条目表示大量网络。网络描述可以“聚合”并由单个条目表示。由于CIDR是分层的，较低级别、较小网络的详细信息可以对在大型网络组之间移动流量的路由器隐藏。这在IP路由问题一节中进行了更全面的讨论。

- 没有单独的子网方法：CIDR在互联网内部实现了子网的概念。组织可以使用Internet上使用的相同方法将其内部网络细分为任意复杂的子网，而无需单独的子网机制。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipclasslesssolution.png)

​                                                                   **图81：无类别寻址（CIDR）解决了“粒度问题”**

图64说明了“有类”寻址的主要问题：B类和C类网络的大小之间的距离太远。CIDR通过允许任意数量的位用于网络ID来解决此问题。对于拥有5000台主机的组织，可以分配具有8190台主机的/19网络。这将此类组织的地址空间浪费减少约95%。

<u>**CIDR的主要缺点：复杂性**</u>
由于 "分类 "寻址的主要好处是它的简单性，所以CIDR的主要缺点是它的复杂性更高，这并不奇怪。一个问题是，不再可能通过查看第一个八位数来确定一个IP地址中有多少位代表网络ID，有多少位代表主机ID。在设置路由器时也需要更谨慎一些，以确保正确完成路由。

###### 3.1.2.1-5-2 IP“超网”：无类别域间路由 (CIDR) 分层寻址和表示法（部分：1 2 3 4）

 **当我们第一次查看IP地址时，我们看到IP地址被设计为分为网络标识符和主机标识符。然后，当引入子网时，我们从主机ID中“窃取”位来创建子网ID，使IP地址总共有三个层次结构级别。使用VLSM，我们进一步将子网划分为子网，从主机ID中提取更多的位，以提供具有“子网”、“子子网”等的多级层次结构。**

在无类环境中，我们通过将VLSM概念不仅应用于一个网络，而且应用于整个互联网，彻底改变了我们看待IP地址的方式。从本质上讲，互联网只是一个巨大的网络，它被“子网”划分成许多大块。然后，这些大的块中的一些被分解成更小的块，而这些块又可以进一步分解。这种分解可能会发生多次，使我们能够将互联网地址的“block”分割成许多不同大小的块，以满足组织的需要。

顾名思义，无类寻址完全消除了以前的类概念。不再有被地址的前几个位除的A、B、C类块。相反，在CIDR下，所有Internet块都可以是任意大小。不是让所有网络都使用8位（A类）、16位（B类）或24位（C类）作为网络ID，我们可以使用13位作为网络ID的大型网络（为主机ID保留19位），或者使用28位作为网络标识的小型网络（主机ID只有4位）。当然，网络的大小仍然基于主机ID位数的二进制幂。

回想一下，当我们使用子网时，我们遇到了一个问题：子网可以通过获取任意数量的可用主机ID位来实现，那么设备如何知道子网ID和主机ID之间的线路在哪里？CIDR下也会出现相同的问题。没有类，所以我们不能通过查看IP地址的前几位来判断任何事情。由于地址可以有主机ID和网络ID之间的分界点出现在任何地方，因此我们需要额外的信息来正确解释IP地址。当然，在CIDR下，这不仅会影响组织内的地址，还会影响整个互联网，因为没有类，每个网络可以有不同的大小。

<u>**CIDR（"斜线"）符号**</u>

正如子网划分需要使用子网掩码来显示哪些位属于网络ID或子网ID，哪些属于主机ID一样，CIDR使用子网掩码来显示主机ID和网络ID之间的界限。然而，为了简单起见，在CIDR下我们通常不使用32位的二进制子网掩码。相反，我们使用斜线符号，更恰当地称为CIDR符号。在这种方法中，我们通过在IP地址后面加上一个整数来显示网络的大小，有时称为前缀长度，这个整数告诉我们网络ID（前缀）使用了多少比特。

**关键概念:** 由于在CIDR中没有地址类别，所以不能仅从地址中看出一个地址的网络ID的大小。在CIDR中，前缀（网络ID）的长度是通过把它放在地址后面的斜线上表示的。这被称为CIDR符号或斜线符号。

例如，考虑网络规范184.13.152.0/22。22 "意味着这个网络有22位的网络ID和10位的主机ID。这相当于指定一个地址为184.13.152.0、子网掩码为255.255.252.0的网络，如图82所示。这个样本网络共提供了1022个主机（210减去2）。下面的主题中的表格显示了在CIDR下可以配置的所有不同的网络规模。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipcidr.png)

​                                                                **图82:CIDR（“Slash”）符号及其子网掩码等效项**

无类网络通常用CIDR或“斜杠”表示法指定，例如：184.13.152.0/22。这里，“/22”表示地址的前22位是网络ID。等效子网掩码可以通过创建一个32位数字来计算，其中22个1后跟10个零。

注意：您可能还记得我提到过，在“有类”子网下，用于子网ID的位不需要是连续的。尽管为了避免混淆，很少使用这种方法，但可以使用非连续子网ID位。在CIDR下，对连续子网ID位的要求已正式规定，否则不能使用斜杠表示法。

<u>**"Supernetting": 互联网的子网化**</u>

从理论上讲，CIDR所做的是为中央地址分配机构提供灵活性，根据组织的需要向其分配不同大小的地址块。然而，当CIDR被开发出来时，公共IP地址的分配方法也发生了变化。让世界上的每个人都试图从一个组织获得地址并不是最好的方法。在 "类 "方案下，这是必要的，因为层次结构只有两层：IANA向每个人发放网络ID，然后由他们分配主机ID（或子网）。

在CIDR下，我们有许多层次：我们把大的区块分成更小的区块，然后再分成更小的区块，如此循环。以类似的分层方式来管理区块也是有意义的。因此，发生的情况是，IANA/ICANN将地址分成大块，并将其分配给四个区域互联网注册机构（RIRs）。APNIC、ARIN、LACNIC和RIPE NCC。然后，这些注册机构进一步划分地址块，并将其分配给较低级别的国家互联网注册机构（NIRs）、地方互联网注册机构（LIRs）和/或个人组织，如互联网服务提供商（ISPs）。这在关于互联网管理机构和注册机构的背景专题中都有解释。

然后，互联网服务供应商可以将这些区块划分为更小的区块，分配给他们的客户。这些客户有时是较小的ISP本身，它们重复这个过程。他们把自己的区块分成不同大小的块，然后分配给他们的客户，其中有些是更小的ISP，有些是 "终端用户"。这种情况发生的次数只受原始区块中多少地址的限制。

还值得注意的是，虽然CIDR是基于子网的概念，但子网本身并没有在CIDR中使用，或者至少没有以 "类 "寻址的方式使用。在CIDR中没有使用子网ID的明确的子网划分：所有的IP地址只被解释为有一个网络ID和一个主机ID。一个组织通过使用与ISP相同的一般方法将自己的网络划分为子网，来进行相当于子网的划分。这可能看起来有点令人困惑。在本节后面，我提供了一个详细的例子，说明在CIDR下分层地址块分配和分割是如何进行的。

<u>**“有类”和无类寻址的共同特点**</u>

请注意，在CIDR下，有几个在“类”方案下定义的寻址方面没有改变：

- 专用地址块：某些地址块仍保留用于专用网络寻址。这些地址不直接在Internet上路由，但可以与网络地址转换（NAT）结合使用，以允许没有公共地址的IP主机访问Internet。

- 具有特殊含义的地址：指定给某些网络ID和主机ID模式的特殊含义与以前相同。这也是为什么我们仍然必须从每个网络中的主机数量中减去两个：对于表示整个网络的全零情况，以及用于广播的全一地址。

- 环回地址：网络127.0.0.0仍保留用于环回功能。（CIDR中给出了符号127.0.0.0/8）。

最后，请注意，使用无类寻址需要设计用于处理它的硬件和软件。如果硬件和软件仍然假设它们在“有类”环境中运行，它们将无法正确解释地址。由于CIDR已经存在了十多年，这通常不是现代系统的问题。

###### 3.1.2.1-5-3 IP 无类别寻址块大小和“有类”网络等效项

由于CIDR允许我们沿任何比特边界将IP地址分为网络ID和主机ID，它允许创建数十个不同大小的网络。与子网划分一样，网络的大小是在用于网络ID的比特数和用于主机ID的比特数之间进行权衡。与传统的子网划分不同的是，CIDR允许对互联网进行多层次的划分，因此许多规模的网络同时存在。较大的网络被创建并细分为较小的网络，正如我们在上一主题中看到的那样。

由于许多人习惯于用 "有类 "的大小来看待IP地址块，所以通常用 "类 "的等价物来表示CIDR地址块。首先，在这一点上应该很简单，CIDR"/8 "网络的大小相当于A类网络；"/16 "相当于B类；"/24 "相当于C类。当然，这是因为A类网络使用8位的网络ID，B类使用16位，C类使用24位。然而，请记住，这些CIDR等价物不需要像 "classful "方案那样，对其第一个八位字节有任何特定的范围。

每次我们减少前缀的长度，我们都是在定义一个大约两倍于较高数字的网络，因为我们在主机ID中增加了一个比特。因此，一个"/15 "网络的大小等于两个"/16"。

表55显示了在CIDR下将IP地址的32位划分为网络ID和主机ID位的每种可能的理论方法。对于每一种方式，我都显示了每个网络中的主机数量，以及每种规模的网络在斜线符号和传统子网掩码中的表示方式。我还显示了每个网络的A类、B类和C类网络的数量。

在看这个表的时候，有几件事要记住。

- 所显示的一些条目更多的是理论上的，而不是实践上的，列入这些条目只是为了完整。对于大型网络来说，情况尤其如此。例如，我怀疑是否有人真正使用过/1或/2大小的CIDR网络；前者只有两个，后者有四个，涵盖了整个IP地址空间。大多数时候，你会使用较小的网络，/16及以下。

- 在正常情况下，你不能有一个/31或/32的CIDR网络，因为它们的有效主机ID是零。(有一种特殊情况。/31网络可以用于点对点的链接，在这种情况下，每次传输的目标接收者是谁是显而易见的，而且没有必要进行广播。这在RFC 3021中有描述）。

- 在显示相当于A类、B类和C类网络数量的栏目中，为了简单起见，我只显示了1/256到256之间的数字。显然，一个/6网络除了等于4个A类网络外，还等于1024个B类和262,144个C类网络，但很少有人会把一个/6说成是262,144个C类。

​                                                                

​                                                                    **表55: CIDR地址块和 "类 "地址的等价**

- | **# of Bits For Network ID** | **# of Bits For Host ID** | **# of Hosts Per Network** | **Prefix Length in Slash Notation** | **Equivalent Subnet Mask** | **# of Equivalent “Classful” Addressing Networks** |       |      |
  | ---------------------------- |:-------------------------:|:--------------------------:|:-----------------------------------:|:--------------------------:| --------------------------------------------------:|:-----:| ---- |
  | **Class A**                  | **Class B**               | **Class C**                |                                     |                            |                                                    |       |      |
  | 1                            | 31                        | 2,147,483,646              | /1                                  | 128.0.0.0                  | 128                                                | —     | —    |
  | 2                            | 30                        | 1,073,741,822              | /2                                  | 192.0.0.0                  | 64                                                 | —     | —    |
  | 3                            | 29                        | 536,870,910                | /3                                  | 224.0.0.0                  | 32                                                 | —     | —    |
  | 4                            | 28                        | 268,435,454                | /4                                  | 240.0.0.0                  | 16                                                 | —     | —    |
  | 5                            | 27                        | 134,217,726                | /5                                  | 248.0.0.0                  | 8                                                  | —     | —    |
  | 6                            | 26                        | 67,108,862                 | /6                                  | 252.0.0.0                  | 4                                                  | —     | —    |
  | 7                            | 25                        | 33,554,430                 | /7                                  | 254.0.0.0                  | 2                                                  | —     | —    |
  | 8                            | 24                        | 16,777,214                 | /8                                  | 255.0.0.0                  | 1                                                  | 256   | —    |
  | 9                            | 23                        | 8,388,606                  | /9                                  | 255.128.0.0                | 1/2                                                | 128   | —    |
  | 10                           | 22                        | 4,194,302                  | /10                                 | 255.192.0.0                | 1/4                                                | 64    | —    |
  | 11                           | 21                        | 2,097,150                  | /11                                 | 255.224.0.0                | 1/8                                                | 32    | —    |
  | 12                           | 20                        | 1,048,574                  | /12                                 | 255.240.0.0                | 1/16                                               | 16    | —    |
  | 13                           | 19                        | 524,286                    | /13                                 | 255.248.0.0                | 1/32                                               | 8     | —    |
  | 14                           | 18                        | 262,142                    | /14                                 | 255.252.0.0                | 1/64                                               | 4     | —    |
  | 15                           | 17                        | 131,070                    | /15                                 | 255.254.0.0                | 1/128                                              | 2     | —    |
  | 16                           | 16                        | 65,534                     | /16                                 | 255.255.0.0                | 1/256                                              | 1     | 256  |
  | 17                           | 15                        | 32,766                     | /17                                 | 255.255.128.0              | —                                                  | 1/2   | 128  |
  | 18                           | 14                        | 16,382                     | /18                                 | 255.255.192.0              | —                                                  | 1/4   | 64   |
  | 19                           | 13                        | 8,190                      | /19                                 | 255.255.224.0              | —                                                  | 1/8   | 32   |
  | 20                           | 12                        | 4,094                      | /20                                 | 255.255.240.0              | —                                                  | 1/16  | 16   |
  | 21                           | 11                        | 2,046                      | /21                                 | 255.255.248.0              | —                                                  | 1/32  | 8    |
  | 22                           | 10                        | 1,022                      | /22                                 | 255.255.252.0              | —                                                  | 1/64  | 4    |
  | 23                           | 9                         | 510                        | /23                                 | 255.255.254.0              | —                                                  | 1/128 | 2    |
  | 24                           | 8                         | 254                        | /24                                 | 255.255.255.0              | —                                                  | 1/256 | 1    |
  | 25                           | 7                         | 126                        | /25                                 | 255.255.255.128            | —                                                  | —     | 1/2  |
  | 26                           | 6                         | 62                         | /26                                 | 255.255.255.192            | —                                                  | —     | 1/4  |
  | 27                           | 5                         | 30                         | /27                                 | 255.255.255.224            | —                                                  | —     | 1/8  |
  | 28                           | 4                         | 14                         | /28                                 | 255.255.255.240            | —                                                  | —     | 1/16 |
  | 29                           | 3                         | 6                          | /29                                 | 255.255.255.248            | —                                                  | —     | 1/32 |
  | 30                           | 2                         | 2                          | /30                                 | 255.255.255.252            | —                                                  | —     | 1/64 |

###### 3.1.2.1-5-4 IP CIDR 寻址示例（部分：1 2 3 4）

CIDR的多个层次使该技术看起来相当复杂。然而，理解CIDR的工作原理其实并不难，前提是你已经知道子网是如何完成的。特别是，如果你知道VLSM的功能，你基本上已经知道CIDR的功能，因为它们几乎是同样的东西。它们的区别仅仅在于完成网络分层的方式和术语。

为了更好地展示CIDR的工作原理，让我们举一个例子来说明无类别寻址的威力：它能够有选择地将一大块地址细分为更小的地址，以满足不同组织的需要。由于CIDR的地址分配通常从较大的互联网服务提供商（ISP）拥有的较大的块开始，我们也从这里开始。

假设我们有一个刚刚起步的ISP。它不是一个 "主要 "的ISP，而是一个只有少数客户的中等规模的ISP，所以它只需要一个相对较小的分配。它以71.94.0.0/15这个区块开始。该块地址末尾的"/15 "告诉我们，这是一个地址块，前15位是网络ID，后17位是主机ID。当然，这个块是从一个更大的ISP那里获得的，由该ISP从一个更大的地址块中刻出来的。例如，71.94.0.0/15等于地址块71.92.0.0/14的一半，71.88.0.0/13的四分之一，以此类推。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipcidrsplit.png)

​                                                                **图83：A/15 CIDR地址块的分层划分示例**

此图显示了一种方法，通过该方法，具有相对较大/15地址块（131070台主机）的ISP可以选择对其进行分层划分。在这种情况下，首先将其分为两个/16块。一个保留，另一个分为4/18个区块。每一个都被划分为不同大小的块，以允许分配给分别需要62、126、254或510个主机的组织。

我们的ISP块大小等于两个B类，共有131070个可能的主机地址。该ISP可以选择以多种方式划分此块，具体取决于其客户的需求和自身的内部使用。然而，这家ISP刚刚起步，所以它甚至不确定其最终需求是什么。比方说，它预计将把大约一半的地址空间转售给其他ISP，但尚不确定他们需要多少大小。另一半，它计划将其分成四个不同大小的区块，以满足不同规模组织的需求。

想象一下ISP是如何分地址空间的，我们可以把它比作切饼。ISP将首先“把馅饼切成两半”，并为其未来的ISP客户保留一半。然后，它会将另一半切成一些大块和一些小块。这如图83所示

实际的划分过程可能遵循这个过程（如图84所示）：

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipcidrexample.png)

​                                                                **图84：使用无类别寻址（CIDR）的分层地址划分**

<u>**第一层划分**</u>

通过使用最左边的一个主机ID位作为额外的网络位，"饼 "最初被从中间切开。让我们看看我们的网络地址块，二进制的71.94.0.0/15，最左边的主机ID位高亮显示。

​        01000111 01011110 00000000 00000000
为了进行分割，我们让一个网络等于这个二进制网络地址，高亮显示的位保持为零，另一个网络则改为1。这就创造了两个子网络--不是 "类 "意义上的子网络，而是原网络的一部分--我根据新的网络ID位的数值对其进行了编号。

> Subnetwork #0: 01000111 0101111**0** 00000000 00000000

> Subnetwork #1: 01000111 0101111**1** 00000000 00000000

由于第16位现在也是网络地址的一部分，这些是"/16 "网络，是一个 "classful "B类网络的大小。所以，这些子网络是

> Subnetwork #0: 71.94.0.0/16

> Subnetwork #1: 71.95.0.0/16

你会注意到，"#0 "子网络的IP地址与它来自的大网络相同；在一个网络中，0号子网络总是如此。

<u>**第二层划分**</u>

假设我们把上面的0号子网络留作未来的ISP分配之用。然后我们选择将第二个子网络，分成四个。然后，这些我们将进一步细分为不同的大小，以满足客户的需求。为了分成四组，我们需要从子网 #1 的主机 ID 上再取两个位，在原来的子网位旁边用高亮和下划线显示。

​            01000111 01011111 00000000 00000000
这两个位被图案00、01、10和11取代，得到四个子网络。当然，它们将是"/18 "网络，因为我们从"/16 "的主机ID中多拿了两个比特。

> Sub-subnetwork #1-0: 01000111 0101111**1** **00**000000 00000000 (71.95.0.0/18)

> Sub-subnetwork #1-1: 01000111 0101111**1** **01**000000 00000000 (71.95.64.0/18)

> Sub-subnetwork #1-2: 01000111 0101111**1** **10**000000 00000000 (71.95.128.0/18)

> Sub-subnetwork #1-3: 01000111 0101111**1** **11**000000 00000000 (71.95.192.0/18)

每一个都有16,382个地址。

<u>**第三层次的划分**</u>

我们现在把上述四个/18网络中的每一个进一步细分。我们想让其中的每一个都包含一些不同大小的区块，与我们的潜在客户相对应。做到这一点的一个方法是如下。

- **较大的组织**：需要多达510个地址的客户需要一个/23网络。我们通过从主机ID字段中抽取5位来划分1-0号子网络，71.95.0.0/18。
  01000111 01011111 00000000 00000000
  我们把00000、00001、00010等五个比特代入，在这个区块中就有32个不同的/23网络，每个网络包含9个比特的主机ID，用于510个主机。第一个将是1-0-0号子网络，71.95.0.0/23；第二个是1-0-1号子网络，71.95.2.0/23；最后一个将是1-0-31号子网络。71.95.62.0/23.
- **中等规模的组织**:对于需要多达254个地址的客户，我们将子子网络#1-1，71.95.64.0/18，从主机ID字段中抽取6位来划分。
  01000111 01011111 01000000 00000000
  这就给了我们64个不同的/24网络。第一个将是子子网络#1-1-0，71.95.64.0/24，第二个是子子网络#1-1-1，71.95.65.0/24，以此类推。
  **较小的组织:** 对于拥有多达126台主机的客户，我们通过从主机ID字段中抽取7位来划分1-2号子网，71.95.128.0/18。
  01000111 01011111 10000000 00000000
  7位允许在我们的/18区块内有128个这样的/25网络。第一个将是71.95.128.0/25，第二个是71.95.128.128/25，第三个是71.95.129.0/25，以此类推。
- **非常小的组织:** 对于拥有多达60台主机的客户，我们通过从主机ID字段中抽取8位来划分1-3号子网，71.95.192.0/18。
  01000111 01011111 11000000 00000000
  这使我们在/18区块中得到256个不同的/26网络。第一个是71.95.192.0/26，第二个是71.95.192.64/26，以此类推。

<u>**其他划分网络的方法**</u>

最重要的是，CIDR是关于灵活性的--这只是分割这个网络的许多不同方法之一（布朗尼蛋糕的薄片，等等！），ISP可能决定事先创建四个不同大小的客户网络不是正确的方法。他们可能会采取将馅饼分成两半，再分成两半的办法，以此类推，根据需要多次创建合适大小的 "馅饼片"。另外，如果他们的大多数客户需要50、100、200或500个主机，上面的例子可能是最容易管理的。

如果ISP需要的话，仍有可能进一步划分任何小块。例如，他们可以把一个/26子子网络分成四个/28子子网络，供非常小的客户使用。此外，该ISP的个人客户也可以做同样的事情，划分自己的区块，以适应其网络的内部结构。

###### 3.1.2.2 IP数据报的封装和格式化

互联网协议的主要工作是通过互联网网络在设备之间传递数据。在互联网中两个主机之间的旅程中，这些数据可能穿越许多物理网络。为了帮助确保数据的正确发送和接收，它被封装在一个称为IP数据报的消息中。这个数据报包括几个字段，帮助管理IP的运作，确保数据到达它需要去的地方。

在这一节中，我将看一看互联网协议是如何从高层获取数据并将其打包传输的。我首先对IP数据包和封装进行了一般性讨论。然后，我描述了IP数据包的一般格式，包括IP头中使用的字段以及如何解释它们。我还包括对IP数据报选项及其使用的简要讨论。

**背景信息：**本节假定至少对IP寻址概念有一定的熟悉。它还参考了关于数据报碎片和重新组合的部分。

**注意：**IP数据报有时被称为IP包。数据报 "或 "包 "是否是首选术语，似乎取决于你问谁；甚至标准也不完全使用一个术语。另一方面，我曾看到IP数据报被称为IP帧，这绝对是不正确的。基本原理一章中关于消息和名称的主题更完整地描述了这些术语。

###### 3.1.2.2-1 IP数据报的封装

在描述OSI参考模型的章节中，我研究了网络协议栈中各层协议相互作用的几种方式。协议间操作中最重要的概念之一是封装。大多数数据起源于OSI模型的高层。这些层的协议将数据传递给下层进行传输，通常是以离散消息的形式。收到后，每个下层协议将收到的消息的全部内容封装成自己的消息格式，并添加一个包头，可能还有一个包含重要控制信息的包尾。封装将在一个单独的主题中作一般性解释。

对于封装的工作原理，有一个很好的比喻，那就是把信装在信封里寄出去。你可能会写一封信，然后把它放在一个白色的信封里，上面写上名字和地址，但是如果你把它交给快递员进行隔夜递送，他们会把这个信封放在一个更大的快递信封里。(如果你有兴趣，我实际上已经写了一份关于这种类比的完整描述）。

由于TCP/IP的突出地位，互联网协议是现代网络上发生数据封装的最重要地方之一。数据通常从两个主要的传输层协议之一传递到IP。TCP或UDP。这些数据已经以TCP或UDP消息的形式出现，并带有TCP或UDP头。然后被封装成IP消息的主体，通常称为IP数据报或IP包。IP数据报的封装和格式化有时也称为打包--同样，与信封的隐含比较是很明显的。这个过程如图85所示。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipencap.png)

​                                                                                     <u>**图85:IP数据报封装**</u>

这是对图15的改编，这是OSI参考模型的整体非常相似的图，具体显示了数据封装是如何在TCP/IP中完成的。如您所见，上层消息打包为TCP或UDP消息。然后，它成为IP数据报的有效载荷，这里只显示了一个标头（事情可能会比这个复杂一些）。然后，IP数据报被传递到第2层，在那里它被封装成某种LAN、WAN或WLAN帧，然后转换成位并在物理层传输。

如果要传输的消息对于基础网络的大小来说太大，那么它可能首先会被分割。这类似于将一个大的送货分成多个较小的信封或盒子。在这种情况下，每个IP数据报只携带高层消息的一部分。接收设备必须重新组装来自IP数据报的消息。因此，数据报并不总是携带完整的高层消息；它可能只能容纳其中的一部分。

IP数据报在概念上与以太网或其他数据链路层中使用的帧有些相似。当然，重要的区别在于，IP数据报旨在促进跨互联网的传输，而数据链路层帧仅用于物理网络内的直接传输。IP报头中包含的字段用于管理网络间数据报传递。这包括用于传送的关键信息，例如目标设备的地址、帧类型的标识和控制位。标题遵循以下主题中描述的特定格式。

数据封装到IP数据报中后，向下传递到数据链路层，以便跨网络的当前“跃点”传输。在那里，它当然被进一步封装，IP头和所有的，到一个数据链路层帧，如以太网帧。IP数据报可以封装在许多这样的数据链路层帧中，因为它是通过互联网路由的；在每个跃点上，IP数据报从数据链路层帧中删除，然后重新打包为下一个跃点的新数据报。然而，IP数据报在到达其最终目的地之前不会更改（某些控制字段除外）。

###### 3.1.2.2-2 IP数据报的一般格式（部分：1 2 3 )

使用IP在互联网上传输的数据以称为IP数据报的消息形式传输。与所有网络协议消息一样，IP对其数据报使用特定格式。当然，我们在这里查看的是IP版本4，因此我们将检查IPv4数据报格式，它与IPv4的其余部分一起在RFC 791中定义。

IPv4数据报在概念上分为两部分：报头和有效载荷。报头包含寻址和控制字段，而有效载荷携带要通过互联网发送的实际数据。与某些消息格式不同，IP数据报的有效负载后面没有包尾。

尽管IP是一个相对简单、无连接、“不可靠”的协议，但IPv4报头携带了相当多的信息，这使得它相当大。它至少有20个字节长，有选项时可以更长。IP数据报格式如表56所示，如图86所示。

​                                                             **表56：互联网协议版本4（IPv4）数据报格式**

| **Field Name**             | **Size (bytes)** | **Description**                                                                                                                                                                                  |
| -------------------------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| ***Version\***             | 1/2 (4 bits)     | ***Version:\*** 版本：标识用于生成数据报的IP版本。对于IPv4，这当然是数字4。此字段的目的是确保运行不同版本IP的设备之间的兼容性。通常，运行较旧版本IP的设备将拒绝由较新实现创建的数据报，前提是较旧版本可能无法正确解释较新的数据报。                                                                  |
| ***IHL\***                 | 1/2 (4 bits)     | 指定IP标头的长度，以32位字表示。这包括任何选项字段的长度和填充。未使用选项时，此字段的正常值为5（5个32位字=5*4=20字节）。与下面较长的“总长度”字段形成对比。                                                                                                           |
| ***TOS\***                 | 1                | ***Type Of Service (TOS):\*** 一个字段，用于携带信息，为IP数据报提供服务质量特性，如优先级传递。它从未像最初定义的那样被广泛使用，其含义随后被重新定义，以供一种称为差异化服务（DS）的技术使用。有关详细信息，请参见下文。                                                                   |
| ***TL\***                  | 2                | ***Total Length (TL):\*** 指定IP数据报的总长度，以字节为单位。由于该字段的宽度为16位，因此IP数据报的最大长度为65535字节，尽管大多数数据报的长度要小得多。包含IP 头部长度                                                                                         |
| ***Identification\***      | 2                | ***Identification:\*** 此字段包含一个16位值，该值是属于特定消息的每个片段的公用值；对于最初未经分段发送的数据报，它仍然被填写，因此，如果数据报必须在传送期间由路由器分段，则可以使用它。收件人使用此字段重新组装消息，而不会意外混合不同消息的片段。这是必要的，因为碎片可能来自混合在一起的多条消息，因为IP数据报可以从任何设备无序接收。请参阅IP消息碎片的讨论。 |
| ***Flags\***               | 3/8 (3 bits)     | ![img](http://www.tcpipguide.com/free/aa1f0152.png)                                                                                                                                              |
| ***Fragment Offset\***     | 1 5/8 (13 bits)  | ***Fragment Offset:\*** 当消息出现片段时，此字段指定该片段中的数据在整个消息中的偏移量或位置。它以8字节（64位）为单位指定。第一个片段的偏移量为0。同样，有关如何使用该字段的描述，请参阅片段的讨论。                                                                                 |
| ***TTL\***                 | 1                | ***Time To Live (TTL):\*** 短版本：指定允许数据报在网络上“生存”的时间，以路由器跳数表示。每个路由器在传输TTL字段之前将其值减小（减小一）。如果TTL字段降为零，则认为数据报占用了太长的路由并被丢弃。                                                                              |
| ***Protocol\***            | 1                | ![img](http://www.tcpipguide.com/free/aa1f02ce.png)                                                                                                                                              |
| ***Header Checksum\***     | 2                | ***Header Checksum:\*** 在标头上计算的校验和，用于提供基本保护，防止传输中的损坏。这不是以太网等数据链路层技术通常使用的更复杂的CRC代码；这只是一个16位校验和。它的计算方法是将头字节划分为单词（单词是两个字节），然后将它们相加。数据没有校验和，只有标头。在每个跃点，接收数据报的设备执行相同的校验和计算，如果不匹配，则将数据报视为损坏而丢弃。        |
| ***Source Address\***      | 4                | ***Source Address:\*** 数据报发起者的32位IP地址。请注意，即使路由器等中间设备可以处理数据报，但它们通常不会将地址输入此字段，它始终是最初发送数据报的设备。                                                                                                      |
| ***Destination Address\*** | 4                | ***Destination Address:\*** 数据报预期收件人的32位IP地址。同样，即使路由器等设备可能是数据报的中间目标，此字段始终是最终目的地。                                                                                                                 |
| ***Options\***             | Variable         | ***Options:\*** 某些IP数据报中的标准标头后面可能包含一种或多种类型的选项。我将在接下来的主题中讨论这些问题。                                                                                                                                  |
| ***Padding\***             | Variable         | ***Padding:\*** 如果包含一个或多个选项，并且用于这些选项的位数不是32的倍数，则会添加足够的零位，以将标头“填充”为32位（4字节）的倍数。                                                                                                                   |
| ***Data\***                | Variable         | ***Data:\*** 数据报中要传输的数据，可以是整个高层消息，也可以是其中的一个片段。                                                                                                                                                   |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipformat.png)

​                                                                **图86：互联网协议版本4（IPv4）数据报格式**

此图以图形方式显示了最重要的IPv4数据报格式。前20个字节是固定IP头，后面是可选的选项部分和可变长度的数据区域。请注意，服务类型字段显示为IPv4标准中最初定义的字段。

这是一个很大的表，因为IP数据报格式非常重要，并且有很多字段需要解释。为了避免它变得更长，我决定将一些更复杂的描述移出表格。

<u>**生存时间（TTL）字段**</u>

由于IP数据报在穿过互联网时从路由器发送到路由器，因此可能会出现这样的情况：数据报从路由器a传递到路由器B，再传递到路由器C，然后再返回到路由器a。路由器循环不应该发生，也很少发生，但有可能发生。

为了确保数据报不会无休止地循环，TTL字段打算在最初发送数据报时填充一个时间值（以秒为单位）。路由器会定期减少时间值，如果时间值为零，数据报就会被销毁。这也是为了确保时间关键型数据报不会停留在“过时”的点上。

实际上，这个字段并不是以这种方式使用的。今天的路由器速度很快，转发数据报所需的时间通常不到一秒钟；测量数据报“生存”的时间是不切实际的。相反，此字段用作数据报的“最大跃点计数”。路由器每次处理数据报时，它都会将TTL字段的值减少一。如果这样做导致字段为零，则称数据报已过期。它被丢弃，通常会发送一条ICMP超时消息，通知消息的发起者发生了这种情况。

TTL字段是保护网络免受路由器环路影响的主要机制之一（有关TTL如何帮助IP处理路由器环路的更多信息，请参阅ICMP超时消息的描述。）

<u>**服务类型（TOS）字段**</u>

这个单字节字段最初旨在为IP数据报交付提供某些服务质量特性。它允许用信息标记IP数据报，不仅表明它们的优先级，还表明它们应该以何种首选方式传递。如表57（和图86）所示，它被划分为若干子字段。

长期以来，缺乏服务质量特性一直被视为IP的弱点。但正如我们在表57中看到的那样，这些特性从一开始就内置于IP中。这是怎么回事？答案是，尽管该字段早在20世纪80年代初就在标准中定义，但它并没有被硬件和软件广泛使用。多年来，它只是在位中全部为零的情况下传递，大多数情况下都被忽略了。

​                                                   <u>**表57：IPv4服务类型（TOS）字段的原始定义**</u>

| **Subfield Name** | **Size (bytes)** | **Description**                                                                      |
| ----------------- | ---------------- | ------------------------------------------------------------------------------------ |
| ***Precedence\*** | 3/8 (3 bits)     | ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\aa3648cf.png) |
| ***D\***          | 1/8 (1 bit)      | ***Delay:\***延迟：设置为0以请求“正常”延迟交付；如果请求低延迟交付，则设置为1                                      |
| ***T\***          | 1/8 (1 bit)      | ***Throughput:\*** 设置为0以请求“正常”交付吞吐量；如果请求更高的吞吐量传递，则设置为1。                              |
| ***R\***          | 1/8 (1 bit)      | ***Reliability:\*** 设置为0以请求交付时的“正常”可靠性；如果要求更高的可靠性交付，则设置为1。                           |
| ***Reserved\***   | 2/8 (2 bits)     | ***Reserved:\*** Not used.                                                           |

IETF看到该字段未使用，试图恢复其使用。1998年，RFC 2474重新定义了TOS字段的前六位，以支持称为区分服务（DS）的技术。在DS下，TOS字段中的值称为代码点，并与不同的服务级别相关联。这开始变得相当复杂，因此如果需要所有详细信息，请参阅RFC 2474。

了解IP数据报格式是排除IP网络故障的重要部分。有关如何在数据报中使用IP选项的详细信息，请务必参阅以下关于选项的主题；有关碎片的主题，请参阅有关碎片相关字段（如标识、碎片偏移和更多碎片）使用的更多上下文。

###### 3.1.2.2-3 IP数据报选项和选项格式（部分：1 2 3）

所有IP数据报必须包含标准的20字节报头，其中包含关键信息，如数据报的源地址和目标地址、碎片控制参数、长度信息等。除了这些不变的字段之外，IPv4的创建者还可以添加选项，以在IP处理数据报的方式上提供额外的灵活性。当然，使用这些选项是可选的。J然而，所有处理IP数据报的设备必须能够正确读取和处理它们。

IP数据报可能包含零个、一个或多个选项，这就构成了IP头变量中options字段的总长度。每个选项可以是单字节长，也可以是多字节长，具体取决于该选项需要传达多少信息。当包含多个选项时，它们只是连接在一起，并作为一个整体放入选项字段中。由于IP标头必须是32位的倍数，如果所有选项中的位数合计不是32位的整数倍，则包含填充字段。

<u>**IP选项格式**</u>

每个IP选项都有自己的子字段格式，通常结构如表58和图87所示。对于大多数选项，使用所有三个子字段：选项类型、选项长度和选项数据。然而，对于一些简单的选项，不需要这种复杂的子结构。在这些情况下，选项类型本身传递所有所需信息，因此选项类型字段单独显示，而选项长度和选项数据子字段被省略。

​                                                           **表58：互联网协议版本4（IPv4）选项格式**

| **Subfield Name**    | **Size (bytes)** | **Description**                                                                          |
| -------------------- | ---------------- | ---------------------------------------------------------------------------------------- |
| ***Option Type\***   | 1                | ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\aa3648cf (1).png) |
| ***Option Length\*** | 0 or 1           | ***Option Length:\*** 对于可变长度选项，表示整个选项的大小，包括此处显示的所有三个子字段，以字节为单位                           |
| ***Option Data\***   | 0 or Variable    | ***Option Data:\*** 对于可变长度选项，包含作为选项一部分发送的数据。                                             |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipoptionformat.png)

​                                                        **图87：互联网协议版本4（IPv4）选项格式**

此图显示IPv4选项的完整字段格式。注意，一些简单的选项可能只包含Option Type子字段，而Option Length和Option Data子字段被省略。

<u>**IP选项**</u>

表59列出了最常见的IPv4选项，显示了每个选项的选项类别、选项编号和长度（长度为1表示仅由选项类型字段组成的选项），并简要描述了每个选项是如何使用的。

​                                                      **表59:Internet协议版本4（IPv4）选项**

| **Option Class** | **Option Number** | **Length (bytes)** | **Option Name**       | **Description**                                                                                           |
| ---------------- | ----------------- | ------------------ | --------------------- | --------------------------------------------------------------------------------------------------------- |
| **0**            | **0**             | 1                  | *End Of Options List* | 仅包含一个零字节的选项，用于标记选项列表的结尾。                                                                                  |
| **0**            | **1**             | 1                  | *No Operation*        | 一个“虚拟选项”，用作“内部填充”，用于在需要时在32位边界上对齐某些选项。                                                                    |
| **0**            | **2**             | 11                 | *Security*            | 为安全提供的一种选项，用于指示IP数据报的安全分类。                                                                                |
| **0**            | **3**             | Variable           | *Loose Source Route*  | IP数据报源路由的两个选项之一。有关说明，请参见下文。                                                                               |
| **0**            | **7**             | Variable           | *Record Route*        | 此选项允许数据报使用的路由记录在数据报本身的报头中。如果源设备发送一个包含此选项的数据报，则“处理”该数据报的每个路由器都会将其IP地址添加到此选项。然后，接收方可以提取IP地址列表，以查看数据报所采用的路由。 |
| **0**            | **9**             | Variable           | *Strict Source Route* | 请注意，这个选项的长度是由发端设备设置的。当数据报被路由时，它不能被扩大，如果它在到达目的地之前就 "填满 "了，那么将只记录部分路由。                                      |
| **2**            | **4**             | Variable           | *Timestamp*           | 这个选项类似于记录路由选项。然而，处理数据报的每个设备不是在选项中插入它的IP地址，而是插入一个时间戳，所以收件人可以看到数据报在路由器之间旅行了多长时间。                            |
| **2**            | **18**            | 12                 | *Traceroute*          | 用于traceroute实用程序的增强实现，如RFC 1393所述。另请参阅ICMP traceroute消息的主题。                                               |

**关键概念：**每个IPv4数据报都有一个20字节的强制标头，并且可能还包括一个或多个选项。每个选项都有自己的字段格式，大多数字段的大小都是可变的。

<u>**IP选项和源路由**</u>

通常，IP数据报的路由没有来自设备的关于数据报从源到目标的路径的任何特定指示。路由器的工作就是使用路由协议来找出这些细节。然而，在某些情况下，让数据报的源指定数据报通过网络的路由可能是有利的。这称为源路由。

有两个IP选项支持源路由。在每个选项中，都包含一个IP地址列表，指定必须使用哪些路由器才能到达目的地。当使用严格的源路由时，这意味着必须按顺序准确使用选项中指定的路径，而不允许其他路由器处理数据报。相比之下，松散源路由指定了必须按顺序遵循的IP地址列表，但允许在列表上的设备之间有中间跳。

有关每个选项类型使用的确切结构的完整详细信息，请参阅RFC 791。

###### 3.1.2.3 IP数据报大小、最大传输单元（MTU）、分片和重新组合

IP 的主要职责是在互联设备之间传递数据。正如我们在上一节中看到的，这需要将从更高层接收到的数据封装到 IP 数据报中进行传输。然后这些数据报被向下传递到数据链路层，在那里它们通过物理网络链路发送。

为了使其正常工作，每个数据报必须足够小以适应底层技术的帧格式。如果消息大于底层网络的最大帧大小，则可能需要将 IP 消息分解为多个数据报，这一过程称为分片。然后将数据报单独发送并重新组合成原始消息。

Internet 协议旨在管理数据报的大小，并允许以无缝方式进行分段和重组。在本节中，我将探讨与管理 IP 数据报大小相关的问题。我首先概述了数据报大小问题和网络最大传输单元 (MTU) 的重要概念，讨论了为什么需要分段。然后，我描述了要传输的 IP 消息被源设备和可能的路由器沿到达目的地的路径分段的过程，然后概述了接收者如何重新组装它们。

**背景信息**：解释分段和重组需要对 IP 数据报的基本格式及其包含的一些字段有所了解。如果您还没有阅读描述 IP 数据报一般格式的主题，您可能希望在继续之前查看它。

###### 3.1.2.3-1 IP 数据报大小、最大传输单元 (MTU) 和分片概述（部分：1 2 3 4）

作为 TCP/IP 协议套件的核心网络层协议，IP 旨在实现潜在的大型设备互联网络。当我们使用 IP 时，我们习惯了主机能够来回发送信息的概念，即使它们可能很远，并且数据可能需要在它们之间的许多设备上传输。尽管我们通常可以将 TCP/IP 互联网视为一个大型的、抽象的设备“虚拟网络”，但我们必须始终记住，在网络层之下，数据总是通过一个或多个物理网络传输。互联网协议的实施也必须考虑到这一现实。

为了使用 IP 发送消息，我们将高层数据封装成 IP 数据报。然后，这些数据报必须向下发送到数据链路层，在那里它们被进一步封装到将用于物理传送它们的任何技术的帧中，或者直接传送到它们的目的地，或者间接传送到它们旅程的下一个中间步骤给他们的预期收件人。数据链路层实现将整个 IP 数据报放入其帧格式的数据部分（有效负载），就像 IP 将传输层消息、传输头和所有内容放入其 IP 数据字段一样。这立即向我们提出了一个潜在问题：将 IP 数据报的大小与底层数据链路层帧大小的大小相匹配。

<u>**将 IP 数据报大小与底层网络帧大小匹配**</u>
设备用于连接其他设备的底层网络可以是 LAN 连接（如以太网或令牌环）、无线 LAN 链接（如 802.11）或拨号、DSL、T-1 或其他 WAN 连接。每个物理网络一般都会使用自己的帧格式，每种格式都有一个帧可以发送多少数据的限制。如果 IP 数据报对于数据链路层帧格式的有效负载部分来说太大了，我们就有问题了！

例如，考虑一个 FDDI。 FDDI 中数据字段的最大大小约为 4,470，具体取决于是否使用 SNAP。这意味着 FDDI 可以处理高达 4,470 字节的 IP 数据报。相比之下，常规以太网帧使用的帧格式将其发送的有效负载大小限制为 1,500 字节。这意味着以太网无法处理大小超过 1,500 字节的 IP 数据报。

现在，请记住，在通过互联网发送数据报时，它可能会通过多个物理网络。例如，要访问 Internet 上的站点，我们通常通过本地路由器发送请求，然后连接到最终将请求中继到 Internet 站点的其他路由器。转发数据报时的每一跳都可能使用不同的物理网络，具有不同的最大底层帧大小。

网络层协议背后的整个想法是实现“虚拟网络”的概念，即使距离很远，设备也可以在其中进行通信。这意味着高层不需要担心底层数据链路层技术的大小限制等细节。但是，必须有人担心。此任务属于 Internet 协议。

<u>**最大传输单元 (MTU) 和数据报分片**</u>

IP 互联网上所有设备的 IP 实施需要了解该实施所使用的技术的能力，以便与其他设备直接进行数据链路层连接。此限制称为网络的最大传输单元 (MTU)。该术语有时也被视为最大传输单位。

如果 IP 层接收到要通过互联网发送的消息，它会查看消息的大小，然后计算在添加 IP 标头所需的 20 或更多字节后 IP 数据报的大小。如果总长度大于底层网络的 MTU，IP 层会将消息分片成多个 IP 分片。因此，如果主机使用以太网 LAN 连接到其本地网络，它可能会使用 1,500 的 MTU 来处理 IP 数据报，并将任何更大的数据分段。图 88 显示了不同 MTU 和分段的示例。

**关键概念：**可以通过物理网络传输的最大 IP 数据报的大小称为该网络的最大传输单元 (MTU)。如果数据报从具有高 MTU 的网络传递到具有低 MTU 的网络，则必须对其进行分段以适应具有较小 MTU 的网络。

由于设备之间路径上的某些物理网络的 MTU 可能比其他网络小，因此可能需要多次分段。例如，假设源设备要发送 12,000 字节长的 IP 消息。其本地连接的 MTU 为 3,300 字节。它必须将此消息分成四个片段进行传输：三个大约 3,300 字节长，第四个大约 2,100 字节长。 （通过忽略所需的额外标头，我过于简单化了；下一个主题包括碎片过程的全部细节。）

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipmtu.png)

​                                                                  <u>**图 88：IP 最大传输单元 (MTU) 和分段**</u>

在这个简单的示例中，设备 A 通过一个由一个路由器和两个物理链路组成的小型互联网向设备 B 发送数据。从 A 到路由器的链路具有 3,300 字节的 MTU，但从路由器到 B 的 MTU 只有 1,300 字节。因此，任何超过 1,300 字节的 IP 数据报都需要分段。

<u>**多级分片**</u>

虽然上述片段正在传输中，但它们可能需要在物理网络的 MTU 仅为 1,300 字节的两个路由器之间传递一个跃点。在这种情况下，每个片段将再次需要被分段。 3,300 字节的片段最终将分成三个片段（大约 1,300 字节中的两个和大约 700 字节中的一个），最终的 2,100 字节片段将成为 1300 字节和 800 字节的片段。所以我们最终会得到十一个（3*3+1*2），而不是四个片段！如图 89 所示。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipfragmentationreassembly.png)

​                                                                                       **图 89：IPv4 数据报分段**

此示例说明了大型 IP 数据报的两步分段。方框代表数据报或数据报片段，并按比例显示。原始数据报大小为 12,000 字节，由灰色的大框表示。为了通过第一条本地链路传输此数据，设备 A 将其拆分为四个片段，在左侧以四种原色显示。第一个路由器必须将它们中的每一个分割成更小的片段，以便通过 1,300 字节的 MTU 链路发送它们，如底部所示。请注意，第二个路由器不会重新组装 1,300 字节的片段，即使它与设备 B 的链接具有 3,300 字节的 MTU。

（图 90 显示了创建此示例中的片段的过程。）

<u>**互联网最小 MTU：576 字节**</u>

每个路由器必须能够根据需要对 IP 数据报进行分段，以处理它们所连接的网络所使用的最大 MTU 大小。至少还需要路由器来处理至少 576 字节的 MTU。此值在 RFC 791 中指定，并被选择为允许至少 512 字节的“合理大小”数据块，以及标准 IP 标头和选项的空间。由于它是 IP 标准中指定的最小大小，因此 576 字节已成为用于 IP 数据报的常见默认 MTU 值。即使主机通过 MTU 大于 576 的本地网络连接，它也可以选择使用 576 的 MTU 值，以确保中间路由器不需要进一步的分段。

**！！！！！请注意，虽然中间路由器可能会进一步对已经分段的 IP 消息进行分段，但中间设备不会重新组装分段。重组仅由接收设备完成。这有一些优点和一些缺点，我们将在检查重新组装过程时看到。**

<u>**MTU 路径发现**</u>
当尝试发送大量数据时，消息传输的效率变得很重要。我们发送的每个 IP 数据报越大，浪费在头字段等开销上的字节百分比就越小。这意味着理想情况下，我们希望使用尽可能大的 MTU 而不会发生碎片。

确定用于两个设备之间的路由的最佳 MTU 需要知道该路由上每个链路的 MTU——连接的端点根本没有的信息。然而，他们可以使用一种称为路径 MTU 发现的巧妙技术来确定整个路由的 MTU。我称这种技术为“clever”，因为它不使用为确定路由 MTU 的特定目的而设计的任何特殊功能，而是使用 TCP/IP 互联网控制消息协议 (ICMP) 中内置的错误报告机制。

ICMPv4 中定义的消息类型之一是 Destination Unreachable 消息，它在无法传递 IP 数据报的各种条件下返回。其中一种情况是发送的数据报太大而无法由路由器通过物理链路转发，但设置了不分片 (DF) 标志以防止分片。在这种情况下，必须丢弃数据报，并将 Destination Unreachable 消息发送回源。设备可以通过使用不同大小的数据报测试路径来利用此功能，以查看它们在被拒绝之前必须有多大。

源节点通常发送具有其本地物理链路的 MTU 的数据报，因为它表示进出该设备的任何路径的 MTU 的上限。如果此过程没有任何错误，则它知道它可以将该值用于未来的数据报到该目的地。如果它返回任何 Destination Unreachable - Fragmentation Needed 和 DF Set 消息，这意味着它与目标之间的某些其他链路具有较小的 MTU。它再次尝试使用较小的数据报大小，并继续直到找到可以在路径上使用的最大 MTU。

###### 3.1.2.3-2 IP 消息分片过程（部分：1 2 3 4）

当 IP 数据报对于其下一阶段使用的底层数据链路层技术的最大传输单元 (MTU) 来说太大时，必须先将其分段，然后才能通过网络发送。要传输的高层消息不是在单个 IP 数据报中发送，而是分解成称为片段的片段，这些片段分别发送。在某些情况下，片段本身可能需要进一步分段。

<u>**碎片化问题和担忧**</u>
碎片化对于实现独立于较低层细节的网络层互联网是必要的，但会给 IP 带来显着的复杂性。请记住，IP 是一种不可靠的无连接协议。 IP 数据报在从源到目的地的途中可以采用多条路由中的任何一条，有些甚至可能根本无法到达目的地。当我们将消息分段时，我们将单个数据报分成多个，这引入了几个需要关注的新问题：

- 排序和放置：片段通常会按从消息开头到结尾的顺序发送，但它们不一定按照发送的顺序显示。接收设备必须能够确定片段的顺序，才能以正确的顺序重新组装它们。事实上，一些实现首先发送最后一个片段，因此接收设备将立即知道原始完整数据报的完整大小。这使得跟踪段的顺序变得更加重要。

- 分段消息的分离：源设备可能需要一次发送多个分段消息；或者，它可能会发送多个在途中分段的数据报。这意味着目的地可能正在接收必须重新组合在一起的多组片段。想象一个盒子，里面混合了两个、三个或更多拼图游戏的碎片，你就理解了这个问题。

- 完成：目标设备必须能够判断它何时收到所有碎片，以便知道何时开始重新组装（或者如果没有得到所有碎片则何时放弃）。

为了解决这些问题并允许正确重组分段消息，IP 在 IP 格式标头中包含几个字段，用于将有关分段的信息从源传送到目的地。其中一些包含消息的所有片段的共同值，而另一些对于每个片段都不同。

<u>**IP 分片过程：一个例子**</u>

执行分片的设备遵循特定的算法将消息分成片段进行传输。分片过程的具体实现取决于设备。让我们以上一个主题中的相同示例为例，一条 12,000 字节长度的 IP 消息（包括 20 字节的 IP 标头）需要通过 MTU 为 3,300 的链路发送。以下是执行此分段的典型方法（您可能会发现图 90 中的插图很有帮助）：

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipfragmentation.png)

​                                                                             **图 90：IPv4 数据报分片过程**

在此图中，显示了每个片段的 MF 和片段偏移字段以供参考。数据字段按比例显示（每个字段的长度与片段中的字节数成正比。）

1. 创建第一个片段：第一个片段是通过获取 12,000 字节 IP 数据报的前 3,300 个字节创建的。这包括原始标头，它成为第一个片段的 IP 标头（某些字段已更改，如下所述）。因此，第一个片段中有 3,280 字节的数据。剩下 8,700 字节需要封装（11,980 减去 3,280）。

2. 创建第二个片段：接下来的 3,280 字节数据取自构建第一个片段后剩余的 8,700 个字节，并与新标头配对以创建片段 #2。剩下 5,420 个字节。

3. 创建第三个片段：第三个片段是从接下来的 3,280 字节数据创建的，带有 20 字节的标头。这留下了 2,140 字节的数据。

4. 创建第四个片段：剩余的 2,140 字节放入第四个片段中，当然还有一个 20 字节的标头。
   我想在这里强调两个重点。首先，通过将原始 IP 消息完全封装到分片的数据字段中，IP 分片不起作用。如果这样做，第一个片段的数据字段的前 20 个字节将包含原始 IP 标头。这种技术被一些其他协议使用，例如 PPP 多链路协议，但不被 IP 使用。原始 IP 报头被“转换”为第一个片段的 IP 报头。

其次，请注意传输的字节总数增加了：我们发送的是 12,060 字节（3,300 乘以三加上 2,160）而不是 12,000。额外的 60 字节来自第二个、第三个和第四个片段中的附加标头。 （如果标题包含选项，理论上大小的增加可能更大。）

**<u>与分片相关的 IP 数据报头字段</u>**

当发送设备或路由器对数据报进行分段时，它必须提供信息，使接收设备能够识别分段并将它们重新组合成最初发送的数据报。该信息由分段设备记录在 IP 数据报头中的多个字段中。

<u>**总长度**</u>
分片后，该字段表示每个分片的长度，而不是整个消息的长度。通常，选择片段大小以匹配以字节为单位的 MTU 值。但是，片段的长度必须是 8 的倍数，以允许正确的偏移规范（见下文）。最后一个片段通常比其他片段短，因为它将包含一个“剩余”片段，除非消息长度恰好是片段大小的整数倍。

<u>**鉴别**</u>
为了解决“一个盒子里有很多拼图游戏”的问题，每个被分割的消息都分配了一个唯一的标识符。考虑一下这就像在将拼图扔进盒子之前在每个拼图的底部写一个不同的数字。该值被放置在每个已发送片段的 IP 标头中的标识字段中。标识字段为 16 位宽，因此总共可以使用 65,536 个不同的标识符。

显然，我们希望确保在同一源和目标之间发送的每条消息都具有不同的标识符。源可以决定它如何生成唯一标识符。这可以通过像每次创建新的片段集时递增的计数器这样简单的东西来完成。

<u>**更多片段**</u>
对于除最后一个片段之外的所有片段，此标志设置为 1，将其设置为 0。当看到更多片段标志中值为 0 的片段时，目标知道它已收到消息的最后一个片段.

<u>**片段偏移**</u>
该字段通过向接收设备指示每个特定片段应放置在整个消息中的哪个位置来解决片段排序问题。该字段为 13 位宽，因此偏移量可以从 0 到 8191。片段以 8 字节为单位指定，这就是为什么片段长度必须是 8 的倍数。不巧的是，8191 * 8 是 65,528，大约是最大值IP 数据报允许的大小。

让我们从上面举同样的例子。第一个片段的片段偏移量为 0。第二个片段的偏移量为 410（3,280 除以 8）。第三个的偏移量为 820（6,560 除以 8）。第四个的偏移量为 1230。

<u>**关键概念**</u>：当 MTU 要求强制数据报被分段时，它会被分成几个较小的 IP 数据报，每个数据报都包含原始数据报的一部分。原始数据报的报头变为第一个分片的报头，并为其他分片创建新的报头。每个都设置为相同的标识值，以将它们标记为相同原始数据报的一部分。每个的 Fragment Offset 设置为该 Fragment 在原始中所属的位置。对于除最后一个以外的所有片段，More Fragments 字段设置为 1，以便让接收者知道它何时收到了所有片段。

<u>**与分段相关的 IP 标头标志**</u>

除了上述字段之外，IP 标头中还有几个与分片相关的标志。

<u>**复制的标志**</u>
如果必须对包含选项的数据报进行分段，则可以将一些选项复制到每个分段中。这由每个选项字段中的已复制标志控制。

<u>**不要碎片化标志**</u>
发送设备可以将此标志设置为 1，以指定数据报在传输过程中不被分段。这可以在某些情况下使用，其中整个消息必须完整地传递，因为片段可能没有意义。如果目标设备的 IP 实现受限且无法重新组装片段，也可以使用它，也可以用于测试链路的最大传输单元 (MTU)。但是，通常设备不关心碎片，并且该字段保留为零。

如果路由器遇到一个数据报太大而无法通过下一个物理网络但 Don't Fragment 位设置为 1 时会发生什么？它不能分割数据报，也不能传递它，所以它被“卡住”了。它通常会丢弃数据报，然后发回一个特殊的 ICMP Destination Unreachable 错误消息：“Fragmentation Needed and Don't Fragment Bit Set”。如上一节所述，这在 MTU 路径发现中使用。

###### 3.1.2.3-3 IP消息重组过程（部分：1 2）

当一个数据报被原始设备或一个或多个传输数据报的路由器分片时，它就变成了多个分片数据报。整个消息的目的地必须收集这些片段，然后将它们重新组合成原始消息。重新组装是通过使用我们在前面主题中看到的字段中的特殊信息来完成的，以帮助我们“将拼图重新组合在一起”。

<u>**碎片和重组的不对称**</u>
重要的是要理解，虽然重组是碎片化的补充，但这两个过程并不是对称的。两者之间的主要区别在于，虽然中间路由器可以对单个数据报进行分段或进一步对已经是分段的数据报进行分段，但中间设备不执行重组。这仅由 IP 消息的最终目的地完成。因此，如果物理网络一侧的中间路由器上的数据报具有 1,300 的 MTU，导致 3,300 字节数据报的碎片，则此 1,300 MTU 链路另一端的路由器不会将 3,000 字节数据报恢复到其原始状态。它将在 Internet 上发送所有 1,300 字节的片段，如图 89 所示。

决定以这种方式实施 IP 重组的原因有很多。也许最重要的一点是，片段可以采用不同的路由从源到目的地，因此任何给定的路由器可能无法看到消息中的所有片段。另一个原因是路由器需要担心重新组装片段会增加它们的复杂性。最后，正如我们将看到的，消息的重组要求我们在发送重组消息之前等待所有片段。让路由器这样做会减慢路由速度。由于路由器不会重新组装，它们可以立即将所有片段转发给最终接收者。

然而，这种设计也有缺点。一是与中间重组相比，它会导致更多更小的碎片在更长的路线上传播。这增加了片段丢失和整个消息被丢弃的机会。另一个是数据链路层帧容量利用方面的潜在低效。在上面的示例中，1,300 字节的片段不会在 1,000-MTU 链路的末端重新组合成 3,300 字节的数据报。如果该链接之后的下一个链接的 MTU 也为 3,300，我们将不得不发送三个帧，每个帧都封装一个 1,300 字节的片段，而不是一个更大的帧，这会稍微慢一些。

**关键概念：**在 IPv4 中，可以由路由器在 IP 数据报的源和目标之间执行分段，但重组只能由目标设备完成。

<u>**重组过程**</u>

正如我们在查看碎片化的工作原理时所看到的，它涉及到相当多的复杂性。当消息被分段时，会填写几个 IP 头字段，以便为接收设备提供正确重组分段所需的信息。接收设备遵循一个过程来跟踪接收到的片段，并建立其从源设备接收到的全部消息的副本。它的大部分工作都围绕着处理与 IP 作为不可靠协议相关的潜在困难。

重装过程的实现细节因设备而异，但一般包括以下功能：

- 片段识别和片段消息识别：当接收者第一次看到更多片段位设置为 1 或片段偏移量为非零值的数据报时，接收者就知道它已收到消息片段。它根据以下内容识别消息：源 IP 地址和目标 IP 地址；标头中指定的协议；以及发件人生成的标识字段。

- 缓冲区初始化：接收设备初始化一个缓冲区，它可以在接收到消息片段时存储它们。它可能使用一个特殊的表来跟踪该缓冲区的哪些部分已被接收到的片段填充。通过这样做，它知道缓冲区何时部分被接收到的片段填充以及何时完全填满。

- 定时器初始化：接收设备为消息的重组设置一个定时器。由于某些片段可能永远不会出现，因此此计时器可确保设备不会“永远”等待尝试重新组装消息。

- 片段接收和处理：每当此消息的片段到达时（如它具有与第一个片段相同的源和目标地址、协议和标识所指示的那样），该片段被处理。它被插入消息缓冲区中由其片段偏移字段指示的位置。该设备还记下已收到这部分消息的情况。

当整个缓冲区被填满并且接收到更多片段位设置为零的片段时，重组完成，表明它是数据报的最后一个片段。重新组装的数据报然后像正常的、未分段的数据报一样被处理。另一方面，如果重组计时器到期而任何片段丢失，则无法重建消息。碎片被丢弃，并生成 ICMP Time Exceeded 消息。由于 IP 是不可靠的，它依赖于 TCP 等更高层协议来确定消息没有被正确接收，然后重新传输它。

###### 3.1.2.4 IP数据报传输和路由

IP 数据报封装和寻址的基本功能有时被比作将一封信放入信封，然后在上面写上收件人的地址。一旦我们的 IP 数据报“信封”被填满并贴上标签，它就可以发送了，但它仍然放在我们的办公桌上。 IP 的最后一个主要功能是将信封从我们那里送到我们的预期收件人。这是数据报传递的过程。当接收者不在我们的本地网络上时，这种传递要求数据报从我们的网络路由到目的地所在的网络。

在本节中，我将讨论 IP 如何通过互联网路由数据报的一些细节。我首先概述了该过程，并对比了设备之间的直接和间接数据传输。我讨论了用于通过 Internet 路由数据报的主要方法，并简要解释了 IP 路由表是如何构建和维护的。我讨论了使用 CIDR 从“有类”寻址到无类寻址如何影响路由。

相关信息：请注意，本节内容很简短，主要关注与 IP 工作方式直接相关的路由问题。路由是网络中一个复杂而重要的主题，您将在讨论 TCP/IP 路由/网关协议的部分中找到更多有关它的信息。我试图通过在此处放置太多有关路由过程的信息来避免重复该部分。

###### 3.1.2.4-1 IP 数据报直接传递和间接传递（路由）（部分：1 2 3）

互联网协议的总体工作是通过设备的互联网传输来自更高层协议的消息。 这些消息必须被打包和寻址，如果需要的话，必须分段，然后它们必须被传递。 交付过程可以是简单的也可以是复杂的，这取决于源设备和目标设备的接近程度。

<u>**数据报传送类型**</u>
从概念上讲，我们可以将所有 IP 数据报传送分为两种一般类型，如图 91 所示：

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipdirectindirect.png)

​                                            **图 91：IP 数据报的直接和间接（路由）传送**

此图显示了 IP 数据报传送的三个示例。第一次传输（以绿色突出显示）显示本地网络上两个设备之间的直接传输。第二个（紫色）显示在本地网络内的间接传递，在由路由器分隔的客户端和服务器之间。第三个显示了更远的间接交付，在本地网络上的客户端和 Internet 上的服务器之间。

- 直接数据报传递：当数据报在同一物理网络上的两个设备之间发送时，数据报可以直接从源传递到目的地。想象一下，你想给街上的邻居寄一封信。您可能不会费心通过邮局邮寄；你只需把邻居的名字写在信封上，然后直接贴在他或她的邮箱里。

- 间接数据报传递：当两个设备不在同一个物理网络上时，数据报从一个到另一个的传递是间接的。由于源设备在其本地网络上看不到目的地，因此它必须通过一个或多个中间设备发送数据报来传递它。间接递送类似于给不同城市的朋友寄一封信。你不自己投递——你把它放进邮政系统。这封信经过邮政系统，可能需要几个中间步骤，最终到达您朋友的附近，邮递员将其放入他或她的邮箱。

<u>**比较直接和间接交付**</u>

直接交付显然是其中更简单的一种。源只是将 IP 数据报向下发送到它的数据链路层实现。数据链路层将数据报封装在一个帧中，该帧通过物理网络直接发送到接收方的数据链路层，然后再向上传递到 IP 层。

间接传递要复杂得多，因为我们不能将数据直接发送给接收者。事实上，我们通常甚至不知道收件人的确切位置。当然，我们有它的地址，但我们可能不知道它在哪个网络上，或者该网络相对于我们自己的网络在哪里。 （如果我告诉你我的地址，你会知道它在佛蒙特州本宁顿的某个地方，但你能找到吗？）就像在信封类比中依靠邮政系统一样，我们必须依靠互联网本身来间接传递数据报。与邮政系统一样，IP 的力量在于您无需知道如何将信件寄给收件人；您只需将其放入系统即可。

实现这种间接传递“魔力”的设备通常称为路由器，而间接传递通常称为路由。就像将一封信委托给您当地的邮递员或邮箱一样，需要发送到远程设备的主机通常会将数据报发送到其本地路由器。路由器连接到一个或多个其他路由器，它们每个都维护有关将数据报发送到何处的信息，以便它们到达最终目的地。

与远程设备（例如 Internet 上的设备或通过 WAN 链接的设备）通信时，几乎总是需要间接交付。但是，如果该设备未在第二层直接连接到您的设备，甚至可能需要发送到您办公室隔壁房间的设备。

**注意：**过去，路由器通常被称为网关。今天，这个术语更普遍地可以指以各种方式连接网络的设备。您有时仍会听到称为网关的路由器——尤其是在“默认网关”等术语的上下文中——但由于它含糊不清，因此首选术语路由器。

<u>**数据报路由与寻址的关系**</u>

显然，每次必须发送数据报时，我们都必须首先确定是否可以直接发送，或者是否需要路由。还记得所有关于IP地址的详细信息吗？好吧，这就是回报所在。同样，IP地址有时很难理解网络ID和主机ID位的划分，以及子网掩码，这使得设备能够快速确定其是否与目标接收方在同一网络上：

- 传统的“分类”寻址：我们通过查看前几个位来了解每个地址的类别。这告诉我们地址的哪些位是网络ID。如果目的地的网络ID与我们自己的相同，则收件人在同一网络上；否则，它就不是。

- 子网“Classful”寻址：我们使用子网掩码来确定网络ID和子网ID以及目标地址的ID。如果网络ID和子网相同，则收件人位于同一子网中。如果只有网络ID相同，则收件人位于同一网络的不同子网中。如果网络ID不同，则目标完全位于不同的网络上。

- 无类别寻址：除了没有子网之外，基本技术与子网“有类别”寻址相同。我们使用“斜杠编号”来确定地址的哪一部分是网络ID，并像以前一样比较源和目标。然而，这里有一些复杂的问题，我将在无类环境中的路由主题中详细讨论。

**关键概念：**IP数据报的交付分为两类：直接和间接。当两台设备位于同一物理网络上时，可以直接传送。如果不是这样，则需要间接传递（通常称为路由）将数据报从源传输到目标。设备可以通过查看目的地的IP地址以及补充信息（如子网掩码）来判断需要哪种类型的传送，该子网掩码告诉设备其所在的网络或子网。

确定需要哪种类型的传递是源决定向何处发送数据报的第一步。如果它意识到目的地在同一本地网络上，它将直接在数据链路层将数据报寻址给接收方。否则，它将把数据报发送到它所连接的路由器之一的数据链路层地址。数据报的IP地址仍然是最终目的地的IP地址。IP地址和数据链路层地址之间的映射是使用TCP/IP地址解析协议（ARP）完成的。

我还应该澄清一件事，即直接交付和间接交付之间的区别。在后一种情况下，路由是为了将数据报发送到接收方的本地网络。数据报路由到接收方的物理网络后，由接收方的本地路由器发送给接收方。所以，你可以说间接交付包括直接交付作为其最后一步。

下一个主题将更详细地讨论IP路由过程和概念。

注意：严格来说，源设备和目标设备之间的任何传递过程都可以被视为路由，即使它们位于同一网络上。然而，路由过程通常更具体地指代上文所述的间接交付。

###### 3.1.2.4-2 IP 路由概念和下一跳路由的过程（部分：1 2）

当数据报在不是同一物理网络上的源设备和目标设备之间发送时，数据报必须在设备之间间接传递，这一过程称为路由。正是这种在可能很远的设备之间路由信息的能力，使得IP能够创建等效于虚拟互联网的网络，该网络可能跨越数千个物理网络，甚至可以让地球两端的设备进行通信。一般来说，路由的过程太复杂，无法在这里详细介绍，但我想简要介绍一下关键的IP路由概念。

<u>**IP路由和跃点概述**</u>

为了继续我们的邮政系统类比，我可以从美国的家里给印度等地的人发一封信，两国的邮政系统将努力把信送到目的地。然而，当我把一封信投进邮箱时，并不像有人出现，抓起信，用手把它送到印度的正确地址。这封信从邮筒寄到我当地的邮局。从那里，它可能会去一个地区配送中心，然后再从那里去一个国际交通枢纽。它可能（很可能）通过一个中间国家流向印度。到达印度后，印度邮政系统使用自己的办公室和设施网络将信件发送到目的地。信封从一个位置“跳跃”到另一个位置，直到到达目的地。

IP路由的工作方式非常相似。尽管IP允许设备通过间接传递在互联网上“连接”，但所有实际的数据报通信都是通过使用路由器的物理网络进行的。我们不知道目标设备的网络具体在哪里，而且我们肯定没有任何方法直接连接到数千个网络中的每一个。相反，我们依赖于中间设备，它们以各种方式彼此物理连接，形成一个包含网络间数百万条路径的网格。为了把数据报送到它需要去的地方，它需要从一个路由器传送到下一个路由器，直到它到达目标设备的物理网络。这通常称为下一跳路由。该过程如图92所示。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\iphops.png)

​                                                                                     <u>**图92：IP数据报下一跳路由**</u>

这与图91中所示的图相同，只是这次我明确地显示了三个样本传输中的每一个的跳数。第一个（绿色）传输的直接传输只有一个跃点（请记住，交换机不计数，因为它在第三层不可见）。本地间接传送通过一个路由器，因此有两个跃点。在这种情况下，互联网交付有六个跳跃；实际的互联网路由可能要长得多。

<u>**下一跳路由的好处**</u>

这是IP如何工作的一个关键概念:路由是一步一步地完成的，一次一跳。当我们决定将一个数据报发送到一个遥远网络上的设备时，我们不知道数据报将经过的确切路径;我们只有足够的信息将它发送到我们所连接的正确路由器。然后，该路由器查看目的地的IP地址，并决定数据报下一步应该“跳”到哪里。这个过程会一直持续，直到数据报到达目标主机的网络。

下一跳路由乍一看似乎是一种在网络上通信数据报的奇怪方式。事实上，这也是IP如此强大的原因之一。在去往其他主机的每一步中，路由器只需要知道数据报的下一步在哪里。如果没有这个概念，每个设备和路由器都需要知道到互联网上其他主机的路径，这是非常不切实际的。

**关键概念:**IP数据报的间接传递使用一种称为下一跳路由的过程来完成，在这种过程中，每个消息从一个路由器传递到下一个路由器，直到它到达目的地的网络。这样做的主要优点是，每个路由器只需要知道哪个邻居路由器应该是给定数据报的下一个接收者，而不需要知道到每个目标网络的确切路由。

<u>**每一跳的数据报处理**</u>

如上所述，路由中的每个“跳”都包含对物理网络的遍历。当一个源将一个数据报发送到它的本地路由器后，路由器上的数据链路层将它传递到路由器的IP层。在那里，检查数据报的头，路由器决定下一个设备将把数据报发送到哪个设备。然后，它将数据传输回数据链路层，通过路由器的一个物理网络链路发送，通常是发送到另一个路由器。路由器要么有它所连接的路由器的物理地址的记录，要么使用ARP来确定这些地址。

<u>**路由器在IP数据报传递中的重要作用**</u>

与下一跳路由原理相关的另一个关键概念是，路由器被设计来完成路由，而不是主机。大多数主机只使用一个路由器连接到internet的其他部分。必须让每个主机都知道如何路由到其他主机，这将是一个维护噩梦。相反，主机只决定它们是在本地发送到自己的网络，还是发送到非本地网络。如果是后者，他们只需将数据报发送到路由器，并说“这里，你来处理这个”。如果一个主机与多个路由器有连接，它只需要知道对某些远程网络使用哪个路由器。路由器从主机接收数据报时如何决定如何处理数据报是下一个主题的主题。

###### 3.1.2.4-3 IP 路由和路由表（部分：1 2 3）

路由器负责转发IP互联网络上的流量。每个路由器接受来自不同来源的数据报，检查目的地的IP地址，并决定数据报需要采取的下一跳是什么，以便使它更接近最终目的地。那么一个问题自然就产生了:路由器如何知道在哪里发送不同的数据报?

每个路由器都维护一组信息，这些信息提供了不同网络id和它所连接的其他路由器之间的映射关系。这些信息包含在通常称为路由表的数据结构中。表中的每个条目(不出所料地称为路由条目)提供关于一个网络(或子网络或主机)的信息。它基本上是说“如果这个数据报的目的地在下面的网络中，那么您应该采取的下一跳是到下面的设备”。每当接收到一个数据报时，路由器会根据表中的路由表项检查它的目的IP地址，以决定将数据报发送到哪里，然后在下一跳发送它。

显然，该表中的条目越少，路由器决定如何处理数据报的速度就越快。(这是无类寻址的主要动机，它将路由聚合成“超级网络”，以减少路由器表的大小，我们将在下一个主题中看到。)有些路由器只连接到另外两台设备，所以它们没有太多的决定要做。通常，路由器会简单地从它的一个接口接收数据报，如果有必要，将它们发送到另一个接口。例如，考虑一个小公司的路由器充当三台主机和Internet之间的接口。从这个网络上的主机发送到路由器的任何数据报都需要经过路由器连接到ISP的路由器。

当一个路由器连接到两个以上的设备时，事情就变得相当复杂。如果使用其中一种路由器发送数据报，那么一些远程网络可能更容易访问。路由表不仅包含与路由器直接相连的网络的信息，还包含路由器“了解”到的更远网络的信息。

**关键概念:**路由器使用其内部路由表来决定如何路由数据报。该表包含指定路由数据报应该发送到哪个路由器以到达特定网络的条目。

<u>**互连网实例中的路由表**</u>

让我们考虑一个例子(见图93)，将路由器R1、R2和R3连接成一个“三角形”，这样每个路由器都可以直接发送到其他路由器，也可以发送到自己的本地网络。假设R1的局域网络是11.0.0.0/8,R2的局域网络是12.0.0.0/8,R3的局域网络是13.0.0.0/8。(我只是想把事情简单化。J) R1知道它看到的任何以11为第一个字节的数据报都在它的本地网络上。它还有一个路由条目，上面写着任何以“12”开头的IP地址都应该去R2，以“13”开头的IP地址都应该去R3。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\iprouting.png)

​                                                                                      **图93:IP路由和路由表**

这张图显示了一个小型、简单的互联网络，由四个局域网组成，每个局域网由一台路由器提供服务。每个路由表都列出了每个目标网络的数据报应该发送到的路由器，并且用颜色编码来匹配网络的颜色。注意，由于“三角形”的存在，R1、R2和R3中的每一个都可以互相发送。然而，R2和R3必须通过R1发送到R4，而R4必须使用R1到达另一个。

让我们假设R1也连接到另一个路由器R4，该路由器的本地网络为14.0.0.0/8。R1将有一个本地网络的条目。然而，R2和R3也需要知道如何到达14.0.0.0/8，即使它们不直接连接到它的路由器。最有可能的是，它们会有一个条目，说任何打算发送给14.0.0.0/8的数据报都应该发送给R1。然后R1将它们转发给R4。类似地，R4将通过R1发送任何用于12.0.0.0/8或13.0.0.0/8的通信。

<u>**路由确认**</u>

现在，假设这个过程扩展到处理数千个网络和路由器。路由器不仅需要知道要为每个网络使用哪种本地连接，还需要知道（如果可能的话）每个网络使用什么样的最佳连接。由于路由器在网格中互连，因此任何两个设备之间通常有多条路由，但我们希望尽可能采用最佳路由。这可能是最短的路线，最不拥挤的路线，或者根据其他标准被认为是最优的路线。

决定我们应该为不同的网络使用什么路由是一项重要但非常复杂的工作。路由器必须规划路由并交换有关路由和网络的信息，这可以通过多种方式实现。这是使用特殊的IP路由协议在IP中实现的。正是通过这些协议，R2和R3才能发现14.0.0.0/8的存在，并通过R1连接到它们。我在他们所属的章节中讨论了这些重要的“支持协议”。

**注意：**可路由协议和路由协议之间存在差异。IP是一种可路由协议，这意味着它的消息（数据报）可以路由。路由协议的示例是RIP或BGP，它们用于在路由器之间交换路由信息。

###### 3.1.2.4-4 子网或无类别寻址 (CIDR) 环境中的 IP 路由（部分：1 2）

IP地址主要有三类:“有类”、子网“有类”和无类。正如我们已经看到的，用于确定需要直接还是间接传递数据报的方法对于每种寻址类型是不同的。网络中使用的寻址类型也会影响路由器如何决定在互联网中转发流量。

创建传统的基于类的寻址方案的主要原因之一是它使寻址和路由都相对简单。我们必须记住，IPv4是在20世纪70年代末开发出来的，当时我们今天认为理所当然的廉价而强大的计算机硬件还处于科幻小说的领域。为了使互联网络正常工作，路由器必须能够查看IP地址并迅速决定如何处理它。

“高雅”的称呼就是为了使这成为可能。整个互联网只有两级层次结构:网络ID和主机ID。路由器可以通过查看任何IP地址的前四位来判断哪个位是网络ID，哪个是主机ID。然后，他们只需要查阅路由表来查找网络ID，并查看哪台路由器是到该网络的最佳路由。

对于互联网上的主要路由器来说，在传统寻址中加入子网并没有真正改变这一点，因为子网是组织内部的。在互联网上处理大量流量的主要路由器根本不考虑子网;子网所代表的附加层次结构只存在于选择使用子网的每个组织中的路由器。当决定如何处理组织网络中的数据报时，这些路由器不仅要提取IP地址的网络ID，还要提取子网ID。这告诉他们将数据报发送到哪个内部物理网络。

<u>**聚合路由及其对路由的影响**</u>

无类寻址正式称为无类域间路由(CIDR)。它的名称提到了路由而不是寻址，这证明CIDR的引入在很大程度上是为了提高路由的效率。这种改进是因为无类网络使用多级层次结构。每个网络可以被分解成子网络、子子网络等等。这意味着当我们在CIDR环境中决定如何路由时，我们也可以以分层的方式描述路由。许多较小的网络可以使用一个单独的、更高级别的网络描述来描述，该描述将它们全部表示给internet的其他路由器。这种技术有时称为路由聚合，可以减小路由表的大小。

让我们回顾一下我在CIDR寻址部分给出的详细示例。一家ISP从71.94.0.0/15块开始，并多次细分它，为自己和客户创建更小的块。对于这个区块的客户和用户，这些较小的区块必须进行区分;ISP显然需要知道如何将流量路由到正确的客户。然而，对于Internet上的其他所有人来说，在决定如何将数据报路由到该ISP区块中的任何人时，这些细节并不重要。例如，假设我正在使用一个IP地址为211.42.113.5的主机，我需要发送到71.94.1.43。我的本地路由器和Internet上的主要路由器都不知道该地址在71.94.0.0/15块的什么位置，它们也不需要知道。它们只知道，任何前15位包含等效的二进制71.94的内容都将被发送到处理(s) 71.94.0.0/15的路由器，这是整个块的聚合地址。它们让ISP的路由器找出它的哪个组成子网络包含71.94.1.43。

与此相反的是，在一个“有班级”的环境中。这个ISP的每个客户可能都有一个或多个C类地址块。其中每一个都需要一个单独的路由器条目，并且这些块必须被Internet上的所有路由器所知道。因此，对于每个客户网络，不是只有一个71.94.0.0/15条目，而是有几十个甚至数百个条目。在无类方案中，对于“父”ISP，只有一个条目存在。

<u>**无类路由中潜在的歧义**</u>

CIDR为路由提供了好处，但也增加了复杂性。在CIDR下，我们不能仅仅从IP地址确定哪些位是网络ID，哪些位是主机ID。更糟糕的是，我们可以拥有拥有相同基址的网络、子网络、子子网络等等!

在上面的示例中，71.94.0.0/15是完整的网络，子网#0是71.94.0.0/16。它们有不同的前缀长度(网络ID的位数)，但相同的基址。如果路由器通过这种方式对一个网络ID有多个匹配项，它必须首先使用最长的网络标识符，因为它代表一个更具体的网络描述。

###### 3.1.2.5 IP组播（部分：1 2）

大量的TCP/IP通信使用Internet协议将消息从一个源设备发送到一个接收设备;这被称为单播通信。这是我们通常使用TCP/IP进行的消息传递类型;当你使用互联网时，你几乎所有的事情都在使用单播。由于这个原因，我对IP的大部分讨论都围绕着描述单播消息。

然而，IP也支持让一台设备向一组收件人发送消息的能力。这被称为多播。自IPv4首次定义以来，IP组播就得到了“官方”支持，但多年来并未得到广泛使用，这主要是由于许多硬件设备缺乏对组播的支持。近年来，对多播的兴趣增加了，对多播的支持成为下一代IP版本6协议的标准组成部分。因此，我觉得有必要简要介绍一下IP多播。这是一个庞大而复杂的主题，所以我不会详细讨论它-你必须从其他地方寻找IP多播的完整描述。(对不起，它要么是一个简短的总结，要么什么都没有;也许我将来会写更多关于多播的东西。)

IP多播背后的思想是允许IP互连网络上的设备不仅向一个接收者发送数据报，而且向其他设备的任意集合发送数据报。IP组播模仿了数据链路层中使用的类似功能，允许单个硬件设备向组中的各个成员发送消息。然而，多播在数据链路层相对容易，因为所有设备都可以直接通信。相反，在网络层，我们连接的设备彼此之间可能很远，并且必须在这些不同的网络之间路由数据报。当使用IP进行组播时，这必然会使组播变得复杂(除非在特殊情况下，我们只在同一数据链路层网络上的设备之间使用IP组播)。

要实现IP组播，必须执行三个主要功能:寻址、组管理和数据报处理/路由。

<u>**多播地址**</u>

多播必须使用特殊寻址。这些多播地址标识的不是单个设备，而是侦听发送给它们的特定数据报的多播设备组。在IPv4中，整个地址空间的1/16被预留给组播地址:原始的“有类”寻址方案的D类块。

使用特殊的技术来定义该块内地址的含义，并定义IP组播地址和数据链路层组播地址之间的映射关系。这在IP组播寻址的主题中都有描述;IP组播地址到硬件层组播地址的映射在地址解析一节中讨论。

<u>**多播组管理**</u>

组管理包括设置设备组所需的所有活动。他们必须能够动态地加入和离开组，组的信息必须在IP网络中传播。为了支持这些活动，需要额外的技术。因特网组管理协议(IGMP)是用于此目的的主要工具。它定义了一种消息格式，允许在internet上的设备和路由器之间发送关于组和组成员关系的信息。

<u>**多播数据报处理与路由**</u>

这可能是最复杂的:在多播环境中处理和路由数据报。这里有几个问题:

- 由于我们是从一个设备发送到多个设备，因此我们需要实际创建数据报的多个副本来进行传递，而不是在单播情况下使用单个数据报。路由器必须能够分辨何时需要创建这些副本。

- 路由器必须使用特殊的算法来确定如何转发多播数据报。由于每一个都可能导致多个副本被发送到不同的地方，因此效率对于避免产生不必要的流量非常重要。

- 路由器必须能够处理发送到多播组的数据报，即使源不是组成员。

在多播环境中进行路由需要路由器硬件方面的更多智能。一些特殊的协议，如距离向量组播路由协议(DVMRP)和OSPF的组播版本，被用来使路由器有效地转发组播流量。这些算法必须在两种需求之间取得平衡:一是确保组中的每个设备都接收到针对该组的所有数据报的副本，二是防止不必要的流量在网络间移动。

关键概念:IP多播允许开发特殊的应用程序，其中一个设备通过私有互联网或全球互联网向多个其他设备发送信息。它比传统的单播IP更为复杂，需要特别注意，特别是在寻址和路由方面。

本文的概述只触及了IP组播的皮毛。处理组和将消息转发到多播组所涉及的复杂性是对该特性的支持相当不均的原因之一，因此它没有得到广泛使用。另一个问题是多播的高要求性;它使用大量的网络带宽来复制消息，还需要本已繁忙的路由器进行更多的工作。

##### 3.1.3 互联网协议第6版（IPv6）/IP下一代（IPng）

自1981年以来，TCP/IP建立在Internet协议的第4版之上。IPv4诞生之时，我们今天习以为常的庞大的全球互联网还只是一个小型实验网络。考虑到互联网在过去20年的发展和变化，IPv4已经完成了令人钦佩的工作。与此同时，多年来一直很明显的一点是，如果不加以解决，这个令人尊敬的协议中的某些限制将阻碍未来互联网规模和服务的增长。

由于IP所扮演的关键角色，改变它不是一件简单的事情。它意味着对TCP/IP中几乎所有东西的运行方式进行实质性的修改。然而，即使我们发现改变是困难的，我们大多数人都知道这是必要的。在过去的几年里，一个新的IP版本的开发一直在进行中，官方称为互联网协议版本6 (IPv6)，有时也被称为IP下一代或IPng。IPv6即将取代IPv4，并将成为未来互联网的基础。

在本节中，我将详细描述IP version 6。因为IPv6和IPv4一样仍然是IP，它执行相同的功能:寻址、封装、碎片和重组、数据报传递和路由。由于这个原因，本节关于IPv6的小节和主题都是按照IPv4小节的模式进行的。其中包括IPv6概念和问题的讨论，IPv6寻址和数据打包的覆盖范围，以及版本6如何进行碎片化、重组和路由。

**背景信息:**由于IPv6代表了IP的发展，它的许多操作概念都建立在IPv4中引入的概念的基础上。为了避免不必要的重复，本文假定读者熟悉IPv4的操作，特别是寻址以及数据报是如何打包和传递的。如果你没有读过关于IPv4的那一节，最好先复习一下，因为IPv6的描述集中在它与当前IP版本的区别上。

**相关信息:**您可能希望参考关于ICMP(其中一部分是IPv6的ICMPv6-ICMP)和IPv6邻居发现(ND)协议的章节，因为它们是IPv6的“伙伴”。然而，这并不是必须的。

**注意:**IPv6显然仍在开发中，因此，编写这样的章节就像试图击中一个移动的目标。这可能就是为什么大多数TCP/IP指南对ipv6说得不多的原因——它一直在变化!我认为它很重要，所以我已经按照出版日期的定义描述了它。然而，由于每个月都在对IPv6标准和实现进行更改，这一特定部分的信息更有可能过时。(甚至在本指南第一版出版之前，我不得不做了几次修改!)

###### 3.1.3.1 IPv6概述，变化和过渡

IPv6注定是未来的互联网协议，由于IP的关键重要性，它将形成未来TCP/IP和互联网的基础。事实上，它从上个十年中期就开始开发了，一个真正的IPv6互联网络也已经用于测试很多年了。尽管如此，许多人对IPv6了解不多，只知道它是IP的新版本。有些人甚至从未听说过它!当然，我们会纠正这一点——但在我们深入研究IPv6版本6中对IP地址、封装、碎片和其他功能的重要改变之前，让我们先从“鸟瞰”的角度来了解IPv6。

在本节中，我将简要介绍IPv6的高级概述，包括它与IPv4在一般术语上的区别。我首先简要概述了IPv6及其创建的原因。我列出了在IPv6中所做的主要改变和对当前版本协议的补充。我还解释了从IPv4向IPv6过渡庞大的全球互联网所面临的一些困难。

###### 3.1.3.1-1 IPv6动机和概述(部分:1 2 3)

“如果没坏，就别修。”我认为这是我最喜欢的民间智慧之一。和大多数人一样，我通常喜欢坚持做有用的事情。IP版本4运行得非常好。它已经存在了几十年，在互联网从一个小型研究网络成长为横跨全球的强大力量的过程中幸存了下来。所以，就像一辆可靠的老车，我们已经成功运行多年，如果它仍然可以完成工作，我们为什么要更换它?

就像那辆老车一样，我们可以在可预见的未来继续使用IPv4。问题是:代价是什么?如果你愿意花时间和金钱来维护和保养一辆旧的汽车，它是可以保持良好的工作状态的。然而，它在某些功能上仍将受到限制。它的可靠性可能值得怀疑。它不会有最新的功能。除了那些把修车当作爱好的人，一直修车最终都没有意义了。

在某些方面，这甚至不是一个很好的类比。我们的高速公路与20世纪70年代相比并没有太大的不同，与驾驶有关的大多数其他问题在过去25年里也没有太大的变化。更新车辆的选择更多的是基于实际考虑而非必要性。

相比之下，看看计算机和网络世界在过去25年里发生了什么!如今的掌上电脑比当时最强大的服务器所能做的还要多。网络技术的速度是它的100倍甚至1000倍。连接到全球互联网的人数增加了一个更大的因素。在许多情况下，计算机通信的方式发生了巨大的变化。

在某些方面，IPv4可以被看作是一辆经过长期精心维护和修理的旧车。它完成了任务，但它的年龄开始显现。IPv4的主要问题是它相对较小的地址空间，这是仅使用32位IP地址的决定遗留下来的。在最初的“分类”地址分配方案下，我们现在可能已经用完IPv4地址了。向无分类寻址的转变有助于推迟这种情况的发生，正如IP网络地址转换(NAT)等技术允许私有地址主机访问Internet一样。

然而，最终，这些只是修补工作和不完善的维修，以保持IPv4的老化汽车在路上行驶。核心问题是32位地址空间对于当前和未来的互联网规模来说太小，只能通过移动到更大的地址空间来解决。这是创建下一个版本的互联网协议IPv6的主要激励因素。

**注:**IPv4的后续版本是版本6而不是版本5的原因是版本5被用来指一个叫做Internet流协议的实验性协议，它从未被广泛部署。有关完整的讨论，请参阅IP历史和版本主题。

<u>**IPv6标准**</u>

IPv6代表了自1981年IPv4正式形成以来互联网协议的第一次重大变化。多年来，它的核心运作是在1998年发表的一系列rfc2460至2467中定义的。其中最值得注意的是IPv6的主要标准RFC 2460 (Internet Protocol, Version 6 (IPv6) Specification)，以及描述IPv6的两个“helper”协议的文档:RFC 2461，描述IPv6的邻居发现协议，和RFC 2463，描述IPv6的ICMP版本6 (ICMPv6)。

除此之外，1998年还创建了两个文档来更多地讨论IP寻址:RFC 2373 (IP版本6寻址架构)和RFC 2374 (IPv6可聚合全球单播地址格式)。由于IPv6寻址方式的改变，在2003年由RFC 3513(互联网协议版本6 (IPv6)寻址体系结构)和RFC 3587 (IPv6全球单播地址格式)更新。

许多其他rfc定义了IPv6功能的更多细节，也描述了其他TCP/IP协议(如DNS和DHCP)的IPv6兼容版本。IPv6仍然是一个正在进行中的工作，它的新标准正在被定期提出和采用。

由于IPv6是为下一代互联网设计的IP版本，它有时也被称为IP下一代或IPng。就我个人而言，我不喜欢这个名字;这太让我想起《星际迷航:下一代》了。我和我妻子经常看的很棒的节目，但还是。不管它的名字是什么，IPv6或IPng被设计用来把TCP/IP和互联网带到“以前没有人去过的地方”。(对不起，我必须这么做!J)

<u>**IPv6的设计目标**</u>

寻址问题是创建IPv6的主要动机。不幸的是，这导致许多人认为地址空间的扩展是IP的唯一变化，但事实绝对不是这样。因为改变IP是件大事，所以很少有人这么做。不仅要纠正寻址问题，还要在许多其他方面更新协议，以确保其可行性，这是有意义的。事实上，即使是IPv6中的寻址变化也远远不止在IP地址字段中添加更多的比特。

设计IPv6的一些最重要的目标包括:

- 更大的地址空间:这是我们之前讨论的内容。IPv6必须为不断增长的因特网提供更多的地址。

- 更好地管理地址空间:IPv6不仅需要包含更多的地址，而且需要一种更有能力的方式来划分地址空间并使用每个地址中的位。

- 消除“寻址拼凑”:像NAT这样的技术是有效的“拼凑”，弥补了IPv4中地址空间的不足。IPv6不需要NAT和类似的变通方法，允许每个TCP/IP设备都有一个公网地址。

- 更容易的TCP/IP管理:IPv6的设计者希望解决IPv4当前的一些劳动密集型需求，如配置IP地址的需要。即使像DHCP这样的工具消除了手动配置许多主机的需要，它也只能部分解决这个问题。

- 路由的现代设计:IPv4是在我们还不知道现代互联网会是什么样子之前设计的，与之相比，IPv6是专门为当前互联网的高效路由而创建的，并具有未来的灵活性。

- 更好地支持多播:多播从一开始就是IPv4下的一个选项，但是对它的支持一直很慢。

- 更好地支持安全性:在设计IPv4时，安全性还不是一个大问题，因为internet上的网络数量相对较少，它们的管理员通常彼此认识。今天，公共互联网的安全是一个大问题，互联网未来的成功需要安全问题得到解决。

- 更好地支持移动性:当IPv4创建时，还没有移动IP设备的概念。与在网络之间移动的计算机相关的问题导致了对移动IP的需求。IPv6建立在移动IP之上，并在IP内部提供移动支持。

<u>**IPv6: IP的进化**</u>

与此同时，IPv6旨在解决上述问题和其他许多传统IP的问题，我们应该记住，它的变化是渐进的，而不是革命性的。在20世纪90年代IETF的多次讨论中，有些人说，在我们更新IP的同时，也许我们应该对一种新型的互联协议进行彻底的、彻底的改变。最终的决定并不是这样做，而是为我们一直在使用的IP定义一个更强大的版本。

原因很简单:IP就像我们所信任的老式汽车一样有效。IPv6代表了一种更新，它努力添加IPv4的最佳特性，而不是让所有人从头开始使用一些新的、未经验证的东西。这种设计确保了从IPv4到IPv6的变化所带来的任何痛苦都可以被管理，并且希望最小化。

**关键概念:**互联网协议的新版本是互联网协议版本6 (IPv6)。它的创建是为了纠正IPv4的一些重大问题，特别是IPv4地址空间即将耗尽的问题，并从整体上改进协议的操作，使TCP/IP走向未来。

###### 3.1.3.1-2 IPv6的主要变化和增加

在前面的概述中，我解释了创建新版本IP的主要动机是修复IPv4下寻址的问题。但我们也看到，新协议还有许多其他的设计目标。一旦决定迈出重要的一步，创建一个和IP一样重要的协议的新版本，就有必要利用这个机会进行尽可能多的改进。

当然，仍然有改变带来的痛苦的问题需要担心，所以IPv6中每一个潜在的改变或增加都必须带来大于成本的好处。最终的设计很好地提供了有用的优点，同时保持了原始Internet协议的大部分核心。下面的列表总结了IPv4和IPv6之间最重要的变化，展示了IPv6团队满足新协议设计目标的一些方法:

- 更大的地址空间:IPv6地址是128位而不是32位。这将地址空间从大约40亿个地址扩展到一个天文数字(超过300万亿亿亿个地址)。

- 分层地址空间:IPv6地址扩展如此之大的一个原因是允许它分层划分，以提供大量的各种类型的地址。

- 单播地址的分级分配:创建了一种特殊的全球单播地址格式，允许地址在整个互联网上轻松分配。它允许ISP和组织级别的多级网络和子网络层次结构。它还允许基于底层硬件接口设备id(如以太网MAC地址)生成IP地址。

- 更好地支持非单播寻址:改进了对多播的支持，并增加了对一种新寻址类型的支持:任意播寻址。这种新的寻址方式基本上说的是“将此消息传递给该组中最容易联系到的成员”，并可能实现新的消息传递功能类型。

- 自动配置和重新编号:包括一个条款，允许更容易地自动配置主机和根据需要重新编号网络和子网络中的IP地址。路由器地址的重新编号技术也存在。

- 新的数据报格式:IP数据报格式已被重新定义并赋予了新的功能。每个IP数据报的主报头已经精简，并添加了支持，以便为需要更多控制信息的数据报轻松扩展报头。

- 支持服务质量:IPv6数据报包括QoS特性，允许更好地支持多媒体和其他需要服务质量的应用程序。

- 安全支持:安全支持被设计成IPv6使用认证和加密扩展头和其他功能。

- 更新的碎片和重组程序:IPv6对数据报的碎片和重组工作方式进行了更改，以提高路由的效率，更好地反映当今网络的现实。

- 现代化的路由支持:IPv6协议旨在支持现代化的路由系统，并允许随着Internet的增长而扩展。

- 过渡能力:从一开始人们就认识到从IPv4到IPv6是一个巨大的转变，对IPv4/IPv6过渡的支持已经在许多领域提供。这包括一个IPv4和IPv6网络互操作的计划，IPv4和IPv6地址之间的映射等等。

关于IPv6的其余部分提供了更多关于IP的这些变化和添加的细节。你会注意到这些大多数都与寻址有关，因为这是IPv6中最重要的变化。当然，路由和寻址是密切相关的，寻址的变化也对路由产生了很大的影响。

我要提到的另一个变化是，随着IPv6的引入，其他几个与IP密切相关的TCP/IP协议也必须进行更新。其中之一是ICMP，它是IPv4最重要的支持协议，通过为IPv6创建ICMPv6对其进行了修订。对TCP/IP协议的一个补充是邻居发现(ND)协议，它为IPv6执行一些在版本4中由ARP和ICMP完成的功能。

###### 3.1.3.1-3 从IPv4到IPv6的过渡(部分:1 2 3)

Internet协议是TCP/IP协议集和Internet的基础，因此在结构重要性方面有点类似于房子的基础。考虑到这一点，改变IP有点类似于对房子的基础进行实质性的修改。由于IP被用来连接许多设备，它实际上就像改变的不只是你的房子，而是世界上的每一个房子!

如何改变房子的地基?很小心。IPv6的实现也需要同样的谨慎。虽然对大多数人来说IPv6是一个“新事物”，但事实是IPv6的规划和发展已经进行了将近十年，如果我们从头开始，该协议早在几年前就准备好了。然而，IPv4硬件和软件的安装基数确实巨大。这意味着开发TCP/IP的人不能只是“拨动开关”，让所有人都转向使用IPv6。相反，必须计划从IPv4到IPv6的过渡。

<u>**IPv4-IPv6转换:意见分歧**</u>

这种转变已经开始了，尽管大多数人不知道。正如我所说的，IPv6本身的开发已经基本完成，尽管在改进协议和开发其他协议的IPv6兼容版本方面的工作仍在继续。IPv6的实现始于开发网络的创建，以测试IPv6的运行。这些连接在一起形成了一个实验性的IPv6互联网络，称为6BONE (6BONE是“IPv6骨干网”一词的缩写)。这个互联网络已经运行好几年了。

实验性的网络是很好的，但当然，最大的问题是如何将“真正的”互联网过渡到ipv6——在这一点上，意见分歧相当快。其中一个阵营是非常渴望快速过渡到IPv6的公司、组织和个人，以获得它在寻址、路由和安全方面承诺的许多好处。其他人则采取了更为谨慎的方法，他们指出，上世纪90年代中期关于IPv4即将毁灭的可怕预测并没有成为现实，并认为我们应该花时间来确保IPv6能够大规模运行。

在接下来的几年里，这两个群体将继续进行拉锯战，但现在看来，潮流似乎转向了那些希望加快这一长达数年的过渡进程的人。采用IPv6作为生产协议的行动是由一些团体和组织带头进行的。IPv6在美国以外的地区得到了很多支持，其中许多地区由于相对于其规模较小的分配，IPv4地址正处于短缺状态。亚洲就是这样一个地区，这个地区拥有数十亿人口，互联网使用迅速增长，但IPv4地址短缺。

在拥有IPv4地址最大份额的美国(由于互联网是在美国发展起来的)，人们似乎对IPv6的快速部署不那么热情。然而，即使在这里，IPv6也在2003年7月得到了一剂重要的“兴奋剂”，当时美国国防部(DoD)宣布，从当年10月开始，它将只购买与IPv6兼容的网络产品。国防部——当然，它首先要对互联网的发展负责——希望在2008年完全过渡到IPv6。这可能会对美国其他政府和私人组织的计划产生重大影响。

当然，IPv6的创造者从一开始就知道过渡将是新协议的一个重要问题。由于寻址系统和数据报格式不同，IPv6和IPv4不兼容。然而IPv6的设计者知道，由于过渡将需要很多年，他们有必要为IPv4和IPv6主机提供一种互操作的方式。考虑到在任何转型中总会有“掉队者”。就像角落里的旧Windows 3.11电脑，你仍然需要偶尔使用一次，即使大多数互联网是IPv6，仍然可能有一些设备仍然是IPv4，因为它们从未升级过。

**关键概念**:由于IPv4和IPv6之间的许多差异，以及Internet协议对TCP/IP的根本重要性，从IPv4到IPv6的有序过渡已经计划了多年。

<u>**IPv4-IPv6转换方法**</u>

由于更改需要时间，IETF一直致力于特定的条款，以允许从版本4到版本6的平稳过渡，以及硬件和软件互操作性解决方案，以允许较新的IPv6设备访问IPv4主机。IPv6中包含了一项技术，允许管理员在IPv6地址中嵌入IPv4地址。定义了处理互操作性的特殊方法，包括:

- “双栈”设备:路由器和其他一些设备可以用IPv4和IPv6实现编程，以允许它们与两种类型的主机通信。

- IPv4/IPv6转换:“双栈”设备可能被设计为接受来自IPv6主机的请求，将它们转换为IPv4数据报，将数据报发送到IPv4目的地，然后以类似的方式处理返回的数据报。

- IPv6的IPv4隧道:IPv6设备之间没有完全由IPv6路由器组成的路径，可以通过在IPv4中封装IPv6数据报进行通信。从本质上说，他们将在IPv4之上使用IPv6;两个网络层。封装的IPv4数据报将在传统的IPv4路由器之间传输。

请记住，这些解决方案通常只解决向后兼容，允许IPv6设备与IPv4硬件通信。IPv4和IPv6之间的向前兼容是不可能的，因为IPv4主机不能与IPv6主机通信——它们缺乏IPv6如何工作的知识。可能会创建一些特殊的适配来允许IPv4主机访问IPv6主机。但最终，所有重要的IPv4设备都会迁移到IPv6。

IETF过去在引进新技术方面做得很好，在IPv6的过渡上也付出了很多努力，因此我非常有信心，过渡到IPv6将不会出现什么问题。过渡的一个好处是，目前IPv4仍然可以完成这项工作，所以不需要太急于转移到版本6。虽然CIDR和NAT等技术只是IPv4的“创可贴”，但它们在延长老化协议的使用寿命方面非常成功。

###### 3.1.3.2 IPv6地址

创建IPv6的主要动机是纠正IPv4的寻址问题。需要更多的地址，但更重要的是，IPv6设计者希望有一种更符合现代互联网络的解释、分配和使用地址的方式。基于此，IPv6中的许多变化与IP寻址相关就不足为奇了。IPv6寻址方案在总体概念上与IPv4寻址方案相似，但已经进行了彻底的改革，以创建一个在可预见的未来能够支持持续互联网扩展和新应用的寻址系统。

介绍IPv6下寻址的相关概念和方法。我首先介绍版本6中的一些寻址通用性，包括寻址模型、地址类型大小和地址空间。我将讨论用于IPv6地址和前缀的独特的、有时令人困惑的表示和符号。然后，我将介绍地址是如何按类型进行排列和分配的，首先全面了解地址空间的组成，然后是全局单播地址格式。我将描述用于将IP地址映射到底层物理网络地址的新方法。然后，我将描述特殊的IPv6寻址问题，包括保留地址和私有地址、IPv4地址嵌入、任意播地址和组播地址，以及地址的自动配置和重新编号。

IPv6下的寻址在主要的IPv6 RFC, RFC 2460(互联网协议，版本6 (IPv6)规范)中有概述。然而，IPv6寻址的大部分细节包含在另外两个标准中:RFC 3513(互联网协议版本6 (IPv6)寻址架构)和RFC 3587 (IPv6全球单播地址格式)。它们取代了1998年的标准RFC 2373 (IP版本6寻址架构)和RFC 2374 (IPv6可聚合全球单播地址格式)。

**背景信息:**与本指南中的其他IPv6部分一样，我们对寻址的研究在一定程度上是基于与IPv4中寻址的对比。我强烈建议在继续本文之前全面了解IPv4寻址，包括使用CIDR的无类寻址。与IPv4寻址部分一样，熟悉二进制数的工作原理以及二进制数和十进制数之间的转换也是一个不错的主意。关于数据表示和计算数学的背景部分可能在这方面有帮助。

###### 3.1.3.2-1 IPv6寻址概述:寻址模型和地址类型(部分:1 2)

在IPv6概述部分，我解释了IPv6代表了对互联网协议的重大更新，但它的修改和添加并没有改变IP如何工作的核心性质。地址是IPv4和IPv6之间最大的区别所在，但主要的变化是地址的实现和使用方式。IPv6中用于IP寻址的整体模型与IPv4中几乎相同;有些方面完全没有改变，而另一些方面只发生了轻微的变化。

<u>**IPv6中未改变的寻址方面**</u>

IPv6寻址模型的一些基本与IPv4相同的一般特征:

- 寻址的核心功能:寻址的两个主要功能仍然是网络接口识别和路由。通过互连网络上的地址结构可以方便地进行路由。

- 网络层寻址:IPv6地址仍然是TCP/IP网络中与网络层相关联的地址，与数据链路层(有时也称为物理地址)地址不同。

- 每台设备的IP地址数量:地址仍然分配给网络接口，所以像PC这样的普通主机通常会有一个(单播)地址，而路由器会有多个地址，对于它连接到的每个物理网络。

- 地址解释和前缀表示:IPv6地址类似于无分类的IPv4地址，因为它们被解释为具有网络标识符部分和主机标识符部分，但描述并不编码到地址本身。前缀长度数字，使用类似cidr的表示法，用来表示网络ID的长度(前缀长度)。

- 私网地址和公网地址:这两种类型的地址都存在于IPv6中，尽管它们的定义和使用有些不同。

<u>**IPv6地址类型**</u>

IPv6的寻址模型的一个重要变化是支持的地址类型。IPv4支持单播、组播和广播三种地址类型。其中，绝大多数实际流量是单播的。IP多播支持直到Internet建立多年后才得到广泛部署，并继续受到各种问题的阻碍。由于性能原因，必须严格限制IP中广播的使用(我们不希望任何设备能够跨整个互联网广播!)

IPv6也支持三种地址类型，但有一些变化:

- 单播地址:这些是IPv4中的标准单播地址，每个主机接口一个。

- 组播地址:这些地址表示不同的IP设备组:发送到组播地址的消息将发送到组播地址中的所有设备。IPv6包含比IPv4更好的多播特性和更多的多播地址。由于IPv4下的组播在很大程度上是由于许多硬件设备缺乏对该特性的支持，所以对组播的支持是IPv6中必需的，而不是可选的。

- 任意播地址:当消息必须发送到组中的任何成员，但不需要发送到所有成员时，使用任意播寻址。通常情况下，最容易联系到的小组成员将被发送消息。如何使用任意播寻址的一个常见例子是在组织中一组路由器之间的负载共享。

**关键概念:**IPv6像IPv4一样有单播和多播地址。然而，在IPv6中没有明确的广播地址的概念。添加了一种新的地址类型，即任意播放地址，以允许将消息发送到一组设备中的任何一个成员。

<u>**IPv6地址类型变化的影响**</u>

广播寻址作为一种独特的寻址方法在IPv6中已不复存在。广播功能是通过对设备组的多播寻址实现的。例如，一个所有节点都属于的多播组可以用于在网络中进行广播。

创建任意播寻址的一个重要含义是消除了对IP地址的严格惟一性要求。Anycast是通过给多个设备分配相同的IP地址来实现的。设备还必须被特别告知它们正在共享一个任意播地址，但地址本身在结构上与单播地址相同。

本节的其余部分主要关注单播寻址，因为它是迄今为止最重要的类型。多播和任意播寻址分别得到特别关注。

###### 3.1.3.2-2 IPv6地址大小和地址空间(部分:1 2 3)

在IPv6中引入的所有变化中，最“值得庆祝”的是IP地址大小的增加，因此，地址空间的大小也增加了。与IPv4相比，IPv4的地址空间会增加，这并不奇怪——多年来大家都知道IPv4的地址空间太小，无法支持未来的互联网。值得注意的是这一增长的幅度，以及对互联网地址使用方式的影响。

IPv6地址大小

在IPv4中，IP地址长度为32位;它们通常被分成四个八位，每个八位有八个比特。理论上IPv4地址空间是2^32，即4,294,967,296个地址。要增加这个地址空间，我们只需增加地址的大小;我们赋予地址大小的每一个额外比特都使地址空间加倍。基于此，一些人预计IPv6地址的大小将从32位增加到48位，或者可能是64位。这两个数字都能给出相当多的地址。

然而，IPv6寻址不使用这些数字中的任何一个;相反，IP地址的大小一直跳到128位，或者16个8位字节。这代表了地址规模的真正显著增长，这让很多人感到惊讶。

<u>**IPv6地址空间**</u>

128位的IPv6地址意味着IPv6地址空间的大小，毫不夸张地说，是天文数字;就像描述星系中恒星数量或到最远脉冲星距离的数字一样，IPv6支持的地址数量是令人难以置信的。参见图94，了解我所说的“天文数字”的含义。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipv6addressspace (1).png)

​                                                             **图94:IPv4和IPv6相对地址空间大小的(差的)表示**

我想制作一个很酷的图形来显示IPv4和IPv6地址空间的相对大小。你知道，我把IPv6地址空间显示为一个大盒子，IPv4地址空间显示为一个小盒子。问题是IPv6地址空间比IPv4地址空间大得多，没有办法按比例显示它!为了使这个图具有可伸缩性，可以想象IPv4地址空间是上面的1.6英寸的平方。在这种情况下，IPv6地址空间将由一个太阳系大小的正方形表示。J

由于IPv6地址是128位长，如果所有地址都被使用，理论上的地址空间是2^128个地址。这个数字展开后是340,282,366,920,938,463,463,374,607,431,768,211,456，通常用科学记数法表示为约3.4*10^38个地址。大约有340万亿亿亿个地址。正如我所说，很难把握这个数字到底有多大。考虑:

- 这些地址足以给地球上的每一个人分配上万亿个地址。

- 地球大约有45亿年的历史。如果自地球形成以来，我们一直以每秒10亿个的速度分配IPv6地址，那么到目前为止，我们只使用了不到万亿分之一的地址空间。

- 地球的表面积大约是510万亿平方米。如果一台典型的计算机的占地面积约为十分之一平方米，那么我们将不得不将100亿台计算机堆叠在整个地球表面，以使用同样的万亿分之一的地址空间。

好了，我想你明白了。很明显，使用128位地址的决定的一个目标是确保我们永远不会再次耗尽地址空间，而且似乎很有可能会出现这种情况。

**关键概念**:IPv6地址空间非常非常大。J

<u>**为什么IPv6地址这么大?**</u>

然而，拥有如此巨大的地址空间也有缺点。考虑到即使是64位地址，我们也会有一个非常大的地址空间:2^64是18,446,744,073,709,551,616，或大约1800万兆，仍然可能比我们需要的地址要多。然而，使用128位来代替，我们就使得IP地址的处理变得不规范(我们将在下一个主题中看到)，而且我们也增加了开销，因为每个数据报头或其他IP地址引用的地方必须为每个地址使用16个字节，而不是IPv4中需要的4个字节，或者64位地址可能需要的8个字节。

那么，为什么要过度使用128位呢?主要原因是灵活性。即使我们可以有无数个地址，如果我们一次分配一个，这使得分配很困难。我们在IPv4中摒弃了面向类的寻址，因为它浪费了地址空间，这是事实。但实际上，能够“浪费”地址空间是一种有用的奢侈。

128位允许我们划分地址空间，并将不同的用途分配到不同的位范围，同时仍然不必担心空间耗尽。在描述IPv6全球单播地址格式的主题中，我们将看到这128位的一种很好的使用方式;它允许我们创建一个网络层次结构，同时仍然为主机id节省64位，这有它自己的优势

###### 3.1.3.2-3 IPv6地址和地址表示法和前缀表示(部分:1 2 3 4)

将IP地址的大小从32位增加到128位，将地址空间扩展到一个巨大的规模，确保我们永远不会耗尽IP地址，并允许我们在如何分配和使用它们方面具有灵活性。不幸的是，这种方法有一些缺点，其中之一是128位的数字非常大，这使得它们使用起来很尴尬和困难。

IPv6地址:对于点分十进制格式来说太长了

计算机以二进制工作，它们处理由1和0组成的长串没有问题，但人类却觉得它们令人困惑。即使是IPv4的32位地址对我们来说处理起来也很麻烦，这就是为什么我们使用点分十进制表示它们，除非我们需要使用二进制(如子网)。然而，IPv6地址比IPv4地址大得多，即使使用点分十进制也会有问题。为了使用这种表示法，我们将把128位分割成16个八位，并用0到255的十进制数表示每一个八位。然而，我们最终得到的不是4个，而是16个。这种表示法下的典型IPv6地址如下所示:

​            128.91.45.157.220.40.0.0.0.0.252.87.212.200.31.255

此地址的二进制和点分十进制表示显示在图95顶部附近。在这两种情况下，“优雅”这个词并没有出现在你的脑海中。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipv6rep.png)

​                                                               <u>**图95:IPv6地址的二进制、十进制和十六进制表示**</u>

最上面的两行显示了IPv6地址的二进制和点分十进制表示;这两种都不是常用的(除了计算机本身!)下表的第一行显示了完整的十六进制表示，而接下来的两行演示了零抑制和压缩。最后一行显示混合记数法，其中IPv6地址的最后32位以点分十进制表示。这通常用于嵌入式IPv4地址。

<u>**IPv6地址十六进制表示**</u>

为了使地址更短，IPv6决定改变表示地址的主要方法，使用十六进制而不是十进制。这样做的好处是，它需要更少的字符来表示一个地址，而且从十六进制转换到二进制再转换回来比从二进制转换到十进制或反之容易得多。缺点是，许多人，甚至是计算机人员，发现十六进制很难理解和使用，特别是因为每个数字中有16个值的概念有点奇怪。(我不是其中之一，但我是一个极客。)

用于IPv6地址的十六进制表示法与用于IEEE 802 MAC地址的相同方法类似，用于诸如以太网等技术。在这里，48位由6个八位表示，每个八位是一个从0到FF的十六进制数，用破折号或冒号分隔，如下所示:

​        0 a - a7 - 94 - 07 - cb - d0

由于IPv6地址更大，因此它们被分组为8个16位的单词，用冒号分隔，以创建有时称为冒号的十六进制表示法，如图95所示。因此，上面例子中给出的IPv6地址可以表示为:

​        805 b: 2 d9d: DC28:0000:0000: FC57: D4C8:1FFF

为了保持较小的大小，可以在表示法中抑制前导零，所以我们可以立即将其简化为:

​        805 b: 2 d9d: DC28:0:0: FC57: D4C8:1FFF

嗯。它肯定比点分十进制短，但看起来还是没什么意思。当你处理这么大的数字时，你能做的只有这么多。这就是为什么在IPv6下，主机使用DNS名称要比在IPv4中重要得多;谁能记住这么长的十六进制地址!

<u>**IPv6地址的 0 压缩**</u>

幸运的是，有一种快捷方式可以应用于进一步缩短一些地址。这种技术有时被称为零压缩。该方法允许用双冒号替换IPv6地址中连续的零字符串。例如，上面的地址可以表示为:

​        805 b: 2 d9d: DC28:: FC57: D4C8:1FFF

我们知道有多少零被“::”替换，因为我们可以看到地址中有多少完全表示(“未压缩”)的十六进制单词。在本例中有六个字，因此“::”表示两个零字。为了防止歧义，双冒号只能在任何IP地址中出现一次，因为如果它出现多次，我们就无法知道每个实例中替换了多少个0。因此，如果我们的示例地址是805B:2D9D:DC28:0:0:FC57:0:0，我们可以替换第一对零或第二个，但不能同时替换两个。

零压缩并没有使我们的示例变得更短，但是由于IPv6地址的结构，很长的零字符串是常见的。例如，考虑以下地址:

​        FF00:4501:0:0:0:0:0:32

对于压缩，这可以表示为:

​        FF00:4501::32

在特殊地址上效果更好。全IPv6环回地址为:

​        0:0:0:0:0:0:0:1

对于压缩，这很简单:

​        :: 1

更有趣的是，考虑更奇怪的IPv6“未指定”地址:

​        0:0:0:0:0:0:0:0

对一个全为0的地址应用零压缩，你会得到什么?这是正确的:

​        ::

根本没有数字!当然，将“::”作为地址需要一些时间来适应。

**关键概念：**为了简洁起见，IPv6地址使用八组四位十六进制数字表示，这种形式称为冒号十六进制表示法。其他技术称为0 抑制和0压缩，通过从地址表示中删除不必要的零，进一步减小显示地址的大小。

<u>**IPv6混合表示法**</u>

在某些情况下，还有一种可选的表示法，特别是用于表示嵌入IPv4地址的IPv6地址。对于这些情况，用较老的点分十进制表示地址的IPv4部分是有用的，因为这是我们用于IPv4的方法。由于嵌入使用IPv4地址的后32位，因此表示法的前96位为冒号十六进制表示法，后32位为点分十进制表示法。我们再举一个上面的例子，混合表示法是这样的

​        805 b: 2 d9d: DC28:: FC57:212.200.31.255

这并不是混合表示法的一个很好的例子，因为嵌入通常包括后跟IPv4地址的长串0。因此，零压缩在这里非常方便。而不是看到这样的东西:

​        0:0:0:0:0:0:212.200.31.255

你通常会看到:

​        :: 212.200.31.255

乍一看，这似乎是一个IPv4地址;你必须密切关注IPv6中的冒号!

**关键概念:**一个特殊的混合表示法被定义为IPv6地址的后32位包含一个嵌入的IPv4地址。在这种表示法中，前96位显示为正冒号十六进制表示法，后32位显示为ipv4风格的点分十进制表示法。

<u>**IPv6地址前缀长度表示**</u>

和IPv4无分类地址一样，IPv6地址从根本上被分为若干网络ID位和若干主机ID位。网络标识符称为前缀，使用的比特数是前缀长度。这个前缀的表示方式是在地址后面加一个斜杠，然后在斜杠后面加上前缀长度。这与使用CIDR进行无类IPv4寻址的方法相同。例如，如果我们的示例地址的前48位是网络ID(前缀)，那么我们将其表示为805B:2D9D:DC28::FC57:D4C8:1FFF/48。

**关键概念**:在IPv6中，地址前缀的大小由地址后面的前缀长度表示，用斜杠分隔，就像在IPv4中无类寻址一样。

与IPv4中一样，用于整个网络的指示符通常以一长串零结尾。可以用“::”替换，使用0压缩。例如，上面示例中的48位网络ID为805B:2D9D:DC28:0:0:0:0:0/48或805B:2D9D:DC28::/48。如果要替换末尾的0，则必须包含"::"。

###### 3.1.3.2-4 IPv6地址空间分配(部分:1 2 3)

在与非常小的IPv4地址空间打交道了这么多年之后，IPv6中数量巨大的地址肯定让IETF工程师们觉得自己就像进了糖果店的孩子一样。不过，他们都是好孩子，不会把所有能找到的糖果都抓起来狼吞虎咽。他们非常仔细地考虑了如何为各种用途划分地址空间。当然，当你有这么多糖果时，分享就变得很容易了。

<u>**IPv6地址空间初始分配方案及格式前缀(FP)**</u>

与IPv4的情况一样，决定如何划分IPv6地址空间的两个主要问题是地址分配和路由。IPv6的设计者想要构造地址空间，使地址分配给isp、组织和个人尽可能容易。

起初，这可能具有讽刺意味，这导致IPv6的创建者回到了使用特定的位序列来识别不同类型的地址，就像旧的“类”寻址方案一样。地址类型由地址开头的一组位表示，称为格式前缀(FP)。格式前缀在概念上与IPv4“有类”寻址中用于表示地址类的1到4位相同，但长度可变，从3到10位不等。格式前缀在RFC 2373中有描述。

在RFC 2373发布之后的几年里，管理互联网的专家们在如何考虑地址块的问题上改变了想法。他们仍然希望将IPv6地址空间划分为不同大小的块，用于不同的目的。然而，他们意识到许多人(包括我自己)开始考虑使用格式前缀等效于旧的面向类的IPv4系统。

他们主要担心的是，实现者可能会在IPv6硬件逻辑中编程，只根据地址的前几位做出路由决策。这并不是IPv6应该如何工作;一方面，分配可能会发生变化。因此，在RFC 3513中所做的修改之一是改变关于IPv6地址分配的语言，特别是从标准中删除术语“format prefix”。

<u>**当前IPv6地址空间分配方案**</u>

地址空间的不同部分的分配仍然基于地址的前3到10位的特定模式，以允许某些类别比其他类别拥有更多的地址。删除表示这一点的特定术语意在传达这些位不应给予“特别注意”。

表60显示了IPv6地址空间的分配，以及每个地址空间在总地址空间中所占的比例:

​                                                                            **表60:IPv6地址空间分配**

| **Leading Bits** | **Fraction of Total IPv6 Address Space** | **Allocation**                                                                                                          |
|:----------------:|:----------------------------------------:|:-----------------------------------------------------------------------------------------------------------------------:|
| **0000 0000**    | 1/256                                    | 未分配(包括特殊地址，如未指定和环回地址)                                                                                                   |
| **0000 0001**    | 1/256                                    | Unassigned                                                                                                              |
| **0000 001**     | 1/128                                    | 用于NSAP地址分配                                                                                                              |
| **0000 01**      | 1/64                                     | Unassigned                                                                                                              |
| **0000 1**       | 1/32                                     | Unassigned                                                                                                              |
| **0001**         | 1/16                                     | Unassigned                                                                                                              |
| **001**          | 1/8                                      | 全球单播地址                                                                                                                  |
| **010**          | 1/8                                      | Unassigned                                                                                                              |
| **011**          | 1/8                                      | Unassigned                                                                                                              |
| **100**          | 1/8                                      | Unassigned                                                                                                              |
| **101**          | 1/8                                      | Unassigned                                                                                                              |
| **110**          | 1/8                                      | Unassigned                                                                                                              |
| **1110**         | 1/16                                     | Unassigned                                                                                                              |
| **1111 0**       | 1/32                                     | Unassigned                                                                                                              |
| **1111 10**      | 1/64                                     | Unassigned                                                                                                              |
| **1111 110**     | 1/128                                    | Unassigned                                                                                                              |
| **1111 1110 0**  | 1/512                                    | Unassigned                                                                                                              |
| **1111 1110 10** | 1/1024                                   | [Link-Local Unicast Addresses](http://www.tcpipguide.com/free/t_IPv6SpecialAddressesReservedPrivateLinkLocalSiteLo.htm) |
| **1111 1110 11** | 1/1024                                   | [Site-Local Unicast Addresses](http://www.tcpipguide.com/free/t_IPv6SpecialAddressesReservedPrivateLinkLocalSiteLo.htm) |
| **1111 1111**    | 1/256                                    | Multicast Addresses                                                                                                     |

这比IPv4的“有类”方案要复杂得多，因为有更多的类别，而且它们的大小范围很大，然而，目前大多数类别都没有分配。

<u>**将IPv6地址空间规划视为“八分之八”**</u>

理解这个表的一个更简单的方法是考虑将IPv6地址空间划分为8。在这八组中，一组(001)被保留给单播地址;第二个(000)用于划分更小的保留块，第三个(111)用于本地和多播地址的子块。5个完全没有分配。

你可以看到IPv6设计者已经非常小心地只分配这些“八分之一”的地址空间的一部分，他们认为每一种类型的地址是需要的。例如，只有以“111”开头的地址空间的一小部分被使用，大部分被保留。总的来说，目前只分配了71/512分之一的地址空间，或约14%。剩下的86%没有分配，留作将来使用。(请记住，即使是IPv6地址空间的1/1024也是巨大的——它代表了几万亿个地址。)

本节后续的主题提供了关于其中几个地址块的更多信息。注意，“0000 0000”保留块用于一些特殊的地址类型，包括环回地址、“未指定”地址和IPv4地址嵌入。“1111 1111”格式前缀标识多播地址;该字符串是十六进制的“FF”，因此任何以“FF”开头的地址都是IPv6中的组播地址。

###### 3.1.3.2-5 IPv6全球单播地址格式(部分:1 2 3 4 5)

据预计，单播寻址将用于IPv6下的绝大多数互联网通信，就像较老的IPv4一样。正是由于这个原因，IPv6地址空间中分配的最大块专门用于单播寻址。巨大的IPv6地址“饼”中有1/8的部分被分配给单播地址，单播地址在地址的前三位用“001”表示。接下来的问题是:我们如何使用我们宽敞的IP地址中剩下的125位?

<u>**结构化单播地址块的基本原理**</u>

当IPv4刚被创建时，Internet相当小，分配地址块的模型是基于一个中央协调器:IANA。每个想要地址街区的人都可以直接去中央当局。随着互联网的发展，这种模式变得不切实际。如今，IPv4的无类寻址方案允许可变长度的网络id和地址块的分层分配。大型网络服务提供商从中央当局获得大块数据，然后将其细分，分配给他们的客户，等等。这是由今天的互联网供应商管理的，但在地址空间中没有任何东西可以帮助管理分配过程。反过来，每个组织都有能力进一步细分他们的地址分配，以适应他们的内部需求。

IPv6的设计者从这一经验中获益，并意识到设计单播地址结构以反映因特网的整体拓扑结构将有巨大的优势。这些包括:

- 在Internet拓扑层次结构的各个级别上更容易分配地址块。

- 自动反映路由器在互联网上移动信息的层次结构的IP网络地址，允许路由容易聚合，从而实现更有效的路由。

- 网络服务提供商等组织为客户细分地址块的灵活性。

- 终端用户组织可以灵活地细分他们的地址块以匹配内部网络，就像IPv4中的子网一样。

- IP地址有更大的“意义”。与仅仅是128位没有结构的字符串不同，查看一个地址并知道关于它的某些事情将成为可能。

<u>**单播地址空间的通用划分**</u>

将单播地址空间的128位划分为三个部分的最通用的方法，如表61所示。

​                                                                           **表61:通用IPv6全球单播地址格式**

| **Field Name**      | **Size (bits)** | **Description**                                            |
| ------------------- | --------------- | ---------------------------------------------------------- |
| ***Prefix\***       | “n”             | ***Global Routing Prefix:\*** 网络ID或地址的前缀，用于路由              |
| ***Subnet ID\***    | “m”             | ***Subnet Identifier:\*** 一个数字，用于识别站点内的子网。                 |
| ***Interface ID\*** | “128-n-m”       | ***Interface ID:\*** 一个特定接口（主机或其他设备）的唯一标识。它在特定的前缀和子网内是唯一的。 |

全局路由前缀和子网标识符代表了地址需要分层构建的两个基本层次：全局和特定站点。路由前缀由若干位组成，可以根据互联网注册处和互联网服务提供商的需要进一步细分，以反映整个互联网的地形（我们将很快讨论这个问题）。子网ID为网站管理员提供了一些比特，用于创建他们自己的内部网络结构。

**单播地址空间的IPv6实现**

理论上，任何大小的 "n "和 "m "都可以被使用。然而，为IPv6选择的实现方式是为路由前缀分配48位，为子网标识符分配16位。这意味着64位可用于接口标识符，这些标识符是根据IEEE "EUI-64 "格式构建的，如下一主题所述。因此，整个IPv6单播地址格式的构造如表62所示（如图96所示）。

| **Field Name字段名称** | **Size (bits)大小（比特）** | **Description说明**                                                          |
| ------------------ | --------------------- | -------------------------------------------------------------------------- |
| ***Prefix\***      | 48                    | ***Global Routing Prefix:\*** .全局路由前缀。地址的网络ID或前缀，用于路由。前三位是 "001"，表示一个单播地址。 |
| ***Subnet ID**     | 16                    | ***Subnet Identifier:\*** 子网标识符。一个数字，用于识别站点内的子网。                           |
| Interface ID*      | 64                    | ***Interface ID:\*** 接口ID：一个特定接口（主机或其他设备）的唯一标识。它在特定的前缀和子网内是唯一的。            |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipv6unicast.png)

​                                                               **图96：IPv6全球单播地址格式**

**关键概念：**IPv6地址空间中留给单播地址的部分被结构化为一种地址格式，使用前48位作为路由前缀（如网络ID），接下来的16位为子网ID，最后的64位为接口ID（如主机ID）。

由于这种结构，大多数终端站点（普通公司和组织，而不是互联网服务提供商）将被分配到具有48位前缀的IPv6网络。在通常的说法中，这些网络标识符现在已经被称为48s或/48s。

- 一个较小的组织可以只将子网ID的所有位设置为零，并有一个 "扁平 "的内部结构。
- 一个中等规模的组织可以使用子网ID中的所有位来执行相当于IPv4下的 "直接 "子网，给每个子网分配一个不同的子网ID。这里有16个比特，所以这允许一个高达65,536的子网
- 一个更大的组织可以使用这些比特来创建一个多层次的子网，就像IPv4的可变长度子网屏蔽（VLSM）。例如，该公司可以使用两个比特来创建四个子网。然后，它可以用接下来的三个比特在这四个子网中的一些或全部创建八个子网。还有11个比特可以创建子-子-子网，以此类推。

<u>**全局路由前缀的原始划分:聚合器**</u>

全局路由前缀也类似地划分为一个层次结构，但这个层次结构是为整个因特网的使用而设计的，如CIDR。这里有45位可用(比固定在“001”的前三位少48位)，这是很多的。当RFC 2374第一次详细描述单播地址结构时，该文档描述了基于Internet注册中心和提供者的两级分层拓扑的45位的具体划分。这些组织被描述为:

- 顶级聚合器(TLAs):最大的互联网组织，将从注册当局分配大量IPv6地址。

- 下一级聚合器(NLAs):这些组织将从TLAs获得地址块，并将它们划分给最终用户组织(站点)。

45位被分成两种用途，中间保留了一些位，以便在需要时扩展两个字段。因此，45位的RFC 2374结构如表63所示:

​                                                                          **表63:历史IPv6单播路由前缀结构**

| **Field Name** | **Size (bits)** | **Description**                                                                                              |
| -------------- | --------------- | ------------------------------------------------------------------------------------------------------------ |
| ***TLA ID\***  | 13              | ***Top-Level Aggregation Identifier:\*** 顶级聚合器的全局唯一标识符。共有13位，因此最多允许8192个TLAs                                 |
| ***RES\***     | 8               | ***Reserved:\*** 这8位保留供将来使用，并设置为零。通过不使用TLA ID和NLA ID之间的这8位，它们可以在以后用于根据需要扩展TLA ID或NLA ID字段。                   |
| ***NLA ID\***  | 24              | ***Next-Level Aggregation Identifier:\***每个TLA都有这个24位字段，用于生成地址块以分配给其客户。NLA ID对于每个TLA ID都是唯一的。24位的使用权留给TLA组织。 |

你会注意到我在描述TLA/NLA结构时使用了过去时，而且表格标题也是相当大的泄露。2003年8月，RFC 3587发布了，简而言之，它说的是“嗯，不要在意TLA/NLA的东西”。J人们认为，将这种结构“硬编码”到一个互联网标准中是不灵活的，让区域互联网注册中心(APNIC、ARIN、LACNIC和成熟)自己决定如何使用45位是更有意义的。

注意:“TLA/NLA”结构的过时发生在人们习惯于它很多年之后，所以在未来的一段时间里，你仍然会在IPv6描述中经常看到这些术语的提及。(这就是我在这里讨论它们的原因。)

<u>**全局路由前缀划分的一个例子**</u>

因此，不再有任何单一的结构来确定48位路由前缀如何在全局单播层次结构中划分。例如，可以将其分为三个级别，如表64和图97所示。

​                                                             **表64:IPv6单播路由前缀结构示例**

| **Field Name**             | **Size (bits)** | **Description**                                                                                 |
| -------------------------- | --------------- | ----------------------------------------------------------------------------------------------- |
| ***(Unicast Indicator)\*** | 3               | 每个单播地址以“001”开头；这个没有官方名称（它以前被称为格式前缀）。                                                            |
| ***Level1 ID\***           | 10              | ***Level 1 Identifier:\***级别1标识符：层次结构中最高级别的标识符。这将用于向最大的互联网组织分配全球层次结构中最大的地址块。一级组织的数量为2^10或1024个。 |
| ***Level2 ID\***           | 12              | ***Level 2 Identifier:\*** 2级标识符：分配给1级组织的每个块将使用12位创建4096个地址块，以在其服务的较低级别组织之间划分。                  |
| ***Level3 ID\***           | 23              | ***Level 3 Identifier:\*** 3级标识符：每个2级组织都有23位用于划分其2级地址块。因此，它可以创造800多万个人                          |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipv6unicastsample.png)

​                                                           **图97：IPv6单播路由前缀结构示例**

顶行显示全局IPv6单播地址格式。第二个示例显示了一种将全局路由前缀划分为三个级别的方法，分别使用10、12和23位。第三行显示如何使用前10位创建2^10或1024个不同的Level1块。下一行说明，对于这13位前缀中的每一个，我们可以有2^12或4096个Level2块。然后，在每个25位Level2 ID中，我们有23位或8388608 Level3块。在底部，级别3或“/48”将分配给单个组织。

这只是一种可能的理论方法，即可以分配“/48”网络地址中的位。正如你所看到的，有了这么多的比特，就有了很大的灵活性。在上述方案中，我们可以拥有400多万个二级组织，每个组织可以分配800万/48个地址。而且每个地址的大小都相当于IPv4 B类地址（超过65000个主机）！

<u>**关于全球单播格式的补充说明**</u>

删除RFC 2374对全局路由前缀的“固定结构”与IPv6开发团队强调位域和结构只用于分配地址，而不是用于路由目的的努力是一致的。地址本身一旦创建，就不会被基于这种格式的互联网硬件解释。对于路由器，唯一的结构是网络ID和终端ID之间的划分，由IP地址后面的前缀长度给出，这种划分可以发生在任何位边界上。这些硬件设备只看到一个IP地址的128位，并使用它，而不知道分层地址划分或“级别”。

同样值得注意的是，获得可聚合单播地址格式的分配好处的关键是在IPv6下我们可以获得丰富的比特。有这些层次的能力，同时仍然允许64位的接口ID是IPv6设计者的地址大小从32位一路走到128位的主要原因之一。通过创建这种结构，我们保持了灵活性，同时避免了在128位中分配许多不同网络大小的潜在混乱。

最后，请注意，任意广播地址的结构与单播地址相同，因此它们根据相同的模型进行分配。相反，多播地址不是;它们从自己的IPv6地址空间分配。

###### 3.1.3.2-6 IPv6接口标识符和物理地址映射(部分:1和2)

在IPv4中，IP地址与用于底层数据链路层网络技术的地址没有关系。使用以太网卡(NIC)连接到TCP/IP网络的主机有一个以太MAC地址和一个IP地址，但这两个数字是不同的，在任何方面都不相关。IP地址由管理员手动分配，而不考虑底层的物理地址。

<u>**IPv6非常大的地址大小的收益**</u>

随着IPv6寻址技术的革新，一个创造更好的IP单播地址和物理网络地址映射方式的机会出现了。实现这种高级映射技术是IPv6地址变得如此庞大的原因之一。正如我们在前面的主题中看到的，128位的总数，即使为网络前缀保留了整整45位，为站点子网保留了16位，我们仍然有64位用于接口标识符，这类似于IPv4下的主机ID。

有这么多的比特供我们使用，给了我们很大的灵活性。我们可以根据底层数据链路层硬件地址来确定接口ID，而不是使用任意“编造”的主机标识符，只要该地址的长度不超过64位。因为几乎所有的设备都使用64位或更少的二层地址，所以在IP地址中使用这些地址作为接口标识符是没有问题的。这提供了一个直接的好处:它使网络更容易管理，因为我们不必为每个主机记录任意两个数字。IP地址可以由MAC地址和网络标识符派生。这也意味着我们将来可以区分IP地址和MAC地址，反之亦然。

<u>**IPv6修改后的EUI-64格式**</u>

从数据链路层地址到IP接口标识符的实际映射取决于特定的技术。当然，同一网络上的所有设备都必须使用相同的映射技术。到目前为止，网络中最常见的二层地址类型是IEEE 802 MAC地址，用于以太网和其他IEEE 802项目网络技术。你可能已经知道，这些地址有48位，分成两个24位的块。上面的24位被排列成一个称为组织唯一标识符(OUI)的块，并为各个组织分配不同的值;下面的24位用于每个特定设备的标识符。

IEEE还定义了一种称为64位扩展惟一标识符的格式，简称EUI-64。它类似于48位MAC格式，除了OUI保持24位，设备标识符变为40位而不是24位。这为每个制造商在其OUI中提供了65,536倍的设备地址。

这种格式的一种形式，称为修改的EUI-64，已被用于IPv6接口标识符。要获得修改后的设备EUI-64接口ID，只需取EUI-64地址，并将左侧第7位(“通用/本地”或“U/L”位)从0更改为1。

<u>**将48位MAC地址转换为IPv6修改的EUI-64标识符**</u>

当然，大多数设备仍然使用旧的48位MAC地址格式。它们可以转换为EUI-64格式，然后再转换为修改后的EUI-64格式，用于创建IPv6接口ID。流程如下:

1. 我们取24位的OUI部分，即以太网地址最左边的24位，并将它们放入接口ID最左边的24位中。我们取24位的本地部分(以太网地址最右边的24位)，并将其放入接口ID最右边的24位。

2. 在接口ID中间的其余16位中，我们放入值“11111111 11111110”(十六进制的“FFFE”)。

3. 地址现在是EUI-64格式。我们将“通用/局部”位(从左开始的第7位)从0改为1。这为我们提供了修改后的EUI-64接口ID。

**关键概念**:IPv6单播地址的最后64位用于接口标识符，该标识符以一种称为修改的EUI-64的特殊格式创建。可以使用一个简单的过程从设备(如以太网网络接口卡)的48位MAC地址确定接口标识符。然后可以结合网络前缀(路由前缀和子网ID)确定设备对应的IPv6地址。

让我们以39-A7-94-07-CB-D0的以太网地址为例(如图98所示):

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipv6eui64.png)

​                                                      **图98:IEEE 802 MAC地址转换为IPv6修改过的EUI-64标识符**

1. 我们取标识符的前24位“39-A7-94”，并将其放入地址的前(最左)24位。“07-CB-D0”的本地部分成为标识符的最后24位。

2. 中间的16位赋值为“FF-FE”。

3. 我们将第7位从0变为1，这将第一个八位从“39”变为“3B”。

因此该标识符变为“3B-A7-94-FF-FE-07-CB-D0”，或者在IPv6冒号十六进制中为3BA7:94FF:FE07:CBD0。设备地址的前64位使用全局单播地址格式提供。

这种技术的唯一缺点是，如果物理硬件发生变化，IPv6地址也会发生变化。

###### 3.1.3.2-7 IPv6特殊地址:保留，私有(Link-Local / Site-Local)，未指定和环回(部分:1 2 3)

正如某些IPv4地址范围被指定为保留地址、私有地址和其他“不寻常的”地址一样，巨大的IPv6地址空间的一小部分被预留给了特殊地址。这些地址和地址块的目的是为IPv6网络中的特殊需求和私有使用提供地址。当然，IPv6的好处是，即使是相对较小的部分，它仍然是巨大的，所以留出0.1%的地址空间用于特定用途，通常仍然会产生比任何人都需要的更多的地址。

<u>**特殊IPv6地址类型**</u>

“特殊”IPv6地址有四种基本类型:保留、私有、环回和未指定。

<u>**保留地址**</u>

一部分地址空间被预留出来，供IETF当前和未来的各种用途使用。与IPv4不同，IPv4在地址空间的不同位置有许多小的保留块，IPv6中的保留块位于地址空间的“顶部”:以“0000 0000”开头的块(或以16进制的第一个八位字节为00)。这表示总地址空间的1/256。下面的一些特殊地址来自这个空间。IPv4地址嵌入也在这个保留地址区域内完成。

**注意:** 保留地址与未分配地址是不同的。后一个术语只是指那些用途尚未确定的区块。

<u>**专用/未注册/不可路由地址**</u>

与IPv4一样，一个地址块被预留给私有地址，不同的是，与IPv6中的所有内容一样，IPv6中的私有地址块要大得多。这些专用地址仅限于特定链接或站点，因此永远不会路由到特定公司的网络之外。

私有地址由前九位为“1111 1110 1”的地址表示。因此，私有地址的第一个八位字节值是十六进制的“FE”，下一个十六进制数字是从“8”到“F”。这些地址根据其范围进一步分为两种类型，如下所述。

<u>**环回地址**</u>

像IPv4一样，已经为测试提供了一个特殊的环回地址；发送到此地址的数据报“循环”到发送设备。然而，在IPv6中，此功能只有一个地址，而不是一个完整的块（实际上，一开始根本就不需要它！）环回地址为0:0:0:0::0:0:0:1，通常使用零压缩表示为“：：1”。

<u>**确定地址**</u>

在IPv4中，所有0 的IP地址具有特殊含义；它指的是主机本身，在设备不知道自己的地址时使用。在IPv6中，这个概念已经正式化，全零地址（0:0:0:0:0-0:0:0:0）被命名为未指定的地址。它通常用于寻求配置其IP地址的设备发送的数据报的源字段。此地址可以应用0压缩；因为它都是0，地址就变成了“：：”。（我自己认为这很令人困惑。我认为“0:：0”这样的词更清楚，也够简短。）

**关键概念：**在IPv6中，为测试目的预留了一个特殊的环回地址0:0:0:0::0:0:0:1（压缩形式的“：：1”）。未指定的地址0:0:0:0:0-0:0:0:0（压缩格式为“：：”）用于指示未知地址。定义了一个私有或本地地址块，它是以“11111101”作为前九位开始的所有地址的集合。

<u>**IPv6私有地址类型/作用域**</u>

现在，让我们更深入地了解一下私有地址。在IPv6中，这些地址称为本地使用的地址，这个名称清楚地表达了它们的用途。它们有时也称为链路层地址。回想一下，当无法获取所有设备的公有地址时，通常使用IPv4私有地址，有时与网络地址转换(NAT)等技术结合使用。在IPv6中，不需要像NAT这样的诡计。相反，本地使用的地址旨在用于本质上仅设计为仅发送到本地设备的通信。例如，使用IPv6邻居发现(ND)协议的邻居发现功能使用本地使用的地址。

本地地址的范围显然是本地网络，而不是公共互联网地址的全局范围。IPv6中的本地地址进一步分为两种类型，反映了本地范围的进一步划分。

<u>**站点-本地地址。**</u>
这些地址的范围是整个站点或组织。它们允许在不需要使用公共前缀的情况下在组织内寻址。路由器将使用站点内的站点本地地址(但不是站点外部的地址)将数据报转发到公共互联网。

站点本地地址与链路本地地址的区别在于，在所有私有IPv6地址共有的九个起始地址位之后有第十位“1”。因此，它们以“1111111011”开头。在十六进制中，站点本地地址以“FE”开头，然后以“C”到“F”表示第三个十六进制数字。因此，这些地址以“FEC”、“FED”、“Fee”或“FEF”开头。

<u>**本地链路地址**</u>
这些地址的范围比站点本地地址小；它们仅指特定的物理链路(物理网络)。路由器根本不会使用本地链路地址转发数据报，甚至在组织内部也不会；它们只用于特定物理网段上的本地通信。它们可用于地址配置或ND功能，如地址解析和邻居发现。

链路本地地址与站点本地地址的不同之处在于，在所有私有IPv6地址共有的九个初始地址位之后，具有第十位“0”：“111111101”。因此，站点本地地址以“FE”开头，然后以“8”到“B”表示第三个十六进制数字。因此，这些地址以“FE8”、“FE9”、“FEA”或“FEB”开头。

**关键概念**：IPv6站点本地地址仅允许将数据发送到站点或组织内的设备。它们以十六进制的“FEC”、“FED”、“Fee”或“FEF”开头。IPv6本地链路地址仅在特定本地链路(物理网络)上使用，通常用于地址解析或邻居发现等特殊目的。它们以“FE8”、“FE9”、“FEA”或“Feb”开头。

请注意，站点本地IPv6地址等同于IPv4私有地址，因为它们在整个组织内进行路由。链路本地作用域的概念是IPv6中的新概念。

###### 3.1.3.2-8 IPv6/IPv4地址嵌入(部分:1 2)

由于互联网协议的重要性和IPv6所作变化的重要性，部署该协议的较新版本不会一下子完成。需要从IPv4过渡到IPv6，这需要仔细规划。预计从IPv4向IPv6的迁移将需要数年时间。我将在专门讨论IPv4/IPv6过渡问题的专题中讨论这一点。

如果使用特殊技术，则IPv6向后兼容IPv4。例如，为了实现通过IPv4网络连接的IPv6设备的“岛”之间的通信，可以使用隧道。为了支持IPv4/IPv6兼容性，开发了一种允许在IPv6地址结构中嵌入IPv4地址的方案。此方法采用常规的IPv4地址，并将其设置为特殊的IPv6格式，以便某些IPv6设备将其识别为IPv4地址。

由于IPv6地址空间比IPv4地址空间大得多，因此将后者嵌入前者很容易；这就像将一辆紧凑型轿车塞进货船的船舱一样。嵌入地址空间是保留地址块的一部分，该保留地址块的地址以八个零比特开始，但只是其中相对较小的一部分。使用了两种不同的嵌入格式。两者的地址前80位都为零，并将嵌入的IPv4地址放入IPv6地址格式的后32位。它们之间剩余的16位的值不同(位81到96，从左开始计数)：

使用这两种嵌入格式是为了使用嵌入地址来指示设备的能力。

**与IPv4兼容的IPv6地址**
这些地址是分配给支持IPv6的设备的特殊地址，例如同时使用IPv4和IPv6的所谓“双协议栈”设备。它们的中间16位都是零；因此，它们从96个零的字符串开始，后跟IPv4地址。这种地址的示例如图99所示，其混合表示法为0：0：0：0：0：101.45.75.219，或者更简洁地表示为：：101.45.75.219。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipv6ipv4compatible.png)

​                                                                       **图99：兼容IPv4的嵌入式IPv6地址表示法**

<u>**IPv4映射的IPv6地址**</u>

这些是已映射到IPv6地址空间的常规IPv4地址，用于仅支持IPv4的设备。它们在80个0的初始字符串之后有一组16个1，然后是IPv4地址。因此，如果IPv4设备的地址为222.1.41.90，如图100所示，它将表示为0：0：0：0：0：ffff：222.1.41.90或：：ffff：222.1.41.90。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipv6ipv4mapped.png)

​                                                                        **图100：IPv4映射的嵌入式IPv6地址表示法。**

**关键概念：**IPv4地址嵌入用于在IPv4地址和IPv6地址之间创建关系，以帮助从IPv4过渡到IPv6。一种类型是与IPv4兼容的IPv6地址，用于同时与IPv4和IPv6兼容的设备；它以96个零位开始。另一个是IPv4映射地址，用于将与IPv6不兼容的IPv4设备映射到IPv6地址空间；它以80个0开头，后跟16个1。

**<u>比较兼容IPv4和映射IPv4的嵌入式IPv6地址。</u>**

这两种地址之间的区别很细微，但很重要。前80位始终为零，因此当看到这一点时，您就知道它是某种嵌入的IPv4地址。兼容IPV4的IPv6地址仅用于实际支持IPV6的设备；兼容IPV4的地址是对其常规IPV6地址的补充。相反，如果在首字母80之后的16位中看到“FFFF”，则这表示其IPv4地址已被映射到IPv6格式的传统的IPv4设备。它不是支持IPv6的设备。

###### 3.1.3.2-9 IPv6组播和任意播寻址(部分:1 2 3 4 5)

IPv6中一般寻址模型中最重要的修改之一是对基本地址类型及其使用方式的更改。与在IPv4中一样，单播地址仍然是绝大多数通信的选择，但在IPv6中，“批量”寻址方法有所不同。作为特定寻址类型的广播已被消除。取而代之的是，对多播寻址的支持得到了扩展，并成为协议的必需部分，并且实现了一种称为任播的新型寻址。

<u>**IPv6组播地址**</u>
让我们从IPv6下的组播开始。组播用于允许单个设备向一组收件人发送数据报。IPv4支持在有类寻址方案中使用D类地址块进行组播寻址。在IPv6下，组播地址是从组播块分配的。这是地址空间的1/256，由所有以“1111 1111”开头的地址组成。因此，冒号十六进制表示法中以“FF”开头的任何地址都是IPv6组播地址。

剩余的120位地址空间足以定义一个或三个多播地址。(好的，官方数据约为1.3万亿个地址。)。就像单播地址的分配是通过使用一种特殊的格式来划分这许多位来组织的一样，对多播地址也是如此。

<u>**IPv6组播地址格式。**</u>
组播地址的格式如表65所示，如图101所示。

​                                                                                     **表65：IPv6组播地址格式**

| **Field Name**     | **Size (bits)** | **Description**                                                                                                                         |
| ------------------ | --------------- | --------------------------------------------------------------------------------------------------------------------------------------- |
| ***(Indicator)\*** | 8               | 前八位始终为“1111 1111”，表示多播地址。在删除该术语之前，它曾被称为“格式前缀”，如IPv6地址空间分配主题中所述；该字段现在没有名称。                                                               |
| ***Flags\***       | 4               | ***Flags:\*** 为标志保留四位，可用于指示特定多播地址的性质。目前，前三个未使用并设置为零。第四个是“T”（瞬态）标志。如果保留为零，则将多播地址标记为永久分配的“已知”多播地址，如下所示。如果设置为1，这意味着这是一个临时多播地址，意味着它不是永久分配的。 |
| ***Scope ID\***    | 4               | ![img](http://www.tcpipguide.com/free/aa1f0d82.png)                                                                                     |
| ***Group ID\***    | 112             | ***Group ID:\*** 定义每个范围级别中的特定组。                                                                                                         |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipv6multicast.png)

​                                                                             **图101:IPv6多播地址格式**

<u>**多播作用域**</u>

明确界定组播地址作用域的概念很重要。全局范围的组播地址在整个Internet中必须是唯一的，但本地范围的地址仅在组织内是唯一的。这提供了极大的灵活性，因为每种类型的组播地址实际上都有几种“版本”：一种只在节点内组播，一种在本地链路(本地网络)上，一种在本地站点上，等等。该范围还允许路由器立即确定它们应该传播多大范围的组播数据报，以提高效率并消除将流量发送到预期区域之外的问题。图102图形化地说明了作用域的概念(您不觉得它很漂亮吗？j)。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipv6scope.png)

​                                                                                       **图102：IPv6组播作用域**

此图显示了作用域概念如何将IPv6组播限制在特定影响范围内。“最紧”的作用域是节点-本地作用域，作用域ID值为1。随着作用域ID值的增加，作用域扩大到覆盖本地网络、站点、组织，最后覆盖整个Internet。

**关键概念：**组播地址用于同时向网际网络中的多个设备发送数据。在IPv6中，可以为各种不同的作用域指定每个组播地址，从而使传输可以针对广泛或狭窄的接收方设备受众。

**<u>广为人知的组播地址</u>**

瞬时标志允许明确地确定哪些组播地址可用于正常使用，而哪些组播地址被放在一边被留作“众所周知的”。通过保留用于多个不同作用域ID值的某些组ID，定义了几个预定义的众所周知的组播地址。表66显示了这些值；多播地址模式中的“x”是对应于4位范围ID字段的十六进制数字。

“所有节点”和“所有路由器”组播地址实现了与在IPv4中执行的广播功能相同的功能。同样，作用域的概念在这种类型的多播中很重要，例如，因为我们不想尝试向全球Internet上的“所有节点”发送消息。因此，当“所有路由器”地址的作用域值为2时，它表示“本地链路上的所有路由器”。如果与值5一起使用，则表示“此站点中的所有路由器”。

​                                                                        **表66：重要的IPv6“知名”组播地址**

| **Multicast Address Pattern** | **Valid Scope Values (decimal)** | **Designation** | **Description**                                                                      |
| ----------------------------- | -------------------------------- | --------------- | ------------------------------------------------------------------------------------ |
| FF0x:0:0:0:0:0:0              | 0 to 15                          | Reserved        | 保留112位组ID为零的所有多播地址。                                                                  |
| FF0x:0:0:0:0:0:1              | 1, 2                             | All Nodes       | 当组ID正好等于1时，这是对所有节点的组播。节点本地（FF01:0:0:0:0:0:1）和链路本地（FF02:0:0:0:0:0:1）"所有节点 "组播地址都是可能的。 |
| FF0x:0:0:0:0:0:2              | 1, 2, 5                          | All Routers     | 当组ID正好等于2时，这会将特定范围内的所有路由器指定为收件人。有效范围值为节点本地、链接本地和站点本地。                                |

<u>**请求的节点组播地址**</u>

除了常规的组播地址外，每个单播地址都有一个特殊的组播地址，称为其请求节点地址。此地址是通过从设备的单播地址进行特殊映射创建的。IPv6邻居发现(ND)协议使用请求节点地址来提供比IPv4中使用的ARP技术更有效的地址解析。

所有请求节点地址的T标志都设置为0，作用域ID设置为2，因此它们以“FF02”开头。112位组ID分解如下(参见图103)：

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipv6solicitednode (1).png)
                                                               **图103：IPv6请求节点地址计算**

请求的节点组播地址是从单播地址计算出来的，方法是取地址的最后24位，并在它们前面加上IPv6部分地址“FF02：0：0：0：0：0：1：Ff”。图95中的示例地址转换为其请求的节点地址FF02：：1：FFC8：1FFF。

- 由79个0和一个1组成的80位；这意味着在冒号十六进制记法中，接下来的五个十六进制值是“0000：0000：0000：0000：0001”，或者更简洁地说，是“0：0：0：0：1”。
- 8个1：“FF”。
- 24位取自其单播地址的最低24位。

因此，这些地址以“FF02：0：0：0：0：1：ff”开头，后跟单播地址的后24位。因此，IP地址为805B：2D9D：DC28：0：0：FC57：D4C8：1FFF的节点将具有请求节点地址FF02：0：0：0：0：0：1：FFC8：1FFF(或FF02：：1：FFC8：1FFF)。

**关键概念：**每个单播地址都有一个等效的请求节点组播地址，该地址是从单播地址创建的，并在其他设备需要在本地网络上到达它时使用。

<u>**IPv6任播地址**</u>

任播地址是一种新的、唯一的地址类型，对于IPv6中的IP来说是新的；IPv6实施基于RFC 1546，主机任播服务中的材料。可以将任播地址视为单播寻址和组播寻址之间的概念交叉。其中单播说的是“发送到这个地址”，而多播说的是“发送到这个组的每一个成员”，而任播说的是“发送到这个组的任何一个成员”。当然，在选择发送给哪个成员时，出于效率原因，我们通常会发送到最接近的成员-在路由方面最接近的成员。因此，我们通常也可以认为Anycast的意思是“发送给这个组中最接近的成员”。

Anycast背后的想法是启用以前难以在TCP/IP中实现的功能。Anycast专门用于在需要由多个不同服务器或路由器提供但实际上并不关心提供它的服务器或路由器的服务的情况下提供灵活性。在路由中，任播允许将数据报发送到一组等价路由器中距离最近的任何路由器，以允许路由器之间的负载分担和在某些路由器停止服务时的动态灵活性。发送到任播地址的数据报将自动发送到最容易到达的设备。

也许令人惊讶的是，没有特殊的任播寻址方案：任播地址与单播地址相同。当将单播地址分配给多个接口时，会自动创建任播地址。

与组播一样，任播为路由器带来了更多的工作；它比单播寻址更复杂。具体地说，共享任播地址的设备距离越远，产生的复杂性就越大。全球互联网上的任播可能很难实现，而IPv6任播是为彼此接近的设备设计的，通常在同一网络中。此外，由于互联网社区在使用任播方面相对缺乏经验，目前任播地址仅由路由器使用，而不是单个主机。

**关键概念：**任播地址是IPv6中的新增地址，可用于设置一组设备，其中任何一个都可以响应发送到单个IP地址的请求。

###### 3.1.3.2-10 IPv6自动配置和重编号

IPv6中实施的最有趣和最有潜在价值的寻址功能之一是允许IPv6上的设备实际独立配置自己的功能。在IPv4中，主机最初是手动配置的。后来，主机配置协议(如DHCP)使服务器能够向加入网络的主机分配IP地址。IPv6更进一步，定义了一种方法，使某些设备无需服务器即可自动配置其IP地址和其他参数。它还定义了一种方法，通过该方法可以对网络上的IP地址进行重新编号(集体更改)。这些都是令TCP/IP网络管理员垂涎三尺的功能。

IPv6自动配置和重新编号功能在RFC 2462，IPv6无状态地址自动配置中定义。“无状态”一词将该方法与基于服务器的方法进行了对比，该方法使用了类似于DHCPv6的东西，这被称为“有状态”。(另一个像“有类”这样的词让我很难堪。)。这种方法之所以称为“无状态”，是因为它是从一个“dead start”开始的，根本没有任何信息(或“状态”)可供主机使用，并且不需要一台DHCP服务器。

<u>**IPv6无状态自动配置**</u>

无状态自动配置利用了IPv6中的其他几个新功能，包括本地链路地址、组播、邻居发现(ND)协议，以及从底层数据链路层地址生成地址的接口标识符的功能。一般的想法是让设备生成一个临时地址，直到它可以确定它所在网络的特征，然后根据该信息创建一个它可以使用的永久地址。在多宿主设备的情况下，如您所料，每个接口分别执行自动配置。

以下是设备在使用无状态自动配置时采取的步骤摘要：

1. 本地链路地址生成：设备生成本地链路地址。回想一下，这是本地使用的两种IPv6地址之一。本地链路地址的前十位为“1111 1110 10”。生成的地址使用这10位后跟54个零，然后是64位接口标识符。通常，这将从数据链路层(MAC)地址派生，如关于接口标识符的主题中所述，或者它可能是以某种其他方式生成的“令牌”。
2. 链路本地地址唯一性测试：节点进行测试，以确保其生成的地址由于某种原因没有在本地网络上使用。(如果本地链路地址来自MAC地址，则这不太可能成为问题，但如果它基于生成的令牌，则更有可能。)。它使用邻居发现(ND)协议发送邻居请求消息。然后，它会侦听邻居通告作为响应，该通告指示另一台设备已在使用其本地链路地址；如果是这样的话，要么必须生成新地址，要么自动配置失败，必须使用另一种方法。
3. 本地链路地址分配：假设唯一性测试通过，设备会将本地链路地址分配给其IP接口。此地址可用于本地网络上的通信，但不能用于更广泛的Internet上的通信(因为本地链路地址不会被路由)。
4. 路由器联系：该节点下一步尝试联系本地路由器以获取有关继续配置的更多信息。这可以通过侦听路由器定期发送的路由器通告消息来实现，也可以通过发送特定的路由器请求来向路由器请求有关下一步操作的信息。此过程在IPv6邻居发现协议一节中介绍。
5. 路由器方向：路由器向节点提供如何继续进行自动配置的方向。它可以告诉节点在此网络上正在使用“有状态”自动配置，并告诉它要使用的DHCP服务器的地址。或者，它会告诉主机如何确定其全球互联网地址。
6. 全局地址配置：假设网络上正在使用无状态自动配置，主机将使用其全球唯一的Internet地址进行自我配置。该地址通常由路由器提供给主机的网络前缀与第一步中生成的设备标识符组合而成。

显然，与手动配置和基于服务器的配置相比，此方法具有许多优势。它在支持IP设备的移动性方面特别有用，因为它们可以移动到新网络并获得有效地址，而不需要了解任何本地服务器或网络前缀。同时，如果需要的话，它仍然允许使用(IPv6兼容的)版本的DHCP来管理IP地址。本地网络上的路由器通常会使用ICMPv6路由器通告消息中的特殊标志告诉主机支持哪种类型的自动配置。

**关键概念：**IPv6包含一个有趣的功能，称为无状态地址自动配置，它允许主机按照特殊的过程从第二层地址实际确定自己的IPv6地址。

**IPv6设备重新编号**

设备重新编号是一种与自动配置相关的方法。与主机配置一样，它可以使用DHCP等协议来实现，通过使用一段时间后到期的IP地址“租约”。在IPv6下，当自动配置完成时，可以通过让路由器为网络前缀指定过期间隔来对网络重新编号。稍后，他们可以发送一个新的前缀，告诉设备重新生成其IP地址。设备实际上可以将旧的“不推荐”地址保留一段时间，然后转移到新地址。

RFC 2894中还定义了一种用于重新编号路由器地址的类似技术。它使用特殊的ICMPv6消息，并在该部分的主题中进行了描述。

###### 3.1.3.3 IPv6数据报封装和格式化

通过IPv6网际网络传输数据是通过将高层数据封装到IPv6数据报中来完成的。这些协议用于IPv6的一般用途与协议的旧版本中的IPv4数据报相同。然而，作为IPv6所代表的整体变化的一部分，它们已被重新设计。IPv6数据报具有灵活的结构，其格式更符合当前IP网络的需求。

在本节中，我将介绍IPv6数据报使用的格式。我首先概述了IPv6数据报的一般结构，描述了主要变化，并展示了主报头和扩展报头在数据报中的排列方式。然后描述主头的格式，并定义和描述各种扩展头类型。最后，我将简要解释IPv6选项及其实现方式。

**背景信息：**本部分假定您基本了解IPv6寻址概念，并大体熟悉IPv4数据报格式。

###### 3.1.3.3-1 IPv6数据报概述和总体结构(第1部分：第2部分)。

IPv6封装从更高层协议接收的数据以通过网际网络传输的方法与IPv4使用的方法基本相同。从传输层或更高层接收的数据成为IPv6数据报的有效负载，该数据报具有一个或多个控制消息传递的报头。这些报头向路由器提供信息，使它们能够在网络中移动数据报，也向主机提供信息，以便它们可以知道它们打算接收哪些数据报。

<u>**IPv6中数据报结构和字段的主要变化概述。**</u>

虽然数据报的基本用法自IPv4以来没有改变，但在创建IPv6时对其结构和格式进行了许多修改。这在一定程度上是出于必要性：IPv6地址不同于IPv4地址，而IP地址位于数据报头中。IP地址的大小从32位增加到128位，为报头增加了惊人的额外192位，即24字节的信息。这反过来又导致了一种努力，即删除不是严格必要的字段，以补偿必要的大小增加。然而，也对IPv6数据报进行了更改，以添加功能，使其更好地适应现代互联网的需要。

以下是IPv6中数据报最重要的总体更改列表：

多报头结构：IPv6数据报不是包含数据报的所有字段的单个报头(可能包括选项)，而是支持“主”报头，然后在需要时支持用于附加信息的扩展报头。

- 简化的标题格式：从主标题中删除了几个字段，以减小其大小并提高效率。只有几乎所有数据报真正需要的字段保留在主头中；其他字段被放入扩展头中，并根据需要使用。其中一些被删除是因为不再需要它们，例如Internet报头长度字段；IPv6报头具有固定长度。在有关主IPv6报头的主题中对此进行了更详细的讨论。
- 重命名字段：一些字段已重命名，以更好地反映其在现代网络中的实际使用情况。
- 更大的灵活性：扩展报头允许在需要时随数据报一起提供大量额外信息。IPv6中也支持选项。
- 无需计算校验和：在IPv6中，不再对报头计算校验和。这既节省了打包IP数据报的每个设备(主机和路由器)所花费的计算时间，也节省了校验和字段在IPv4报头中占用的空间。
- 改进的服务质量支持：定义了一个新的字段--流标签，以帮助支持确定流量的优先级。

**关键概念**：IPv6数据报使用的一般结构以40字节长度的强制主头开始，然后是可选的扩展头，然后是可变长度的数据区。创建这种结构是为了简化主报头，同时允许设备在需要时向数据报添加额外信息。

<u>**IPv6通用数据报结构**</u>

正如我上面提到的，IPv6数据报现在包括一个主头格式(在标准中没有正式名称，它只是“头”)和0个或多个扩展头。因此，总体结构如表67和图104所示。

​                                                                             **表67：IPv6通用数据报结构**

| **Component**            | **Number of Components Per Datagram** | **Size (bytes)** | **Description**                        |
| ------------------------ | ------------------------------------- | ---------------- | -------------------------------------- |
| ***Main Header\***       | 1                                     | 40               | 包含源地址和目的地址，以及每个数据报需要的重要信息。             |
| ***Extension Headers\*** | 0 or more                             | Variable         | 每个都包含一种类型的额外信息，以支持各种功能，包括分片、源路由、安全和选项。 |
| ***Data\***              | 1                                     | Variable         | 数据报中要传输的来自上层的有效载荷。                     |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipv6genformat.png)

​                                                                   **图104：IPv6通用数据报结构**

**请注意，与IPv4一样，大的有效载荷可以在封装前进行分片，以确保数据报的总大小不超过基础网络允许的最大大小。然而，IPv6中的分片细节与IPv4中不同。**

###### 3.1.3.3-1 IPv6数据报主报头格式(部分：1 2 3)。

正如我们在上一个主题中看到的，IPv6数据报使用的结构包括常规报头和一个或多个扩展报头(可选)。此常规报头类似于IPv4数据报的报头，尽管它具有不同的格式，我们很快就会看到。标准没有给这个报头命名；它只是“IPv6报头”。为了将其与IPv6扩展报头区分开来，我将其称为主报头。

<u>**主报头格式**</u>
每个数据报都需要IPv6主头。它包含用于管理数据报处理和路由的寻址和控制信息。IPv6数据报的主要报头格式如表68所示，如图105所示。

​                                                                             **表68：IPv6主头格式**

| **Field Name**             | **Size (bytes)** | **Description**                                                                                                                                                                                                                                                                                        |
| -------------------------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| ***Version\***             | 1/2 (4 bits)     | ***Version:\*** 版本。识别用于生成数据报的IP版本。这个字段的使用方式与IPv4相同，当然，除了它携带的值是6（0110二进制）。                                                                                                                                                                                                                              |
| ***Traffic Class\***       | 1                | ***Traffic Class:\*** 流量类别。这个字段取代了IPv4头中的服务类型（TOS）字段。它不是按照TOS字段的原始定义方式（用优先级、D、T和R位），而是使用RFC 2474中定义的新的差异化服务（DS）方法。该RFC实际上规定了IPv4和IPv6的服务质量（QOS）技术；更多信息见IPv4格式描述。                                                                                                                                       |
| ***Flow Label\***          | 2 1/2 (20 bits)  | ***Flow Label:\*** 流量标签。这个大字段的创建是为了给实时数据报传输和服务质量特性提供额外支持。流的概念在RFC 2460中定义为从一个源设备发送到一个或多个目标设备的数据报序列。一个独特的流标签用于识别特定流中的所有数据报，以便源和目的地之间的路由器都以相同的方式处理它们，以帮助确保流中数据报交付方式的统一性。例如，如果一个视频流在IP网络中被发送，包含该流的数据报可以用一个流标签来识别，以确保它们以最小的延迟被传送。**并非所有的设备和路由器都支持流量标签处理，源设备对该字段的使用是完全可选的。此外，该字段仍具有一定的实验性，可能会随着时间的推移而被完善。** |
| ***Payload Length\***      | 2                | ***Payload Length:\*** T有效载荷长度。这个字段取代了IPv4头中的总长度字段，但它的使用方式不同。它不是测量整个数据报的长度，而是只包含有效载荷的字节数。然而，如果扩展头被包括在内，它们的长度也会在这里被计算。                                                                                         **更简单地说，这个字段测量的是数据报的长度减去主标头本身的40字节。**                                                    |
| ***Next Header\***         | 1                | ***Next Header:\*** 下一个头。这个字段取代了协议字段，有两种用途。当一个数据报有扩展头时，这个字段指定了第一个扩展头的身份，它是数据报的下一个头。当一个数据报只有这个 "主 "头而没有扩展头时，它的作用与旧的IPv4协议字段相同，并且具有相同的值，尽管新的数字用于常见协议的IPv6版本。在这种情况下，"下一个头 "是IPv6数据报携带的上层消息的头。更多细节见下文。                                                                                                     |
| ***Hop Limit\***           | 1                | ***Hop Limit:\*** 跳数限制：它取代了IPv4头中的生存时间（TTL）字段；其名称更好地反映了现代网络中使用TTL的方式（因为TTL实际上是用来计算跳数，而不是时间。）                                                                                                                                                                                                           |
| ***Source Address\***      | 16               | ***Source Address:\*** 源地址。数据报发起人的128位IP地址。与IPv4一样，这始终是最初发送数据报的设备。                                                                                                                                                                                                                                     |
| ***Destination Address\*** | 16               | ***Destination Address:\*** 目的地地址。数据报预定接收者的128位IP地址；单播、任播或多播。同样，即使路由器等设备可能是数据报的中间目标，这个字段也总是用于最终目的地。                                                                                                                                                                                                    |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipv6format.png)

​                                                                                  **图105：IPv6主标头格式**

<u>**IPv6下一个报头字段**</u>

下一个报头字段是对IPv6数据报格式最重要的补充之一。当IPv6数据报使用扩展报头时，此字段包含第一个扩展报头的标识符，该扩展报头又使用其自己的下一个报头指向下一个报头，依此类推。然后，最后一个扩展报头引用封装的更高层协议--因为更高层协议的报头出现在IPv6数据字段的开头，所以对于接收数据报的设备来说，它就像“下一个报头”。对于一些人来说，从概念上看这有点困难；有关该字段如何工作的更多详细信息(包括有用的插图)可以在下一个主题中找到，该主题描述了扩展标头。表69显示了IPv6中Next报头的一些最常见的值。

​                                                                                **表69：常见的IPv6下一标头值**

| **Value (Hexadecimal)** | **Value (Decimal)** | **Protocol / Extension Header**      |
| ----------------------- | ------------------- | ------------------------------------ |
| 00                      | 0                   | Hop-By-Hop选项扩展头(注意，此值在IPv4中是 "保留 "的) |
| 01                      | 1                   | ICMPv4                               |
| 02                      | 2                   | IGMPv4                               |
| 04                      | 4                   | IP封装中的IP                             |
| 06                      | 6                   | TCP                                  |
| 08                      | 8                   | EGP                                  |
| 11                      | 17                  | UDP                                  |
| 29                      | 41                  | IPv6                                 |
| 2B                      | 43                  | Routing Extension Header             |
| 2C                      | 44                  | 分片扩展头                                |
| 2E                      | 46                  | 资源预订协议（RSVP）                         |
| 32                      | 50                  | 加密安全有效载荷（ESP）扩展头                     |
| 33                      | 51                  | 验证头（AH）扩展头                           |
| 3A                      | 58                  | ICMPv6                               |
| 3B                      | 59                  | No Next Header                       |
| 3C                      | 60                  | 目的地选项扩展头                             |

主IPv6报头格式的总长度为40字节。这是没有选项的IPv4报头大小的两倍，这主要是因为巨大的IPv6地址需要额外的24字节。IPv6主报头中只有8个字节的非地址报头字段，而IPv4报头中有12个字节。

**IPv4和IPv6之间主标头的主要变化**

总而言之，IPv6主报头与IPv4报头的比较如下：

- 未更改的字段：三个字段使用相同的方式并保留相同的名称(尽管它们具有不同的内容和/或大小)：版本、源地址和目标地址。

- 重命名的字段：两个字段的使用方式相同，但已重命名：流量类别和跳数限制。

- 修改后的字段：两个字段的使用方式类似于它们的IPv4前身，但含义略有不同，并且还重命名为：有效载荷长度和下一个报头。

- 新增字段：新增一个字段：Flow Label。

- 删除的字段：为了减少报头长度和不必要的工作，从IPv6报头中删除了五个IPv4报头字段：
  互联网报头长度：不再需要，因为主IPv6报头的长度固定为40字节。

- ​                标识、标志、分段偏移量：它们用于分段，这在IPv6中比在IPv4中执行得更少，因此现在只有在分段扩展报头中需要时才能找到这些字段。

- ​                报头校验和：已决定在IPv6中消除报头校验和计算。它被认为与更高层的错误检查和数据链路层CRC计算是冗余的。这节省了路由器的处理时间和数据报头中的2个字节。

此外，虽然选项以前在IPv4中被认为是主头的一部分，但在IPv6中它们是分开的。

###### 3.1.3.3-1 IPv6数据报扩展报头(部分：1 2 3 4 5 6)。

在IPv6数据报中的强制“Main”报头之后，一个或多个扩展报头可能出现在封装的有效载荷之前。创建这些报头是为了在创建IPv6数据报时提供灵活性和效率。仅用于特殊目的的所有字段都被放入扩展标头中，并在需要时放入数据报中。这使得主数据报头的大小变得更小和更流线化，只包含那些真正必须始终存在的字段。

关于扩展标头的作用经常存在混淆，特别是与数据报选项相比。IPv4数据报只有一个报头，但它包括选项的规定，而IPv6也有选项，所以为什么要费心使用扩展报头呢？问得好。

使用选项来做任何事情都是可能的。然而，对于诸如分段等常见功能所需的某些信息集，使用扩展标头被认为是更好的设计。选项在IPv6中确实仍然受支持；它们被用来通过提供可用于任何目的的可变长度字段来提供更大的灵活性。它们本身是使用扩展标头定义的，我们将在下面(以及在它们自己的主题中，如下所示)看到。

当扩展报头包含在IPv6数据报中时，它们会一个接一个地出现在主报头之后。每种扩展报头类型都有其自己的内部字段结构。

<u>**使用下一个头域的IPv6头链**</u>

所有扩展报头类型唯一通用的字段是下一个报头字段(它实际上出现在一种报头类型的末尾，即ESP报头)。8位Next Header字段用于逻辑链接IPv6数据报中的所有报头，如下所示：

- 主标头中的下一个标头字段包含第一个扩展标头类型的参考号。
- 第一个扩展头中的下一个头字段包含第二个扩展头类型的编号，如果有第二个的话。如果有第三个，第二个头的下一个头指向它，以此类推。
- 最后一个扩展头的下一个头字段包含封装的上层协议的协议号。从本质上讲，这个字段指向有效载荷本身的 "下一个头"。

例如，假设封装了TCP的数据报具有逐跳选项扩展报头和片段扩展报头。然后，这些标头的下一个标头字段将包含下列值：

- 主标头的下一个标头值为0，表示逐跳选项头。
- 逐跳选项标头的下一个标头值为44(十进制)，即片段扩展标头的值。
- 片段报头将具有下一个报头值6。

这一点如图106所示。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipv6nextheader.png)

​                                                             <u>**图106：使用下一个报头字段链接IPv6扩展报头。**</u>

下一个报头字段允许设备更容易地处理接收到的IPv6数据报中的报头。当数据报没有扩展报头时，“下一个报头”实际上是IP数据字段开头的报头，在这种情况下是一个值为6的TCP报头。这与在IPv4中使用协议字段的方式相同。当扩展标头出现时，每个标头的下一个标头值包含一个数字，指示数据报中下一个标头的类型，因此它们在逻辑上将标头“链接在一起”，如上所示。

**关键概念:** IPv6的下一个头字段用于将IPv6数据报中的头 "连在一起"。主标头中的下一个标头字段包含第一个扩展标头的编号；其下一个标头包含第二个标头的编号，以此类推。数据报中的最后一个头包含了数据字段开头的封装协议的编号。

<u>IPv6扩展标头摘要</u>

表70列出了不同的扩展报头，显示了它的下一个报头值、长度和定义RFC，并提供了每个扩展报头如何使用的简要说明。

​                                                                           **表70：IPv6扩展报头**

| **Next Header Value (decimal)** | **Extension Header Name**                   | **Length (bytes)** | **Description**                                                                                      | **Defining RFC** |
| ------------------------------- | ------------------------------------------- | ------------------ | ---------------------------------------------------------------------------------------------------- | ---------------- |
| **0**                           | ***Hop-By-Hop Options\***                   | Variable           | 定义了一组任意的选项，目的是让源设备到目的设备的路径上的所有设备都能检查。 这是用于定义可变格式选项的两个扩展头之一。                                          | 2460             |
| **43**                          | ***Routing\***                              | Variable           | 定义了一种允许源设备为数据报指定路由的方法。这种头类型实际上允许定义多种路由类型。IPv6标准定义了0型路由扩展头，它相当于IPv4中的 "松散 "源路由选项，使用方式类似。 这种扩展头的格式见下文。 | 2460             |
| **44**                          | ***Fragment\***                             | 8                  | 当一个数据报只包含原始信息的一个片段时，这个扩展头被包括在内。它包含了从主标头中删除的片段偏移、识别和更多片段字段。 该扩展头的格式见下文，关于如何使用这些字段的详细情况，见关于片段和重新组合的主题。 | 2460             |
| **50**                          | ***Encapsulating Security Payload (ESP)\*** | Variable           | 携带用于安全通信的加密数据。这个头在关于IPSec的章节中有详细描述。                                                                  | 2406             |
| **51**                          | ***Authentication Header (AH)\***           | Variable           | 包含用于验证加密数据的真实性的信息。该标头在IPSec部分有详细描述。                                                                  | 2402             |
| **60**                          | ***Destination Options\***                  | Variable           | 定义了一组任意的选项，这些选项仅由数据报的目的地检查。 这是用于定义可变格式选项的两个扩展头之一。                                                    | 2460             |

请注意，IPv6主标头的下一个标头值是41；IPv4标头的下一个标头值是4（其协议号）。请注意，还有一个名为No Next Header的 "假 "扩展头，其值为59。这是一个占位符，当在Next Header字段中发现时，表示该扩展头之后没有任何东西。

正如我在表中提到的，几个标题的格式已在其他主题中提供。不过，我将在这里介绍其中的两个。

<u>**IPv6路由扩展报头**</u>

路由扩展报头用于在IPv6中执行源路由。它如表71所示，如图107所示。

​                                                                    **表71：IPv6路由扩展报头格式**

| **Field Name**             | **Size (bytes)**          | **Description**                                                                                   |
| -------------------------- | ------------------------- | ------------------------------------------------------------------------------------------------- |
| ***Next Header\***         | 1                         | ***Next Header:\***下一个头。包含路由头之后的下一个头的协议号。如上所述，用于将头连接在一起。                                          |
| ***Hdr Ext Len\***         | 1                         | ***Header Extension Length:\***Routing头的长度，以8字节为单位，不包括头的前8字节。对于Routing Type为0的情况，这个值是嵌入头中的地址数的2倍。 |
| ***Routing Type\***        | 1                         | ***Routing Type:\*** 这个字段允许定义多种路由类型；目前，唯一使用的值是0。                                                  |
| ***Segments Left\***       | 1                         | ***Segments Left:\*** 指定路由中剩余的明确命名的节点数量，直到目的地。                                                    |
| ***Reserved\***            | 4                         | ***Reserved:\*** Not used; set to zeroes.                                                         |
| ***Address1 … AddressN\*** | Variable (multiple of 16) | ***Addresses:\*** 一组IPv6地址，指定要使用的路由。                                                              |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipv6routingheaderformat (1).png)

​                                                                      **图107：IPv6路由扩展头格式**

<u>**IPv6分片扩展报头**</u>

片段扩展报头包括在分段的数据报中，以提供允许重组片段所需的信息。其格式见表72和图108。

​                                                                  **表72：IPv6片段扩展报头格式**

| **Field Name**         | **Size (bytes)** | **Description**                                                                                          |
| ---------------------- | ---------------- | -------------------------------------------------------------------------------------------------------- |
| ***Next Header\***     | 1                | ***Next Header:\*** 下一个头。包含Fragment头之后的下一个头的协议号。如上所述，用于将头连接在一起。                                          |
| ***Reserved\***        | 1                | ***Reserved:\*** 保留。不使用；设置为零。                                                                            |
| ***Fragment Offset\*** | 13/8 (13 bits)   | ***Fragment Offset:\*** 片段偏移。指定该片段数据在整个信息中的偏移量或位置。它以8字节（64位）为单位，其使用方式与IPv4头中的同名字段非常相似。                   |
| ***Res\***             | 1/4 (2 bits)     | ***Reserved:\*** 保留。不使用；设置为零。                                                                            |
| ***M Flag\***          | 1/8 (1 bit)      | ***More Fragments Flag:\*** 更多片段标志：与IPv4头中的同名标志相同--当设置为0时，表示消息中的最后一个片段；当设置为1时，表示该片段消息中还有更多的片段要处理。        |
| ***Identification\***  | 4                | ***Identification:\*** 识别。与IPv4头中的同名字段相同，但扩展到32位。它包含一个特定的值，这个值对属于某个特定消息的每个碎片都是通用的，以确保来自不同碎片消息的碎片不会被混在一起。 |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipv6fragmentheaderformat.png)

​                                                                                    **图108: IPv6分片扩展头格式**

**<u>IPv6扩展标头顺序</u>**

每个扩展标头在任何数据报中只出现一次(有一个例外，见下文)。此外，扩展报头只由数据报的最终接收者检查，而不是中间设备(同样有一个例外，我们稍后将介绍)。RFC 2460规定，当出现多个报头时，它们应按以下顺序出现在IPv6数据报有效负载中的主报头之后和更高层封装报头之前：

1. *Hop-By-Hop Options*
2. *Destination Options* (for options to be processed by the destination as well as devices specified in a Routing header)
3. *Routing*
4. *Fragmentation*
5. *Authentication Header*
6. *Encapsulating Security Payload*
7. *Destination Options* (for options processed only by the final destination)

现在让我们来看看这些例外情况。唯一可以出现两次的标题是Destination Options。正常情况下，它显示为最后一个标题。然而，可能存在目的地选项报头，该报头包含除目的地之外还必须由源路由中指定的设备列表检查的选项。在这种情况下，这些选项的目标选项标头放在路由标头之前。还可以出现仅包含用于最终目的地的选项的第二这样的报头。

**关键概念：**每个扩展报头在IPv6数据报中只能出现一次，并且它们必须以固定的顺序出现。例外是Destination Options报头，它可能出现两次；对于要由去往目的地的设备处理的选项，在数据报的开头附近，以及对于仅打算用于最终目的地的选项，在扩展报头的末尾。

所有中间设备通常检查的唯一报头是逐跳选项扩展报头。它专门用于将管理信息传送到路由中的所有路由器。逐跳选项扩展标头必须显示为第一个扩展标头(如果存在)。因为它是每个路由器必须读取的唯一一个(这代表路由器的性能消耗)，所以它被赋予“最高计费”，以使其更容易、更快地查找和处理。

最后，请注意，出于对齐目的，所有扩展标头的长度必须是8字节的倍数。另外，请记住，特定扩展标头的下一个标头值出现在前一个标头的下一个标头字段中，而不是标头本身。

###### 3.1.3.3-1 IPv6数据报选项(第1部分：第2部分)

在IPv4中，各种目的所需的所有“额外”信息都以出现在IPv4报头中的选项的形式放入数据报中。在IPv6中，引入了扩展报头的新概念；这些报头取代了许多预定义的IPv4选项。但是，出于略微不同的目的，选项的概念仍然保留在IPv6中。选项允许使用常规扩展报头中未定义的任意信息集来补充IPv6数据报。它们提供了最大的灵活性，允许基本的IPv6协议以设计者从未预料到的方式进行扩展，目标是减少该协议过时的机会。

<u>**IPv6选项扩展标头类型**</u>
我说过IPv6选项是对扩展报头的补充；事实上，它们实际上是作为扩展报头实现的。有两个不同的选项用于编码选项。这两个标头的不同之处只是它们包含的选项将如何由设备处理；否则，它们的格式和使用方式都相同。

这两种扩展报头类型是：

- Destination Options：包含仅用于数据报最终目的地的选项(如果存在，可能还包括在路由标头中指定的一组路由器)。
- 逐跳选项：包含传送源和目的地之间每台设备(路由器)的信息的选项

<u>**IPv6选项格式**</u>

这些标头类型中的每一个都有一个单字节的下一个标头字段，以及一个指示标头总长度的单字节标头扩展长度字段。报头的其余部分具有一个或多个选项字段。图109显示了这两个标头的总体格式。每个选项的格式类似于IPv4选项，如表73所示。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipv6optionformat.png)
                            **图109：IPv6逐跳选项和目的地选项报头格式。**

这些扩展报头中的每一个都以两个固定的字段开始，即下一个报头和报头扩展长度。标题的其余部分由一系列可变长度的选项组成。每个选项的结构如表73所示，由类型/长度/值三元组组成。

| **Subfield Name**   | **Size (bytes)** | **Description**                                                                                                   |
| ------------------- | ---------------- | ----------------------------------------------------------------------------------------------------------------- |
| ***Option Type\***  | 1                | ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\aa364a0d.png)                              |
| ***Opt Data Len\*** | 1                | ***Option Data Length:\*** 选项数据长度。指定下面选项数据子字段的长度。注意，这是与IPv4的语义不同，IPv4的长度字段表示整个选项的大小；在IPv6中，选项类型和选项数据长度字段的长度不包括在内。 |
| ***Option Data\***  | Variable         | ***Option Data:\*** 选项数据。作为选项的一部分要发送的数据，它是选项类型所特有的。有时也被称为 "选项值"。                                                  |

注意：就解释方式而言，选项类型子字段有点奇怪。尽管它有一个具有三个子字段的子结构，如表73所示，但该结构是“非正式的”。我的意思是，此字段的8位被视为单个实体。尽管三个最高位有特殊的含义，但整个字段被称为选项类型，而不仅仅是最后五位，整个字段被用作从0到255的单个值。事实上，标准中甚至没有指定“子子字段”名称；我编造这些名称是为了帮助解释这些字段。

由于每个选项都有一个用于类型、长度和值(数据)的子字段，因此它们有时被称为TLV编码。如果有多个选项，它们将在标题中一个接一个地放置。在逐跳选项或目的地选项扩展报头中的所有选项的末尾，可以放置填充以确保报头长度是8字节的倍数。

**关键概念**：两种IPv6扩展报头类型，逐跳选项和目的地选项，用于在IPv6数据报中携带任意可选信息。每个选项都由一组可变长度的选项组成，这些选项使用三个子字段定义，这些子字段指示选项的类型、长度和值。

###### 3.1.3.4 IPv6数据报大小，最大传输单元(MTU)，碎片和重组(部分:1 2 3 4)

互联网协议的工作是在连接网络的互联网上传递信息。当数据报在遥远的网络上的主机之间发送时，它们由路由器在许多物理网络链接上一跳一跳地进行。在这个旅程的每一步，数据报都被编码在数据链路层的框架中进行传输。

<u>**IPv6数据报大小调整和分段概述**</u>
为了使数据报能够成功地沿着路线传输，它的大小必须足够小，以便在途中的每一步都能适应下层的框架。最大传输单元（MTU）这一术语描述了任何给定的物理网络的大小限制。如果一个数据报对于网络的MTU来说太大，它必须被分成几块，这个过程称为分片，然后在目的地设备上重新组装。这是自IPv4以来的一个要求，我在IPv4中专门讨论这些问题的章节中详细解释了与数据报大小、MTU、分片和重新组合有关的概念和问题。

所有这些问题在IPv6中都适用于发送数据报，就像它们在IPv4中一样。然而，与协议的其他领域一样，如何进行分片和重组的一些重要细节已经改变。这些变化是为了提高路由过程的效率，也是为了反映当前网络技术的实际情况：大多数网络技术可以在不需要分片的情况下处理平均IP数据报。

在数据报大小、MTU、分段和重组方面，IPv4和IPv6之间最重要的区别是：

- 增加了默认MTU：在IPv4中，路由器和物理链路需要处理的最小MTU为576字节。在IPv6中，所有链路必须处理至少1280字节的数据报大小。这种大小增加了一倍多，通过增加最大有效负载与报头长度的比率来提高效率，并降低了需要分段的频率。
- 消除路径分段：在IPv4中，数据报可以由源设备或路由器在传输期间进行分段。在IPv6中，只有源节点可以分段；路由器不能。因此，在传输之前，源必须分段到该路由上的最小MTU的大小。正如我们将看到的，这既有好处也有坏处。当然，重组仍然只由目的地完成，就像在IPv4中一样。
- MTU大小错误反馈：由于路由器无法对数据报进行分段，因此如果它们被迫尝试通过物理链路发送过大的数据报，则必须丢弃这些数据报。已使用ICMPv6定义了反馈过程，该过程允许路由器告知源设备它们使用的数据报太大，不适合该路由。
- 路径MTU发现：由于源设备必须决定片段的正确大小，因此如果它们具有确定应该是什么大小的机制，这将是很有帮助的。此功能是通过称为路径MTU发现的特殊技术提供的，该技术最初是为IPv4定义的，但已针对IPv6进行了改进。
- 分段报头字段的移动：为了反映IPv4中分段重要性的降低，与IPv4报头中的进程相关的永久字段已被扩展到分段扩展报头，仅在需要时才包括在内。

<u>**IPv6的 "唯源 "分片规则的影响**</u>

我发现碎片化和重组过程中的变化很有趣。虽然IPv6的许多其他变化代表着从主机设备到路由器对功能的“责任”转移，但这一点是相反的。在IPv4中，源节点可以真正发送其本地链路可以处理的任何大小的数据报，并让路由器根据需要对其进行分段。这似乎是一个合理的模型；节点在一个大型的“虚拟”网络上通信，并且根据物理链路的需要拆分消息的细节是不可见的。

这样做的问题是，它拖累了布线的性能。对于路由器来说，完整地转发数据报比花费时间将其分段要快得多。在某些情况下，数据报传输过程中必须多次出现分段，请记住，对于路由上的每个数据报都必须发生这种情况。对于源来说，首先只发送大小合适的数据报要高效得多。

<u>**确定适当的数据报大小**</u>
当然，这里有一个问题：来源如何知道要使用多大的尺寸？它不知道数据报路由到目的地所使用的物理网络；事实上，它甚至不知道路由是什么！它有两个选择：

1. 使用默认MTU：第一个选项是使用默认MTU 1280，所有物理网络都必须能够处理该MTU。这是一个很好的选择，特别是对于短通信或发送少量数据。
2. 使用路径MTU发现：另一种方法是使用路径MTU发现功能，如下所述。RFC 1981中定义的此方法定义了一种方法，节点通过该方法通过路由发送消息，以确定路径的总体最小MTU是多少，其技术与IPv4中的方法非常相似。

由于路由器不能在IPv6中分段，因此如果路由器发送的数据报太大，则必须丢弃该数据报。然后，它将以ICMPv6数据包太大消息的形式将有关此事件的反馈发回源。这告诉源，它的数据报已被丢弃，它必须分段(或减小其分段的大小)。

该反馈机制也用于发现路径MTU。源节点发送具有其本地物理链路的MTU的数据报，因为这表示路径的MTU的上限。如果这一过程没有任何错误，它知道它可以将该值用于将来到该目的地的数据报。如果它收到任何数据包太大的消息，它会使用较小的数据报大小再次尝试。与默认的1280相比，它的优势在于它可以允许大型通信以更高的MTU继续进行，以提高性能。

仅在源位置分段的决定的一个缺点是，如果设备之间有多个路由或如果路由更改，则可能会出现问题。在IPv4中，分段是动态和自动的；它会自动发生，并随着路由的变化而调整。路径MTU发现是一个很好的功能，但它是静态的。它要求主机跟踪不同路线的MTU，并定期更新。如果节点在其先前对其执行了路径MTU发现的路由上接收到数据包太大消息，则通过重做路径MTU发现来实现这一点，但这需要时间。

**关键概念**：在IPv6中，分段仅由发送数据报的设备执行，而不是由路由器执行。如果路由器遇到太大而无法通过MTU较小的物理网络发送的数据报，则路由器会将ICMPv6数据包太大消息发送回数据报源。这可用作称为路径MTU发现的过程的一部分，以确定整个路由的最小MTU。

<u>**IPv6分段过程**</u>

IPv6中的实际分段机制与IPv4中的类似，但增加了复杂性，即必须小心处理扩展报头。出于分段目的，IPv6数据报分为两部分：

- 不可分段部分：这包括原始数据报的主头，以及需要出现在每个片段中的任何扩展头。这意味着主报头，以及下列任何报头(如果存在)：逐跳选项、目的地选项(用于那些将由沿路线的设备处理的选项)和路由。
- 可分片部分：这包括数据报的数据部分，以及其他扩展报头(如果存在)-身份验证报头、封装安全有效负载和/或目的地选项(用于仅由最终目的地处理的选项)。

不可碎片化部分必须存在于每个片段中，而可碎片化部分则在片段之间拆分。因此，要对数据报进行分段，设备需要按顺序创建一组分段数据报，每个分段数据报包含以下内容：

1. 不可分割部分：原始数据报的完整不可分割部分，其有效负载长度更改为片段数据报的长度。
2. 片段标头：具有片段偏移量、标识和M标志的片段标头，其设置方式与在IPv4中使用的方式相同。
3. 片段：原始数据报的可分片部分的片段。请注意，每个片段的长度必须是8字节的倍数，因为片段偏移量字段中的值是以8字节的倍数指定的。

**关键概念**：在IPv6中进行分段的方式与在IPv4中类似，不同之处在于必须特殊处理扩展报头。某些扩展标头被认为是不可分段的，并出现在每个片段中；其他扩展标头与数据一起被分段。

<u>**IPv6分段示例**</u>

让我们举一个例子来说明IPv6分段是如何工作的(参见图110)。假设我们有一个370字节宽的IPv6数据报，它由40字节的IP报头、4个30字节的扩展报头和210字节的数据组成。其中两个扩展标头是不可分片的，而两个是可分片的。(在实践中，我们永远不需要分割如此小的数据报，但我正在努力使数字保持简单。)。假设我们需要在MTU仅为230字节的链路上发送此消息。我们实际上需要三个片段，而不是您可能期望的两个片段，因为需要在每个片段中放置两个30字节的不可分割的扩展标头，并且要求每个片段的长度是8的倍数。以下是片段的结构：

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipv6fragmentation.png)
                                                      **图110：IPv6数据报分段。**

在此图示中，包含四个30字节扩展报头的370字节IPv6数据报被分成三个片段。字段的大小显示为按比例排列。不可分段部分以蓝色显示，以每个片段开头，然后是片段报头(在图中缩写为“FH”)。然后，将可破碎部分的部分按顺序放置到每个片段中。身份验证和目标选项扩展标头是可分段部分的一部分，因此它们显示为第一个片段的一部分。

1. 第一个片段：第一个片段将由100字节的不可分割部分组成，随后是8字节的片段报头和原始数据报的可分割部分的前120个字节。这将包含两个可分段的扩展标头和数据的前60个字节。这样就剩下150个字节的数据要发送。
2. 第二个片段：它还将包含100字节的不可分割部分，然后是片段报头和120字节的数据(字节60到179)。这将剩下30个字节的数据。
3. 第三个片段：最后一个片段将包含100字节的不可分割部分、片段头和最后30个字节的数据。

“M”(更多分段)标志将在前两个分段中被设置为1，在第三个分段中被设置为零，并且分段偏移值将被适当地设置。有关如何使用这些字段的详细信息，请参阅有关IPv4分段的主题。

接收设备通过从第一个片段中取出不可分割部分，然后依次从每个片段中组装片段数据来进行重组。

###### 3.1.3.5 IPv6数据报发送和路由(部分:1和2)

IP功能，例如寻址、数据报封装以及必要时的分段和重组，都通向协议的最终目标：将数据报从源设备实际传送到一个或多个目的设备。

<u>**IPv6中数据报交付和路由的未变方面**</u>
与IPv6中如何实现数据报传输相关的大多数概念与在IPv4中的概念相同：

- 当源节点和目的节点在同一网络上时，数据报会被直接传送。当它们在不同的网络上时，使用路由间接传送到目的地的网络，然后再直接传送到目的地。
- 路由是通过查看IP地址并确定哪部分是网络ID，哪部分是主机ID来进行的。尽管IPv6单播地址的分配采用了特殊的分层格式，但IPv6的基本方式与无类IPv4相同。
- 路由仍然是在下一跳的基础上进行的，数据源一般不知道数据报如何从A点到B点。
- 路由是由被称为路由器的设备执行的，这些设备维护着路由表，告诉它们在哪里转发数据报以到达不同的目标网络。
- 路由协议用于允许路由器交换有关路由和网络的信息。

**IPv6中数据报传输和路由的变化**

IPv6中路由的大部分变化都与我们在协议的其他领域看到的变化直接相关。与IPv6中的路由和路由器有关的一些主要问题包括以下内容:

- 分层路由和聚合：用于组织单播地址的结构的目标之一是为了改善路由。单播寻址格式旨在为地址和互联网拓扑结构之间提供更好的匹配，并促进路由聚合。在IPv4中使用CIDR的无类别寻址是一种改进，但缺乏任何正式的机制来创建一个可扩展的层次结构。
- 范围广泛的本地地址: IPv6中定义了包括站点本地和链接本地在内的本地使用地址，路由器必须能够识别它们。他们必须在适当的时候对它们进行路由或不进行路由。多播地址也有不同程度的范围。
- 多播和任播路由: 多播是IPv6的标准，而不是像IPv4那样的可选，所以路由器必须支持它。任意广播寻址是IPv6中一种新的寻址类型。
- 更多支持功能: 路由器必须增加功能以支持IPv6的新功能。例如，在新的IPv6分片方案中，路由器在实现无服务器自动配置和路径MTU发现方面起着关键作用。
- 新的路由协议: RIP等路由协议必须更新以支持IPv6。
- 过渡问题：最后但并非最不重要的一点是，路由器在支持从IPv4过渡到IPv6的过程中发挥着重要作用。他们将负责将IPv6“孤岛”连接在一起，并执行转换，以使IPv4和IPv6设备在向新协议的多年迁移期间相互通信。

##### 3.1.4 IP网络地址转换（NAT）协议

为了帮助延长IPv4寻址方案的寿命，同时开发和部署较新的IPv6协议，已经开发了其他技术。其中最重要的一项是IP网络地址转换。这项技术允许大量使用私有地址的主机共享少量的公共IP地址。这个重要的小 "技巧 "使全球互联网上的主机数量实际上远远超过其地址空间通常所能支持的数量。同时，它提供了一些安全方面的好处，使主机更难被公共互联网上的外国机器直接寻址。

在本部分中，我将介绍IP NAT背后的概念，并解释IP NAT类型的工作原理。我首先概述该议定书，并讨论其优缺点。我将介绍您需要了解的地址术语，以了解NAT的工作原理以及各种转换技术之间的差异。我将解释地址映射的执行方式以及静态地址映射和动态地址映射之间的区别。

然后，我将解释四种主要类型的NAT的工作原理：

1. *Unidirectional NAT* 单向NAT(也称为出站NAT或传统NAT)。
2. *Bidirectional* 双向(入站或“双向”)NAT。
3. *Port-Based* or “Overloaded 基于端口或超载的NAT(也称为NAPT或PAT)。
4. “Overlapping”NAT(也称为“双重NAT”)。

最后，我将更多地介绍与NAT相关的兼容性问题。

顺便说一句，大多数人只把这项技术称为“网络地址转换”，而没有“IP”。然而，在我看来，这听起来相当一般，因为这里讨论的版本是特定于IP的，所以我更愿意说明这是一个IP功能。也就是说，为了简单起见，我也经常只说“NAT”，因为“NAT”比较短。我还应该指出，有相当多的人并不认为NAT是最严格意义上的“协议”。

**注意：**NAT在很大程度上是为了解决IPv4中的地址短缺问题而开发的，因此它与IPv4关联并使用。实现与IPv6兼容的NAT版本是可能的，但地址转换在IPv6中几乎没有那么重要，IPv6旨在为每个TCP/IP设备提供自己的唯一地址。因此，我将在本节重点介绍NAT与IPv4的结合使用。

###### 3.1.4.1 IP NAT概述、动机、优缺点(第1部分：1 2 3 4 5)

作为互联网协议最初设计的一部分，决定使IP地址只有32位长，当互联网的爆炸性增长超过任何人的预期时，导致了一个严重的问题：地址空间的耗尽。无类别寻址有助于更好地利用地址空间，而IPv6的创建是为了确保我们永远不会再有地址耗尽的情况。然而，无类别寻址只是减缓了IPv4地址空间的消耗，而IPv6的开发需要多年时间，并且还需要多年时间来部署。

除非在完成向IPv6的过渡之前实施某种解决方案，否则IP地址的短缺承诺将在20世纪90年代末变得非常严重。互联网工程任务组（IETF）的创造性工程师们接受了这一挑战。他们创造了一种技术，不仅可以阻止地址空间的耗尽，而且还可以用来解决20世纪90年代中后期的另外两个日益严重的问题。

- IP地址的成本不断增加: 随着任何资源的日益稀缺，它变得更加昂贵。即使在有IP地址的情况下，从服务提供商那里获得较大数量的地址比获得较小数量的地址成本更高。为了整个互联网的发展，也为了节省资金，保护IP地址是可取的。
- 对安全问题的关注日益增加: 随着20世纪90年代互联网使用的增加，更多的 "坏人 "也开始使用这个网络。一个公司直接连接到互联网的机器越多，他们潜在的安全风险就越大。

<u>**间接互联网连接**</u>

解决IP地址空间和安全问题的一个办法是建立一个系统，公司的网络不直接连接到互联网，而是间接连接。由于大多数机构使用互联网的几个重要特点，以这种方式设置网络是可能的：

- 大多数主机是客户端设备: 互联网是基于客户/服务器的，大多数的主机是客户。客户端设备一般不需要被公开访问。例如，当使用你的本地PC访问万维网时，你向服务器发出请求，它们会作出回应，但服务器没有任何理由试图与你发起联系。根据定义，大多数通信是由客户而不是服务器开始的。
- 很少有主机同时访问互联网: 当你在同一个网络上有大量的主机连接到互联网时，在任何特定的时间，通常只有少数的主机试图访问互联网。没有必要假设它们都需要同时访问服务器。即使在你积极地浏览网络时，你也会不时地停顿若干秒来阅读信息；你只是在执行交易的时间内访问网络服务器。
- 互联网通信是路由的: 一个组织的网络和互联网之间的通信要经过一个路由器，它充当了流量的 "控制点"。

解释为什么这些属性很重要的最好方法是将其与组织如何使用电话进行类比，因为许多相同的属性也适用于组织。典型组织中的大多数电话都用于让员工向外拨打电话。通常不需要有任何方式直接呼叫员工；相反，一个系统或一个人可以处理所有来电。在任何给定的时间，都只有少数员工会给“外部世界”打电话。并且所有呼叫都通过管理电话系统的中心点进行路由。

出于这些原因，为了节省资金，组织不会将公共电话线分别连接到每个员工的办公桌上。相反，它建立了一个电话系统，其中每个员工都有一个分机，基本上是一个仅在组织内有效的本地电话号码。在一个池中提供少量外线供员工共享，电话系统根据需要将内部分机与外线进行匹配。语音邮件系统和/或人工接待员负责将呼叫路由到组织。

(是的，有些公司在分机号码和真实电话号码之间有直接映射。别惹麻烦。)

 <u>**IP网络地址转换(NAT)概述**</u>

一种非常类似的技术可用于将组织的计算机连接到Internet。在TCP/IP网络中，这项技术首先在1994年5月采用的RFC 1631(IP网络地址转换器(NAT))中正式确定。“转换器”一词指的是实施NAT的设备(路由器)。更常见的是，这项技术整体上称为IP网络地址转换(IP NAT或NAT)。

注：RFC 1631的文档状态为“信息性”。这意味着，从技术上讲，IP NAT不是官方的互联网标准。

NAT的基本实施包括使用为本地IP网络预留的私有地址范围之一来设置组织的内部网络。还将一个或多个公共(Internet)地址分配给组织，并在本地网络和公共Internet之间安装一个或多个支持NAT的路由器。公共IP地址就像电话系统中的“外线”，而私有地址就像“内部分机”。

NAT路由器充当电话系统、计算机和接待员的角色。它根据需要将内部分机映射到外线，并在需要时处理“来电”。它不仅通过路由IP数据报，而且根据需要修改它们，将私有网络中的数据报中的地址转换为公共地址，以便在Internet上传输，然后再传输回来。

随着时间的推移，还创建了更新版本的NAT，以解决其他问题或提供更多功能。基于端口的NAT允许两个或更多设备一次共享一个IP地址，从而允许在有限数量的IP地址上共享更多主机。所谓的“两次NAT”通过转换传入和传出数据报中的源地址和目的地址来帮助实现虚拟专用网络(VPN)。

**关键概念：**IP网络地址转换(IP NAT或NAT)是一种允许组织使用私有地址建立网络，同时仍能在公共Internet上通信的技术。支持NAT的路由器根据需要将私有地址转换为公有地址，反之亦然。这允许在大量设备之间共享少量的公共IP地址，并且还提供了其他好处(但也有一些缺点)。

<u>**NAT的优势**</u>

NAT是一种既有优点也有缺点的技术。这意味着它在各种情况下都非常有用，但在其他情况下也会出现问题。其主要优势是：

- 公有IP地址共享：大量主机可以共享少量公有IP地址。这既节省了资金，又节省了IP地址空间。
- 更容易扩展：由于本地网络设备是私有寻址的，并且每个设备都不需要公共IP地址，因此很容易向本地网络添加新的客户端。
- 更好的本地控制：管理员可以获得专用网络带来的所有控制优势，但仍然可以连接到互联网。
- 更灵活的互联网服务：更改组织的互联网服务提供商(ISP)更容易，因为只有公有地址才会更改。没有必要对网络上的所有客户端计算机重新编号。
- 增强的安全性：NAT转换代表一定程度的间接性。因此，它自动在组织的网络和公共互联网之间创建一种类型的防火墙。任何客户端设备都更难被恶意用户直接访问，因为客户端没有公知的IP地址。
- （基本上）透明：NAT实现基本上是透明的，因为更改发生在一个或几个路由器中。几十个或数百个主机本身不需要更改。

<u>**NAT的缺点**</u>

以上都是使用NAT的充分理由，但该技术也存在缺陷。其中一些措施剥夺了上述清单中某些项目的部分好处：

- 复杂性：NAT代表了设置和管理网络的另一个复杂性。它还会因为地址替换而使故障排除更加混乱。
- 由于缺少公共地址而导致的问题：由于客户机主机中缺少“真正的”IP地址，某些功能将无法正常工作。
- 与某些应用程序的兼容性问题：我在上面说过，NAT只是大部分透明的。实际上，由于NAT对数据报中的IP报头字段而不是应用数据中的IP报头字段进行了“修修补补”，因此出现了与某些应用程序的兼容性问题。这意味着，像ftp这样在命令中传递IP地址和端口号的工具必须经过特殊处理，一些应用程序可能无法运行。
- 安全协议的问题：像IPSec这样的协议旨在检测对报头的修改，并通常对NAT所做的更改犹豫不决，因为它们无法将这些更改与恶意数据报“黑客攻击”区分开来。NAT和IPSec的结合仍然是可能的，但这会变得更加复杂。
- 对客户端访问的支持不佳：每个客户端缺乏公共IP地址是一把双刃剑；它可以防止黑客试图访问主机，但也会使合法访问本地网络上的客户端变得困难。“点对点”应用程序更难设置，像组织网站(从整个互联网访问)这样的应用程序通常需要在没有NAT的情况下设置。
- 性能降低：每次数据报在专用网络和互联网之间传输时，都需要进行地址转换。此外，还必须完成其他工作，例如重新计算报头校验和。每个单独的翻译都不太费力，但当你把它加在一起时，你就放弃了一些性能。

许多组织认为利大于弊，特别是如果他们确实像大多数组织那样主要以客户端/服务器的方式使用互联网。正因为如此，NAT变得非常流行。但是，您应该始终记住，导致NAT的主要问题是地址空间不足。IPv6解决了这个问题，而NAT只是为这个问题找到了一个聪明的“变通办法”。出于这个原因，许多人认为NAT是一种“杂乱无章”的东西。一旦部署了IPv6，就不再需要它，有些人甚至不喜欢它用于IPv4。另一方面，一些人认为它的其他好处使其即使在IPv6中也值得考虑。

注：“kluge”(或“kluge”)指的是用一种不雅观的方式来解决问题，比如用活动扳手的侧面钉钉子。(我永远不会做这样的事情，当然不会是…)

###### 3.1.4.2 IP NAT地址术语(第1部分：第2部分)

顾名思义，IP网络地址转换就是IP地址的转换。当数据报在组织的私有网络和公共Internet之间传递时，NAT路由器会更改这些数据报中的一个或多个地址。这种转换意味着NAT环境中的每个事务不仅涉及源地址和目的地址，而且可能涉及源地址和目的地址中的每一个的多个地址。

为了更清楚地解释NAT是如何运行的，已经开发了几个特殊的名称来表示使用NAT时可以在IP数据报中找到的不同类型的地址。不幸的是，NAT中用于寻址的术语可能会令人困惑，因为很难直观地看到(通常听起来相似的)名称之间的区别。但是，如果不知道这些地址的含义，就不可能正确理解NAT的运行方式，因此我们需要从解释它们开始。

<u>**基于设备位置的NAT地址术语(内部/外部)。**</u>
区分地址的第一种方式是根据设备在网络中的位置来区分地址：

- 内部地址：组织的专用网络中使用NAT的任何设备都被称为位于内部网络。因此，以任何形式引用本地网络上的设备的任何地址都称为内部地址。
- 外部地址：公共互联网--即本地网络之外的一切--被认为是外部网络。任何引用公共Internet设备的地址都是外部地址。

**关键概念**：在NAT中，术语内部和外部用于标识设备的位置。内部地址是指组织的私有网络上的设备；外部地址是指公共互联网上的设备。

**<u>基于数据报位置的NAT地址术语(本地/全球)</u>**

内部设备始终具有内部地址；外部设备始终具有外部地址。但是，根据地址出现在数据报中的网络部分，有两种不同的方法来寻址内部或外部设备：

- 本地地址：此术语描述出现在内部网络上的数据报中的地址，无论它是指内部地址还是外部地址。
- 全局地址：这个术语描述出现在外部网络数据报中的地址，无论它是指内部地址还是外部地址。

**关键概念**：在NAT中，术语本地和全局用于指示特定地址出现在哪个网络中。本地地址用于组织的专用网络（无论是指内部设备还是外部设备）；在公共互联网上使用全局地址（再次，无论是指内部还是外部设备）。

<u>**组合内部/外部和本地/全球地址指定**</u>

这有点令人困惑，所以我会试着进一步解释。NAT转换路由器负责将内部网络连接到外部网络(Internet)。内部设备需要能够与外部设备通信，反之亦然，但内部设备只能使用与本地网络寻址方案一致的寻址。同样，外部设备也不能使用本地寻址。因此，内部和外部设备都可以使用本地或全局地址版本来引用。这会产生四种不同的特定地址类型：

1. 内部本地地址：本地网络上设备的地址，使用其正常的本地设备表示形式表示。因此，例如，如果我们的网络上有一个客户端使用10.0.0.0私有地址块，并为其分配了地址10.0.0.207，则这将是其内部本地地址。
2. 内部全局地址：这是一个全局的、可公开路由的IP地址，用于向外部世界表示内部设备。在NAT配置中，内部全局地址是分配给组织以供NAT路由器使用的“真实”IP地址。

假设设备10.0.0.207想要向地址为204.51.16.12的Internet服务器发送一个HTTP请求。它使用10.0.0.207作为源地址来形成数据报。但是，如果此数据报按原样发送到Internet，服务器将无法回复，因为10.0.0.207不是可公开路由的IP地址。因此，NAT路由器会将数据报中的10.0.0.207转换为组织的注册IP地址之一，即194.54.21.10。这是对应于10.0.0.207的内部全局地址。当服务器发送其HTTP响应时，它将被用作目的地。请注意，在某些情况下，内部本地地址和外部本地地址可能相同。

1. 外部全球地址：外部(公共互联网)设备在全球互联网上的地址。这基本上是互联网上设备的常规公开注册地址。在上例中，204.51.16.12是公共服务器的外部全局地址。
2. 外部本地地址：本地网络上的设备引用的外部设备的地址。在某些情况下，这可能与该外部设备的外部全局地址相同。

<u>**从设备位置的角度看本地/全球地址指定**</u>

唉，这还是让人困惑，不是吗？让我们试着用另一种方式来看待这个问题。在这四个地址中，有两种是内部或外部设备以本机方式获知的地址，而另两种是转换后的地址：

- 内部设备名称：对于内部设备，内部本地地址是其“正常”或“本地”地址。内部全局地址是转换后的地址，用于在必要时表示外部网络上的内部设备。
- 外部设备名称：对于外部设备，外部全局地址是其“正常/本地”地址。外部本地地址是转换后的地址，用于在必要时表示内部网络上的外部设备。

因此，NAT所做的就是将内部或外部设备的身份从本地表示转换为全局表示，反之亦然。更改哪些地址以及如何更改取决于所采用的特定NAT类型。例如，在传统NAT中，内部设备使用其适当的(全局)表示来指代外部设备，因此这些外部设备的外部全局地址和外部本地地址是相同的。

**关键概念**：NAT路由器将本地地址转换为全局地址，反之亦然。因此，内部本地地址被转换为内部全局地址(反之亦然)，外部本地地址被转换为外部全局地址(反之亦然)。

<u>**NAT术语图解**</u>

在所有这些之后，…。这仍然令人困惑。J最大的问题之一是“内部”和“本地”这两个词在某种程度上是同义词，就像“外部”和“全球”一样，但它们在NAT中的含义是不同的。试图解释网络概念的典型悖论在这里再次出现：我想定义这些地址，以便更容易地描述NAT操作，但我发现自己想使用一个NAT操作的示例来阐明地址是如何使用的。

即使在写完这一节后，我仍然觉得这些术语令人困惑，所以我创建了图111，它以图形形式显示了相同的术语，可能会有一些帮助。该图还用作后续主题中每种不同类型NAT的图解模板，这些主题对四种地址类型中的每一种都使用相同的颜色编码，以保持一致性。当您阅读讨论NAT操作的主题时，如果您想要仔细检查地址类型的含义，请记住回顾此处。如果需要几次才能弄清楚地址，也不要灰心丧气。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipnatterminology.png)

​                                                                    **图111：IP网络地址转换(NAT)术语。**

希望这个图表将帮助您更好地理解整个“内部/外部/本地/全局”的事情。J

###### 3.1.4.3 IP NAT静态和动态地址映射(第1部分：第2部分)。

NAT允许我们通过在连接私有(内部)网络和公共(外部)网络的路由器中实施地址转换算法，将两者连接到公共(外部)网络。每次NAT路由器遇到跨越两个网络之间边界的IP数据报时，它都必须适当地转换地址。但它如何知道要转换什么，以及转换后的地址使用什么？

路由器中的NAT软件必须维护一个转换表，以告诉它如何运行。转换表包含将内部设备的内部本地地址(其常规地址)映射到内部全局地址表示(用于外部通信的特殊公有地址)的信息。如果合适，它还可以包含入站事务的外部全局地址和外部本地地址之间的映射。

有两种基本方法可以将条目添加到NAT转换表。

<u>**静态映射**</u>
当使用静态映射时，在内部或外部设备的地址的全局表示和本地表示之间定义了永久的固定关系。例如，如果希望内部本地地址为10.0.0.207的内部设备始终使用内部全局地址194.54.21.10，则可以使用静态转换。每当10.0.0.027发起与Internet的交易时，NAT路由器都会将该地址替换为194.54.21.10。

<u>**动态映射**</u>
使用动态映射时，全局和本地地址表示由NAT路由器自动生成，根据需要使用，然后丢弃。最常见的方式是允许大量内部设备共享内部全局地址池。

例如，假设我们对从194.54.21.1到194.54.21.20可用的内部全局地址池使用动态映射。当10.0.0.207向Internet发送请求时，其源地址不会自动替换为194.54.21.10。地址池中的20个地址中的一个将由NAT路由器选择。然后，路由器会查看使用该地址返回的回复，并将其转换回10.0.0.207。当会话完成时，它将丢弃该条目以将内部全局地址返回到池。

\

**<u>比较静态和动态映射</u>**

静态和动态NAT映射之间的权衡与在“静态”和“动态”之间进行选择时几乎总是相同的；例如，在ARP缓存中会出现相同的问题。静态映射是永久性的，因此非常适合需要在外部网络上始终使用相同公有地址表示的设备。它们还可用于允许进入特定设备的入站流量；即，用于在公共网络上发起的发送到内部网络上的特殊服务器的事务。但是，它们需要手动设置和维护，并且不允许在内部网络上共享IP。

动态映射通常用于常规客户端，以促进公共IP地址共享，这是大多数NAT实施的主要目标。它比静态映射更复杂，但一旦设置就是自动的。

当然，可以在同一系统上混合使用动态和静态映射。我们可以指定某些静态映射的设备，让其余设备使用动态映射。我们只需确保静态映射不与用于动态分配的池重叠。

顺便说一句，执行全局和本地寻址动态映射的另一种方式是通过使用DNS的域名解析。当外部设备使用双向NAT(入站事务)访问内部主机时，这种情况尤其常见。由于公共互联网上的主机对组织的专用网络一无所知，因此它们会发出请求，要求提供它们要访问的设备的DNS名称。这会导致生成NAT转换条目，该条目将主机的内部本地公有地址映射到供网络外部用户使用的内部全局地址。有关双向NAT工作原理的更多详细信息，请参阅双向NAT的说明。

###### 3.1.4.4 IP NAT单向(传统/出站)操作(第1部分：第2部分)。

现在我们已经了解了NAT背后的动机及其优缺点，并且还介绍了NAT地址术语和转换表创建，现在是时候深入了解它的工作原理了。NAT有许多不同的类型，本指南介绍了四种常见的NAT类型。首先来看看RFC 1631中描述的NAT的原始变体是有意义的。这是最简单的NAT方法，因此也是最容易解释的方法。

NAT当然是为了让私有网络上的主机在访问互联网时共享公共IP地址而设计的。由于大多数主机都是发起事务的客户端，因此NAT是在假设客户端/服务器请求/响应通信将从内部网络发送到外部的数据报开始的基础上设计的。因此，第一类NAT有时称为单向NAT或出站NAT。由于它是最古老的味道，现在也被称为传统NAT，以区别于较新的品种。

<u>**唯一NAT示例**</u>
为了说明单向NAT的工作原理，我们当然会使用一个示例。使用示例解释事情总是更容易，特别是当它像NAT这样令人困惑的事情时。让我们使用前两个主题中的相同数字。我们假设内部网络有250台主机使用10.0.0.0/8地址范围中的私有(内部本地)地址(我之所以选择这个地址范围，是因为它的数字很小！)。这些主机使用动态NAT，共享从194.54.21.1到194.54.21.20的20个内部全局地址池。

在我们的示例中，设备10.0.0.207想要访问公有地址为204.51.16.12的万维网服务器。表74显示了该(简化)事务中涉及的四个基本步骤。我用表格的形式代替了要点，这样我就可以清楚地向您展示请求数据报(步骤1和2)和响应数据报(步骤3和4)中的地址发生了什么。为清楚起见，我还突出显示了转换后的地址值，并提供了图112，它以图形方式显示了该过程。

​                                                            **表74：单向(传统/出站)NAT的工作原理**

| **Step #** | **Description**                                                                                                                                                                                                                                                                                                                            | **Datagram Type**                                      | **Datagram Source Address**     | **Datagram Destination Address** |
| ---------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------ | ------------------------------- | -------------------------------- |
| **1**      | **Inside Client Generates Request And Sends To NAT Router:** 内部客户端生成请求并发送到NAT路由器：设备10.0.0.207生成HTTP请求，最终传递到IP并封装在IP数据报中。源地址本身为10.0.0.207，目标地址为204.51.16.12。数据报被发送到支持NAT的路由器，该路由器将组织的内部网络连接到Internet。                                                                                                                                       | ***Request\*** (from inside client to outside server)  | 10.0.0.207 (*Inside Local*)     | 204.51.16.12 (*Outside Local*)   |
| **2**      | **NAT Router Translates Source Address and Sends To Outside Server:** NAT路由器转换源地址并发送到外部服务器：NAT路由器意识到10.0.0.207是一个内部本地地址，并且知道它必须替换一个内部全局地址，以便让公共互联网目标响应。它查询其地址池，发现下一个可用的地址是194.54.21.11。它将数据报中的源地址从10.0.0.207更改为194.54.21.1。目标地址在传统NAT中没有转换。换句话说，外部本地地址和外部全局地址.NAT路由器将10.0.0.207到194.54.21.11的映射放入其转换表中。它发送修改后的数据报，最终在204.51.16.12将其路由到服务器。 | **194.54.21.11 **(*Inside Global*)                     | 204.51.16.12 (*Outside Global*) |                                  |
|            |                                                                                                                                                                                                                                                                                                                                            |                                                        |                                 |                                  |
| **3**      | **Outside Server Generates Response And Sends Back To NAT Router:** 外部服务器生成响应并发送回NAT路由器：204.51.16.12处的服务器生成HTTP响应。当然，它不知道NAT参与其中；它在发送给它的请求中看到了194.54.21.11，因此它在那里发回响应。然后将其路由回原始客户端的NAT路由器。                                                                                                                                                 | ***Response\*** (from outside server to inside client) | 204.51.16.12 (*Outside Global*) | 194.54.21.11 (*Inside Global*)   |
| **4**      | **NAT Router Translates Destination Address And Delivers Datagram To Inside Client:** NAT路由器转换目标地址并将数据报传递给内部客户端：NAT路由器在从互联网收到的响应中看到194.54.21.11。它查阅其转换表，并知道此数据报用于10.0.0.207。这一次，目标地址被更改，但源地址没有更改。然后，它将数据报发送回原始客户端。                                                                                                                         | 204.51.16.12 (*Outside Local*)                         | **10.0.0.207 **(*Inside Local*) |                                  |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipnatunidirectional.png)

​                                                              **图112：单向(传统/出站)NAT的工作原理。**

这个过程中的四个步骤可以通过顺时针顺序遵循这些步骤来看到。转换后的地址以粗体显示。请参阅表74以了解此图中的步骤，或参见图111以了解四种地址类型的说明。

正如您所看到的，这真的不是火箭科学，一旦您习惯了术语和概念，就很容易理解正在发生的事情。在单向NAT中，源地址在传出数据报上转换，目的地址在传入数据报上转换。传统NAT只支持这种由内部网络上的设备启动的出站交易。它不能处理公共互联网上的设备向私有地址发送请求。

<u>**NAT中路由器的其他功能**</u>

另请注意，尽管我的重点是NAT路由器对地址进行的更改，但它也必须对数据报进行其他更改。更改IP报头中的任何字段都意味着需要重新计算IP报头校验和字段。需要重新计算UDP和TCP校验和，根据数据报中数据的性质，可能还需要进行其他更改。我将在NAT兼容性问题主题中讨论这些问题。

这个简化的示例假设私有网络和公共网络之间只有一台路由器。这些网络之间可以有多台路由器。但是，如果使用此配置，则它们必须使用相同的转换表。否则，如果请求由路由器R1处理，但响应由路由器R2接收，则R2将不知道如何转换回传入数据报上的目的地址。当然，这使得动态映射非常困难：路由器必须协调它们的地址映射。

**关键概念：**在单向(传统)NAT中，NAT路由器将传出请求的源地址从内部本地形式转换为内部全局形式。然后，它将响应的目的地址从内部全局转换为内部本地。外部本地地址和外部全局地址在请求和应答中都相同。

###### 3.1.4.5 IP NAT双向(双向/入站)操作(第1部分：2 3)

传统NAT被设计为仅处理出站事务；本地网络上的客户端发起请求，而互联网上的设备发回响应。然而，在某些情况下，我们可能想要走相反的方向。也就是说，我们可能希望外部网络上的设备发起与内部网络上的设备的交易。要实现这一点，我们需要一种比传统版本更强大的NAT。此增强功能有多种名称，最常见的是双向NAT、双向NAT和入站NAT。所有这些都传达了这样一个概念，即这种NAT既允许我们在上一个主题中看到的事务类型，也允许从外部网络发起的事务。

<u>**入站NAT的问题：隐藏地址**</u>
在入站事务上执行NAT比传统的出站NAT更困难。要了解原因，请记住使用NAT时的网络配置本质上是不对称的：内部网络通常知道外部设备的IP地址，因为它们是公共的，但外部网络不知道内部网络的私有地址。即使它们确实知道它们，也永远不能将它们指定为从外部发起的IP数据报的目标，因为它们是不可路由的--没有办法将它们送到专用网络的本地路由器。

这有什么关系呢？考虑从内部网络的设备A到外部的设备B的出站NAT的情况。本地客户端A始终启动事务，因此设备A的NAT路由器能够在请求期间创建设备A的内部本地地址和内部全局地址之间的映射。设备B是已经转换的数据报的接收方，因此设备A使用NAT的事实是隐藏的。设备B作出响应，NAT路由器执行反向转换，而设备B甚至不知道设备A使用了NAT。

现在，让我们来看看入站案例。这里，设备B尝试发送到使用NAT的设备A。设备B无法发送到设备A的私有(内部本地)地址。它需要设备A的内部全局地址才能开始滚动。然而，设备A的NAT路由器并不靠近设备B。事实上，设备B甚至可能不知道设备A的NAT路由器的身份！

<u>**使用域名系统促进入站NAT**</u>

只有两种方法可以解决隐藏地址问题。一种是对需要从外部访问的内部网络上的服务器等设备使用静态映射。当使用静态映射时，使用静态映射的设备的全局地址将是公开的，这解决了“我将请求发送到哪里”的问题。

另一种解决方案是使用TCP/IP域名系统(DNS)。正如在有关DNS的一节中详细解释的那样，此协议允许以名称而不是IP地址的形式发送请求；DNS服务器将这些名称转换为其相应的地址。可以将DNS和NAT集成在一起，以便它们协同工作。此过程在RFC 2694，网络地址转换器的DNS扩展(DNS_ALG)中进行了描述。

在这种技术中，外部设备实际上可以利用动态映射。基本流程(高度简化)如下：

1. 外部设备使用其希望到达的内部网络上的设备的名称发送DNS请求。例如，它可能是“www.ilikenat.com”。
2. 内部网络的DNS服务器将“www.ilikenat.com”名称解析为与此DNS条目对应的设备的内部本地地址。
3. 内部本地地址被传递到NAT，并用于在从外部访问的服务器的内部本地地址和内部全局地址之间创建动态映射。该映射被放入NAT路由器的转换表中。
4. 当DNS服务器发回名称解析时，它不会告诉外部设备正在查找的服务器的内部本地(私有)地址，而是上一步中映射的内部全局(公有)地址。

<u>**双向NAT示例**</u>

一旦外部设备知道内部网络上设备的内部全局地址，交易就可以开始。让我们使用与上一个主题中相同的示例，只是我们反转了它，因此外部设备204.51.16.12正在向内部设备10.0.0.207(即服务器)发起请求(因此现在是客户端)。假设使用了静态映射或DNS，以便外部设备知道内部全局地址10.0.0.207实际上是194.54.21.6。表75详细描述了该事务；图113中也对其进行了说明。

​                                              **表75：双向(双向/入站)NAT的工作原理**

| **Step #** | **Description**                                                                                                                                                                                                              | **Datagram Type**                                      | **Datagram Source Address**     | **Datagram Destination Address** |
| ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------ | ------------------------------- | -------------------------------- |
| **1**      | **Outside Client Generates Request And Sends To NAT Router:** 外部客户端生成请求并发送到NAT路由器：设备204.51.16.12向内部服务器生成请求。它使用内部全局地址194.54.21.6作为目标。数据报将被路由到该地址的本地路由器，该路由器是为服务器所在的内部网络提供服务的NAT路由器。                                           | ***Request\*** (from outside client to inside server)  | 204.51.16.12 (*Outside Global*) | 194.54.21.6 (*Inside Global*)    |
| **2**      | **NAT Router Translates Destination Address and Sends To Inside Server:** NAT路由器转换目标地址并发送到内部服务器：NAT路由器已经有一个从内部全局地址到服务器内部本地地址的映射。它将194.54.21.6目标地址替换为10.0.0.207，并根据需要执行校验和重新计算和其他工作。源地址未转换。然后，路由器在10.0.0.207将修改后的数据报发送到内部服务器。 | 204.51.16.12 (*Outside Local*)                         | **10.0.0.207 **(*Inside Local*) |                                  |
|            |                                                                                                                                                                                                                              |                                                        |                                 |                                  |
| **3**      | **Inside Server Generates Response And Sends Back To NAT Router:** 内部服务器生成响应并发送回NAT路由器：10.0.0.207的服务器生成响应                                                                                                                    | ***Response\*** (from inside server to outside client) | 10.0.0.207 (*Inside Local*)     | 204.51.16.12 (*Outside Local*)   |
| **4**      | **NAT Router Translates Source Address And Routes Datagram To Outside Client:** NAT路由器转换源地址并将数据报路由到外部客户端：NAT路由器在响应中看到私有地址10.0.0.207，并将其替换为194.54.21.6。然后将其路由回外部网络上的原始客户端。                                                    | **194.54.21.6 **(*Inside Global*)                      | 204.51.16.12 (*Outside Global*) |                                  |

如您所见，一旦外部设备知道内部设备的内部全局地址，入站NAT就与出站NAT非常相似。它只是做了完全相反的翻译。路由器不会修改出站请求的源地址和入站响应的目的地址，而是会更改入站请求的目的地址和出站回复的源地址。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipnatbidirectional.png)

​                                                               <u>**图113：双向(双向/入站)NAT的工作原理。**</u>

这个数字与图112非常相似，除了交易是反向的，所以请从右上角开始，逆时针前进。转换后的地址以粗体显示。表75包含对这四个步骤的完整解释。有关地址类型的说明，请参见图111。

**关键概念：**在传统NAT中，事务必须从本地网络上的客户端请求开始，但在双向(双向/入站)NAT中，公共Internet上的设备可以访问本地网络服务器。这需要使用静态映射或DNS向外部客户端提供内部网络上服务器的地址。然后，NAT事务与单向情况下几乎相同，除了相反的情况：传入请求的目的地地址从内部全局更改为内部本地；响应的源从内部本地更改为内部全局。

###### 3.1.4.6 基于IP NAT端口(过载)的操作：网络地址端口转换(NAPT)/端口地址转换(PAT)(第1部分：第2部分)

传统NAT和双向NAT的工作原理都是根据需要交换内部网络和外部网络地址，以允许私有网络访问公共网络。对于每个事务，私有网络上设备的内部本地地址与代表该设备在公共网络上的内部全局地址之间存在一对一的映射。我们可以使用动态地址分配来允许大量私有主机共享少量注册的公有地址。

然而，这里存在一个潜在的障碍。以前面的NAT为例，其中250台主机共享20个内部全局(公有)地址。如果20台主机已经有正在进行的交易，当第21台主机尝试访问Internet时会发生什么？没有任何内部全局地址可供它使用，因此它将无法使用。

<u>**使用端口多路复用私有地址**</u>
幸运的是，TCP/IP中已经内置了一种机制，可以帮助我们缓解这种情况。两个TCP/IP传输层协议，即TCP和UDP，都使用称为端口的附加寻址组件。TCP或UDP消息中的端口号有助于识别两个地址之间的单独连接。它用于允许TCP/IP客户端和服务器上的许多不同应用程序同时与每个应用程序通信，而不会造成干扰。例如，当您打开多个浏览器窗口以同时访问同一站点上的多个网页时，可以使用此功能。这种IP地址在多个连接之间的共享称为多路传输。关于TCP和UDP端口的部分更详细地描述了所有这些内容。

现在，让我们回到NAT。当我们在网际网络的公共和私有部分之间发送数据报时，我们已经在转换IP地址。如果我们还可以转换端口号，会怎么样？嗯，我们可以的！地址和端口的组合唯一地标识连接。当数据报从私有网络传递到公共网络时，我们不仅可以更改IP地址，还可以更改TCP或UDP报头中的端口号。数据报将使用不同的源地址和端口发送。响应将返回到这个相同的地址和端口组合(称为套接字)，并且可以再次转换回来。

这种方法有不同的名称。由于这是一种可以让多个内部本地地址共享单个内部全局地址的技术，因此称为内部全局地址过载，或者也称为NAT过载。更优雅的名称更能说明该技术的工作原理，包括基于端口的NAT、网络地址端口转换(NAPT)和端口地址转换(PAT)。

无论它叫什么，在翻译中使用端口都有巨大的优势。它可以允许我们专用网络上的所有250台主机仅使用20个IP地址-甚至可能更少。从理论上讲，你甚至可以让250个人同时共享一个公共IP地址！您不希望共享太多本地主机而导致端口号用完，但有数千个端口号可供选择。

当然，基于端口的NAT需要对路由器进行编程，以便在网络之间传输数据报时为其进行适当的地址和端口映射。该方法的缺点包括这种更大的复杂性，以及更多潜在的兼容性问题(例如与像FTP这样的应用程序)，因为我们现在必须监视更高层的端口号，而不仅仅是IP地址。

**关键概念：**基于端口或“过载”的NAT是常规NAT的增强，它允许专用网络上的大量设备通过更改在TCP和UDP消息中使用的端口号来同时“共享”单个内部全局地址。

<u>**基于端口的NAT示例**</u>

除了端口号也被转换之外，NAPT/PAT的工作方式与常规NAT的工作方式非常相似。对于传统的出站事务，在修改源地址的同时，在请求上更改源端口号；在使用目的地址的响应上修改目的端口号。

让我们再次考虑我们在关于传统NAT的主题中查看的示例，但这一次是在PAT环境中。设备10.0.0.207是访问地址为204.51.16.12的WWW服务器的专用网络上的250台主机之一。假设由于使用了PAT，为了节省资金，所有250人共享一个内部全局地址194.54.21.7，而不是20个地址池。交易将如表76中所述和图114中所示进行。

​                                       **Table 76: Operation Of Port-Based (“Overloaded”) NAT**

| **Step #** | **Description**                                                                                                                                                                                                                                                                                                 | **Datagram Type**                                      | **Datagram Source Address:Port**     | **Datagram Destination Address:Port** |
| ---------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------ | ------------------------------------ | ------------------------------------- |
| **1**      | **Inside Client Generates Request And Sends To NAT Router:** 内部客户端生成请求并发送到NAT路由器：设备10.0.0.207在204.51.16.12向服务器生成HTTP请求。WWW的标准服务器端口为80，因此请求的目标端口为80；假设客户端上的源端口是7000。数据报被发送到NAT路由器，该路由器将组织的内部网络连接到Internet。                                                                                                       | ***Request\*** (from inside client to outside server)  | 10.0.0.207:7000 (*Inside Local*)     | 204.51.16.12:80 (*Outside Local*)     |
| **2**      | **NAT Router Translates Source Address And Port And Sends To Outside Server:** NAT路由器转换源地址和端口并发送到外部服务器：NAT路由器意识到10.0.0.207是内部本地地址，并且知道它必须替换内部全局地址。但是，这里有多台主机共享单个内部全局地址194.54.21.7。假设端口7000已被另一个专用主机连接用于该地址。路由器将替换内部全局地址，并为该请求选择新的源端口号，例如7224。目的地址和端口不变。NAT路由器将地址和端口映射放入其转换表中。它将修改后的数据报发送出去，并在204.51.16.12到达服务器。 | **194.54.21.7:7224 **(*Inside Global*)                 | 204.51.16.12 (*Outside Global*)      |                                       |
|            |                                                                                                                                                                                                                                                                                                                 |                                                        |                                      |                                       |
| **3**      | **Outside Server Generates Response And Sends Back To NAT Router:** 外部服务器生成响应并发送回NAT路由器：204.51.16.12处的服务器生成HTTP响应。当然，它不知道NAT参与其中；它在发送给它的请求中看到一个地址194.54.21.7和端口7224，因此它将发送回该地址和端口。                                                                                                                              | ***Response\*** (from outside server to inside client) | 204.51.16.12:80 (*Outside Global*)   | 194.54.21.7:7224 (*Inside Global*)    |
| **4**      | **NAT Router Translates Destination Address And Port And Delivers Datagram To Inside Client:** NAT路由器转换目的地址和端口，并将数据报发送到内部客户端：NAT路由器在从Internet到达的响应中看到地址94.54.21.7和端口7224。它查询其转换表，知道该数据报的目的地是10.0.0.207，端口为7000。这一次更改了目的地址和端口，但不更改源地址。然后，路由器将数据报发回始发客户端。                                                         | 204.51.16.12:80 (*Outside Local*)                      | **10.0.0.207:7000 **(*Inside Local*) |                                       |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipnatpat.png)

​                                                          **图114：基于端口（“过载”）的NAT操作**

此图与图112非常相似，只是源和目标端口号已显示，因为它们用于此类型的NAT。转换的地址/端口以粗体显示。表76包含基于端口的NAT中四个步骤的完整说明。请参阅图111了解地址类型的说明。

**关键概念：**在基于端口的NAT中，NAT路由器将输出请求的源地址和端口从本地内部转换为全局内部形式。然后将响应的目标地址和端口由全局内部转换为本地内部。外部本地地址和外部全局地址在请求和回复中都相同。

与NAPT/PAT有关的另一个问题值得一提：它假定所有的流量在传输层使用UDP或TCP。虽然通常是这样，但这不一定是真的。如果没有端口号，就不能进行端口转换，该方法就不能工作。

###### 3.1.4.7 IP NAT“重叠”/“两次NAT”操作(第1 2 3部分)。

到目前为止讨论的所有三种NAT版本--传统NAT、双向NAT和基于端口的NAT--通常用于将使用私有、不可路由地址的网络连接到使用唯一、注册、可路由地址的公共Internet。使用此类NAT，内部网络和外部网络的地址空间通常不会重叠，因为前者是私有的，而后者是公共的。这使NAT路由器能够仅通过查看就能立即区分内部地址和外部地址。

在我们到目前为止看到的示例中，内部地址都来自RFC 1918地址块10.0.0.0。这些地址不能是公共Internet地址，因此NAT路由器知道此范围内来自内部网络的请求引用的任何地址都是内部网络内的本地引用。同样，这个范围之外的任何地址都很容易被识别为属于“外部世界”。

<u>**私有地址块和公有地址块重叠的情况**</u>
然而，在某些情况下，用于内部网络的地址和用于部分外部网络的地址之间可能确实存在重叠。请考虑以下情况：

- 专用网络到专用网络连接：我们使用10.0.0.0块地址的示例网络可能希望使用相同的方法连接到另一个网络。如果两家公司合并并且碰巧使用相同的寻址方案(并且没有那么多私有IP块，所以这种情况并不少见)，就可能发生这种情况。
- 为专用网络分配的公共地址空间无效：某些网络可能未使用指定的专用地址块设置，而是使用包含有效Internet地址的块设置。例如，假设管理员决定他正在设置的网络“永远不会连接到Internet”(哈！)。并使用属于麻省理工学院(MIT)的18.0.0.0地址对整个事件进行了编号。后来，当网络确实需要连接到网络时，这个管理员的短视会适得其反。
- 过时的公有地址分配：A公司可能多年来一直在使用某个特定的地址块，而该地址块由于任何原因被重新分配或重新分配给B公司。A公司可能不想经历对其网络重新编号的麻烦，然后即使B公司开始在Internet上使用它们，也会保留它们的地址。

这些情况的共同点是私有网络中使用的内部地址与公有网络上的地址重叠。当从本地网络内部发送数据报时，NAT路由器无法知道预期的目的地是在内部网络还是外部网络。例如，如果我们要将私有网络中的主机10.0.0.207连接到不同网络中的主机10.0.0.199，并将10.0.0.199放入数据报的目的地并发送，路由器如何知道我们指的是本地网络中的10.0.0.199还是远程网络中的10.0.0.199？因此，我们可能需要向另一个私有网络中的10.0.0.207发送请求，这是我们自己的地址！以用麻省理工学院的地址块编号的网络为例。路由器如何知道数据报何时真正发送到MIT，而不是私有网络上的另一台设备？

**使用两次NAT处理重叠块**

解决这一困境的办法是使用更复杂的NAT形式。到目前为止，我们看到的其他版本总是在数据报从内部网络传递到外部网络时转换源地址或目的地址，反之亦然。为了处理重叠地址，我们必须在从内部到外部或相反方向的每次转换中同时转换源地址和目的地址。这种技术因其解决的问题而被称为重叠NAT，或因其解决问题的方式而被称为“**Twice NAT**”。(顺便说一句，尽管有后一种名称，但常规NAT并不称为“一次NAT”。)。

两次NAT通过不仅为NAT路由器服务的专用网络，而且为与内部网络的地址空间冲突的重叠网络(或多个网络)创建一组映射来发挥作用。为了使其发挥作用，两次NAT依赖于使用TCP/IP域名系统(DNS)，就像双向NAT一样。这允许内部网络以可唯一标识的方式向重叠网络发送请求。否则，路由器无法知道我们的内部网络试图联系的是哪个重叠网络。

<u>**重叠/两次NAT示例**</u>

让我们来试一个新的例子。假设我们的网络编号不正确，因此它不在10.0.0.0私有块中，而在MIT使用的18.0.0.0块中。我们的专用网络18.0.0.18上的一个客户端想要向服务器“www.twicenat.mit.edu”发送一个请求，该服务器在MIT的地址为18.1.2.3。我们的客户端不能只制作一个以18.1.2.3为目的地的数据报并将其发送出去，因为路由器会认为它在本地网络上，而不会对其进行路由。相反，18.0.0.18使用DNS和NAT的组合来获取外部设备地址，如下所示：

1. 我们本地网络上的客户端(18.0.0.18)发送一个DNS请求以获取“www.twicenat.mit.edu”的地址。
2. 为我们的本地网络提供服务的(兼容两次NAT的)NAT路由器拦截此DNS请求。然后，它会查询其表，以找到该外部设备的特殊映射。假设它被编程为将“www.twicenat.mit.edu”转换为地址172.16.44.55。这是一个私有的不可路由的RFC 1918地址。
3. NAT路由器将此值172.16.44.55返回给源客户端，源客户端将其用作目的地。

一旦我们的客户端获得了转换后的地址，它就会像以前一样启动一个事务。NAT现在将执行内部设备和外部设备的转换。必须转换外部设备地址，因为内部设备使用的是172.16.44.55，该地址不是它试图访问的服务器的有效地址。内部设备地址仍必须像在常规NAT中一样进行转换，因为18.0.0.18对于我们来说不是有效的公有地址。它可能指的是麻省理工学院的真实机器，我们不应该在互联网上使用它！

假设我们仍然使用从194.54.21.1到194.54.21.20的20个内部全局地址池作为内部地址，让我们进一步假设NAT路由器选择194.54.21.12用于此特定交换。交易顺序大致如表77所示，如图115所示。

​                                                                     <u>**表77：“重叠”NAT/“两次NAT”操作**</u>

| **Step #** | **Description**                                                                                                                                                                                                                                           | **Datagram Type**                                      | **Datagram Source Address**     | **Datagram Destination Address** |
| ---------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------ | ------------------------------- | -------------------------------- |
| **1**      | **Inside Client Generates Request And Sends To NAT Router:** 内部客户端生成请求并发送到NAT路由器：设备18.0.0.18使用目标172.16.44.55生成请求，该请求是从“www.twicenat.mit.edu”的（NAT拦截）DNS查询中获得的。数据报被发送到本地网络的NAT路由器。                                                                         | ***Request\*** (from inside client to outside server)  | 18.0.0.18 (*Inside Local*)      | 172.16.44.55 (*Outside Local*)   |
| **2**      | **NAT Router Translates Source Address And Destination Address and Sends To Outside Server:** NAT路由器转换源地址和目标地址并发送到外部服务器：NAT路由器进行两次转换。首先，它将18.0.0.18地址替换为公开注册的地址，在本例中为194.54.21.12。然后，它将伪造的172.16.44.55翻译回真正的麻省理工学院地址“www.twicenat.MIT.edu”。它将数据报路由到外部服务器。 | **194.54.21.12 **(*Inside Global*)                     | **18.1.2.3 **(*Outside Global*) |                                  |
|            |                                                                                                                                                                                                                                                           |                                                        |                                 |                                  |
| **3**      | **Outside Server Generates Response And Sends Back To NAT Router:** 外部服务器生成响应并发送回NAT路由器：18.1.2.3处的MIT服务器生成响应，并将其发送回194.54.21.12，这导致其返回NAT路由器                                                                                                              | ***Response\*** (from outside server to inside client) | 18.1.2.3 (*Outside Global*)     | 194.54.21.12 (*Inside Global*)   |
| **4**      | **NAT Router Translates Source Address And Destination Address And Delivers Datagram To Inside Client:** NAT路由器转换源地址和目标地址，并将数据报传递给内部客户端：NAT路由器将目标地址转换回我们内部客户端使用的实际地址，就像在常规NAT中一样。它还将172.16.44.55值替换回它用来替代“www.twicenat.mit.edu”的实际地址。                     | **172.16.44.55 **(*Outside Local*)                     | **18.0.0.18 **(*Inside Local*)  |                                  |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipnattwicenat.png)

​                                                                        **图115：重叠NAT/两次NAT的操作**

此图与图112非常相似，除了您可以看到，每次NAT路由器都会转换源地址和目标地址（以粗体显示）。表77包含了“重叠”NAT中四个步骤的完整说明。有关地址类型的说明，请参阅图111。

如您所见，在本例中，外部本地地址和外部全局地址是不同的，与前面的NAT示例不同。两次NAT还可以处理入站事务，方法是监视来自Internet的数据报，这些数据报与本地网络上使用的地址重叠，并根据需要进行双重替换。

**关键概念：**“重叠”NAT用于数据报中的源地址和目的地址都是私有地址或无法在公共互联网上正常使用的情况。在这种情况下，与其他类型的NAT不同，NAT路由器转换传入和传出数据报的源地址和目的地址。在传出消息时，内部本地地址将更改为内部全局地址，外部本地地址更改为外部全局地址；对于传入的消息，内部全局地址将更改为内部本地地址，外部全局地址更改为外部本地地址。

###### 3.1.4.8 IP NAT兼容性问题和特殊处理要求

在一个完美的世界中，网络地址转换对于使用它的设备是透明的。我们希望NAT路由器能够在请求数据报离开网络时更改请求数据报中的IP地址，并在返回的响应中将其更改回来，并且没有一个主机知道这些地址。不幸的是，这并不是一个完美的世界。

NAT不可能对使用它的设备完全透明。如果NAT不执行某些功能，而不仅仅是简单地交换IP地址和IP报头中的端口号，就会出现潜在的兼容性问题。主要问题是，尽管IP地址被认为是互联网协议域，但它们实际上也被其他协议使用，无论是在网络层还是在更高层。当NAT更改IP数据报中的IP地址时，它通常还必须更改其他位置的地址，以确保各种报头和有效负载中的地址仍然匹配。

这些兼容性问题要求，尽管NAT理论上应该只在网络层的IP级别工作，但实际上NAT路由器必须“意识到”更多的协议，并根据需要执行特殊操作。其中一些是所有已转换数据报所必需的，而另一些则只适用于某些数据报，而不适用于其他数据报。即使将这些技术添加到NAT路由器中，有些东西在NAT环境中仍可能无法正常工作。

大多数NAT实施都会考虑到这些问题。当然，NAT路由器广泛支持像FTP这样的常见应用程序，否则没有人会想要使用NAT。也就是说，有些应用程序可能无法在NAT上工作。NAT实际上是不透明的，必须对其他协议头甚至有效负载进行这些额外的“黑客攻击”，这一事实是许多人将NAT称为“杂乱无章”的很大一部分原因；优雅的解决方案没有那么多需要特殊处理的特殊情况。

让我们来看看一些具体的问题和要求。

<u>**重新计算TCP和UDP校验和。**</u>
更改IP报头中的IP地址意味着必须计算IP报头校验和。由于UDP或TCP也都有校验和，并且这些校验和是在包含IP源地址和目的地址的伪报头上计算的，因此每次进行转换时也必须重新计算它们。

<u>**ICMP操纵。**</u>
由于NAT与IP报头的工作关系如此密切，并且IP与其“助理”协议ICMP密切相关，因此NAT还必须查找特定的ICMP消息并对其中包含的地址进行更改。许多ICMP报文，例如无法到达目的地和参数问题，都包含导致ICMP报文的数据报的原始IP报头作为数据。由于NAT正在转换IP报头中的地址，因此它必须监视这些消息，并根据需要转换包含的报头中的地址。

<u>**嵌入IP地址的应用程序。**</u>
许多TCP/IP应用程序在实际应用程序数据有效负载中嵌入IP地址。最臭名昭著的例子是TCP/IP文件传输协议(FTP)，它实际上在连接期间以文本信息的形式在设备之间的数据报中发送地址和端口分配。为了使NAT支持FTP，必须使用专门的算法对其进行编程，以查找此信息并根据需要进行更改。

复杂程度甚至可能超过这一水平。想一想，当包含这些文本地址或端口号的FTP消息被分段时会发生什么--要转换的地址的一部分可能是两个不同的IP数据报，并且很难识别！

<u>**端口转换的其他问题。**</u>
使用基于端口的NAT(PAT)时，适用于地址的问题现在也适用于端口，这使得路由器需要执行更多工作。

<u>**地址或端口号更改的级联影响。**</u>
以对NAT必须更改的IP地址进行编码的FTP数据报为例。被替换的地址可能需要比原始地址更多的字符；在我们的第一个示例中，10.0.0.207(10个ASCII字符)被替换为194.54.21.11(12个ASCII字符)。进行此替换会更改有效负载的大小！这意味着还必须修改TCP序列号。

在这些情况下，NAT本身应该负责可能需要的任何额外工作。如果不使用NAT，这肯定是一个复杂的问题，也是NAT“笨拙”的一个经常被引用的例子。

**<u>IPSec的问题</u>**
在传输模式中使用IPSec时，身份验证头(AH)和封装安全有效负载(ESP)协议都使用基于整个有效负载的值的完整性检查。当NAT尝试更新IP数据报中的TCP或UDP校验和时，这会更改接收设备在执行AH或ESP完整性检查时使用的数据值。检查将失败。因此，NAT不能用于IPSec传输模式。它可能仍然在隧道模式下工作，但在这里也可能会有复杂的情况。

##### 3.1.5 IP安全（IPSec）协议

最初的互联网协议的弱点之一是，它缺乏任何类型的通用机制来确保数据在互联网上传输时的真实性和隐私。由于IP数据报通常必须在未知网络上的两台设备之间进行路由，因此其中的任何信息都可能被截获，甚至可能被更改。随着关键应用程序越来越多地使用互联网，需要加强知识产权的安全。为此，开发了一套称为IP安全或IPSec的协议。

在本节中，我将简要介绍IPSec的概念和协议。我首先概述IPSec，包括讨论该技术的历史和定义标准。我描述了IPSec套件的主要组件和协议，以及它的不同体系结构和实现方法。然后，我将转到实际讨论IPSec的工作方式，首先描述两种IPSec模式(传输和隧道)以及它们之间的区别。我描述了安全关联和相关的构造，如安全参数索引(SPI)。最后三个主题介绍了三种主要的IPSec协议：IPSec身份验证头(AH)、IPSec封装安全有效负载(ESP)和IPSec互联网密钥交换(IKE)。

**注意：**IPSec最初是在考虑到IPv6的情况下开发的，但已被设计为为IPv4和IPv6网络提供安全，并且这两个版本的操作类似。根据在IPv4和IPv6中是否使用IPSec，用于AH和ESP的数据报格式存在一些差异，因为这两个版本具有不同的数据报格式和寻址。在适当的情况下，我会强调这些差异。

注意：本指南中有许多主题非常复杂，因此已经有许多大型书籍对其进行了介绍。IP网络和IPSec上的安全肯定属于这一类。由于本指南的篇幅已经很大，而且IPSec的复杂性，我在这里只能对其工作原理进行非常有限的描述。有关更全面的信息，您需要补充特定于该技术的参考资料。

###### 3.1.5.1 IPSec概述、历史和标准(部分：1 2 3)

原始互联网协议(IPv4)最著名的问题是其地址空间即将耗尽。出现这种情况的原因是，在开发IPv4时，互联网的迅速扩张超出了任何人的预期。创建IPv4时的互联网与现在的互联网之间的这种不匹配同样导致了IP的另一个主要问题：缺乏确保IP网际网络安全的权威手段。

之所以会出现安全问题，是因为25年前，互联网规模很小，而且相对“私密”。今天，它是巨大的，真正的“公共”。随着互联网的发展，对安全的需求也与日俱增。考虑到TCP/IP和早期的互联网先驱是作为非常小的网络开发的，供美国国防高级研究计划局(DARPA或ARPA)的政府研究人员使用。所有的硬件都是由一些知名人士控制的，他们通常都有安全许可。在这样的网络中，您不需要将安全性构建到协议中-您可以将其构建到建筑物中！使用锁和警卫来确保安全比花哨的加密更容易，如果你可以逃脱惩罚的话。毕竟，要防止有人窥探或篡改网络上的数据，最简单的方法就是拒绝他们访问连接到网络的主机。

起初，当互联网上只有几十台机器时，这一点运行得很好。即使在互联网刚开始发展的时候，它也只是被用来连接研究人员和其他网络专业人员。起初，新站点加入网络的速度很慢，至少有人知道添加到不断增长的互联网中的每个新站点的身份。然而，随着互联网规模的不断扩大并最终向公众开放，维护整个网络的安全变得不可能。如今，互联网上已经出现了“未被清洗的大群众”。许多路由器--由“谁知道”拥有，由“谁知道”管理--阻碍了你和你想要连接的大多数其他设备之间的联系。您不能假定您发送或接收的数据是安全的。

多年来，已经发展了许多方法来满足安全需求。其中大部分集中在OSI协议堆栈的较高层，以弥补IP的安全性不足。这些解决方案对于某些情况很有价值，但它们不容易推广，因为它们特定于各种应用程序。例如，我们可以将安全套接字层(SSL)用于某些应用程序，如万维网访问或FTP，但有数十个应用程序从未打算使用这种类型的安全性。

真正需要的是一种解决方案，允许IP级别的安全性，以便TCP/IP中的所有高层协议都可以利用它。当决定开发新版本的IP(IPv6)时，这是一个千载难逢的机会，不仅可以解决旧的IPv4中的寻址问题，而且还可以解决缺乏安全性的问题。新的安全技术是在考虑到IPv6的情况下开发的，但由于IPv6的开发和推出花了数年时间，而且现在需要安全，因此该解决方案设计为同时适用于IPv4和IPv6。

将安全通信引入Internet协议的技术称为IP安全，通常缩写为IPSec(此缩写的大小写是可变的，因此也可以看到IPSec和IPSec。幸运的是，虽然不是IPSec或IPSec。j)

<u>**IPSec服务和功能概述**</u>

IPSec不是单一的协议，而是为IP网络提供完整安全解决方案的一组服务和协议。这些服务和协议组合在一起可提供各种类型的保护。由于IPSec工作在IP层，它可以为任何更高层的TCP/IP应用或协议提供这些保护，而不需要额外的安全方法，这是一个主要的优势。IPSec提供的一些保护服务包括：

- 对用户数据进行加密以保护隐私。
- 对消息的完整性进行身份验证，以确保消息在传输过程中不会更改。
- 防止某些类型的安全攻击，例如重放攻击。
- 设备能够协商满足其安全需求所需的安全算法和密钥。
- 隧道和传输两种安全模式，满足不同的网络需求。

**关键概念：**IPSec是IP安全的缩写，由一组为IP网络提供安全的服务和协议组成。它是由一系列的几个互联网标准定义的。

**<u>IPSec标准</u>**

由于IPSec实际上是技术和协议的集合，因此它没有在单一的Internet标准中定义。相反，一组RFC定义了IPSec中使用的体系结构、服务和特定协议。表78列出了其中一些最重要的信息，这些信息都发表于1998年11月：

| **RFC Number** | **Name**                                                             | **Description**                                                      |
| -------------- | -------------------------------------------------------------------- | -------------------------------------------------------------------- |
| **2401**       | *Security Architecture for the Internet Protocol*                    | IPSec的主要文档，描述了该技术的体系结构和一般操作，并显示了不同组件如何配合在一起。                         |
| **2402**       | *IP Authentication Header*                                           | 定义用于确保数据完整性和源验证的IPSec身份验证头（AH）协议。                                    |
| **2403**       | *The Use of HMAC-MD5-96 within ESP and AH*                           | 描述AH和ESP使用的特定加密算法，称为消息摘要5（MD5），HMAC变体。（显然.J）                         |
| **2404**       | *The Use of HMAC-SHA-1-96 within ESP and AH*                         | 描述AH和ESP使用的特定加密算法，称为安全哈希算法1（SHA-1），HMAC变体。                           |
| **2406**       | *IP Encapsulating Security Payload (ESP)*                            | 描述为保密性提供数据加密的IPSec封装安全有效载荷（ESP）协议。                                   |
| **2408**       | *Internet Security Association and Key Management Protocol (ISAKMP)* | 定义用于交换密钥和协商安全关联的方法。                                                  |
| **2409**       | *The Internet Key Exchange (IKE)*                                    | 描述Internet密钥交换（IKE）协议，该协议用于在设备之间协商安全关联和交换密钥，以实现安全通信。基于ISAKMP和OAKLEY。 |
| **2412**       | *The OAKLEY Key Determination Protocol*                              | 描述密钥交换的通用协议。                                                         |

<u>**IPSec的未来**</u>
IPSec的部署在过去几年才真正开始起步；该技术的主要用途是实现虚拟专用网络(VPN)。随着越来越多的个人和公司决定他们需要利用互联网的力量，同时保护他们通过互联网传输的数据的安全，IPSec的未来似乎是光明的。

###### 3.1.5.2 IPSec一般操作、组件和协议(第1部分：第2部分)

我必须承认：我曾考虑在本指南中不写有关IPSec的内容。当你发现自己在写一本像这本一样大的书时，你有时会失去耐心，会有一种避免写令人困惑的主题的冲动。IPSec不是本指南中唯一的难点主题，但它绝对是一个让许多人感到困惑的主题，因为它很难理解。大多数对它的讨论都直接跳到描述机制和协议上，而没有提供它所做的事情以及这些部分如何结合在一起的一般描述。嗯，我认识到IPSec很重要，我不会回避挑战。因此，这里我试图提供一个框架来理解IPSec的各种细节。

那么，IPSec到底做了什么，又是如何做到的呢？一般而言，它在IP层提供安全服务，以供其他TCP/IP协议和应用程序使用。这意味着IPSec提供了TCP/IP网络上的设备安全通信所需的工具。当两个设备(最终用户主机或中间设备，如路由器或防火墙)要进行安全通信时，它们会在彼此之间建立一条安全路径，该路径可能会穿越许多不安全的中间系统。要做到这一点，他们必须(至少)执行以下任务：

1. 它们必须就一套要使用的安全协议达成一致，以便每个协议都能以对方可以理解的格式发送数据。
2. 他们必须决定在编码数据时使用的特定加密算法。
3. 它们必须交换用于“解锁”已加密编码的数据的密钥。
4. 完成此后台工作后，每台设备必须使用先前商定的协议、方法和密钥对数据进行编码并通过网络发送。

<u>**IPSec核心协议**</u>

为了支持上述活动，许多不同的组件组成了称为“IPSec”的集合，如图116所示。这两个主要部分是一对技术，有时被称为IPSec的核心协议。它们实际上负责对信息进行编码以确保安全。它们是：

- IPSec验证头(AH)：该协议为IPSec提供身份验证服务。这意味着它允许消息的接收者验证假定的消息发起者实际上就是发送消息的人。它还允许接收方验证数据报中的任何数据都未被途中的任何中间设备更改。它还提供了对所谓的“重播”攻击的保护，即消息被未经授权的用户捕获并重新发送。
- 封装安全有效负载(ESP)：身份验证头可确保数据报中数据的完整性，但不能确保其保密性。当数据报中的信息仅供您查看时，可以使用ESP协议对其进行进一步保护，该协议对IP数据报的有效负载进行加密。 

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipsecoverview.png)

​                                                                     <u>**图116：IPSec协议和组件概述**</u>

<u>**IPSec支持组件**</u>

AH和ESP通常被称为“协议”，尽管这是另一种情况，这个术语的有效性是有争议的。正如我们将看到的，它们并不是真正不同的协议，而是作为插入到IP数据报中的报头来实现的。因此，它们可以做IPSec的“繁琐工作”，并且可以一起使用来提供身份验证和隐私。然而，他们不能单独运作。为了让它们正常运行，它们需要其他几种协议和服务的支持。其中最重要的包括：

- 加密/散列算法：AH和ESP是通用的，没有指定用于加密的确切机制。这使他们可以灵活地使用各种这样的算法，并根据需要协商使用哪种算法。IPSec使用的两种常见协议是消息摘要5(MD5)和安全散列算法1(SHA-1)。这些算法也称为散列算法，因为它们的工作原理是根据输入数据和密钥计算一个称为散列的公式。
- 安全策略和关联以及管理方法：由于IPSec提供了让不同设备决定如何实施安全的灵活性，因此需要一些方法来跟踪设备之间的安全关系。这是在IPSec中使用称为安全策略和安全关联的构造，并通过提供交换安全关联信息的方法(见下文)来完成的。
- 密钥交换框架和机制：对于要交换加密信息的两个设备，它们需要能够共享用于解锁加密的密钥。他们还需要一种方式来交换安全关联信息。在IPSec中，称为Internet密钥交换(IKE)的协议提供了这些功能。

**关键概念：**IPSec由许多协同工作以提供安全服务的不同组件组成。两个主要的协议是称为身份验证报头(AH)和封装安全有效负载(ESP)的协议，它们以添加到IP数据报的特殊报头的形式为IP数据提供真实性和保密性。

好吧，这至少是为理解IPSec的全部内容以及各个部分如何组合在一起提供框架的一个开始。在本部分中，我们将更详细地研究这些组件和协议。

###### 3.1.5.3 IPSec体系结构和实现方法(第1、2、3部分)

IPSec如此强大的主要原因是它为IP提供了安全性，而IP是所有其他TCP/IP协议的基础。在保护IP的同时，我们也在保护几乎所有其他的TCP/IP协议。那么，一个重要的问题是，我们到底如何将IPSec引入IP？部署IPSec有几种实现方法，它们代表了IPSec修改TCP/IP的整体层体系结构的不同方式。

<u>**IPSec实现方法**</u>
RFC 2401中为IPSec定义了三种不同的实现体系结构。我们使用哪个版本取决于各种因素，包括使用的IP版本(v4和v6)、应用程序的要求以及其他因素。这些反过来又取决于主要的实现决策：IPSec是应该编程到网络上的所有主机中，还是只编程到某些路由器或其他“中间设备”中。

此实施决策必须基于网络的要求。有两种选择：在终端主机或路由器中实施IPSec。

<u>**结束主机实施**</u>
将IPSec应用于所有主机设备可提供最大的灵活性和安全性。它实现了网络上任何两个设备之间的“端到端”安全。然而，一个典型的网络上有许多主机，因此这意味着比在路由器中实施IPSec要多得多的工作。

<u>**路由器实施**</u>
此选项的工作量要小得多，因为这意味着我们只更改几个路由器，而不是数百或数千个客户端。它只在实现IPSec的路由器对之间提供保护，但对于某些应用(如虚拟专用网络(VPN))来说，这可能就足够了。路由器可用于仅为数据报在组织外部传输的那部分路由提供保护，从而使路由器和本地主机之间的连接不安全(或可能通过其他方式保护)。

<u>**IPSec架构**</u>

定义了三种不同的体系结构，描述了如何将IPSec加入到TCP/IP协议栈中的方法。

<u>**集成架构**</u>
在理想情况下，我们会将IPSec的协议和功能直接集成到IP本身中。这是最优雅的解决方案，因为它允许提供所有IPSec安全模式和功能，就像提供普通IP一样容易。不需要额外的硬件或架构层。

IPv6旨在支持IPSec，使其成为主机或路由器的可行选择。使用IPv4，集成将需要对每台设备上的IP实现进行更改，这通常是不切实际的(至少可以说！)。

**Bump In The Stack  (BITS) 架构**
在这种技术中，IPSec是IP和数据链路层之间的一个单独的架构层；这个可爱的名字指的是IPSec是网络协议堆栈中的一个额外元素，如图117所示。IPSec在IP数据报沿协议堆栈向下传递时对其进行拦截，对其进行处理以提供安全性，然后将其传递到数据链路层。

该技术的优点在于，由于IPSec功能独立于IP，因此IPSec可以“改造”到任何IP设备上。缺点是与集成架构相比，存在重复工作。BITS通常用于IPv4主机。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipsecbits.png)
                        **图117：IPSEC“**Bump In The Stack**”(BITS)体系结构。**

在这种类型的IPSec实现中，IPSec成为TCP/IP堆栈中的一个单独层。它被实施为位于IP之下的软件，并为IP层创建的数据报添加安全保护。

<u>**《Bump in the Wire》(BITW)架构**</u>

在这种方法中，我们添加了一个提供IPSec服务的硬件设备。例如，假设我们有一家公司有两个站点。每个路由器都有一个使用不具备IPSec功能的路由器连接到Internet的网络。我们可以在两个站点的路由器和互联网之间插入一个特殊的“IPSec”设备，如图118所示。然后，这些设备将拦截传出的数据报并为其添加IPSec保护，并将其从传入的数据报中剥离。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipsecbitw.png)
                                      图118：IPSec“**Bump In The Wire**”(BITW)架构。

在此IPSec体系结构中，IPSec实际上是在希望安全通信的设备之间的独立设备中实现的。它们重新打包不安全的IP数据报，以便在公共互联网上传输。

就像BITS允许我们将IPSec添加到传统主机一样，BITW可以“改造”非IPSec路由器以提供安全优势。缺点是复杂性和成本。

**BITS和BITW之间的并行**
顺便说一句，尽管BITS和BITW看起来很不同，但它们实际上是做同一件事的不同方式。在BITS的情况下，我们增加了一个额外的软件层，以增加现有IP数据报的安全性；在BITW中，同样的工作由不同的硬件设备完成。在这两种情况下，结果是相同的，并且对选择IPSec模式的影响也是相同的。

正如我们将在下一个主题中看到的，体系结构的选择对使用两种IPSec模式中的哪一种具有重要影响。

**关键概念：**为IPSec定义了三种不同的体系结构或实现模型。最好的是集成架构，其中IPSec直接内置于设备的IP层。另外两个是“Stack中的Bump”(BITS)和“Bire中的Bump”(BITW)，它们都是分别使用软件和硬件解决方案在常规IP下对IPSec进行分层的方法。

###### 3.1.5.4 IPSec模式：传输和隧道(部分：1 2 3 4)

可以使用三种不同的基本实现体系结构来为TCP/IP网络提供IPSec设施。我们使用哪种实现方式的选择，以及我们是在终端主机上还是在路由器上实现，都会影响IPSec的具体工作方式。为与这些体系结构相关的IPSec定义了两种特定的操作模式，称为传输模式和隧道模式。

IPSec模式与身份验证头(AH)和封装安全有效负载(ESP)这两个核心协议的功能密切相关。这两种协议都通过向数据报添加包含安全信息的报头(可能还有其他字段)来提供保护。模式的选择不影响每个报头生成其报头的方法，而是改变IP数据报的哪些特定部分被保护以及报头如何被安排来实现这一点。本质上，该模式真正描述的是，而不是规定AH或ESP如何做他们的事情。它用作定义其他构造的基础，例如安全关联(SA)。

让我们来看看这两种模式是如何工作的。

<u>**传输方式**</u>

顾名思义，在传输模式下，该协议保护从传输层向下传递到IP的消息。消息由AH/ESP处理，并在传输(UDP或TCP)报头之前添加适当的报头。然后通过IP将IP报头添加到该报头之前。

看待这一问题的另一种方式如下所示。通常，传输层将数据打包以进行传输，并将其发送到IP。从IP的角度来看，该传输层消息是IP数据报的有效负载。当在传输模式中使用IPSec时，IPSec报头仅应用于此IP有效负载，而不是IP报头。AH和/或ESP报头出现在原始的单个IP报头和IP有效负载之间。这一点如图119所示。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipsectransport.png)

​                                                                         **图119：IPSec传输模式操作**

当IPSec以传输模式运行时，它与IP集成在一起，用于直接传输上层(TCP/UDP)报文。经过处理后，数据报只有一个包含AH和/或ESP IPSec报头的IP报头。与图120形成对比。

<u>**隧道模式**</u>

在此模式下，IPSec用于在IP报头已应用于完整封装的IP数据报之后对其进行保护。IPSec报头出现在原始IP报头的前面，然后在IPSec报头的前面添加一个新的IP报头。也就是说，对整个原始IP数据报进行保护，然后将其封装在另一个IP数据报中。这如图120所示。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipsectunnel.png)

​                                                                    **图120：IPSec隧道模式操作**

IPSec隧道模式之所以这样命名，是因为它代表对完整IP数据报的封装，从而在支持IPSec的设备之间形成虚拟隧道。IP数据报被传递到IPSec，在那里创建具有AH和/或ESP IPSec报头的新IP报头。与图119形成对比。

<u>**比较运输模式和隧道模式**</u>

理解这两者之间的区别的底线是：隧道模式将原始IP数据报作为一个整体、报头和全部进行保护，而传输模式则不保护。因此，一般而言，标头的顺序如下：

- 传输模式：IP头、IPSec头(AH和/或ESP)、IP载荷(含传输头)。
- 隧道模式：新IP报头、IPSec报头(AH和/或ESP)、旧IP报头、IP负载。

同样，这是IPSec数据报构造方式的简化视图；实际情况要复杂得多。在传输和隧道模式下，报头在IPSec数据报中的确切排列方式取决于所使用的IP版本；IPv6使用扩展报头，当使用IPSec时，扩展报头必须以特定方式排列。标头位置还取决于正在使用的IPSec协议：AH或ESP。请注意，也可以将AH和ESP应用于同一数据报；如果是这样，则AH报头始终出现在ESP报头之前。

因此，存在模式(隧道或传输)、IP版本(IPv4或IPv6)和协议(AH或ESP)的三个变量和八个基本组合。有关AH和ESP的两个主题介绍了适用于每个协议的传输/隧道模式和IPv4/IPv6的四种格式组合。请注意，ESP还包括一个追随受保护数据的ESP尾部。

通过阅读这些描述，您可能会知道这两种模式与上一主题中选择的IPSec体系结构有何关系。传输模式要求将IPSec集成到IP中，因为在传输层消息上执行原始IP打包时必须应用AH/ESP。这通常是需要与直接运行IPSec的主机进行端到端安全性的实现的选择。

隧道模式代表IP+IPSec组合中的IP封装。因此，它对应于BITS和BITW实现，在这些实现中，IPSec是在IP处理了高层消息并已经添加了其报头之后应用的。隧道模式是VPN实施的常见选择，它基于IP数据报在不安全的网络(如Internet)中的隧道传输。

**关键概念**：IPSec有两种基本操作模式。在传输模式中，在创建原始IP数据报时添加IPSec AH和/或ESP报头；此模式与集成的IPSec体系结构相关联。在隧道模式下，正常创建原始IP数据报，然后将整个数据报封装到包含AH/ESP IPSec报头的新IP数据报中。此模式最常与“Bump In The Stack”和“Bump In The Wire”实现一起使用。

###### 3.1.5.5 IPSec安全关联和安全关联数据库(SAD)；安全策略和安全策略数据库(SPD)选择器,安全参数索引(SPI)(1 2)

哇，在那个话题标题里肯定有很多“安全”的东西。这些项目都是密切相关的，在我们继续研究核心IPSec协议本身之前，了解它们是很重要的。这些构造通常用于指导IPSec的操作，特别是设备之间的交换。它们控制IPSec的工作方式，并确保进入或离开支持IPSec的设备的每个数据报都得到适当处理。

从哪里开始…。从哪里开始。J让我们首先考虑如何在可能正在处理与其他设备的许多不同数据报交换的设备中应用安全性的问题。提供安全是有开销的，所以我们不想对传入或传出的每一条消息都这样做。某些类型的消息可能需要更高的安全性，而其他类型的消息可能需要更少的安全性。此外，与某些设备的交换可能需要不同于其他设备的处理。

<u>**安全策略、安全关联和关联数据库**</u>
为了管理所有这些复杂性，IPSec配备了一种灵活而强大的方式来指定应该如何处理不同类型的数据报。要了解其工作原理，我们必须首先定义两个重要的逻辑概念：

- 安全策略：安全策略是编程到IPSec实现中的规则，告诉它如何处理设备接收的不同数据报。例如，安全策略用于确定特定的包是否需要由IPSec处理；那些不完全绕过AH和ESP的策略。如果需要安全性，安全策略提供了关于如何提供安全性的一般指导原则，如果需要，还提供了指向更具体详细信息的链接。

设备的安全策略存储在设备的安全策略数据库(SPD)中。

- 安全关联：安全关联(SA)是一组安全信息，描述一台设备和另一台设备之间的特定类型的安全连接。如果您愿意，您可以将其视为一种“合同”，它指定了用于两者之间安全通信的特定安全机制。

设备的安全关联包含在其安全关联数据库(SAD)中。

SPD和SAD通常很难区分，因为它们在概念上是相似的。它们之间的主要区别是安全策略是通用的，而安全关联则更具体。为了确定如何处理特定的数据报，设备首先检查SPD。SPD中的安全策略可以引用SAD中的特定安全关联。如果是，设备将查找该安全关联并使用它来处理数据报。

<u>**选择器**</u>

我们还没有讨论的一个问题是，设备如何确定对特定数据报使用什么策略或SA。同样，在这里，IPSec定义了一个非常灵活的系统，它允许每个安全关联定义一组规则，用于选择SA应用到的数据报。这些规则集中的每一个都称为选择器。例如，可以定义一个选择符，该选择符表示数据报的源地址中的特定范围的值与目的地址中的另一个值相结合，意味着必须对数据报使用特定的SA。

现在让我们回到安全关联方面，这在IPSec中是一个非常重要的概念。一个设备与另一个设备进行的每一次安全通信都需要建立SA。SA是单向的，因此每个SA只处理特定设备的入站或出站流量。这允许为从设备A到设备B的流实施不同级别的安全，而不是为从设备B到设备A的流量实施不同级别的安全。在这种类型的双向通信中，A和B都将具有两个SA；A将具有我们可以称为“SAdeviceBin”和“SAdeviceBout”的SA。设备B将具有SA“SAdeviceAin”和“SAdeviceAout”。

<u>**安全关联三元组和安全参数索引(SPI)。**</u>
然而，安全关联实际上并没有名称。相反，它们由一组三个参数定义，称为三元组：

- 安全参数索引(SPI)：一个32位数字，用于唯一标识任何连接设备的特定SA。SPI被放置在AH或ESP数据报中，从而将每个安全数据报链接到安全关联。它由传输的接收方使用，因此它知道哪个SA管理数据报。
- IP目的地址：为其建立SA的设备的地址。
- 安全协议标识符：指定此关联是用于AH还是用于ESP。如果两者都与此设备一起使用，则它们具有单独的SA。

如您所见，AH和ESP这两个安全协议依赖于安全关联和策略以及控制其操作的各种数据库。这些数据库的管理很重要，但又是另一项复杂的课题。通常，可以手动设置SA(这当然是额外的工作)，也可以使用像IKE这样的协议来部署自动化系统。

困惑？我不会责怪你，尽管我尽了最大努力，但请记住，这一切都高度简化了。欢迎来到网络安全的奇妙世界。如果你曾经被失眠所困扰，我强烈推荐**RFC 2401**。😄

###### 3.1.5.6 IPSec身份验证头(AH)(部分：1 2 3 4)

 IPSec中的两个核心安全协议之一是验证头(AH)。这是另一个名称选择得很好的协议：AH是一种协议，它通过添加基于数据报中的值计算的报头来提供对数据报全部或部分内容的验证。数据报的哪些部分用于计算以及报头的位置取决于模式(隧道或传输)和IP版本(IPv4或IPv6)。

AH协议的操作出奇地简单--尤其是对于任何与网络安全有关的协议。它可以被认为类似于用于计算校验和或执行CRC校验以进行错误检测的算法。在这些情况下，发送者使用标准算法来根据消息的内容计算校验和或CRC码。该计算结果与原始数据一起被传输到目的地，如果发现其计算与源所做的计算之间有任何差异，则目的地重复计算并丢弃该消息。

AH背后的想法是相同的，只是我们不使用每个人都知道的简单算法，而是使用特殊的散列算法和只有源和目标才知道的特定密钥。在两个设备之间建立安全关联，指定这些细节，以便源设备和目标设备知道如何执行计算，而其他设备不能。在源设备上，AH执行计算并将结果(称为完整性校验值或ICV)放入带有其他字段的特殊报头中进行传输。目的设备使用两个设备共享的密钥进行相同的计算，这使它能够立即查看原始数据报中的任何字段是否被修改(由于错误或恶意)。

重要的是，我要明确指出，正如校验和不会更改原始数据一样，ICV计算也不会更改原始数据。AH报头的存在使我们能够验证消息的完整性，但不会对其进行加密。因此，AH提供身份验证，但不提供隐私(这就是ESP的用途)。不，我不是指使用灵媒，我是指另一种IPSec核心协议！)

![image-20221021183912845](C:\Users\zy\AppData\Roaming\Typora\typora-user-images\image-20221021183912845.png)

<u>**身份验证头数据报的放置和链接**</u>

对于IPv4和IPv6，身份验证报头的计算类似。一个不同之处在于用于将报头放入数据报并将报头链接在一起的确切机制。我将首先描述IPv6，因为它更简单，因为AH实际上是为适应IPv6的机制而设计的。

<u>**IPv6身份验证报头放置和链接**</u>
AH作为扩展报头插入到IP数据报中，遵循用于扩展报头链接的正常IPv6规则。它通过前一个报头(扩展或主)将为AH报头(51)分配的值放入其下一个报头字段来链接。然后，AH报头使用其下一个报头字段链接到下一个扩展报头或传输层报头。

在传输模式中，AH被放置在主IP报头中，并且出现在包含用于最终目的地的选项的任何目的地选项报头之前、ESP报头(如果存在)之前、但在任何其他扩展报头之后。在隧道模式下，它显示为新IP数据报的扩展报头，该报头封装了正在隧道传输的原始IP数据报。这在图121中以图形方式显示。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipsecahipv6.png)

​                                                           **图121：带有IPSec身份验证报头(AH)的IPv6数据报格式**

顶部是一个IPv6数据报示例，其中包含使用标准IPv6机制链接的两个扩展报头(参见图106)。当AH应用于传输模式时，它只是作为新的扩展报头(以粉色显示)添加，该报头位于路由扩展报头和目的地选项报头之间。在隧道模式下，整个原始数据报被封装到包含身份验证头的新IPv6数据报中。在这两种情况下，下一个报头字段用于将每个报头一个链接到下一个。请注意，在隧道模式中使用Next Header值41，它是用于封装的IPv6数据报的值。

**关键概念**：IPSec身份验证头(AH)协议允许数据报的接收方验证其真实性。它被实现为添加到IP数据报的报头，该报头包含基于数据报中的字段的值计算的完整性校验值。接收方可以使用此值来确保数据在传输过程中未被更改。身份验证头不加密数据，因此不能确保传输的私密性。

<u>**身份验证标头格式**</u>

验证头本身的格式如表79所示，如图123所示

​                                                                       **表79：IPSec身份验证报头(AH)格式**

| **Field Name**             | **Size (bytes)** | **Description**                                                                                                          |
| -------------------------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------ |
| ***Next Header\***         | 1                | ***Next Header:\***包含AH之后的下一个Header的协议号。用于将标题链接在一起。                                                                      |
| ***Payload Len\***         | 1                | ***Payload Length:\*** 尽管名称不同，该字段测量的是身份验证头本身的长度，而不是有效负载的长度。（我想知道这背后的历史是什么！）它是以32位为单位测量的，减去2以与IPv6中标头长度的正常计算方式保持一致。       |
| ***Reserved\***            | 2                | ***Reserved:\*** 未使用；设置为零。                                                                                               |
| ***SPI\***                 | 4                | ***Security Parameter Index (SPI):\*** 安全参数索引（SPI）：一个32位值，当与目标地址和安全协议类型（这里显然是AH的类型）相结合时，它标识用于此数据报的安全关联。有关详细信息，请参阅安全关联主题。 |
| ***Sequence Number\***     | 4                | ***Sequence Number:\*** 序列号：这是一个计数器字段，当两个设备之间形成安全关联时，该字段初始化为零，然后针对使用该SA发送的每个数据报递增。这唯一地标识每个数据报                            |
| ***Authentication Data\*** | Variable         | ***Authentication Data:\*** 身份验证数据：此字段包含AH协议执行的哈希算法的结果，即完整性检查值（ICV）。                                                     |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipsecahformat.png)

​                                                                        **图123:IPSec认证标头（AH）格式**

验证数据字段的大小是可变的，以支持不同的数据报长度和哈希算法。其总长度必须是32位的倍数。此外，整个报头必须是32位（对于IPv4）或64位（对于IPv6）的倍数，因此，如果需要，可以在身份验证数据字段中添加额外的填充。

您还可能注意到，标头中没有显示IP地址，这是IPv4和IPv6相同的前提条件。

###### 3.1.5.7 IPSec封装安全负载(ESP)(部分：1 2 3 4)

IPSec身份验证头(AH)为支持IPSec的设备提供完整性身份验证服务，因此它们可以验证从其他设备接收的消息是否完好无损。然而，对于许多应用程序来说，这只是拼图中的一部分。我们不仅要防止中间设备更改我们的数据报，还要防止它们检查其内容。对于这种级别的私有通信，AH是不够的；我们需要使用封装安全有效负载(ESP)协议。

ESP的主要工作是通过对IP数据报进行加密来提供我们所寻求的隐私。加密算法将数据报中的数据与密钥相结合，以将其转换为加密形式。然后使用我们很快会看到的特殊格式重新打包，并传输到目的地，目的地使用相同的算法对其进行解密。ESP还支持其自己的身份验证方案，就像在AH中使用的那样，或者可以与AH结合使用。

<u>**封装安全负载字段**</u>
ESP有几个字段与AH中使用的字段相同，但以非常不同的方式打包其字段。它不是只有一个标题，而是将其字段分为三个部分：

- ESP头：包含SPI和序列号两个字段，位于加密数据之前。其位置取决于ESP是在传输模式中使用还是在隧道模式中使用，如IPSec模式主题中所述。
- ESP尾部：此部分位于加密数据之后。它包含用于通过填充和填充长度字段对齐加密数据的填充。有趣的是，它还包含ESP的下一个报头字段。
- ESP身份验证数据：此字段包含完整性检查值(ICV)，当使用ESP的可选身份验证功能时，该值的计算方式类似于AH协议的工作方式。

这些字段被分成这样的部分有两个原因。首先，一些加密算法要求加密的数据具有一定的块大小，因此填充必须出现在数据之后，而不是出现在数据之前。这就是为什么填充会出现在ESP预告片中。第二，ESP身份验证数据单独出现，因为它用于在加密后对加密数据报的其余部分进行身份验证。这意味着它不能出现在ESP报头或ESP报尾中。

<u>**封装安全有效负载操作和现场使用**</u>

让我们通过考虑ESP执行的三个基本步骤来尝试从程序上解释这一点。

<u>**1.表头计算和放置。**</u>
首先要考虑的是ESP报头的设置方式；这类似于AH的工作方式：

- IPv6：ESP报头作为扩展报头插入到IP数据报中，遵循正常的IPv6扩展报头链接规则。在传输模式中，它显示在包含最终目的地选项的目标选项标头之前，但如果存在任何其他扩展标头，则显示在该标头之后。在隧道模式下，它显示为新IP数据报的扩展报头，该报头封装了正在隧道传输的原始IP数据报。这可以在图124中看到。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipsecespipv6.png)

​                                           **图124：使用IPSec封装安全有效负载(ESP)的IPv6数据报格式。**

顶部是具有两个扩展报头的相同示例IPv6数据报，如图121所示。当ESP应用于传输模式时，ESP报头会像在AH中一样添加到现有数据报中，并将ESP报尾和ESP身份验证数据放在末尾。在隧道模式下，ESP报头和报尾括起整个封装的IPv6数据报。请注意每种情况下的加密和身份验证覆盖范围，以及自数据报出现在ESP报尾中以来，下一个报头字段如何“指向”数据报。

- IPv4：与AH一样，ESP报头放在正常的IPv4报头之后。在传输模式下，它出现在原始IP报头之后；在隧道模式下，它出现在封装原始数据报的新数据报的IP报头之后。这如图125所示。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipsecespipv4.png)

​                                                 <u>**图125：采用IPSec封装安全有效负载(ESP)的IPv4数据报格式。**</u>

顶部是如图122所示的相同的示例IPv4数据报。当此数据报在传输模式下由ESP处理时，ESP报头被放置在IPv4报头和数据之间，ESP报尾和ESP身份验证数据紧随其后。在隧道模式下，整个原始IPv4数据报都被这些ESP组件包围，而不仅仅是IPv4数据。同样，如图124所示，请注意加密和身份验证覆盖范围，以及下一个头字段如何“指向”以指定加密数据/数据报的身份。

<u>**2.尾部计算和放置**</u>

ESP尾部被附加到要加密的数据。ESP然后执行加密。有效负载(TCP/UDP消息或封装的IP数据报)和ESP报尾都是加密的，但ESP报头不加密。再次注意，出现在ESP报头和有效负载之间的任何其他IP报头也是加密的。在IPv6中，这可以包括目的地选项扩展报头。

正常情况下，下一个报头字段将出现在ESP报头中，并用于将ESP报头链接到其后面的报头。然而，ESP中的下一个标题字段出现在尾部而不是标题中，这使得ESP中的链接看起来有点奇怪。该方法通常与AH和IPv6中使用的方法相同，使用下一个报头和/或协议字段将所有内容捆绑在一起。但是，在ESP中，下一个报头字段出现在加密数据之后，因此将指向以下内容之一：目的地选项扩展报头(如果存在)、TCP/UDP报头(在传输模式中)或IPv4/IPv6报头(在隧道模式中)。图124和图125也显示了这一点。

<u>**3.ESP身份验证字段计算和放置**</u>
如果使用可选的ESP身份验证功能，则在整个ESP数据报上计算身份验证字段(当然，身份验证数据字段本身除外)。这包括ESP报头、有效载荷和报尾。

**关键概念：**IPSec封装安全有效负载协议允许对数据报的内容进行加密，以确保只有预期的接收者能够看到数据。它使用三个组件实现：添加到受保护数据报前面的ESP报头、跟随受保护数据的ESP报尾、以及可选的ESP身份验证数据字段，该字段提供与身份验证报头(AH)提供的身份验证服务类似的身份验证服务。

<u>**封装安全负载格式**</u>

ESP部分和字段的格式如表80所示，如图126所示。我在每个代码中都显式地展示了字段的加密和身份验证覆盖范围，这有望使我刚才编写的所有内容至少更有意义。

​                                                          <u>**表80：IPSec封装安全有效负载(ESP)格式**</u>

| **Section**                 | **Field Name**      | **Size (bytes)**                                                                | **Description**                                                                                         | **Encryption Coverage**                                                  | **Authentication Coverage**                                           |
| --------------------------- | ------------------- | ------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------ | --------------------------------------------------------------------- |
| **ESP Header**              | ***SPI\***          | 4                                                                               | **Security Parameter Index (SPI):** 安全参数索引（SPI）：一个32位值，与目标地址和安全协议类型相结合，以标识用于此数据报的安全关联。有关详细信息，请参阅安全关联主题。 |                                                                          | ![img](http://www.tcpipguide.com/free/diagrams/ipsecespauthrange.png) |
| ***Sequence Number\***      | 4                   | **Sequence Number:**序列号：当两个设备之间形成安全关联时，计数器字段初始化为零，然后针对使用该SA发送的每个数据报递增。这用于防止重播攻击 |                                                                                                         |                                                                          |                                                                       |
| **Payload**                 | ***Payload Data\*** | Variable                                                                        | **Payload Data:** 有效载荷数据：加密的有效载荷数据，由更高层消息或封装的IP数据报组成。还可能包括某些加密方法所需的支持信息，例如初始化向量。                        | ![img](http://www.tcpipguide.com/free/diagrams/ipsecespencryptrange.png) |                                                                       |
| **ESP Trailer**             | ***Padding\***      | Variable (0 to 255)                                                             | **Padding:** 填充：加密或对齐所需的附加填充字节。                                                                         |                                                                          |                                                                       |
| ***Pad Length\***           | 1                   | **Pad Length:** 填充长度：前一个填充字段中的字节数。                                              |                                                                                                         |                                                                          |                                                                       |
| ***Next Header\***          | 1                   | **Next Header:** 包含数据报中下一个Header的协议号。用于将收割台连接在一起。                               |                                                                                                         |                                                                          |                                                                       |
| **ESP Authentication Data** | Variable            | **ESP Authentication Data:**ESP验证数据：此字段包含应用可选ESP验证算法产生的完整性检查值（ICV）。             |                                                                                                         |                                                                          |                                                                       |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ipsecespformat.png)

​                                                       **图126:IPSec封装安全有效载荷（ESP）格式**

 请注意，此格式中的大多数字段和部分都是可变长度的。例外的是SPI和序列号字段，长度为4个字节，以及填充长度和下一个报头字段，每个字节长1个字节。

填充字段在加密算法需要时使用。填充也用于确保ESP拖车在32位边界上结束。也就是说，ESP标题加有效载荷加ESP尾部的大小必须是32位的倍数。ESP身份验证数据也必须是32位的倍数。

###### 3.1.5.8 IPSec密钥交换(IKE)(第1部分：第2部分)

与许多安全网络协议集一样，IPSec基于“共享秘密”的概念。两个想要发送信息的设备使用只有他们知道的一段信息对其进行安全编码和解码。任何不了解该秘密的人都能够截取该信息，但被阻止读取该信息(如果使用ESP来加密有效负载)或在未被检测到的情况下篡改该信息(如果使用AH)。然而，在使用AH或ESP之前，这两个设备有必要交换安全协议本身将使用的“秘密”。IPSec中用于此目的的主要支持协议称为Internet**密钥交换(IKE)**。

IKE是在RFC 2409中定义的，是IPSec协议中理解起来比较复杂的协议之一。事实上，如果没有重要的密码学背景，就不可能真正理解它的操作的真正简化。我没有密码学的背景，我必须假设你，我的读者，也没有。因此，我不会用令人费解的缩略语和未解释的概念来填充这个主题，我只会简要介绍一下IKE及其使用方法。

<u>**IKE概述及其与其他密钥交换方法的关系**</u>
IKE的目的是允许设备交换安全通信所需的信息。正如标题所示，这包括用于编码身份验证信息和执行有效负载加密的加密密钥。IKE的工作方式是允许支持IPSec的设备交换安全关联(SA)，以填充其安全关联数据库(SAD)。然后，这些协议用于与AH和ESP协议进行安全数据报的实际交换。

IKE被认为是一种“混合”协议，因为它结合(和补充)了其他三种协议的功能。第一个是互联网安全协会和密钥管理协议(ISAKMP)。该协议提供了用于交换加密密钥和安全关联信息的框架。它的运作方式是允许通过一系列阶段协商安全关联。

ISAKMP是支持多种不同密钥交换方法的通用协议。在IKE中，ISAKMP框架用作特定密钥交换方法的基础，该方法结合了两个密钥交换协议的功能：

- Oakley：描述了通过定义各种密钥交换“模式”来交换密钥的具体机制。大部分IKE密钥交换过程都是基于Oakley的。
- Skeme：描述与Oakley不同的密钥交换机制。IKE使用了SKEME的一些功能，包括其公钥加密方法和快速密钥更新功能。

<u>**IKE操作**</u>

因此，IKE并没有严格地实现Oakley或SKEME，而是从每种实现中提取一小部分来形成自己的使用ISAKMP的方法。干净得像泥一样，我知道。由于IKE在ISAKMP框架内运作，其运作基于ISAKMP分阶段协商过程。有两个阶段：

- ISAKMP阶段1：第一阶段是“设置”阶段，两个设备就如何安全地交换进一步的信息达成一致。这两个单元之间的协商为ISAKMP本身创建了一个安全关联；一个ISAKMP SA。然后，此安全关联用于在阶段2中安全地交换更详细的信息。
- ISAKMP阶段2：在此阶段中，在阶段1中建立的ISAKMP SA用于为其他安全协议创建SA。通常，这是协商用于AH和ESP协议的“真实”SA的参数的地方。

一个明显的问题是，为什么IKE要纠结于这种分两个阶段的方法；为什么不首先就AH或ESP的安全关联进行协商？嗯，即使额外的阶段增加了开销，在一个阶段1之后可以进行多个阶段2的谈判，这摊销了两阶段方法的额外“成本”。一旦在阶段1中建立了ISAKMP安全关联，也可以对阶段2使用更简单的交换方法。

在阶段1期间协商的ISAKMP安全关联包括用于后续协商的以下属性的协商：

- 要使用的加密算法，如数据加密标准(DES)。
- 散列算法(由AH或ESP使用的MD5或SHA)。
- 一种身份验证方法，例如使用以前共享的密钥进行身份验证。

Diffie-Hellman组合。迪菲和赫尔曼是该行业的两位先驱，他们发明了公钥密码术。在该方法中，不使用相同的密钥进行加密和解密，而是使用任何人都知道的公钥对数据进行加密，并使用保密的私钥进行解密。Diffie-Hellman组定义如何执行这种类型的密码术的属性。在IKE中指定了从Oakley派生的四个预定义组，并且还允许提供用于定义新组的设置。
请注意，即使安全关联通常是单向的，ISAKMP SA也是双向建立的。一旦阶段1完成，则任一设备都可以使用它为AH或ESP设置后续SA。

##### 3.1.6 互联网协议移动性支持（移动IP）

互联网协议(IP)因其许多优点而成为计算领域最成功的网络层协议，但它也有一些弱点，其中大多数弱点随着网络的发展而变得更加重要。无类寻址和网络地址转换等技术可解决IPv4地址空间耗尽的问题，而IPSec则为其提供其所缺乏的安全通信。IP的另一个弱点是，它的设计没有考虑到移动计算机。

虽然移动设备肯定可以使用IP，但当设备从一个网络移动到另一个网络时，设备的寻址和数据报的路由方式会带来问题。在开发IP的时候，计算机很大，很少移动。今天，我们有数百万台笔记本电脑和更小的设备，其中一些甚至使用无线网络连接到有线网络。为这些移动设备提供完整的IP功能的重要性已显著增加。为了在移动环境中支持IP，开发了一种新的协议，称为IP移动性支持，或更简单地，移动IP。

在本部分中，我将介绍为克服移动计算机连接到IP网际网络而出现的问题而开发的特殊协议。我首先对移动IP进行概述，并对其创建原因进行更详细的描述。我将讨论定义移动IP及其一般操作模式的重要概念。然后，我将详细介绍移动IP的工作原理。这包括对特殊移动IP寻址方案的描述，对移动设备如何发现代理的解释，向设备的归属代理注册的过程，以及如何封装和路由数据。我将讨论移动IP对TCP/IP地址解析协议(ARP)运行的影响。在这一节的最后，我将研究一些在使用移动IP时起作用的效率和安全问题。

注：本节具体介绍如何为IPv4网络提供IP移动性支持。在未来，我可能会添加更多关于如何在IPv6中实现移动性的具体细节。
**背景信息**：如果您不熟悉IP寻址和路由的基础知识，我强烈建议您在尝试阅读有关移动IP的内容之前，至少浏览一下这些部分。

###### 3.1.6.1 移动IP概述、历史和动机(第1部分：2 3 4)

在过去的几年里，移动计算的普及程度大大提高，这在很大程度上要归功于小型化的进步。今天，我们可以在笔记本电脑，甚至是手持电脑中获得曾经需要一台庞然大物的机器所需的能力。我们还拥有无线局域网技术，可以轻松地让设备从一个地方移动到另一个地方，并在数据链路层保持网络连接。不幸的是，互联网协议是在庞然大物时代开发的，并不是为了优雅地处理四处移动的计算机而设计的。为了理解为什么IP在移动环境中不能很好地工作，我们必须回顾一下IP寻址和路由是如何工作的。

<u>**移动节点在TCP/IP协议中的问题**</u>
如果您读过本指南中有关IP寻址的任何材料--我当然希望您读过--您就会知道IP地址基本上分为两部分：网络标识符(网络ID)和主机标识符(主机ID)。网络ID指定主机位于哪个网络上，主机ID唯一指定网络内的主机。这种结构是数据报路由的基础，因为设备使用数据报目的地址的网络ID部分来确定接收方是在本地网络上还是在远程网络上，而路由器则使用它来确定如何路由数据报。

这是一个很棒的系统，但它有一个严重的缺陷：IP地址与设备所在的网络紧密绑定。大多数设备从不(或至少很少)更改其到网络的连接点，因此这不是问题，但对于移动设备来说肯定是一个问题。当移动设备离开其原籍位置时，基于IP地址的路由系统就会“崩溃”。这一点如图127所示。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\mobileipproblem.png)

​                                                                    **图127：IP互联网上移动设备的主要问题。**

在本例中，移动设备(笔记本电脑)已从其位于伦敦的家庭网络移至位于东京的另一个网络。远程客户端(左上角)决定向移动设备发送数据报。然而，它并不知道设备已经移动了。因为它使用移动节点的家乡地址71.13.204.20发送，所以它的请求被路由到负责该网络的路由器，该路由器位于伦敦。当然，移动设备不在那里，所以路由器无法传递它。移动IP使移动设备和路由器能够将数据报从一个位置转发到另一个位置，从而解决了这一问题。

<u>**旧版移动节点解决方案的困难**</u>

网络标识符和主机IP地址的紧密绑定意味着，当移动设备从一个网络移动到另一个网络时，在传统IP下只有两个真正的选择：

- 更改IP地址：我们可以将主机的IP地址更改为新地址，该地址包括主机要移动到的网络的网络ID。
- 将IP路由与地址分离：我们可以更改为设备进行路由的方式，以便路由器不再根据其网络ID向其发送数据报，而是基于其整个地址进行路由。

乍一看，这两种选择似乎都是可行的，如果只有几台设备尝试一下，它们可能会奏效。不幸的是，它们都效率低下，往往不切实际，而且都不是可扩展的，也就是说，当数千或数百万台设备尝试它们时，它们都不实用：

- 每次移动设备时更改IP地址都很耗时，通常需要手动干预。此外，整个TCP/IP堆栈将需要重新启动，从而中断所有现有连接。
- 如果我们更改移动设备的IP地址，我们如何将地址更改传达给互联网上的其他设备？这些设备将只有移动节点的原始家乡地址，这意味着即使我们给它一个与其新位置匹配的新地址，它们也无法找到它。
- 基于主机整个地址的路由将意味着整个互联网将充斥着每台移动计算机的路由信息。考虑到开发无类寻址等技术以减少路由表条目所遇到的困难，很明显，这是一个没有人愿意碰的潘多拉盒子。

**关键概念**：在IP网际网络中支持移动设备的基本问题是使用IP地址执行路由，这意味着设备的IP地址与该设备所在的网络绑定。如果设备改变网络，则发送到其旧地址的数据不能通过传统方式传送。传统的解决办法，如按完整IP地址进行路由或手动更改IP地址，通常会产生更多问题。

<u>**更好的解决方案：移动IP**</u>

这些困难的解决方案是定义一个新的协议，特别是支持移动设备，它增加了原来的互联网协议。该协议称为对IPv4的IP移动性支持，在RFC 2002中首次定义，在RFC 3220中更新，现在在RFC 3344中进行描述。该文档标题中给出的正式名称相当长；在RFC本身和联网人员中，该技术通常被称为移动IP。

为了确保它的成功，移动IP的设计者必须满足一些重要的目标。由此产生的协议具有以下关键属性和功能：

- 使用现有设备地址的无缝设备移动性：移动设备可以更改其物理网络连接方法和位置，同时继续使用其现有IP地址。
- 没有新的寻址或路由要求：保持常规IP中的寻址和路由的整体方案。IP地址仍然由每个设备的所有者以传统方式分配。网际网络不会有新的路由要求，例如特定于主机的路由。
- 互操作性：移动IP设备仍然可以向不知道移动IP如何工作的现有IP设备发送和接收，反之亦然。
- 层透明：移动IP所做的更改仅限于网络层。传输层和更高层的协议和应用程序能够像在常规IPv4中一样工作，甚至可以在移动过程中保持现有连接。
- 有限的硬件更改：需要更改移动设备中的软件以及移动设备直接使用的路由器。然而，其他设备不需要更改，包括归属网络和访问网络上的路由器之间的路由器。
- 可扩展性：移动IP允许设备从任何网络切换到任何其他网络，并支持任意数量的设备。连接变化的范围可以是全球的；例如，你可以将一台笔记本电脑从伦敦的办公室分离出来，然后将其转移到澳大利亚或巴西，它的工作原理就像你把它带到隔壁的办公室一样。
- 安全性：移动IP通过重定向消息来工作，并包括身份验证程序，以防止未经授权的设备造成问题。

移动IP通过为移动设备实现转发系统来实现这些目标。当一个移动单元在它的“家庭”网络上时，它的功能正常。当它移动到不同的网络时，数据报从它的家庭网络发送到它的新位置。这允许不知道移动IP的普通主机和路由器继续运行，就像移动设备没有移动一样。实施移动IP需要特殊的支持服务，以允许诸如让移动设备确定其位置、告诉归属网络将消息转发到哪里等活动。我将在下一个主题中更多地探讨移动IP操作，并在本节的其余部分介绍实现细节。

**关键概念**：移动IP通过建立一个系统来解决与改变网络位置的设备相关的问题，在该系统中，发送到移动节点归属位置的数据报被转发到移动节点所在的任何位置。它对无线设备特别有用，但也可用于定期在网络之间移动的任何设备。

移动IP通常与无线网络联系在一起，因为使用WLAN技术的设备可以如此轻松地从一个网络移动到另一个网络。然而，它并不是专门为无线设计的。在从一栋建筑的以太网络迁移到另一栋建筑、城市或国家/地区的网络时，它也同样有用。移动IP可在许多应用中发挥巨大作用，包括出差销售人员、访问客户端站点的顾问、在园区内走动排除问题的管理员等等。

<u>**移动IP的局限性**</u>

重要的是要认识到，移动IP在无线环境中的可用性有一定的局限性。它旨在处理设备的移动性，但仅限于相对不频繁的移动性。这是由于每次更改所涉及的工作。当你一周、一天、甚至一个小时移动一台电脑时，这些开销并不是什么大问题。这可能是诸如在无线网络中漫游之类的“实时”移动性的问题，其中在数据链路层操作的越区切换功能可能更合适。移动IP是在附着点每秒不会更改一次的特定假设下设计的。

我还应该指出，移动IP旨在与维护静态IP配置的设备一起使用。由于设备需要能够始终知道其家庭网络的身份和正常的IP地址，因此在使用类似于DHCP的动态获取IP地址的设备中使用它要困难得多。

###### 3.1.6.2 移动IP概念和一般操作(第1、2、3部分)

我喜欢类比，因为它们提供了一种用我们都能理解的术语来解释经常枯燥的技术概念的方法。IP网际网络中的移动设备问题很容易被比作现实生活中的移动性和信息传输问题：旅行者的邮件递送问题。为了帮助解释移动IP的工作原理，我将建立这个类比，并将其用作了解移动IP的一般操作的基础。在解释本节其余主题中的某些概念时，我还将参考它。

<u>**移动IP概述：互联网的“地址转发”**</u>
假设你是一名顾问，在一家拥有多个办公室的大公司工作。你的家庭办公室在英国伦敦，你在那里花了大约一半的时间。剩下的时间被分配给其他办公室，比如罗马、东京、纽约市和多伦多。您还可以偶尔访问世界上几乎任何地方的客户站点。你可能会一次在这些偏远的地方呆上几个星期。

问题是：你如何安排事情，让你可以接收你的邮件，而不管你在哪里？你面临着与普通IP相同的移动设备问题，而且如果不采取特殊步骤，同样有两个不令人满意的解决方案：更改地址或将路由与您的地址分离。你不能每次搬家都改变你的地址，因为你会不断地修改它；当你告诉每个人你的新地址时，它还会再次改变。而且，除非您想要建立自己的邮政系统，否则您肯定不能将邮件的路由与您的地址“分离”！

当然，解决这一困境的办法是邮件转发。假设你离开伦敦去东京几个月。你告诉伦敦邮局(PO)，你将在东京。他们拦截发往你正常伦敦地址的邮件，重新贴上标签，然后转发到东京。根据您住在哪里，这封邮件可能会被直接重定向到东京的新地址，也可能会被重定向到您可以取走它的东京邮政信箱。如果你离开东京去另一个城市，你只要打电话给伦敦邮政总局，告诉他们你的新位置。当你回家时，你取消了转发，像往常一样拿到了你的邮件。(是的，我想伦敦和东京各只有一家邮局。你的意思是他们不会？是啊，管他呢。j)。

这个系统的优点有很多。它的理解和实现相对简单。它对每个给你发送邮件的人来说也是透明的；他们仍然在伦敦给你发送邮件，它可以到达需要到达的任何地方。而转寄机制的处理只由伦敦邮政总局完成，可能还有你目前所在的邮政总局；邮政系统的其余部分甚至不知道发生了任何不寻常的事情。

当然，这也有一些不利因素。伦敦邮政总局可能会允许偶尔免费转发，但如果您定期这样做，可能会收费。在你要去的城市，你可能还需要一个特别的安排。你每次搬家都要和家里的PO保持联系。也许最重要的是，每一封邮件都必须通过该系统发送两次--第一次到达伦敦，然后到达你所在的任何地方--这是效率低下的。

移动IP的工作方式与我刚才描述的邮件转发系统非常相似。“旅行顾问”是从一个网络到另一个网络的设备。每个网络都可以被认为是一个不同的“城市”，而路由器的网际网络就像邮政系统。从IP的角度来看，将任何网络连接到Internet的路由器就像是该网络的“邮局”。

移动节点通常驻留在其归属网络上，该归属网络由其IP地址中的网络ID指示。网际网络上的设备总是使用这个地址进行路由，因此，“邮件”(数据报)片段总是到达设备“家”的路由器。当设备“传输”到另一个网络时，家庭路由器(“邮局”)拦截这些数据报并将它们转发到设备的当前地址。它可以使用新的临时地址将它们直接发送到设备，也可以将它们发送到设备当前网络(我们比喻为东京)上的路由器，以进行最终递送。图128中可以看到移动IP操作的概述。

移动节点通常驻留在其归属网络上，该归属网络由其IP地址中的网络ID指示。网际网络上的设备总是使用这个地址进行路由，因此，“邮件”(数据报)片段总是到达设备“家”的路由器。当设备“传输”到另一个网络时，家庭路由器(“邮局”)拦截这些数据报并将它们转发到设备的当前地址。它可以使用新的临时地址将它们直接发送到设备，也可以将它们发送到设备当前网络(我们比喻为东京)上的路由器，以进行最终递送。图128中可以看到移动IP操作的概述。 

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\mobileipoperation.png)

​                                                                            <u>**图128：移动IP协议的一般操作**</u>

此图类似于图127，但实施了移动IP。移动节点的归属路由器充当归属代理，东京的路由器充当外地代理。移动站已经被分配了在东京期间使用的临时转交地址(在这种情况下，该地址是共同定位的转交地址，这意味着它被直接分配给移动节点；图129示出了使用另一类型的转交地址的相同示例)。在步骤#1中，远程客户端使用其归属地址向移动设备发送数据报，如前所述。它像往常一样到达伦敦。在步骤#2中，归属代理将该数据报封装在新的数据报中，并将其发送到东京的移动节点。

<u>**移动IP设备角色**</u>

正如您所看到的，正如邮件转发需要一个或多个邮局的支持一样，移动IP需要两个路由器的帮助。事实上，实现该协议的三个主要参与者都有特殊的名称(如图128所示)：

- 移动节点：这是移动设备，在网际网络中移动的设备。
- home 代理：这是家乡网络上的一个路由器，负责捕获发往移动节点的数据报，并在移动节点移动时将其转发给它。它还实现了运行该协议所需的其他支持功能。
- 外地代理：这是移动节点当前连接到的网络上的路由器。它充当移动节点的“家外之家”，通常充当其默认路由器以及实现移动IP功能。根据操作模式，它可以从归属代理接收转发的数据报，并将它们转发到移动节点。它还支持移动信息的共享，使移动IP能够运行。外地代理在某些移动IP实施中可能不是必需的，但通常被认为是协议运行方式的一部分。

**关键概念：**移动IP通过设置相当于邮件转发系统的TCP/IP来运行。移动节点的归属网络上的路由器充当移动设备的归属代理，而其当前网络上的路由器充当外地代理。归属代理接收去往移动节点的正常IP地址的数据报，并将它们直接或通过发送到外地代理转发到移动节点的当前位置。归属代理和外地代理还负责移动IP工作所需的各种通信和设置活动。

<u>**移动IP功能**</u>

移动IP和我们的邮件转发示例之间的一个重要区别是，它代表了人和计算机之间的经典区别：人是智能的，而计算机不是。当我们的顾问在东京旅行时，他总是知道他在东京，他的邮件正在被转发。(好吧，假设他对清酒宽容，但那是另一回事。他知道要去东京邮局取邮件。伦敦的邮局知道什么是邮寄，也知道怎么做。旅行者和邮局都可以很容易地使用电话进行交流。

相比之下，在计算机世界，当一台设备使用移动IP进行旅行时，事情就更复杂了。假设我们的顾问飞到东京，打开笔记本电脑，把它连接到网络上。当笔记本第一次打开时，它不知道发生了什么。它必须弄清楚自己是在东京。它需要在东京找到一家外国代理商。它需要知道在东京时应该使用什么地址。它需要与其在伦敦的家乡代理通信，以告知它在东京，并开始转发数据报。此外，它还必须在没有任何“电话”的情况下完成通信。

为此，移动IP包括许多用于设置和管理数据报转发的特殊功能。要了解这些支持功能是如何工作的，我们可以将移动IP的一般操作描述为一系列简化的步骤：

1. 代理通信：移动节点通过参与代理发现过程在其本地网络上找到代理。它监听代理发出的代理通告消息，并从中确定它的位置。如果它没有听到这些消息，它可以使用代理请求消息请求一个消息。
2. 网络位置确定：移动节点通过查看代理通告消息中的信息来确定它是在自己的本地网络上还是在外地网络上。
   如果它在其家庭网络上，则使用常规IP运行。为了说明该过程的其余部分是如何工作的，让我们假设该设备发现它刚刚移动到了一个外国网络。其余步骤为：
3. 转交地址获取：设备获取称为转交地址的临时地址。这或者来自外部代理的代理通告消息，或者通过某些其他方式。此地址仅用作转发数据报的目的地点，不作其他用途。
4. 代理注册：移动节点将其在外地网络上的存在通知其归属网络上的归属代理，并通过向归属代理注册来启用数据报转发。这可以在节点和归属代理之间直接完成，或者间接使用外地代理作为管道来完成。
5. 数据报转发：归属代理捕获发往移动节点的数据报并转发它们。根据所使用的转交地址的类型，它可以将它们直接或间接地发送到外地代理以进行递送。

数据报转发将继续，直到当前代理注册到期。然后，设备可以续订它。如果它再次移动，则它重复该过程以获得新的转交地址，然后向归属代理注册其新位置。当移动节点返回其归属网络时，其取消注册以取消数据报转发并恢复正常的IP操作。

以下主题更详细地介绍了上述每个步骤中总结的函数。

###### 3.1.6.3 移动IP寻址：归属地址和转交地址(第1部分：第2部分)

正如我们大多数人只有一个地址用于邮件一样，大多数IP设备也只有一个地址。然而，我们的旅行顾问需要有两个地址；一个正常的地址和一个在他不在的时候使用的地址。继续我们前面的类比，我们的顾问携带的配备移动IP的笔记本电脑也需要有两个地址：

- 归属地址：分配给移动节点的“正常”、永久IP地址。这是设备在其归属网络上使用的地址，也是发往移动节点的数据报始终发送到的地址。
- 转交地址：移动节点在离开家乡网络时使用的次要临时地址。在大多数方面，它是一个普通的32位IP地址，但仅由移动IP用于转发IP数据报和管理功能。更高层从不使用它，普通IP设备在创建数据报时也不使用它。

<u>**移动IP维护地址类型**</u>
转交地址是一个略显棘手的概念。存在两种不同的类型，它们对应于从归属代理路由器转发数据报的两种截然不同的方法。

<u>**外国代理转交地址**</u>
这是外地代理在其代理通告消息中提供的转交地址。实际上，它是外地代理本身的IP地址。当使用这种类型的转交地址时，由归属代理捕获的所有数据报不直接转发到移动节点，而是间接转发到负责最终传递的外地代理。由于在这种布置中，移动节点在外地网络上没有有效的不同IP地址，这通常是使用第二层技术来完成的。这种安排如图129所示。

在我们的顾问类比中，这种转交地址就像是从伦敦邮局转发到东京邮局。伦敦的工作人员会为约翰·史密斯拿一封信，寄到他在伦敦的地址，然后重新打包，送到“约翰·史密斯，东京邮局的转交”。东京邮局(或约翰·史密斯本人)将需要担心递送的最后一段时间。

<u>**同一地点的转交地址**</u>
这是使用移动IP外部的某些手段直接分配给移动节点的转交地址。例如，它可以在外部网络上手动分配，也可以使用DHCP自动分配。在这种情况下，转交地址用于将业务从归属代理直接转发到移动节点。这是图128所示的地址类型。

在我们的顾问类比中，这就像约翰·史密斯在东京期间获得了一个临时地址。伦敦邮局将直接将邮件转发到他在东京的地址。他们不会专门把它寄到东京邮局(当然，PO会在某个时候处理邮件)。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\mobileipforeignaddress.png)

​                                                              <u>**图129：使用外地代理转交地址的移动IP操作**</u>

该图类似于图128，不同之处在于，移动节点使用外地代理转交地址，而不是如该示例中那样具有共同定位(不同)的IP地址。这意味着该节点的转交地址实际上是外地代理本身的转交地址。步骤#1与图128中相同，但在步骤#2中，归属代理不直接转发到移动节点，而是转发到外地代理(因为该路由器是移动设备正在使用其IP地址的路由器)。在步骤#3中，外地代理解开归属代理的包装，并将原始数据报传递给移动节点。这通常使用将移动节点和外地代理连接在一起的任何第二层(局域网或无线局域网)技术来完成。

**关键概念：**在移动IP中，每个移动设备在外地网络上使用一个临时的转交地址。共同定位的转交地址是直接分配给移动节点的地址，并且能够将数据报直接递送到该节点。另一种方法是使用外地代理转交地址。在这种情况下，移动节点实际上使用外地代理的IP地址；数据报被发送到外地代理，由外地代理将其传递给移动节点。

<u>**转交地址类型的优缺点**</u>

外地代理转交地址被认为是典型的移动IP中使用的类型，其中既有归属代理又有外地代理。虽然它的效率似乎不如主机代管地址方法，但它提供了一些重要的优势。一个关键问题是相同的外地代理转交地址可以用于访问该网络的所有移动节点。该网络上所有移动节点的数据报被发送到外地代理，该外地代理完成到各个节点的传送。由于移动节点使用外地代理的地址，因此每个移动节点不需要额外的地址或额外的工作。

共同定位的转交地址具有可以将业务直接从归属代理转发到移动节点的优点。在这种类型的配置中，移动IP设备有可能行进到没有支持移动IP的路由器充当外地代理的外地网络。然而，这确实意味着移动IP实现必须包括外地代理通常执行的与归属代理通信的所有功能。

当使用同一位置的转交地址时，一个问题是如何获得临时地址。在许多外部网络中，使用类似于DHCP的方式自动分配IP地址可能是可能的，但如果不能，则需要分配临时IP地址。无论采用哪种方式，都需要为移动节点预留一些外地网络有限的IP地址空间，每个移动节点都将在网络上使用一个地址。在某些情况下，这可能会导致地址耗尽问题。

当外地代理出现在受访网络上时，由于其更自动的性质，通常优选外地代理转交寻址。考虑到所有数据报无论如何都需要通过外地网络上的某个路由器才能到达移动节点，我们不妨节省额外的IP地址。当没有外地代理时，将使用同一位置的转交地址，或者即使在存在外地代理的情况下，对于长期连接也可能是可行的。

请记住，转交地址仅代表移动节点数据报转发到的目的地。外地代理提供转发以外的服务，因此即使存在外地代理，移动节点也可以使用同一位置的转交地址，同时继续利用其他外地代理服务。

**关键概念：**在移动IP中，同一位置的转交地址具有灵活性的优势，但要求每台设备在远程网络上具有唯一的IP地址。外地代理转交地址的主要优势是允许在外地网络上使用许多移动设备，而每个设备都不需要不同的IP地址。

有关如何在家乡代理和移动节点的转交地址之间转发数据报的详细信息，请参见有关移动IP封装和隧道的主题。

###### 3.1.6.4 移动IP代理发现、代理通告和请求消息(第1部分：1 2 3 4 5)

当移动节点第一次打开时，它不能像正常的IP设备那样认为它仍然是在家中。它必须首先确定它在哪里，如果它不在家乡，则开始从其家乡网络建立数据报转发的过程。此过程通过称为代理发现的过程与充当代理的本地路由器通信来完成。

<u>**代理发现过程**</u>
代理发现包括我在一般操作主题中给出的简化的五步移动IP操作总结中的前三个步骤。代理发现的主要目标包括：

- 代理/节点通信：代理发现是移动节点首先与其所连接的本地网络上的代理建立联系的方法。消息从代理发送到节点，其中包含有关代理的重要信息；也可以从节点向代理发送请求发送此信息的消息。
- 定位：节点使用代理发现过程来确定它所在的位置。具体地说，它通过识别向其发送消息的代理来了解它是在自己的本地网络上还是在外地网络上。
- 转交地址分配：当使用外地代理转交寻址时，代理发现过程是用于告诉移动节点它应该使用的转交地址的方法。

移动IP代理是一种路由器，它被赋予了额外的编程，使它们能够“感知移动IP”。移动节点与其本地网络上的代理之间的通信与IP网络上的设备与其本地路由器之间所需的正常通信基本相同，只是当路由器是代理时需要发送更多信息。

<u>**代理通告和代理邀请消息**</u>

已经存在用于在路由器和节点之间以用于常规IP路由器发现过程的ICMP消息的形式交换数据的规定。有两个消息用于此目的：路由器通告消息和路由器请求消息，路由器通告消息让路由器告诉本地节点它们存在并描述其功能，路由器请求消息让节点提示路由器发送通告。这些将在ICMP一节中各自的主题中进行说明。

考虑到与普通路由器发现的相似之处，将代理发现作为对现有过程的修改而不是建立一个全新的系统是有意义的。代理发现过程中使用的消息包括：

- 代理通告：这是由充当移动IP代理的路由器定期发送的消息。它由添加了一个或多个扩展的常规路由器通告消息组成，这些扩展包含移动节点的特定于移动IP的信息。
- 代理请求：此消息可由移动IP设备发送，以推动本地代理发送代理通告。

这些消息的使用在移动IP标准中进行了详细描述，并且毫不奇怪，它与使用常规路由器通告和路由器请求消息的方式非常相似。代理通常被配置为定期发送代理通告，其速率设置为确保在不消耗过多网络带宽的情况下相当快速地与移动节点联系。他们被要求通过发送通告来回复他们收到的任何代理请求消息。可能会将某些代理配置为仅在收到邀请函时发送通告。

移动节点需要接受和处理代理通告。他们通过查看消息的大小将这些通告与常规路由器通告区分开来。然后，他们解析扩展以了解本地代理的功能。它们确定它们是在自己的本地网络上还是在外地网络上，如果是外地代理，则确定应该如何使用该代理。移动节点需要使用代理通告来检测它们何时移动，并使用标准中定义的两种算法之一来检测它们在移动后何时返回到其归属网络。如果他们在一段时间后没有收到代理通告，他们还必须能够发送代理请求消息。然而，他们被限制为仅偶尔发送这些消息，以保持流量可管理。

现在，让我们来看看这两种消息类型的格式。

<u>**代理征集消息格式**</u>

让我们从代理请求消息开始，因为它要简单得多。事实上，根本没有为此定义新的消息格式；它与路由器请求消息的格式相同。

这里不需要新的消息类型的原因是，请求是一条非常简单的消息：“嘿，如果有路由器，请告诉我你是谁，你能做什么”。无需发送额外的移动IP信息。当常规IP路由器收到路由器请求时，它将发送路由器通告，但移动IP路由器会在任何请求提示时自动发送较长的代理通告，无论它来自移动IP节点还是常规IP设备。

<u>**代理广告消息格式**</u>
代理通告以ICMP路由器通告消息的普通字段开始。如果本地网络支持多播，则消息的目的地是“所有设备”的多播地址(224.0.0.1)，否则是广播地址(255.255.255.255)。路由器地址字段使用代理的地址填充。

**注意：**设备可能希望宣传其处理移动IP消息的能力，但不能充当常规路由器。在这种情况下，它将路由器通告消息报头中的Normal Code字段从0更改为16。

在常规字段之后，向消息格式添加一个或多个扩展名。定义了三个扩展：移动代理通告扩展、前缀长度扩展和单字节填充扩展。

<u>**移动代理通告扩展**</u>

这是用于将代理的移动IP功能传送到本地网络上的移动节点的主要扩展。它包含许多字段，用作移动IP整体部分中描述的各种流程的一部分。

移动代理通告扩展的结构如表81所示，如图130所示。

​                                                                      **表81：移动IP移动代理通告扩展格式**

| **Field Name**               | **Size (bytes)**         | **Description**                                                                                                      |
| ---------------------------- | ------------------------ | -------------------------------------------------------------------------------------------------------------------- |
| ***Type\***                  | 1                        | ***Extension Type:\*** 扩展类型：标识代理播发扩展类型。对于移动性代理广告扩展，它设置为16。                                                           |
| ***Length\***                | 1                        | ***Length:\*** 长度：以字节为单位的扩展名长度，不包括类型和长度字段。因此，对于消息中的每个转交地址，它等于6加4。                                                    |
| ***Sequence Number\***       | 2                        | ***Sequence Number:\*** 序号：路由器初始化时设置为零的一个顺序计数器，然后针对每个发送的广告递增。                                                        |
| ***Registration Lifetime\*** | 2                        | ***Registration Lifetime:\*** 注册生存期：代理愿意接受注册请求的最长时间(以秒为单位)。值65,535(全一)表示“无穷大”。请注意，此字段仅用于注册，与消息的常规路由器通告部分中的常规生存期字段无关。 |
| ***Flags\***                 | 1                        | ![img](http://www.tcpipguide.com/free/aa36c34d.png)                                                                  |
| ***Reserved\***              | 1                        | ***Reserved:\*** 保留：以零发送，收件人忽略。                                                                                      |
| ***Care-Of Addresses\***     | Variable (4 per address) | ***Care-Of Addresses:\*** 转交地址：由外部代理为移动节点提供的零个或多个地址用作外部代理转交地址。外国代理人必须始终在其广告中提供至少一个地址；不能充当外部代理的路由器通常会省略该字段。           |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\mobileipagentadvertisement.png)

​                                                        <u>**图130：移动IP移动代理通告扩展格式**</u>

此扩展显示在路由器通告消息的普通字段之后，如图148所示。

**相关信息：**有关最小和GRE封装以及反向隧道的详细信息，请参阅有关移动IP封装的主题。

<u>**前缀长度扩展**</u>

这是一个可选扩展，它告诉移动节点代理通告消息的常规部分中包含的路由器地址的前缀长度；即，消息的常规路由器通告部分中的路由器地址字段。前缀长度是IP地址中的位数的另一个术语，即网络ID，因此这会告诉节点每个路由器地址中的网络ID。

前缀长度扩展的格式如表82和图131所示。

​                                                         <u>**表82：移动IP前缀长度扩展格式**</u>

| **Field Name**        | **Size (bytes)**        | **Description**                                                        |
| --------------------- | ----------------------- | ---------------------------------------------------------------------- |
| ***Type\***           | 1                       | ***Extension Type:\*** 扩展类型：标识代理播发扩展类型。对于前缀长度扩展，它设置为19。                |
| ***Length\***         | 1                       | ***Length:\*** 长度：以字节为单位的扩展名长度，不包括类型和长度字段。因此，它等于前缀长度的数量（因为每个长度占用1个字节）。 |
| ***Prefix Lengths\*** | Variable (1 per length) | ***Prefix Lengths:\*** 前缀长度：代理公告的常规路由器公告部分中每个路由器地址的一个前缀长度编号。           |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\mobileipprefixlengths.png)

​                                                            **图131：移动IP前缀长度扩展格式**

此扩展出现在路由器广告消息的正常字段之后，如图148所示。

**单字节填充扩展**

有些实现要求ICMP消息的字节数为偶数，因此需要一个字节的填充。（单字节填充扩展只是一个字节的全零。不需要任何表格或数字！）

**关键概念：**移动IP代理发现是移动节点确定其位置并与归属或外地代理建立联系的过程。可以充当代理的路由器定期发送代理通告消息以指示其功能，这些消息是常规路由器通告的修改版本。移动节点还可以发送代理请求来请求发送通告，这与常规路由器请求相同。

###### 3.1.6.5 移动IP  Home 代理注册和注册消息(第1部分：1 2 3 4)

一旦移动节点完成代理发现，它就知道它是在自己的本地网络上还是在外地网络上。如果在其本地网络上作为常规IP设备进行通信，但如果在外地网络上，则必须激活移动IP。这需要它与其家乡代理通信，以便可以在两者之间交换信息和指令。这个过程被称为家乡代理注册，或者更简单地说，仅仅是注册。

注册的主要目的是实际开始移动IP工作。移动节点必须联系归属代理，并告诉它它在外地网络上，并请求打开数据报转发。它还必须让归属代理知道其转交地址，以便归属代理知道将转发的数据报发送到哪里。当执行注册时，归属代理继而需要将各种类型的信息传送回移动节点。请注意，外地代理并不真正参与注册，可能只是转发消息，这一点我们将会看到。

<u>**移动节点注册事件**</u>
成功的注册在标准中建立了归属代理和移动节点之间的移动性绑定。在注册期间，移动节点的常规归属地址被绑定到其当前转交地址，并且归属代理将封装寻址到归属地址的数据报并将其转发到转交地址。移动节点应该使用以下几个操作来管理其注册和处理各种事件：

- 注册：当移动节点第一次检测到它已经从其本地网络移动到外地网络时，它发起注册。

- 注销：当移动节点返回家乡时，它应该通知家乡代理取消转发，这一过程称为注销。

- 重新注册：如果移动节点从一个外地网络移动到另一个外地网络，或者如果其转交地址改变，则它必须向归属代理更新其注册。如果它目前的注册即将到期，它也必须这样做，即使它在一个外国网络上保持固定。

每个注册只在特定的时间长度内建立，这就是为什么无论设备移动与否都需要定期重新注册的原因。注册是有时间限制的，以确保它们不会过时。例如，如果节点在返回家乡时忘记注销注册，则当注册到期时，数据报转发最终将停止。

<u>**新的注册请求和注册回复消息**</u>
为了执行注册，在移动IP中定义了两种新的消息类型：注册请求和注册回复。其中的每一个都做了您从其名称中预期的事情。有趣的是，这些不是代理发现中使用的ICMP消息；它们是用户数据报协议(UDP)消息。因此，从技术上讲，注册是在比移动IP通信的其余部分更高的层执行的。代理侦听众所周知的UDP端口#434上的注册请求，并使用节点用来发送消息的任何临时端口响应移动节点。

这两条消息的格式将在本主题的后面部分介绍。

<u>**注册程序**</u>

根据移动节点使用的转交地址的类型和我们稍后将讨论的其他细节，为注册定义了两个不同的过程。第一种是直接注册法，只有两个步骤：

1. 移动节点向家乡代理发送注册请求。
2. 家乡代理将注册应答发送回移动节点。

然而，在某些情况下，需要稍微更复杂的过程，其中外地代理在归属代理和移动节点之间传送消息。在这种情况下，该过程有四个步骤：

1. 移动节点向外地代理发送注册请求。
2. 外地代理处理注册请求并转发到本地代理。
3. 本地代理向外地代理发送注册回复。
4. 外地代理处理注册应答并将其发送回移动节点。

当移动节点使用共同定位的转交地址时，通常使用第一种更简单的方法。在这种情况下，节点可以很容易地直接与归属代理通信，并且移动节点也被设置为直接从归属代理接收信息和数据报。当没有外国代理人时，这显然是必须使用的方法。这显然也是当移动节点在其返回归属网络之后向其归属代理取消注册时所使用的方法。

当移动节点使用外地转交地址时，需要第二种方法。回想一下，在这种情况下，移动节点根本没有自己的唯一IP地址；它使用由外地代理提供的共享地址，这排除了节点和归属代理之间的直接通信。此外，如果移动节点接收到设置了“R”标志的代理通告，它也应该通过外地代理，即使它具有共同定位的转交地址。

请注意，外地代理实际上只是一个“中间人”；交换仍然是在本地代理和移动节点之间进行的。但是，如果请求违反了使用外地网络的任何规则，则外地代理可以拒绝注册。正是出于这个原因，一些外地代理可能要求它们作为注册的通道，即使移动节点具有共同定位的转交地址。当然，如果外地代理无法联系本地代理，注册将无法继续进行。

上面的描述实际上是对注册基础的高度简化的解释。移动IP标准具体规定了代理和节点如何执行注册的更多细节，包括何时发送请求和回复、如何处理各种特殊情况(如无效请求)、家乡代理如何维护移动性绑定表的规则等等。该标准涵盖了对常规注册消息的扩展的定义，以支持安全通信所需的身份验证(有关更多详细信息，请参阅安全问题主题)。它还包括在需要时让移动节点维护一个以上并发绑定的能力。

**关键概念：**移动IP家乡代理注册是在家乡代理和移动节点之间创建移动性绑定以实现数据报转发的过程。注册是通过移动节点发送注册请求消息并且归属代理返回注册回复来执行的。外国代理商可能会被要求充当促进交易的“中间人”，但在其他方面不会参与进来。

<u>**注册请求报文格式**</u>

注册请求消息的格式如表83和图132所示。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\mobileipregrequest.png)

​                                                    <u>**图132：移动IP注册请求消息格式。**</u>

该消息在用户数据报协议(UDP)消息的有效载荷中携带，其报头未示出。

​                                                    <u>** 表83：移动IP注册请求报文格式**</u>

| **Field Name**         | **Size (bytes)** | **Description**                                                                             |
| ---------------------- | ---------------- | ------------------------------------------------------------------------------------------- |
| ***Type\***            | 1                | ***Type:\*** 类型：标识注册消息类型。对于请求，此字段为1。                                                        |
| ***Flags\***           | 1                | ![img](http://www.tcpipguide.com/free/aa1f6ab5.png)                                         |
| ***Lifetime\***        | 2                | ***Lifetime:\*** 生存时间：移动节点向归属代理请求此注册的时间长度（秒）。                                               |
| ***Home Address\***    | 4                | ***Home Address:\*** 归属地址：移动节点在其归属网络上的归属（正常）IP地址。无论请求如何传递给归属代理，都唯一地标识设备。                    |
| ***Home Agent\***      | 4                | ***Home Agent:\*** 归属代理：充当移动节点归属代理的设备的IP地址。                                                 |
| ***Care-Of Address\*** | 4                | ***Care-Of Address:\*** 该IP地址被移动节点用作其转交地址。                                                  |
| ***Identification\***  | 8                | ***Identification:\*** 标识：一个64位数字，唯一标识注册请求，用于将请求与回复进行匹配。它还提供防止重播攻击的保护；有关详细信息，请参阅移动IP安全问题主题。 |
| ***Extensions\***      | Variable         | ***Extensions:\*** 扩展：此处包含扩展字段，用于验证请求。也可以包括其他扩展。                                            |

**相关信息：**有关最小和GRE封装以及反向隧道的详细信息，请参阅有关移动IP封装的主题。

<u>**注册回复消息格式**</u>

注册回复消息的格式如表84和图133所示。

​                                                                       <u>**表84：移动IP注册回复报文格式**</u>

| **Field Name**        | **Size (bytes)** | **Description**                                                                                                        |
| --------------------- | ---------------- | ---------------------------------------------------------------------------------------------------------------------- |
| ***Type\***           | 1                | ***Type:\*** 类型：标识注册消息类型。作为答复，此字段为3。                                                                                   |
| ***Code\***           | 1                | ***Code:\*** 表示注册请求的结果。如果注册被接受，则此字段设置为0；如果注册被接受，但请求同时绑定且不受支持，则此字段设置为1。如果注册被拒绝，则会提供一个不同的原因代码来指示拒绝的原因，以及是本地代理还是外地代理拒绝注册。 |
| ***Lifetime\***       | 2                | ***Lifetime:\*** 如果注册被接受，则为注册过期前的时间长度(秒)。这当然可以是与所请求的移动节点不同的值。                                                          |
| ***Home Address\***   | 4                | ***Home Address:\*** 移动节点在其归属网络上时的归属(正常)IP地址。唯一标识设备，而不管请求如何传送到归属代理，因此，如果多个移动节点由同一外地代理提供服务，则可以将消息传递给该设备。                |
| ***Home Agent\***     | 4                | ***Home Agent:\***充当移动节点的家乡代理的设备的IP地址。                                                                                 |
| ***Identification\*** | 8                | ***Identification:\*** 唯一标识注册回复的64位数字，并与引发注册回复的请求的标识字段匹配。                                                              |
| ***Extensions\***     | Variable         | ***Extensions:\*** 此处包含扩展字段，用于验证回复。还可以包括其他扩展。                                                                          |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\mobileipregreply.png)

​                                                                <u>**图133：移动IP注册回复报文格式。**</u>

该消息在用户数据报协议(UDP)消息的有效载荷中携带，其报头未示出。

###### 3.1.6.6 移动IP数据封装和隧道(第1、2、3部分)

一旦外地网络上的移动节点完成了向其家乡代理的成功注册，一般操作主题中描述的移动IP数据报转发过程将被完全激活。归属代理将在数据报被路由到其归属网络时截取发往移动节点的数据报，并将它们转发到移动节点。这是通过封装数据报然后将它们发送到节点的转交地址来实现的。

<u>**移动IP数据封装技术。**</u>
封装是必需的，因为我们拦截和转发的每个数据报都需要通过网络重新发送到设备的转交地址。从理论上讲，设计者可能只需要让本地代理更改目的地址并将其重新粘贴到网络上，就可以做到这一点，但有各种复杂的因素使这种做法变得不明智。在重新传输之前，获取整个数据报并将其包装在一组新的报头中更有意义。在我们的邮件类比中，这就好比拿起一封为我们的旅行顾问收到的信，然后把它装进一个新的信封里转发，而不是只划掉原来的地址，然后放上一个新的地址。

移动IP中使用的默认封装过程称为IP内IP封装，在RFC 2003中定义，通常缩写为IP-in-IP。这是一种相对简单的方法，描述了如何获取IP数据报并使其成为另一个IP数据报的有效负载。在移动IP中，新的报头指定如何将封装的数据报发送到移动节点的转交地址。

除了IP-in-IP之外，还可以可选地使用两种其他封装方法：RFC 2004中定义的IP内最小封装和RFC 1701中定义的通用路由封装(GRE)。要使用这些方法中的任何一个，移动节点必须在其注册请求中请求适当的方法，并且归属代理必须同意使用它。如果使用外地代理转交寻址，则外地代理还必须支持所需的方法。

<u>**移动IP数据传输隧道。**</u>
封装过程在封装设备和解封设备之间创建称为隧道的逻辑结构。这与讨论虚拟专用网络(VPN)、IPSec隧道模式或用于安全的各种其他隧道协议时使用的隧道概念相同。隧道代表一条管道，数据报通过该管道在任意网际网络中转发，而封装的数据报的详细信息(即原始IP报头)暂时隐藏。

在移动IP中，隧道的起点是进行封装的家乡代理。隧道的末端取决于使用的转交地址的类型：

- 外地代理转交地址：外地代理是隧道的末端。它从归属代理接收封装的消息，剥离外部IP报头，然后将数据报传递给移动节点。这通常使用第二层来完成，因为移动节点和外地代理位于同一本地网络上，当然，移动节点在该网络上没有自己的IP地址(它使用外地代理的IP地址)。
- 共同定位的转交地址：移动节点本身是隧道的末端，并去掉外部报头。

移动IP传统隧道。

通常，上述隧道仅用于已发送到移动节点并由归属代理捕获的数据报。当移动节点想要发送数据报时，它不会将其隧道返回到归属代理；这将是不必要的低效。相反，它只需使用其当前网络上可以找到的任何路由器(可能是也可能不是外部代理)直接发送数据报。当它这样做时，它使用自己的家庭地址作为其发送的任何请求的源地址。因此，对这些请求的任何响应都将返回到家庭网络。这为这些类型的交易建立了一个“三角形”：

- 移动节点从外地网络向网际网络上的某个第三方设备发送请求。
- 第三方设备向移动节点作出响应。但是，这会将回复发送回移动节点在其归属网络上的归属地址。
- 归属代理截取归属网络上的响应，并将其通过隧道发送回移动节点。

这一过程如图134所示。反向交易将大致相同，只是顺序相反。在这种情况下，第三方(互联网)设备将向移动节点发送请求，该请求将由归属代理接收和转发。移动节点将直接回复互联网主机。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\mobileiptunneling.png)

​                                                                                  <u>**图134：移动IP封装和隧道**</u>

此示例说明了移动IP中的典型请求/回复消息交换如何导致通信的“三角形”。在步骤#1中，移动节点向互联网上某处的远程服务器发送请求。它使用自己的本地地址作为此请求的源，因此在步骤#2中，回复返回到本地代理。步骤#3包括归属代理将应答隧道传送回移动节点。

**关键概念：**一旦建立并运行了移动IP，它的工作方式是让归属代理封装并将接收到的数据报传输到移动节点。移动设备通常会直接向互联网主机发送数据报，互联网主机会对移动设备的归属代理进行响应，后者会将这些数据报转发给移动节点。这意味着请求/应答通信需要三次传输。

<u>**移动IP反向隧道**</u>

可能存在这样的情况，即让移动节点使用我们刚才看到的外部网络上的路由器将数据报直接发送到互联网是不可行或不希望的。在这种情况下，如果移动节点、归属代理和外部代理（如果相关）支持称为反向隧道的可选功能，则可以部署该功能。

完成此操作后，根据转交地址类型，在移动节点和归属代理之间或在外部代理和归属代理间建立反向隧道以补充正常隧道。来自移动节点的所有传输都通过隧道传输回归属网络，归属代理在该网络上通过互联网进行传输，从而产生了比刚才描述的“三角形”更对称的操作。这基本上就是我之前描述的“不必要的低效”，因为这意味着每一次交流都需要四个步骤。因此，它仅在必要时使用。

可能需要反向隧道的一种情况是，如果移动节点所在的网络已经实施了某些安全措施。特别是，网络可能被设置为不允许源地址与其网络前缀不匹配的传出数据报。这通常是为了防止“欺骗”（模仿他人的IP地址）

<u>**关键概念：**</u>在某些情况下，可以使用称为反向隧道的可选功能，例如当网络不允许具有外部源IP地址的传出数据报时。启用后，移动节点不直接发送数据报，而是将所有传输通过隧道传输回归属代理，由归属代理在互联网上发送数据报。

<u>**请注意**</u>，我刚才讨论的所有内容都适用于“正常”，即发送到移动节点和从移动节点发送的单播数据报。家庭网络上的广播数据报（如果移动节点在家中，则通常用于移动节点）不会被转发，除非该节点在注册期间特别请求此服务。也支持在外部网络上进行多播操作，但移动节点需要额外的工作来进行设置。

###### 3.1.6.7 移动IP和TCP/IP地址解析协议(ARP)操作(第1部分：第2部分)

移动IP是一种协议，它很好地实现了一个困难的功能：透明地允许IP设备移动到不同的网络。不幸的是，任何试图改变IP工作方式的协议都会遇到“特殊情况”。让归属代理截取数据报并将其通过隧道传输到移动节点，一般来说效果很好，但有些地方需要额外的工作。其中之一是使用TCP/IP地址解析协议（ARP），除非我们采取特殊步骤，否则在移动IP下，该协议将“中断”。

**背景信息：**本主题假设对ARP的一般工作原理有一定的理解。这包括ARP代理。

<u>**移动IP和ARP的困难**</u>

要了解ARP的问题，请考虑一个位于外部网络上并已成功注册其本地代理的移动节点。归属代理将截获进入归属网络的所有数据报，并将其封装和转发给移动节点。然而，要做到这一点，归属代理（归属路由器）必须看到数据报。这通常只发生在数据报从“外部”进入家庭网络并由路由器处理时。

当家庭网络上的本地设备本身想要向已在别处旅行的移动节点进行传输时，会发生什么？请记住，此设备本身可能不是移动设备，可能对移动IP一无所知。它将遵循标准流程来决定如何处理它需要发送的数据报，如讨论IP数据报的直接和间接传递的主题中所述。它会将其网络ID与移动节点的网络ID进行比较，并意识到它不需要路由其数据报；它可以将其直接发送到移动节点。

本地主机将尝试使用ARP查找移动节点的数据链路层地址，以便它可以直接向其发送数据报。它将从查找其ARP缓存开始，如果它在那里找到节点的数据链路层地址，将使用它在第二层发送。当然，移动节点不再在本地网段上，因此消息将永远不会被接收。如果没有ARP缓存条目，家庭网络上的主机将尝试向移动节点发送ARP请求，以确定其第二层地址。同样，移动节点已离开，因此此请求将无人应答。

<u>**处理ARP的其他归属代理任务**</u>

解决这个问题需要家庭代理的干预，你猜到了。它必须执行两个任务才能使本地主机发送到移动节点：

ARP代理：归属代理必须侦听与当前注册的任何移动节点位于同一网络上的节点发送的任何ARP请求。当它听到一个消息时，它会代替移动节点进行回复，并指定自己的数据链路层地址作为移动节点IP地址的绑定。这将导致归属网络上的主机将打算发送给移动节点的任何数据报发送到归属代理，在那里它们可以被转发。该过程如图135所示。

“无偿”ARP：代理有助于ARP请求，但对于已经为移动节点提供缓存条目的设备呢？一旦移动节点离开网络，它们就会自动过时。为了纠正这些错误，归属代理发送所谓的免费ARP消息，告诉本地网络上的设备将移动节点的IP地址与归属代理的数据链路层地址相关联。术语“无偿”指的是，发送消息不是为了执行实际的地址解析，而是为了更新缓存。它可能会被多次发送，以确保每个设备“收到消息”。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\mobileiparp.png)

​                                                              <u>**图135：移动IP家乡代理的ARP代理。**</u>

归属代理必须采取特殊步骤来处理从本地网络上的设备到移动节点的传输。在该示例中(为简单起见，使用短硬件地址)移动节点的硬件地址是#48，而归属代理的硬件地址是#63。具有硬件地址#97的归属网络上的本地客户端发送ARP请求以找出移动节点的硬件地址。归属代理代表移动设备进行响应，指定的不是硬件地址#48，而是它自己的地址#63。因此，客户端将发送到归属代理，然后归属代理可以将数据转发到外地网络上的移动节点。

完成此操作后，ARP应在本地链路上正常工作。当然，当移动设备返回到家庭网络时，这一过程必须颠倒。在向归属代理取消注册后，它将停止对移动节点的代理。移动节点和归属代理还将发送更新本地设备高速缓存的免费ARP广播，以再次将移动节点的IP地址与其自己的第二层地址相关联，而不是归属代理的IP地址。

**关键概念：**为了避免移动节点的归属网络上的主机在第二层尝试向其发送数据报时出现问题，归属代理需要使用代理ARP来指示此类设备发送到归属代理，以便它们可以被转发。它还必须使用“不必要的”ARP来更新任何现有的ARP缓存以达到该效果。

###### 3.1.6.8 移动IP效率问题(第1部分：第2部分)

让归属代理将所有数据报转发到移动节点，无论它可能在哪里，这是移动性的一种方便的解决方案，但也是一种相当低效的解决方案。由于每个数据报必须首先发送到归属网络，然后转发到移动节点，因此数据报将在网际网络的某个部分上传输两次。转发所代表的低效程度可能非常严重，并可能导致某些应用程序出现问题。

为了了解问题是什么，让我们考虑行进的移动节点M和想要向其发送的常规设备，设备A。移动IP的低效程度是设备A和M的归属网络之间的网际距离的函数，与设备A和M的当前网络之间的网际距离相比。这里所说的距离，指的是用于确定网际网络上的路由的术语；当两台设备之间通信所需的时间和/或跳数更少时，它们之间的距离更近；当它们之间的通信时间更长和/或跳数更少时，它们之间的距离更远。(我在下面的示例中使用地理位置来表示距离这一概念，但请记住，地理位置距离只是网际网络距离的一个因素。)。

<u>**对发送设备定位效率的影响。**</u>
让我们考虑这样的情况，其中移动节点M在离家很远的外地网络上，并且发送设备(设备A)想要使用节点M的归属IP地址来发送数据报。假设家庭网络位于伦敦，设备再次位于日本东京。与让移动节点仅在外地网络上获得新的临时IP地址而不使用移动IP的替代方案相比，以下示例按移动IP的效率越来越低的顺序排列：

- 归属网络上的发送设备：在这种情况下，设备A将发送数据报，该数据报立即被归属网络上的归属代理截取并转发到移动节点。这里实际上根本不存在低效(除了用于封装等的开销)，因为即使A直接发送到具有新的外地地址的移动节点，它也可能无论如何都将通过归属代理路由器被路由。
- 在靠近家庭网络的网络上发送设备：这里，假设法国巴黎的一个设备想要发送到移动节点。数据报从巴黎到伦敦，然后再到东京。这还不算太糟。
- 外网附近网络上的发送设备：现在，假设发送设备在台湾台北。在这种情况下，移动IP变得相当低效。数据报必须从台北一路发送到伦敦，然后一路送回东京。
- 外网发送设备：当发送设备实际位于移动节点正在访问的外网时，效率最低。如果设备A位于移动节点在东京的当前网络上，则它必须一路发送到伦敦，然后将结果一路转发回东京。如果没有移动IP，我们所需要做的就是使用ARP，然后直接在第二层交付，根本不需要路由！此场景如图136所示。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\mobileipinefficiency.png)

​                                                                             **图136：移动IP效率低下的“最坏情况”**

此图显示了移动IP效率低下的最糟糕情况：当移动设备所在的外部网络上的设备尝试向其发送消息时。这里的发送者210.4.79.11使用移动节点的家庭地址，因此传输必须一路路由回伦敦，然后转发回东京，即使这两台设备可能位于同一张桌子上！

不幸的是，最后一个要点中概述的“最糟糕的情况”是经常发生的情况。移动设备连接到外部网络以专门与该网络上的主机通信是很常见的

<u>**反向隧道效应的含义**</u>

更糟糕的是，考虑一下如果使用反向隧道会发生什么！这里，隧道不仅针对发送到移动节点的数据报，而且也针对从移动节点发送的数据报。在我们的“最坏的情况”示例中，从移动节点到外部网络上的另一台设备的请求/回复对需要从东京到伦敦再返回两次完整的往返。显然，这远远不是理想的。

<u>**效率低下是移动IP固有的一部分。**</u>
这个问题在移动IP本身并没有任何解决方案；这只是协议工作方式的自然结果。真正改善局面的唯一方法是“黑进”一个解决方案，最终归结为我们在没有移动性支持的IP中始终拥有的两个选项之一：我们要么决定在外部网络上为移动设备提供一个临时的真实IP地址，要么在外部网络上为移动设备使用特定于主机的路由。

我们已经看到，这两者都有问题，这就是移动IP最初被创建的原因。然而，在某些情况下，效率可能比移动IP提供的透明可移植性更重要。对于在远离本地网络的外地网络上的长期部署，或者对于效率至上的应用，使用这些技术之一可能是有意义的。例如，一家在不同城市有少量办公室使用Internet连接的公司可能会设置特殊的路由。这将允许从其他城市访问的移动设备直接与网络外部的本地节点交谈，而无需通过互联网进行路由。

**关键概念**：由于数据报被发送到位于其归属地址的移动节点，因此发送到移动设备的每个数据报必须首先返回其归属网络，然后被转发到其当前位置。由此导致的低效程度取决于发送者离移动设备归属网络的距离有多远。最糟糕的情况实际上发生在发送者和移动设备在同一外地网络上，在这种情况下，每次传输必须往返于移动设备的本地网络，然后再返回。这是移动IP固有的一部分，不能轻易纠正。

###### 3.1.6.9 移动IP安全注意事项(第1部分：第2部分)

如今，安全性在任何网际网络环境中都是一个令人担忧的问题，但对于移动IP来说尤其重要。造成这种情况的原因有很多，这既与如何使用该协议有关，也与执行该协议的具体机制有关。

在使用方面，由于移动设备经常使用无线网络技术，因此在移动IP的开发过程中将安全性考虑在内。无线通信本质上没有有线通信那么安全，因为传输是“公开”发送的，在那里它们可以被拦截。与有线连接相比，恶意用户也更容易扰乱无线设备的运行。

在运营方面，由于移动IP使用注册系统，然后通过不安全的网际网络转发数据报，因此存在许多风险。恶意设备可能会干扰注册过程，导致原本打算发送给移动设备的数据报被转移。“坏人”也可能干扰数据转发过程本身，通过封装虚假的数据报来欺骗移动节点，使其认为自己收到了从未发送过的东西。

**移动IP安全条款**
出于这些原因，移动IP标准包括有限数量的明确条款，以防范各种安全风险。一种安全措施被认为足够重要，以至于它直接被内置到移动IP标准中：注册请求和注册回复消息的认证。此身份验证过程的完成方式与IPSec身份验证头(AH)的操作方式有些类似。其目标是防止未经授权的设备通过欺骗代理以不正当的方式设置、续订或取消注册来拦截流量。

所有移动IP设备都需要支持身份验证。节点必须将其用于请求，代理必须将其用于回复。密钥必须手动分配，因为没有用于安全密钥分发的自动化系统。默认身份验证方法使用HMAC-MD5(在RFC 2403中指定)，这是IPSec使用的两种哈希算法之一。

<u>**防止重播攻击**</u>

另一个令人担忧的问题是名为重播攻击的安全问题。在这种类型的攻击中，第三方拦截数据报，保留它，然后稍后重新发送它。这看起来相当无害，但考虑到时机的重要性。假设一个移动节点向其家乡代理注册，然后返回家乡并取消注册。如果恶意设备捕获原始注册请求的副本并重新发送，归属代理可能会被愚弄，以为节点已经离开了家乡，而实际上并非如此。然后，它可以拦截转发的数据报。

注册请求和注册回复消息中使用的标识字段旨在防止重放攻击。由于每个请求具有不同的识别号，节点和代理可以将请求与回复相匹配，并拒绝他们收到的任何重复他们已经看到的数据报。移动IP标准还规定了防止重放的替代方法。

<u>**移动IP身份验证的局限性**</u>
虽然移动IP包括注册消息的身份验证措施，但它不包括其他类型的消息。它也没有指定从归属代理转发到移动节点的封装数据报的身份验证。也没有提供加密来保护控制消息或转发的数据报的隐私。当需要更强的隐私或真实性保证时，显而易见的解决方案是使用IPSec身份验证头(AH)和/或封装安全有效负载(ESP)协议。

#### 3.2 互联网控制消息协议（ICMP/ICMPv4和ICMPv6）

网际协议(IP)是实现TCP/IP协议组的关键网络层协议。由于IP协议提供了在设备之间传输数据报的机制，因此它被设计为相对基本，并且功能很少。它缺乏的规定之一是允许将错误报告回传输设备，并允许完成测试和特殊任务。然而，这些功能是网际网络运行所必需的，因此，TCP/IP为IP定义了一个提供这些功能的附属协议：互联网控制消息协议(ICMP)。

在本节中，我将使用两个主要小节描述ICMP的操作。第一小节概括介绍ICMP的概念和操作，包括ICMP消息打包的总体方法和发送ICMP消息的环境。第二小节详细描述了ICMP支持的每种消息类型。

ICMP被开发为最初的Internet协议版本4的伙伴。随着IP版本6(IPv6)的创建，也创建了新版本的ICMP，称为(ta-da)ICMP版本6(ICMPv6)，为了区分它，原始的ICMP现在有时被称为ICMPv4，就像现在经常被称为“IPv4”的“旧”IP一样。这两个版本在细节上有一些不同，但在总体操作上确实非常相似。为此，我决定将两个版本的ICMP的一般操作描述整合在一起，只指出它们之间的差异。IPv4和IPv6的最大不同之处在于特定的消息类型和格式，因此已在第二小节中分别进行了介绍。

**背景信息：**由于ICMP和IP之间的密切关系，本节假定您熟悉基本的IP概念，包括IP寻址、IP数据报的一般格式以及它们的路由方式。为了更好地了解ICMPv6的详细信息，您可能还需要参考IPv6编址和数据报封装主题，尤其是IPv6邻居发现(ND)协议。

##### 3.2.1 ICMP概念和一般操作

互联网控制报文协议(ICMP)是网络世界中被低估的“工蜂”之一。每个人都知道Internet协议等关键协议对TCP/IP有多重要，但很少有人意识到该协议集作为一个整体依赖于ICMP提供的许多功能。ICMP消息最初是为了允许报告一小部分错误情况而创建的，现在用于实现广泛的错误报告、反馈和测试功能。虽然每种消息类型都是唯一的，但它们都是使用通用的消息格式实现的，基于相对简单的协议规则发送和接收。这使得ICMP成为最容易理解的TCP/IP协议之一。(是的，我确实说过本指南中的某些内容很简单！)。

在本节中，我将提供ICMP的一般描述。我首先概述ICMP，讨论它的目的、历史以及定义它的版本和标准。我将介绍ICMP运行的一般方法，并讨论管理如何以及何时创建和处理ICMP消息的规则。然后，我概述了ICMPv4和ICMPv6中用于ICMP消息的通用格式，以及数据在其中的一般封装方式。最后，我对ICMP消息分类进行了讨论，并总结了版本4和版本6的不同消息类型和代码。

###### 3.2.1.1 ICMP概述、历史、版本和标准(部分：1 2 3)

Internet协议是TCP/IP协议族的基础，因为它是负责传递数据报的机制。描述IP数据报传输方法的三个主要特征是无连接、不可靠和未确认。这意味着数据报只是通过网际网络发送，没有事先建立连接，不能保证它们会出现，也不会向发送者发回它们已到达的确认。从表面上看，这似乎会导致一个难以使用和不可能依赖的协议，因此不是设计协议组的糟糕选择。然而，尽管IP“不能保证”，但它工作得很好，因为在大多数情况下，IP网际网络足够强大，消息可以到达它们需要到达的地方。

当然，即使是设计最好的系统也会遇到问题。偶尔会发送不正确的数据包，硬件设备出现问题，发现路由无效，等等。IP设备还经常需要共享特定信息来指导它们的操作，并执行测试和诊断。然而，IP本身不包括允许设备交换低级控制消息的规定。相反，这些功能是以称为互联网控制消息协议(ICMP)的IP“伴生”协议的形式提供的。

<u>**IP与ICMP的关系**</u>
我认为一个很好的比喻是知识产权和ICMP之间的关系，可以考虑一位有权势的高管和她经验丰富的行政助理之间的关系。这位主管很忙，她的时间很贵。她得到的报酬是做好一项特定的工作，而不是把时间花在行政任务上。然而，如果没有人做这些工作，这位高管就不能正确地完成她的工作。行政助理做同样重要的支持工作，使行政人员有可能专注于她的工作。他们之间的工作关系非常重要；好的伴侣会像一个有凝聚力的团队一样合作，甚至预见到对方的需求。

在TCP/IP协议中，互联网协议是执行者，而ICMP是它的“行政助理”。IP专注于其核心活动，如寻址、数据报打包和路由。ICMP以ICMP消息的形式为IP提供关键支持，允许在IP设备之间进行不同类型的通信。这些消息使用通用的通用格式，并封装在IP数据报中进行传输。它们分为不同的类别，每种类型都有特定的用途和内部字段格式。

正如行政助理通常在组织结构图中有一个特殊的位置，通常用“虚线”直接连接到他或她所协助的行政人员一样，ICMP在TCP/IP协议体系结构中占有独特的位置。从技术上讲，可以认为ICMP属于第4层，因为它创建的报文被封装在IP数据报中，并在第3层使用IP发送。然而，在最初定义ICMP的标准中，ICMP被明确声明为不仅是网络层的一部分，而且：

实际上是IP的一个组成部分，[它]必须由每个IP模块来实现"

<u>**用于IPv4和IPv6的ICMP标准**</u>

顺便说一句，我刚才引用的定义标准是RFC 792。这是ICMP的最初定义标准，简称为Internet控制消息协议。它与IP标准RFC 791同时发布。这进一步表明，IP和ICMP确实是一个“团队”。

由于两者之间的密切关系，在20世纪90年代中期开发新的互联网协议版本6(IPv6)时，也有必要定义新版本的ICMP。这当然被称为互联网协议版本6(IPv6)规范的互联网控制消息协议(ICMPv6)，于1995年首次发布为RFC 1885，并于1998年在RFC 2463中修订。正如原始IP现在通常称为IPv4以区别于IPv6一样，原始ICMP现在也称为ICMPv4。

这两个RFC 792和2463分别定义了ICMPv4和ICMPv6的基本操作，还描述了协议的每个版本支持的一些ICMP消息类型。ICMPv4和ICMPv6在大多数一般方面非常相似，尽管它们有一些差异，其中大部分是对IP本身进行更改的直接结果。另一个文档RFC 1122(Internet主机要求-通信层)包含如何使用ICMPv4的规则，我们将在有关ICMP消息创建和处理约定的主题中看到。RFC 1812(对IP版本4路由器的要求)也是相关的。

**关键概念：**在TCP/IP中，互联网/网络层的诊断、测试和错误报告功能由互联网控制消息协议(ICMP)执行，就像互联网协议的“管理助理”。最初的版本现在称为ICMPv4，用于IPv4，较新的ICMPv6用于IPv6。

<u>**定义ICMP消息的其他标准**</u>

该协议的两个版本都定义了一个设计为可扩展的通用消息传递系统。这意味着，除了ICMP标准本身中定义的消息外，其他协议也可以定义ICMP中使用的消息类型。表85显示了其中一些较重要的参数。

​                                                   **表85：定义ICMP消息的非ICMP互联网标准**

| **ICMP Version of Message Types Defined** | **RFC Number**                          | **Name**                                                                      | **ICMP Message Types Defined**                                                                               |
| ----------------------------------------- | --------------------------------------- | ----------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------ |
| **ICMPv4**                                | **950**                                 | *Internet Standard Subnetting Procedure*                                      | *Address Mask Request, Address Mask Reply*                                                                   |
| **1256**                                  | *ICMP Router Discovery Messages*        | *Router Advertisement*, *Router Solicitation*                                 |                                                                                                              |
| **1393**                                  | *Traceroute Using an IP Option*         | *Traceroute*                                                                  |                                                                                                              |
| **1812**                                  | *Requirements for IP Version 4 Routers* | Defines three new codes (subtypes) for the *Destination Unreachable* message. |                                                                                                              |
| **ICMPv6**                                | **2461**                                | *Neighbor Discovery for IP Version 6 (IPv6)*                                  | *Router Advertisement*, *Router Solicitation*, *Neighbor Advertisement*, *Neighbor Solicitation*, *Redirect* |
| **2894**                                  | *Router Renumbering for IPv6*           | *Router Renumbering*                                                          |                                                                                                              |

ICMP消息分类、类型和代码主题包括本指南中涵盖的ICMPv4/ICMPv6消息类型的完整列表以及定义每种类型的标准。

###### 3.2.1.2 ICMP一般操作(第1部分：第2部分)

ICMP是TCP/IP协议簇中最简单的协议之一。大多数协议实现特定类型的功能，以便于网络堆栈的一部分或应用程序的基本操作。为此，它们包括定义协议的许多特定算法和任务，这是最复杂的地方。相比之下，ICMP正如其名称所暗示的那样：一种定义控制消息的协议。因此，ICMP的几乎所有内容都是为任何IP设备提供一种将控制消息发送到另一设备的机制。

<u>**ICMP消息传递服务**</u>
ICMP中定义了各种消息类型，允许交换不同类型的信息。它们通常是为了报告错误或交换保持IP平稳运行所需的不同种类的重要信息而生成的。ICMP本身并不定义如何使用所有不同的ICMP消息；这是由使用消息的协议完成的。通过这种方式，ICMP向其他协议描述了一种简单的消息传递服务。

**关键概念**：ICMP不同于大多数其他TCP/IP协议，因为它不执行特定任务。它定义了一种机制，通过该机制可以发送和接收各种控制消息以实现各种功能。

如前面的概述主题所述，ICMP被视为IP的组成部分，即使它使用IP来发送其消息。通常，ICMP的操作涉及机器上的某些部分的TCP/IP协议软件检测导致其生成ICMP消息的条件。这通常是IP层本身，尽管它可能是软件的其他部分。然后，该消息像任何其他TCP/IP消息一样被封装和传输，并且与其他IP数据报相比不会被给予特殊处理。消息通过网际网络发送到接收设备的IP层，如图137所示。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\icmpoperation.png)

​                                                                              **图137：ICMP一般操作**

ICMP的典型用途是在发送IP消息时提供反馈机制。在本例中，设备A尝试向设备B发送IP数据报。但是，当它到达路由器R3时，会检测到导致数据报被丢弃的某种问题。R3向A发回ICMP消息，告诉它发生了一些事情，如果可能的话，希望有足够的信息让A纠正问题。R3只能将ICMP消息发送回A，而不能发送到R2或R1。

同样，由于许多ICMP消息实际上旨在将信息传送到设备的IP软件，因此一旦接收者获得ICMP消息，IP层本身就可能是ICMP消息的“最终目的地”。在其他情况下，最终目的地可能是TCP/IP协议软件的某个其他部分，这由接收的消息类型确定。ICMP不使用UDP或TCP等端口将其消息定向到主机上的不同应用程序；软件识别消息类型并在软件中相应地将其定向。

ICMP最初的设计理念是大多数消息将由路由器发送，但根据消息类型的不同，它们既可以由两台路由器发送，也可以由普通主机发送。有些显然只由路由器发送，例如重定向消息，而另一些可能由路由器或主机发送。许多ICMP消息被配对使用，特别是各种类型的请求和回复消息以及通告和请求消息。

<u>**ICMP错误报告限制**</u>

ICMP操作的一个有趣的一般特征是，当检测到错误时，可以使用ICMP报告它们，但只能返回到数据报的原始来源。这实际上是ICMP工作方式的一大缺陷。回到图137，再次考虑客户端主机A向服务器主机B发送消息，路由器R3在数据报中检测到问题。即使R3怀疑问题是由前面处理该消息的某个路由器(例如R2)引起的，它也无法向R2发送问题报告。它只能将ICMP消息发送回主机A。

这一限制是网际协议工作方式的缺陷。您可能还记得，在查看IP数据报格式时，唯一的地址字段是数据报的原始源和最终目的地。(唯一的例外是如果使用了IP记录路由选项，但设备不能指望这一点。)。当R3从R2接收数据报时，R2又从R1(在此之前是从A)接收数据报，它在数据报中只是A的地址。因此，R3必须向A发回问题报告，而A必须决定如何处理该报告。设备A可能决定更改其使用的路由，或生成管理员可用来排除R2路由器故障的错误报告。

除了这一基本限制之外，还制定了几个特殊规则和约定来管理生成、发送和处理ICMP消息的环境。

**关键概念：**为响应IP数据报中出现的问题而发送的ICMP错误报告消息只能发送回源设备。中间设备不能作为ICMP消息的接收方，因为它们的地址通常不在IP数据报头中携带。

###### 3.2.1.3 ICMP报文类别、类型和代码(部分：1 2 3)

ICMP消息用于允许网际网络上的IP设备之间通信不同类型的信息。消息本身用于各种各样的目的，并被组织成一般类别以及许多特定类型和子类型。

<u>**ICMP消息类**</u>
在最高级别，ICMP消息分为两类：

- 错误消息：这些消息用于向源设备提供有关已发生错误的反馈。它们通常是专门响应某种操作而生成的，通常是数据报的传输，如图137所示。错误通常与数据报的结构或内容有关，或者与数据报路由过程中遇到的网际网络问题有关。
- 信息性(或查询)消息：这些消息用于让设备交换信息、实现某些与IP相关的功能以及执行测试。它们不指示错误，并且通常不响应常规数据报传输而发送。它们是在应用程序指示时生成的，或者是定期生成的，以便向其他设备提供信息。信息性ICMP消息也可以作为对另一信息性ICMP消息的回复而发送，因为它们经常出现在请求/回复或请求/通告功能对中。

**关键概念：**ICMP消息分为两大类：用于报告问题情况的错误消息和用于诊断、测试和其他目的的信息性消息。

 <u>**ICMP消息类型**</u>

ICMP中的每种消息都被赋予了自己唯一的Type值，该值被放入ICMP通用消息格式中该名称的字段中。此字段为8位宽，因此理论上最多可以定义256种消息类型。分别为ICMPv4和ICMPv6维护一组单独的类型值。

在ICMPv4中，Type值被按顺序分配给错误消息和信息性消息，这是基于“先到先服务”的基础上的(某种程度上)，因此不能仅仅通过Type值来区分每个消息的类型。ICMPv6中的一个小改进是消息类型是分开的。在IPv6中，错误消息的类型值从0到127，信息性消息的值从128到255。当然，当前只定义了部分Type值。

**关键概念：**可以为ICMPv4和ICMPv6中的每一个定义总共256种不同的可能消息类型。每条消息报头中显示的Type字段指定ICMP消息的类型。在ICMPv4中，类型值和消息类型之间没有关系；在ICMPv6中，错误消息的类型值为0到127，信息性消息的值为128到255。

<u>**ICMP消息代码**</u>
报文类型表示每种ICMP报文的一般用途。ICMP还以代码字段的形式在每种消息类型中提供额外的详细级别，也是8位。您可以将此字段视为消息“子类型”。因此，每种消息类型最多可以有256个子类型，这些子类型是消息整体功能的更详细的子类型。一个很好的例子是Destination Unreacable消息，它是在无法传递数据报时生成的。在此邮件类型中，Code值提供了有关无法进行传递的确切原因的详细信息。

<u>**ICMP消息类别和类型摘要**</u>

本指南包括一个完整的章节，介绍ICMPv4和ICMPv6的所有主要ICMP消息类型。为方便起见，我在表86中总结了所有这些消息类型，其中显示了本指南中涵盖的每个消息的类型值、每个消息的名称、其用途的简要摘要以及定义它的RFC。(为了避免表格过大，我没有显示每个Type值的Code值；可以在各个消息类型描述中找到这些值。)。此表的组织方式与ICMP消息类型和格式部分相同，只是此表按每个类别中的类型值升序排序，以便于参考。

​                                                             **表86：ICMP报文类别、类型和代码**

| **Message Class**                               | **Type Value**                | **Message Name**                                                                                 | **Summary Description of Message Type** | **Defining RFC Number** |
|:-----------------------------------------------:|:-----------------------------:|:------------------------------------------------------------------------------------------------:| --------------------------------------- |:-----------------------:|
| **ICMPv4 Error Messages**                       | **3**                         | ***Destination Unreachable\***                                                                   | 表示无法将数据报传递到其目的地。Code值提供了有关错误性质的详细信息。    | 792                     |
| **4**                                           | ***Source Quench\***          | 让拥塞的IP设备告诉正在向其发送数据报的设备减慢其发送数据报的速率。                                                               | 792                                     |                         |
| **5**                                           | ***Redirect\***               | 允许路由器通知主机用于发送数据报的更好的路由。                                                                          | 792                                     |                         |
| **11**                                          | ***Time Exceeded\***          | 当数据报因其生存时间字段过期而在传递前被丢弃时发送。                                                                       | 792                                     |                         |
| **12**                                          | ***Parameter Problem\***      | 指示传递数据报时出现其他问题(由Code值指定)。                                                                        | 792                                     |                         |
| **ICMPv4 Informational Messages (part 1 of 2)** | **0**                         | ***Echo Reply\***                                                                                | 在回复Echo(请求)消息时发送；用于测试连通性。               | 792                     |
| **8**                                           | ***Echo (Request)\***         | 由设备发送以测试与网际网络中另一台设备的连通性。“请求”一词有时会出现在消息名称中。                                                       | 792                                     |                         |
| **9**                                           | ***Router Advertisement\***   | 路由器用来告知主机它们的存在和功能。                                                                               | 1256                                    |                         |
| **10**                                          | ***Router Solicitation\***    | 主机用于提示任何侦听路由器发送路由器通告。                                                                            | 1256                                    |                         |
| **13**                                          | ***Timestamp (Request)\***    | 由设备发送，请求另一设备向其发送用于传播时间计算和时钟同步的时间戳值。“请求”一词有时会出现在消息名称中。                                            | 792                                     |                         |
| **14**                                          | ***Timestamp Reply\***        | 响应时间戳(请求)发送以提供时间计算和时钟同步信息。                                                                       | 792                                     |                         |
| **15**                                          | ***Information Request\***    | 最初用于从另一台设备请求配置信息。现在已经过时了。                                                                        | 792                                     |                         |
| **ICMPv4 Informational Messages (part 2 of 2)** | **16**                        | ***Information Reply\***                                                                         | 最初用于提供配置信息以响应信息请求消息。现在已经过时了。            | 792                     |
| **17**                                          | ***Address Mask Request\***   | 用于请求设备发送子网掩码。                                                                                    | 950                                     |                         |
| **18**                                          | ***Address Mask Reply\***     | 包含回复地址掩码请求时发送的子网掩码。                                                                              | 950                                     |                         |
| **30**                                          | ***Traceroute\***             | 用于实现实验性的“增强型”跟踪路由实用程序。                                                                           | 1393                                    |                         |
| **ICMPv6 Error Messages**                       | **1**                         | ***Destination Unreachable\***                                                                   | 表示无法将数据报传递到其目的地。代码值提供了有关错误性质的详细信息。      | 2463                    |
| **2**                                           | ***Packet Too Big\***         | 当数据报太大而无法转发时发送，因为该数据报对于路由中下一跳的最大传输单位(MTU)来说太大。IPv6而不是IPv4需要此消息，因为在IPv4中，路由器可以分割过大的消息，而在IPv6中则不能。 | 2463                                    |                         |
| **3**                                           | ***Time Exceeded\***          | 当数据报因跳数限制字段减为零而在传送前被丢弃时发送。                                                                       | 2463                                    |                         |
| **4**                                           | ***Parameter Problem\***      | 指示传递数据报时出现其他问题(由Code值指定)。                                                                        | 2463                                    |                         |
| **ICMPv6 Informational Messages**               | **128**                       | ***Echo Request\***                                                                              | 由设备发送以测试与网际网络中另一台设备的连通性。                | 2463                    |
| **129**                                         | ***Echo Reply\***             | 在回复Echo(请求)消息时发送；用于测试连通性。                                                                        | 2463                                    |                         |
| **133**                                         | ***Router Solicitation\***    | 提示路由器发送路由器通告。                                                                                    | 2461                                    |                         |
| **134**                                         | ***Router Advertisement\***   | 由路由器发送，以告知本地网络上的主机路由器的存在并描述其功能。                                                                  | 2461                                    |                         |
| **135**                                         | ***Neighbor Solicitation\***  | 由一台设备发送以请求另一台设备的第二层地址，同时也提供其自己的地址。                                                               | 2461                                    |                         |
| **136**                                         | ***Neighbor Advertisement\*** | 向网络上的其他设备提供有关主机的信息。                                                                              | 2461                                    |                         |
| **137**                                         | ***Redirect\***               | 将传输从主机重定向到网络或路由器上的直接邻居。                                                                          | 2461                                    |                         |
| **138**                                         | ***Router Renumbering\***     | 传送用于路由器重新编号的重新编号信息。                                                                              | 2894                                    |                         |

您可以看到，ICMPv4和ICMPv6中的几种消息类型非常相似，但有一些细微的差异。一个明显的问题是，重定向在ICMPv4中被视为错误消息，但在ICMPv6中被视为信息性消息。消息的使用方式也经常不同。在IPv6中，邻居发现(ND)协议中描述了许多ICMP信息消息的使用，该协议是IPv6中的新功能。

请注意，最初创建信息请求和信息回复消息是为了允许设备确定IP地址和可能的其他配置信息。此功能后来使用RARP、BOOTP和DHCP等协议实现，这些消息类型已过时。

###### 3.2.1.4 ICMP报文创建和处理惯例和规则(第1部分：2 3)

在ICMP概述中，我将IP和ICMP之间的关系与高管和行政助理之间的关系进行了比较。许多高管看重好助理的一个特点是，助理独立工作，不会造成不必要的干扰。一个好的助手应该节省行政人员的时间，而不是浪费他或她的时间。

作为IP的“助手”，ICMP同样必须在不占用太多“时间”的情况下帮助IP运行。在这里，节省的资源与其说是“时间”，不如说是带宽。ICMP消息很重要，但必须被视为运行网络的“开销”的一部分。它们不携带用户数据，因此每一个都代表着网络上最终用户带宽的小损失。出于这个原因，我们只想在必要时发送它们，并仔细控制它们产生的环境。

现在，与网络协议相比，行政助理有一些重要的优势：常识和经验。他们通常知道帮助和阻碍之间的界限；电脑不会。为了部分补偿，ICMP的操作由一组关于如何创建和处理消息的约定或规则指导。对于ICMPv4，这些约定在定义RFC 792中有部分描述，但在RFC 1122（Internet主机的要求-通信层）中有更多描述，该文件提供了在主机设备中实现TCP/IP的具体信息。在ICMPv6中，RFC 1122中出现的与ICMP实现相关的信息已基本并入定义ICMPv3的主文档RFC 2463中。

<u>**ICMP消息响应的限制**</u>

与消息生成相关的大多数问题都与错误消息有关，而不是信息性消息。后一类消息通常不会造成问题，因为它们是基于使用它们的协议中已经建立的特定规则生成的。例如，路由器定期发送路由器通告消息，而路由器会确保这种情况不会经常发生。它们也是对主机偶尔发送的路由器请求消息的响应，只要主机没有失控，开始发送大量请求，就不会有问题。即使这样，路由器也可以被赋予足够的智慧，不会太频繁地发送路由器通告。

这个问题之所以会出现错误消息，是因为它们是在响应太多情况时发送的。潜在地，它们甚至可能被发送以回应彼此。如果不特别注意，可能会发生循环或级联消息生成。例如，考虑设备A遇到错误并向设备B发送错误报告的情况。设备B在设备A的消息中发现错误并将错误报告发送回设备A。这可能导致数十亿条消息来回发送阻塞网络，直到有人找出问题所在并修复它。

为防止出现此类问题，不得针对以下任何情况生成ICMP错误消息：

- ICMP错误消息：这可以防止刚才提到的那种类型的循环。然而，请注意，可以响应ICMP信息性消息生成ICMP错误消息。
- 广播或组播数据报：如果将数据报广播到5,000台主机，并且每台主机都发现其中有错误并尝试将报告发回源，会发生什么情况？一些令人不快的事情。
- 除第一个以外的IP数据报片段：当数据报被分段时，可能只会发送错误以响应第一个片段。通常，由于一个分段的问题而生成的错误也会由每个后续分段生成，从而导致不必要的ICMP流量。
- 具有非单播源地址的数据报：如果数据报的源地址没有定义唯一的单播设备地址，则无法将错误消息发送回该源。这样可以防止ICMP消息被广播、单播或发送到不可路由的特殊地址，例如环回地址。

**关键概念**：为了防止在网络上发送过多的ICMP消息，制定了一组特殊的规则来管理何时以及如何创建这些消息。它们中的大多数旨在消除响应某些事件而生成大量ICMP错误消息的情况。

这些规则同时适用于ICMPv4和ICMPv6，但在ICMPv6中有几种特殊情况。在某些情况下，可能会将ICMPv6数据包太大消息发送到组播地址，因为这是路径MTU发现工作所必需的。某些参数问题消息也可以发送到多播或广播地址。最后，除了上述规则之外，IPv6实施还专门针对限制其发送ICMPv6消息的总体速率。

<u>**ICMP消息处理约定**</u>

消息处理通常按照一般操作主题中的描述进行，并根据需要将ICMP消息发送到IP软件或其他协议软件实施。如何处理消息通常取决于消息的类型。有些只针对IP软件本身，但许多针对的是生成导致错误的数据报的高层协议。在下一个主题中，我们将看到ICMP错误消息包含的信息允许提取上层协议，以便将消息传递到相应的软件层。

在IPv6中，消息的类别(错误或信息性)可以从Type值确定。然后，此知识可用于指导具有未知类型值的ICMP消息的处理。规则是，具有未知类型值的ICMP错误消息必须传递到相应的上层协议。具有未知Type值的信息性消息将被丢弃，而不采取操作。

除了这些一般规则外，还制定了一些特定规则来指导某些消息类型的处理。我将在讨论各个ICMP消息的主题中介绍其中一些约定。

重要的最后一点是，ICMP消息，特别是错误消息，不被视为在处理它们的设备上的“绑定”。坚持办公室的类比，他们在办公室里的地位等同于只有一份“供参考备忘录”，而不是一份“任务”。通常情况下，设备应该在处理ICMP消息时采取操作，但设备不需要这样做。同样，当信息性消息用于特定目的时，也是例外。例如，大多数成对到来的消息都是这样设计的，即请求产生匹配的回复，而请求产生广告。

**关键概念：**除非使用消息类型的协议规定了对特定消息类型的特定响应，否则接收ICMP消息的设备不需要采取操作。特别是，在收到ICMP错误消息时，设备不会被强制执行任何特定任务。

###### 3.2.1.5 ICMP通用报文格式和数据封装(第1部分：第2部分)

正如我们在前面的主题中看到的，ICMP与其说是执行特定功能的协议，不如说是交换错误报告和信息的框架。由于每种消息类型用于不同的目的，因此它们所包含的信息类型也不同。这意味着每个ICMP消息的格式略有不同。但是，与此同时，ICMP消息类型也具有一定程度的共性--每个消息的一部分在消息类型之间是公共的。

<u>**ICMP通用报文格式**</u>
ICMP消息的结构通常可以被认为具有公共部分和唯一部分。公共部分由三个在所有ICMP消息中具有相同大小和相同含义的字段组成(当然，对于每种ICMP消息类型，这些字段中的值并不相同)。唯一部分包含特定于每种消息类型的字段。

有趣的是，ICMPv4和ICMPv6的通用消息格式基本相同。表87和图138对其进行了说明。

​                                                                     **表87：ICMP通用报文格式**

| **Field Name**             | **Size (bytes)** | **Description**                                                                                                            |
| -------------------------- | ---------------- | -------------------------------------------------------------------------------------------------------------------------- |
| ***Type\***                | 1                | ***Type:\*** 类型：标识ICMP消息类型。对于ICMPv6，值0到127是错误消息，值128到255是信息消息。ICMP消息类和类型主题中的表中给出了此字段的通用值。                                  |
| ***Code\***                | 1                | ***Code:\*** 标识每个ICMP消息类型值中消息的“子类型”。因此，每个消息类型最多可以定义256个“子类型”。此字段的值显示在单个ICMP消息类型主题                                          |
| ***Checksum\***            | 2                | ***Checksum:\*** 校验和：以与IPv4中的IP报头校验和类似的方式计算的16位校验和字段。它为整个ICMP消息提供错误检测覆盖范围。请注意，在ICMPv6中，IPv6报头字段的伪报头被预置用于校验和计算；这与TCP中的方式类似。 |
| ***Message Body / Data\*** | Variable         | ***Message Body:\***消息正文：包含用于实现每个消息类型的特定字段。这是我上面提到的信息的独特部分。                                                                |

消息体通常包含一个或多个携带与每种特定类型的ICMP消息相关的信息的字段。对于错误消息，我们在这里看到ICMP消息中的另一个共性：所有ICMP错误消息都包括导致ICMP错误消息的原始IP数据报的一部分。通过允许将错误传递到更高层，这有助于诊断导致生成ICMP消息的问题。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\icmpformat.png)

​                                                                         **图138:ICMP通用消息格式**

此总体通用消息格式用于ICMPv4和ICMPv6消息类型。

<u>**ICMP错误消息中包含原始数据报**</u>

对于两个ICMP版本，包含原始IP数据报信息的方式不同。

**<u>ICMPv4错误消息</u>**
每个错误消息包括完整的IP报头和有效负载的前8个字节。由于有效载荷的开头将包含封装的较高层报头，这意味着ICMP消息还携带完整的UDP报头或TCP报头的前8个字节。在这两种情况下，都包括源端口号和目的端口号。

如果原始标头是没有选项的标准IP标头，则消息正文的长度将为28字节；如果存在选项，则长度将更大。

<u>**ICMPv6错误消息**</u>
每个错误消息包括尽可能多的IPv6数据报，而不会导致ICMPv6错误消息的大小(包括其IP报头封装)超过最小IPv6最大传输单元大小，即1280字节。与ICMPv4相比，这提供了更多用于诊断的信息，同时确保ICMPv6错误消息对于任何物理网段都不会太大。所包含数据的较大大小允许将IPv6扩展报头包括在错误消息中，因为错误可能在这些扩展报头之一中。

请记住，在IPv6中，路由器不能对IP数据报进行分段；对于底层物理网络而言，任何超大的数据报都会被丢弃。因此，ICMPv6旨在通过不在通用IPv6 MTU大小1280上创建ICMPv6数据报来确保不会发生这种情况。

关键概念：每种ICMP报文都包含该报文类型唯一的数据，但所有报文都是根据通用ICMP报文格式构造的。ICMP错误消息始终在其消息正文字段中包括导致错误生成的原始IP数据报的某些部分。

**<u>ICMP数据封装</u>**
ICMP报文格式化后，会像任何其他IP报文一样封装在IP数据报中。这就是为什么有些人认为ICMP在体系结构上是比IP更高的层，尽管正如我们前面讨论的那样，它实际上更多的是一种特殊情况。然后，您还可以看到，当生成ICMP错误消息时，我们最终得到原始IP报头和部分或全部有效负载，封装在ICMP报文中，然后封装在新的IP报头中，通常作为错误报告发送回发送原始IP消息的设备。

##### 3.2.2 ICMP报文类型和格式

互联网控制消息协议(ICMP)为错误报告和IP设备之间的重要信息交换提供了一种机制。ICMP中存在许多不同的消息类型，它们具有我们在讨论ICMP一般情况一节中看到的某些共同属性。除了这些共性之外，有关如何创建和使用ICMP消息的详细信息还会根据特定的消息类型而有所不同，因此是时候来看看它们是如何工作的了。

在本节中，我将提供有关最常见的ICMP消息类型的具体详细信息，包括对它们的用法和特定消息格式的描述。目前涵盖了20种不同的消息类型，因此为了更好地组织，将它们划分为四个小节。它们对应于ICMP版本(ICMPv4和ICMPv6)和消息类别(错误和信息性)的四种组合。

**相关信息：**有关消息类型和相应ICMP类型字段值的交叉引用，请参阅有关ICMP消息类别和类型的一般主题。有关“通用”ICMP报文格式字段(类型、代码和校验和)以及在错误报文中合并原始IP数据报信息的更多信息，请参阅有关ICMP通用报文格式和数据封装的主题。

###### 3.2.2.1 ICMP版本4(ICMPv4)错误消息类型和格式

路由器和主机使用ICMP错误消息来通知发送数据报的设备在传送数据报时遇到的问题。在最初的ICMP版本4中，定义了五种不同的错误消息，它们都在最初的ICMP标准RFC 792中进行了描述。这些是一些最重要的ICMP消息，因为它们提供有关错误情况的关键反馈，并可帮助发送设备采取纠正措施以确保可靠和高效的数据报传输。

在关于特定ICMP类型的四个部分中的第一节中，我将查看ICMPv4错误消息。我首先介绍由于数据报传递失败而发送的目标不可达消息和源抑制消息，源抑制消息用于告诉设备减慢其发送数据报的速率。接下来，我将描述超时消息和重定向消息，前者是指数据报在网络中传输的时间太长，或从碎片重组的时间太长，后者使路由器可以向主机提供有关更佳路由的反馈。最后，我讨论了参数问题消息，这是一种通用的“全部捕获”类型，用于其他ICMP错误消息未涵盖的问题。

###### 3.2.2.1-1 ICMPv4目标无法到达消息(部分： 1 2 3 4)

由于Internet协议是一种不可靠的协议，因此不能保证从一台设备发送到另一台设备的数据报会真正到达那里。主机和路由器的互联网络将尽“最大努力”传递数据报，但由于各种原因，它可能无法到达所需的位置。当然，IP网络上的设备了解这一点，并相应地进行了设计。IP软件从不假设其数据报总是会被接收，而更高层的协议(如TCP)负责为需要这些功能的应用程序提供接收数据的可靠性和确认。

在某些情况下，这种具有较高层处理失败交付的设置就足够了。例如，假设设备A尝试发送到设备B，但B附近的路由器超载，因此它丢弃了该数据报。在这种情况下，问题可能是间歇性的，因此A可以重新传输并最终到达B。但是，如果设备试图发送到不存在的IP地址，或者路由问题不容易纠正，该怎么办？至少可以说，让源代码在其对问题仍然“一无所知”的情况下不断重试将是低效的。

因此，总的来说，虽然IP被设计为允许IP数据报传输失败，但我们应该认真对待任何此类失败。我们真正需要的是一种反馈机制，它可以告诉源设备正在发生不适当的事情，以及发生的原因。在IPv4中，此服务通过传输无法到达目的地的ICMP消息来提供。当源节点收到这些消息之一时，它知道发送数据报有问题，然后可以决定要采取什么操作(如果有的话)。与所有ICMP错误消息一样，无法到达目的地的消息包括无法传递的数据报的一部分，这有助于错误的接收者找出问题所在。

<u>**ICMPv4目标不可达报文格式**</u>

​                                                        <u>**表88和图139显示了ICMPv4目标不可达消息的特定格式**</u>

| **Field Name**                   | **Size (bytes)** | **Description**                                                            |
| -------------------------------- | ---------------- | -------------------------------------------------------------------------- |
| ***Type\***                      | 1                | ***Type:\***类型：标识ICMP消息类型；对于目标无法访问的消息，此设置为3。                               |
| ***Code\***                      | 1                | ***Code:\*** 代码：标识正在通信的无法访问错误的“子类型”。有关代码及其含义的完整列表，请参见表89。                  |
| ***Checksum\***                  | 2                | ***Checksum:\*** 校验和：ICMP报头的16位校验和字段，如ICMP公共消息格式主题中所述。                     |
| ***Unused\***                    | 4                | ***Unused:\*** 未使用：保留为空且未使用的4个字节。                                          |
| ***Original Datagram Portion\*** | Variable         | ***Original Datagram Portion:\*** 原始数据报部分：完整的IP报头和促使发送此错误消息的数据报有效载荷的前8个字节。 |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\icmpdestinationunreachable.png)

​                                                                  <u>**图139：ICMPv4目的地不可达消息格式**</u>

<u>**ICMPv4目标无法到达的消息子类型**</u>

数据报不可能到达其目的地有许多不同的原因。其中一些可能是由于错误的参数造成的(如上面提到的无效IP地址示例)。无论出于何种原因，路由器在到达特定网络时可能会出现问题。也可能有其他更深奥的原因，为什么数据报不能传递。

因此，ICMPv4目标无法到达消息类型实际上可以被视为一类相关的错误消息。收到目的地不可达消息会告诉设备它发送的数据报无法传送，而无法传送的原因由ICMP报头中的Code字段指示。表89显示了不同的代码值、对应的消息子类型以及各自的简要说明。

​                                                          **表89：ICMPv4目的地无法到达的消息子类型**

| **Code Value** | ***Message Subtype\***                                                       | **Description**                                                                                                                                                                                                               |
| -------------- | ---------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **0**          | ***Network Unreachable\***                                                   | 无法将数据报传递到IP地址的网络ID部分中指定的网络。通常意味着路由出现问题，但也可能是由错误地址引起的。                                                                                                                                                                         |
| **1**          | ***Host Unreachable\***                                                      | 数据报已发送到IP地址的网络ID部分中指定的网络，但无法发送到地址中指示的特定主机。同样，这通常意味着存在路由问题。                                                                                                                                                                    |
| **2**          | ***Protocol Unreachable\***                                                  | 协议字段中指定的协议对于接收数据报的主机无效。                                                                                                                                                                                                       |
| **3**          | ***Port Unreachable\***                                                      | UDP或TCP标头中指定的目标端口无效。                                                                                                                                                                                                          |
| **4**          | ***Fragmentation Needed and DF Set\***                                       | 这是一种“深奥”的密码。正常情况下，如果它接收的数据报对于数据报需要穿越的下一个物理网络链路的最大传输单元(MTU)太大，则IPv4路由器将自动将其分段。然而，如果在IP报头中设置了DF(不分段)标志，这意味着数据报的发送方不希望数据报被分段。这使路由器处于两难境地，它将被迫丢弃数据报并发送带有此代码的错误消息。这种消息类型通常以一种“巧妙”的方式使用，通过故意发送增大大小的消息来发现链路可以处理的最大传输大小。此过程称为MTU路径发现。 |
| **5**          | ***Source Route Failed\***                                                   | 如果在选项中为数据报指定了源路由，但路由器无法将数据报转发到路由中的下一步，则生成。                                                                                                                                                                                    |
| **6**          | ***Destination Network Unknown\***                                           | 未使用；改为使用代码0。                                                                                                                                                                                                                  |
| **7**          | ***Destination Host Unknown\***                                              | 指定的主机未知。这通常由目的主机本地的路由器生成，通常表示地址不正确。                                                                                                                                                                                           |
| **8**          | ***Source Host Isolated\***                                                  | 过时了，不再用了。                                                                                                                                                                                                                     |
| **9**          | ***Communication with Destination Network is Administratively Prohibited\*** | 与目的地网络的通信被管理禁止了                                                                                                                                                                                                               |
| **10**         | ***Communication with Destination Host is Administratively Prohibited\***    | 允许源设备向目的设备所在的网络发送，但不允许该特定设备发送。                                                                                                                                                                                                |
| **11**         | ***Destination Network Unreachable for Type of Service\***                   | 由于无法提供数据报头的服务类型字段中指定的服务，因此无法到达IP地址中指定的网络                                                                                                                                                                                      |
| **12**         | ***Destination Host Unreachable for Type of Service\***                      | 由于无法提供数据报头的服务类型字段中指定的服务，因此无法到达IP地址中指定的网络。                                                                                                                                                                                     |
| **13**         | ***Communication Administratively Prohibited\***                             | 该数据报无法被转发，原因是过滤系统根据信息的内容阻止了该信息                                                                                                                                                                                                |
| 14             | ***Host Precedence Violation\***                                             | 当服务类型字段中的Precedence值不允许时，由第一跳路由器（处理发送数据报的第一个路由器）发送                                                                                                                                                                            |
| 15             | ***Precedence Cutoff In Effect\***                                           | 路由器在收到优先级值低于当时网络允许的最小值的数据报时发送。                                                                                                                                                                                                |

正如您在该表中看到的那样，目前并不是所有这些代码都在积极使用。例如，代码8已过时，并且使用代码0而不是6。此外，与服务类型字段相关的一些较高数字未被有效使用，因为服务类型未被有效使用。

**关键概念：**ICMPv4目的地不可达消息用于通知发送设备无法传递IP数据报。邮件的代码字段提供有关传递问题的性质的信息。

<u>**无法到达目的地的消息的解释**</u>

最后，重要的是要记住，正如IP是“尽力而为”，使用ICMP报告无法到达的目的地也是“尽力而为”。首先，这些ICMP消息本身是在IP数据报中承载的。然而，更重要的是，我们必须记住，可能存在阻止路由器检测ICMP消息传递失败的问题，例如低级硬件问题。从理论上讲，路由器也可以被禁止发送ICMP消息，即使检测到传递失败，无论是什么原因。

因此，发送无法到达目的地的消息应被视为补充。不能保证每个发送数据报问题都会导致相应的ICMP消息。对于失败的传送，任何设备都不应指望收到无法到达的ICMP目的地，就像它首先不应指望传送一样。这就是为什么本主题开头提到的高层机制仍然很重要。

###### 3.2.2.1-2 ICMPv4源抑制消息(部分：1 2 3)

当源设备发出数据报时，它将通过网际网络传输，并最终到达其预期的目的地-希望如此。此时，应由目的设备通过检查数据报并确定将数据报交给哪个较高层软件进程来处理数据报。

如果目的地设备以相对较慢的速率接收数据报，则它可能能够在接收到每个数据报时对其进行“动态”处理。然而，典型网际网络中的数据报接收往往是不均匀的或“突发的”，具有交替的较高和较低的流量速率。为了允许数据报到达的速度快于处理它们的速度，每个设备都有一个缓冲区，在那里它可以临时保存它收到的数据报，直到它有机会处理它们。

但是，该缓冲区本身的大小是有限的。假设该设备已正确设计，则缓冲区可能足以在大部分时间内平滑高流量和低流量时段。某些情况仍然可能出现，在这些情况下，业务被接收得如此之快，以至于缓冲区本身完全被填满。可能发生这种情况的一些情况示例包括：

- 单个目的地被来自多个来源的数据报淹没，例如一个流行的网站被HTTP请求淹没。
- 设备A和设备B正在交换信息，但设备A是一台比设备B快得多的计算机，并且可以比设备B更快地生成传出和处理传入数据报。
- 路由器通过高速链路接收需要通过低速链路转发的大量数据报；这些数据报在等待通过低速链路发送时开始堆积。
- 硬件故障或其他情况会导致数据报停留在未处理的设备上。

当设备没有更多的缓冲区空间时，继续接收数据报的设备将被迫丢弃它们，并被称为拥塞。由于拥塞而丢弃其数据报的源将无法知道这一点，因为IP本身是不可靠和未被确认的。因此，虽然可以简单地允许高层协议检测丢弃的数据报并生成替换，但让拥塞的设备向源设备提供反馈，告诉他们它过载了，这要有意义得多。

在IPv4中，由于拥塞而被迫丢弃数据报的设备通过向其发送ICMPv4源抑制消息来向使其不堪重负的源提供反馈。就像我们用水来灭火一样，震源熄灭方法是一种试图扑灭发送速度过快的震源设备的信号。换句话说，这是一种礼貌的方式，让一台IP设备告诉另一台设备：“慢点！”当设备接收到其中一条消息时，它知道需要降低向发送数据报的设备发送数据报的速度。

<u>**ICMPv4源抑制消息格式**</u>

ICMPv4源抑制消息的具体格式见表90和图140

​                                                                   **表90：ICMPv4源抑制消息格式**

| **Field Name**                   | **Size (bytes)** | **Description**                                                         |
| -------------------------------- | ---------------- | ----------------------------------------------------------------------- |
| ***Type\***                      | 1                | ***Type:\***确定ICMP消息的类型；对于源抑制消息，该类型被设置为4                                |
| ***Code\***                      | 1                | ***Code:\*** 标识正在传达的错误的“子类型”。对于源抑制消息，不使用此字段，并且该字段设置为0。                  |
| ***Checksum\***                  | 2                | ***Checksum:\*** 校验和：ICMP报头的16位校验和字段，如ICMP公共消息格式主题中所述。                  |
| ***Unused\***                    | 4                | ***Unused:\***未使用：保留为空且未使用的4个字节。                                        |
| ***Original Datagram Portion\*** | Variable         | ***Original Datagram Portion:\*** 原始数据报部分：由于拥塞而丢弃的完整IP报头和数据报有效载荷的前8个字节。 |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\icmpsourcequench.png)

​                                                                 **图140:ICMPv4源抑制消息格式**

<u>**源抑制消息的问题**</u>

源代码抑制格式的有趣之处在于，它基本上是一条“空消息”。它告诉源设备目的地拥塞，但不提供有关该情况的具体信息，也不具体说明目的地希望源设备做什么，而只是以某种方式降低其传输速率。对于目的地来说，也没有方法来向它已经“熄灭”的源发出它不再拥塞的信号，并恢复其先前的发送速率。这意味着对源抑制的响应由接收它的设备决定。通常，设备会降低其传输速率，直到不再接收到消息，然后可能会再次尝试缓慢提高传输速率。

同样，对于设备最初何时以及如何生成源抑制消息，也没有任何规则。一种常见的约定是为每个丢弃的数据报生成一条消息。然而，可能会使用更智能的算法，特别是在更高端的路由器上，以预测设备的缓冲区何时将被填满，并先发制人地抑制某些发送太快的源。设备还可以决定是在忙碌时关闭所有信号源，还是只关闭某些信号源。与其他ICMP错误消息一样，当忙碌的设备丢弃其数据报之一时，设备不能指望发送源抑制。

源抑制消息中通信的信息不足，这使得它们成为管理拥塞的相当原始的工具。一般而言，控制两台设备之间的消息发送的过程称为流量控制，通常是传输层的功能。传输控制协议(TCP)实际上具有远优于使用ICMP源抑制消息的流控制机制。

源抑制消息的另一个问题是它们可能被滥用。当没有正当理由时，恶意用户传输这些消息可能会导致主机速度减慢。这个安全问题，再加上用于流量控制的TCP方法的优势，已导致源抑制消息在很大程度上失宠。

**关键概念：**ICMPv4源抑制消息由设备发送，以请求另一个设备降低其发送数据报的速率。与更强大的机制(如由TCP提供的机制)相比，它们是一种相当粗糙的流量控制方法。

###### 3.2.2.1-3 ICMPv4超时消息(部分： 1 2 3)

大型IP网际网络可以拥有数千台互连的路由器，这些路由器可以在不同网络上的设备之间传递数据报。在大型网际网络中，路由之间的连接拓扑可能会变得复杂，这会增加路由的难度。路由协议通常允许路由器找到网络之间的最佳路由，但在某些情况下，可能会为数据报选择效率较低的路由。

在最糟糕的低效路由情况下，可能会出现路由器环路。这种情况的一个例子是，路由器A认为发往网络X的数据报接下来应该发往路由器B；路由器B认为它们应该发往路由器C；而路由器C认为它们需要发往路由器A。(有关路由器环路的说明，请参阅ICMPv6超时消息说明。)。

如果发生这样的循环，进入互联网这一部分的网络X的数据报将永远循环，消耗带宽，最终导致网络不可用。为了防止这种情况的发生，每个IP数据报在其报头中都包括生存时间(TTL)字段。此字段最初旨在限制数据报在网际网络上的最长时间(以秒为单位)，但现在通过限制数据报可以从一台设备传递到另一台设备的次数来限制数据报的寿命。TTL由源设置为一个值，该值表示它希望数据报具有的最大跳数。每个路由器都会递减该值；如果该值达到零，则认为数据报已过期并被丢弃。

当数据报由于TTL字段到期而被丢弃时，丢弃该数据报的设备将通过向其发送ICMPv4超时消息来通知源发生这种情况，如图141所示。收到此消息会向原始发送设备表明，发送到该特定目的地时存在路由问题，或者它一开始就将TTL字段值设置得太低。与所有ICMP消息一样，接收该消息的设备必须决定是否以及如何响应消息的接收。例如，它可能首先尝试重新发送具有较高TTL值的数据报。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\icmpttlexpiration.png)

​                                                                            **图141：IP数据报过期和超时消息生成**

在本例中，设备A向设备B发送的IP数据报的生存时间(TTL)字段值仅为4(可能没有意识到B距离7跳)。在第四跳，数据报到达R4，R4将其TTL字段递减为零，然后将其丢弃为过期。然后，R4将ICMP超时消息发送回A。

还有另一种使用ICMP超时消息的“超时”情况。当IP报文被分成多个片段时，目的设备负责将它们重新组合成原始报文。**一个或多个碎片可能无法到达目的地，因此为了防止设备永远等待，它会在第一个碎片到达时设置计时器。如果此计时器在收到其他消息之前超时，则设备放弃此消息。这些片段被丢弃，并生成超时消息。**

<u>**ICMPv4超时消息格式**</u>

表91和图142显示了ICMPv4超时消息的特定格式

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\icmptimeexceeded.png)

​                                                                        <u>**图142：ICMPv4超时消息格式**</u>

​                                                                        **表91：ICMPv4超时报文格式**

| **Field Name**                   | **Size (bytes)** | **Description**                                                                      |
| -------------------------------- | ---------------- | ------------------------------------------------------------------------------------ |
| ***Type\***                      | 1                | ***Type:\***确定ICMP消息的类型；对于超时消息，它被设置为11。                                              |
| ***Code\***                      | 1                | ***Code:\*** 代码：标识正在传达的错误的“子类型”。值0表示IP生存时间字段过期；值1表示已超过片段重新组装时间。                      |
| ***Checksum\***                  | 2                | ***Checksum:\*** 校验和：ICMP报头的16位校验和字段，如ICMP公共消息格式主题中所述。                               |
| ***Unused\***                    | 4                | ***Unused:\*** 未使用：保留为空且未使用的4个字节。                                                    |
| ***Original Datagram Portion\*** | Variable         | ***Original Datagram Portion:\*** 原始数据报部分：由于TTL字段或重新组装计时器到期而丢弃的完整IP报头和数据报有效载荷的前8个字节。 |

<u>**超时报文的应用**</u>

作为ICMP错误消息类型，ICMP超时消息通常响应于上述两种情况(TTL或重组计时器超时)而发送。通常，生存时间到期消息是由路由器在尝试路由数据报时生成的，而重组违规则由终端主机指示。然而，这些消息实际上有一个非常巧妙的应用程序，与报告错误无关。

**关键概念：**ICMPv4超时报文在两种不同的“时间相关”情况下发送。第一种情况是如果数据报的生存时间(TTL)字段减少到零，导致数据报过期并丢弃数据报。第二种情况是，在接收方的重组计时器到期之前，没有收到碎片消息的所有片段。

TCP/IP Traceroute(或Tracert)实用程序用于显示数据报在源和目的地之间的特定路由上通过的设备序列，以及数据报到达该路由中的每一跳所需的时间量。该实用程序最初是使用超时消息通过发送具有连续较高TTL值的数据报来实现的。首先，发送一个TTL值为1的“伪”数据报，导致路由中的第一跳丢弃该数据报并发回一个超过ICMP超时的ICMP；为此所经过的时间可以测量。然后，发送TTL值为2的第二个数据报，导致路由中的第二个设备报告超时，依此类推。通过继续增加TTL值，我们可以从路由中的每一跳获得报告。有关其运行的更多详细信息，请参阅描述Traceroute的主题。

###### 3.2.2.1-4 ICMPv4重定向消息(部分：1 2 3)

网际网络中的每台设备都需要能够向其他所有设备发送数据。如果主机负责确定到每个可能目的地的路由，则每台主机都需要维护一组广泛的路由信息。由于网际网络上有如此多的主机，这将是非常耗时和维护密集的情况。

相反，IP网际网络是围绕一个基本的设计决策而设计的：路由器负责确定路由和维护路由信息。主机只确定它们何时需要路由数据报，然后将数据报传递给本地路由器，以便将其发送到需要发送到的地方。我将在我的IP路由概念概述中更详细地讨论这一点。

由于大多数主机不维护路由信息，因此它们必须依靠路由器来了解路由以及向何处发送发往不同目的地的数据报。通常，IP网络上的主机会从一个路由表开始，该表基本上告诉它将不在本地网络上的所有内容发送到单个默认路由器，然后默认路由器会计算出如何处理这些数据。显然，如果网络上只有一台路由器，主机将使用该路由器作为所有非本地流量的默认路由器。但是，如果有两台或更多路由器，则将所有数据报仅发送到一台路由器可能没有意义。可以将主机手动配置为知道将哪台路由器用于哪些目的地，但IP中的另一种机制可以让主机自动获知这一点。

假设网络N1包含多台主机(H1、H2等…)。和两台路由器，即R1和R2。主机H1已配置为将所有数据报发送到作为其默认路由器的R1。假设它想要向不同网络(N2)上的设备发送数据报。但是，使用R2而不是R1最直接地连接到N1。该数据报将首先发送到R1。R1将查看其路由表，发现需要通过R2发送有关N2的数据报。“但是等一下，”R1说。“R2在本地网络上，而H1在本地网络上--为什么还需要我做中间人？H1应该只将N2的数据报直接发送到R2，而不会将我排除在外。

在这种情况下，R1将向H1发回ICMPv4重定向消息，告诉它将来应该将此类数据报直接发送到R2。这如图143所示。当然，由于没有理由丢弃该数据报，因此R1也会将该数据报转发给R2进行传输。因此，尽管重定向消息通常与真正的ICMP错误消息一起分组，但实际上可以说，重定向消息根本不是错误消息；它们只是表示存在效率低下的情况，而不是彻底的错误。(事实上，在ICMPv6中，它们已被重新分类。)。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\icmpredirection.png)

​                                                             **图143：使用ICMP重定向消息的主机重定向**

在本例中，H1向R1发送去往网络N2的数据报。但是，R1注意到R2位于同一网络中，是通向N2的更直接的路由。它会将数据报转发到R2，但也会将ICMP重定向消息发送回H1，告知其下次使用R2。

<u>**ICMPv4重定向消息格式**</u>

ICMPv4重定向消息的格式可在表92和图144中找到

​                                                                    **表92：ICMPv4重定向消息格式**

| **Field Name**                   | **Size (bytes)** | **Description**                                                         |
| -------------------------------- | ---------------- | ----------------------------------------------------------------------- |
| ***Type\***                      | 1                | ***Type:\***类型：标识ICMP消息类型；对于重定向消息，此值为5。                                 |
| ***Code\***                      | 1                | ***Code:\*** 标识重定向消息的含义或“范围”。有关如何在重定向消息中使用该字段的说明，请参见表93                 |
| ***Checksum\***                  | 2                | ***Checksum:\*** ICMP报头的16位校验和字段，如有关ICMP通用消息格式的主题中所述。                   |
| ***Internet Address\***          | 4                | ***Internet Address:\*** 路由器的地址，将来发送到原始目的地的数据报应发送到该路由器。                 |
| ***Original Datagram Portion\*** | Variable         | ***Original Datagram Portion:\*** 原始数据报部分：导致创建重定向的完整IP报头和数据报有效载荷的前8个字节。 |

<u>**重定向消息解释代码**</u>

当设备收到重定向后，它会检查原始数据报中包含的部分。因为它包含重定向的目标设备的原始目的地址，所以它会告诉原始发送者将来应该重定向哪些地址。Internet地址字段告诉它应该使用哪个路由器来处理后续数据报。代码字段告诉发件人解释重定向的范围有多广。有四个不同的代码值；参见表93。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\icmpredirect.png)

​                                                         **图144：ICMPv4重定向消息格式**

显然，路由器通常会生成重定向消息并将其发送到主机；主机通常不会创建这些消息。何时创建重定向的特定规则可能相当复杂，因为可能存在许多阻止发送这些消息的条件。特别是，对于路由器何时可以重定向整个网络(或子网)而不是仅重定向单个主机，存在特殊的规则。此外，请记住，服务类型字段是可选的，通常不会使用，因此Code值为2或3的重定向比值为0和1的重定向不常见。

​                                                       **表93：ICMP重定向消息解释代码**

| **Code Value** | **Message Subtype**                                                        | **Meaning**                                                                         |
| -------------- | -------------------------------------------------------------------------- | ----------------------------------------------------------------------------------- |
| **0**          | *Redirect Datagrams For The Network (Or Subnet)*                           | 重定向所有未来发送的数据报，不仅重定向到其地址导致此重定向的设备，还重定向发送到该设备所在网络（或子网）上所有其他设备的数据报。（此代码现已过时；请参阅下表的注释。） |
| **1**          | *Redirect Datagrams For The Host*                                          | 仅针对原始数据报发送到的特定设备的地址重定向所有未来数据报。                                                      |
| **2**          | *Redirect Datagrams For The Type Of Service (TOS) and Network (Or Subnet)* | 对于代码值0，但仅适用于与原始数据报具有相同服务类型（TOS）值的未来数据报。（此代码现已过时；请参阅下表的注释。）                          |
| **3**          | *Redirect Datagrams For The Type Of Service (TOS) and Host*                | 对于代码值1，但仅适用于与原始数据报具有相同服务类型（TOS）值的未来数据报。                                             |

注意：整个网络的重定向的一个问题是，在使用子网划分或无类寻址的环境中，网络规范可能不明确。出于这个原因，RFC 1812禁止使用代码值0和2；它们在现代互联网上被认为是过时的。

**<u>重定向消息的限制</u>**

我必须强调，ICMP重定向消息不是用于实施IP中的一般路由过程的机制；它们只是一种支持功能。它们是本地路由器向主机提供有关路由的信息的一种便捷方式，但不用于在路由器之间通信路由信息。

这意味着重定向可以告诉主机使用更高效的第一跳路由器，但不能告诉路由器使用更高效的第二跳路由器。在上面的示例中，假设除了上述连接外，R2还连接到R3和R4，如图143所示。R2将有问题的数据报发送给R3，R3意识到它需要发送到R4，R4是一台已经直接连接到R2的路由器。R3无法向R2发送重定向通知其下次使用R4。这些消息根本不是为此目的而设计的-请记住，ICMP消息始终返回原始数据报的源，在本例中不是R2。这种效率低下的问题必须使用路由协议来解决。

**关键概念：**ICMPv4重定向消息由路由器用来通知主机首选路由器，以用于将来发送到特定主机或网络的数据报。它们不用于更改路由器之间的路由。

###### 3.2.2.1-5 ICMPv4参数问题消息(第1部分：第2部分)

本节前面的主题介绍了四种特定的ICMPv4消息类型，它们允许设备向数据报的原始发送方报告各种错误情况。但是，也可能出现与这四种特定消息类型中的任何一种都不对应的其他错误情况。通常，当设备尝试处理IP数据报的报头字段时，如果发现其中有一些不合理的内容，就会出现问题。

如果设备发现IP数据报头中的任何参数存在严重问题，以至于无法完成对该报头的处理，则必须丢弃该数据报。与必须丢弃数据报的其他情况一样，这种情况的严重性足以保证将问题传回发送原始数据报的设备。这是在ICMPv4中使用参数问题消息类型完成的。

这是一种可用于指示IP数据报的任何报头字段中的错误的“全部捕获”类型的消息。消息类型不包含用于指示问题所在的任何特定字段或编码。这是故意这样做的，以使参数问题消息保持“通用”，并确保它可以指示任何类型的错误。大多数参数问题消息不是特殊的错误代码，而是通过包括一个特殊指针来告诉原始源哪个参数导致了问题，该指针指示原始数据报头中的哪个字段导致了问题。

<u>**ICMPv4参数问题消息格式**</u>
表94和图145显示了ICMPv4参数问题消息的格式。

​                                                                  **表94：ICMPv4参数问题消息格式**

| **Field Name**                   | **Size (bytes)** | **Description**                                                                                   |
| -------------------------------- | ---------------- | ------------------------------------------------------------------------------------------------- |
| ***Type\***                      | 1                | ***Type:\*** 类型：标识ICMP消息类型；对于参数问题消息，该值为12。                                                        |
| ***Code\***                      | 1                | ***Code:\*** 代码：识别正在沟通的问题的“子类型”。有关参数问题消息的此字段的更多信息，请参见表95。                                         |
| ***Checksum\***                  | 2                | ***Checksum:\*** 校验和：ICMP报头的16位校验和字段，如ICMP公共消息格式主题中所述。                                            |
| ***Pointer\***                   | 1                | ***Pointer:\*** 指针：指向数据报中导致生成参数问题消息的字节位置的偏移量。接收ICMP消息的设备可以使用此值来了解原始消息中的哪个字段出现了问题。此字段仅在“代码”值为0时使用。 |
| ***Unused\***                    | 3                | ***Unused:\*** 未使用：3个字节留空且未使用。                                                                    |
| ***Original Datagram Portion\*** | Variable         | ***Original Datagram Portion:\*** 原始数据报部分：完整的IP报头和促使发送此错误消息的数据报有效载荷的前8个字节。                        |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\icmpparameterproblem.png)

​                                                                      **图145：ICMPv4参数问题报文格式**

<u>**参数问题消息解释代码和指针字段**</u>

当由于原始消息中的特定错误字段而生成参数问题消息时，如上所述使用指针字段来显示问题的位置。参数问题消息的这一含义是在原始ICMP标准RFC 792中定义的，并与代码值0相关联。在某些参数问题的情况下，指向原始消息中特定字段的指针确实没有意义，因此其他标准为参数问题消息定义了两个新的Code字段值。表95显示了三个代码值，并对每个值进行了简要说明。

​                                                  **表95：ICMPv4参数问题报文解释代码**

| **Code Value** | **Message Subtype**           | **Description**                         |
| -------------- | ----------------------------- | --------------------------------------- |
| **0**          | *Pointer Indicates The Error* | 这是参数问题消息的正常使用；使用此“代码”值时，“指针”字段指示问题的位置。  |
| **1**          | *Missing A Required Option*   | IP数据报需要有一个缺失的选项。当然，由于选项缺失，因此无法指出它。J     |
| **2**          | *Bad Length*                  | 数据报的总长度不正确，表明整个消息存在一般问题。同样，指针字段在这里没有意义。 |

**关键概念：**ICMPv4参数问题消息是一种通用的“全部捕获”，可用于在IP数据报中传递任何类型的错误。特殊的指针字段通常用于向消息的接收者指示原始数据报中的问题所在。

请注意，指针字段只有8位宽，但由于这允许值高达256，这足以允许它指向IP报头中的任何位置。指针字段可以指向IP选项内的字段。主机和路由器都可以生成参数问题消息。

###### 3.2.2.2 ICMP版本4(ICMPv4)信息性消息类型和格式

五种ICMP错误消息类型传达有关IP网际网络运行期间遇到的错误或问题条件的重要信息。相反，另一类ICMP消息包含具有信息性的消息。它们不是响应常规IP数据报的某些问题而发送的，而是自己用来实现对IP的各种支持功能。信息性消息用于测试和诊断目的，以及让设备共享正常运行所需的关键信息。

在本节中，我将介绍九种不同的ICMP版本4信息性消息。由于这些消息中有许多是在功能集中使用的，因此相关消息对将在同一主题中介绍。我首先讨论用于网络测试的Echo(请求)和Echo回复消息，以及用于时钟同步的时间戳和时间戳回复消息。我解释了路由器通告和路由器请求消息的用法和格式，它们允许主机发现本地路由器的身份并了解有关它们的重要信息。我还介绍了用于传递子网掩码信息的地址掩码请求和地址掩码回复消息。最后，我来看一下Traceroute消息，它实现了更复杂版本的Traceroute实用程序。

注意：最初的ICMP标准还定义了另外两种信息性消息类型：信息请求和信息回复。它们旨在允许设备确定IP地址和可能的其他配置信息。此功能后来使用RARP、BOOTP和DHCP等协议实现，这些消息类型已过时。因此，它们不会在本节中讨论。(嗯，我想我只是在那里讨论了一下……。你知道我的意思！)。

###### 3.2.2.2-1 ICMPv4回声(请求)和回声应答消息(部分：1 2 3)

ICMP信息性消息的主要目的之一是启用测试和诊断，以帮助识别和纠正网际网络上的问题。可以在两台设备之间进行的最基本测试只是检查它们是否能够相互发送数据报。通常的方法是让一台设备向另一台设备发送测试消息，第二台设备收到该消息并回复，告诉第一台设备它收到了该消息。

ICMPv4包括一对专门用于连接测试的消息。假设设备A想要查看它是否可以到达设备B。设备A通过向B发送ICMPv4 Echo消息开始测试过程。设备B在接收到Echo时，用Echo回复消息响应设备A。当设备A接收到该消息时，它知道它能够与设备B成功通信(发送和接收)。

**注意：**此消息对中第一条消息的名称通常为Echo Request.。虽然这确实传达了Echo和Echo回复消息的配对性质，但标准中使用的正式名称只是Echo消息。

<u>**ICMPv4 Echo和Echo回复消息格式**</u>

表96和图146显示了ICMPv4 Echo 和Echo 回复消息的格式

| **Field Name**         | **Size (bytes)** | **Description**                                        |
| ---------------------- | ---------------- | ------------------------------------------------------ |
| ***Type\***            | 1                | ***Type:\*** 类型：标识ICMP消息类型。对于回声消息，值为8；对于回声回复消息，值为0。    |
| ***Code\***            | 1                | ***Code:\*** 代码：不用于回音和回音回复消息；设置为0。                     |
| ***Checksum\***        | 2                | ***Checksum:\*** 校验和：ICMP报头的16位校验和字段，如ICMP公共消息格式主题中所述。 |
| ***Identifier\***      | 2                | ***Identifier:\*** 标识符：可用于帮助匹配回音和回音回复消息的标识字段。          |
| ***Sequence Number\*** | 2                | ***Sequence Number:\*** 序号：有助于匹配回音和回音回复消息的序号。          |
| ***Optional Data\***   | Variable         | ***Optional Data:\*** 可选数据：与消息一起发送的附加数据（未指定）           |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\icmpecho.png)

​                                                               **图146：ICMPv4回声和回声回复消息格式**

源设备可能想要向单个目的地或多个目的地发送多个Echo消息。相反，单个目的地可能会从多个源接收Echo消息。收到Echo回复的设备必须知道是哪个Echo促使其发送的。

在这些消息的格式中使用了两个特殊字段，以允许Echo和Echo回复消息匹配在一起，并允许交换一系列消息。标识符字段被设想为用作更高级别的标签，类似于会话标识符，而序列号被视为标识一系列中的单个测试消息的东西。但是，这些字段的使用取决于特定的实现。在某些情况下，使用Echo或Echo回复消息的应用程序的进程号填充标识符字段，以允许多个用户不受干扰地使用诸如ping之类的实用程序。

 <u>**Echo和Echo回复报文的应用**</u>

使用Echo和Echo回复消息的最常见方式是通过常用的实用程序ping，该实用程序用于测试主机的可达性。虽然基本测试只是发送Echo并等待Echo回复，但现代版本的ping相当复杂。它们允许用户指定许多参数，包括发送的Echo消息的数量、发送频率、传输的消息大小等。它们还提供有关连接的大量信息，包括接收的Echo回复消息的数量、交换消息对所用的时间等等。有关该实用程序的完整解释，请参阅描述ping的主题。

**关键概念**：IICMPv4 Echo(请求)和Echo Reply消息用于促进网络可达性测试。一台设备可以通过发送Echo消息并等待另一台设备返回Echo回复来测试其与另一台设备执行基本通信的能力。Ping实用程序是TCP/IP网际网络中广泛使用的诊断工具，它利用这些消息。

###### 3.2.2.2-2 ICMPv4时间戳(请求)和时间戳回复消息(部分：1 2 3)

网际网络上的所有主机和路由器彼此独立运行。这种自主性的一个方面是每个设备维护一个单独的系统时钟。由于即使是高精度的时钟在计时的精确度和初始化时间方面也有细微的差异，这意味着在正常情况下，网际网络上的两台设备不能保证具有完全相同的时间。

TCP/IP的创建者认识到，如果一对设备的系统时钟差异太大，某些应用程序可能无法正常工作。为了支持这一要求，他们创建了一对ICMP消息，允许设备交换系统时间信息。发起设备创建时间戳消息，并将其发送到它希望与之同步的设备。该设备使用时间戳回复消息进行响应。这些消息中的时间戳字段用于标记发送和接收这些消息的时间，以允许同步设备的时钟。

**注意：**与Echo消息一样，时间戳消息有时被视为时间戳请求，尽管“请求”一词不会出现在其正式名称中。

<u>**ICMPv4时间戳和时间戳回复报文格式**</u>

ICMPv4时间戳和时间戳回复消息具有相同的格式。始发设备填写一些字段，回复设备填写其他字段。格式如表97和图147所示。
                                                  **表97：ICMPv4时间戳和时间戳回复报文格式**

| **Field Name**             | **Size (bytes)** | **Description**                                           |
| -------------------------- | ---------------- | --------------------------------------------------------- |
| ***Type\***                | 1                | ***Type:\*** 类型：标识ICMP消息类型。对于时间戳消息，值为13；对于时间戳回复消息，值为14。   |
| ***Code\***                | 1                | ***Code:\***不用于时间戳和时间戳回复消息；设置为0                           |
| ***Checksum\***            | 2                | ***Checksum:\*** 校验和：ICMP报头的16位校验和字段，如ICMP公共消息格式主题中所述。    |
| ***Identifier\***          | 2                | ***Identifier:\*** 标识符：可用于帮助匹配时间戳和时间戳回复消息的标识字段。           |
| ***Sequence Number\***     | 2                | ***Sequence Number:\*** 序号：帮助匹配时间戳和时间戳回复消息的序号。            |
| ***Originate Timestamp\*** | 4                | ***Originate Timestamp:\*** 始发时间戳：始发设备在发送时间戳消息之前填写的时间值。   |
| ***Receive Timestamp\***   | 4                | ***Receive Timestamp:\***  接收时间戳：响应设备在接收时间戳消息时填写的时间值。     |
| ***Transmit Timestamp\***  | 4                | ***Transmit Timestamp:\*** 传输时间戳：响应设备在发送回时间戳回复消息之前填写的时间值。 |

​                                                   <u>**图147：ICMPv4时间戳和时间戳回复报文格式**</u>

标识符字段和序列号字段用于匹配时间戳和时间戳回复消息，与用于Echo和Echo回复消息的完全相同。标识符字段用作更高级别的标签，就像会话标识符一样，而序列号通常用于标识一系列中的单个消息。但是，这些字段的使用取决于特定的实现。

所有三个时间戳都表示为自午夜以来的毫秒数，世界时间(UT，也称为格林威治标准时间或GMT)。之所以有三个时间戳，而不是您通常预期的两个，是因为响应设备在接收时间戳消息和生成时间戳回复时都会记录一个单独的时间戳。当始发设备收到回复时，它将具有发送时间戳和时间戳回复的时间。这允许始发设备区分通过网络传输数据报所需的时间，以及另一台设备处理时间戳并将其转换为时间戳回复的时间。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\icmptimestamp.png)

​                                             **图147:ICMPv4时间戳和时间戳回复消息格式**

标识符和序列号字段用于匹配时间戳和时间戳回复消息，与它们用于回声和回声回复消息完全相同。Identifier字段用作更高级别的标签，如会话标识符，而Sequence Number通常用于标识序列中的单个消息。然而，这些字段的使用取决于具体的实现。

所有三个时间戳都表示为自午夜以来的毫秒数，即世界时（UT，也称为格林威治标准时间或GMT）。有三个时间戳而不是您通常预期的两个时间戳的原因是，响应设备在接收时间戳消息和生成时间戳回复时都会记录一个单独的时间戳。当发端设备收到回复时，它会显示发送时间戳和时间戳回复的时间。这允许始发设备区分通过网络传输数据报所需的时间和其他设备处理时间戳并将其转换为时间戳回复的时间。

<u>**使用时间戳和时间戳回复消息的问题**</u>

在实践中，即使有三个时间戳字段，也很难在网际网络上协调系统时钟-特别是像Internet这样的大型网络。主要问题是，在任何一对设备之间发送数据报所需的时间因数据报而异。同样，由于IP不可靠，接收数据报的时间可能是无限的--它可能会被路由器丢失或丢弃。

这意味着简单地交换时间戳和时间戳回复消息不是确保两个设备在典型IP网际网络上同步的足够可靠的方法。因此，现代设备通常使用更复杂的时间同步方法，例如网络时间协议(NTP)。

请注意，与许多其他ICMP消息类型不同，对时间戳和时间戳回复消息的支持对于主机和路由器都是可选的。

###### 3.2.2.2-3 ICMPv4路由器通告和路由器请求消息(第1部分：2 3 4)

在描述IP路由基础知识的概述主题中，我讨论了IP网际网络设计的一个重要方面：路由器和主机在路由方面的角色差异。路由器负责路由数据报，因此了解路由并交换路由信息。主机通常不太了解路由；它们依靠路由器来传输发往本地网络以外目的地的数据报。

这种依赖性意味着主机在真正加入网际网络之前，需要知道本地网络中至少一台路由器的身份。确保这种情况的一种方法是，只需手动将每台主机的本地路由器地址配置为其默认路由器。这种方法很简单，但具有与手动流程相关的典型缺点--设置耗时、难以维护且缺乏灵活性。

<u>**路由器发现过程**</u>
如果有某种方法，主机可以自动发现本地路由器的身份，并了解有关它们的重要信息，那就更好了。在IP中，此过程称为路由器发现，最先在RFC 1256，ICMP路由器发现消息中定义。RFC标题中引用的消息是ICMP路由器通告消息和路由器请求消息，并被添加到早期标准(如RFC 792)中定义的ICMP消息类型。

路由器负责发送路由器通告消息。这些消息告诉侦听设备路由器存在，并提供有关路由器的重要信息，例如其地址(如果有多个地址，则为多个地址)以及主机应保留有关路由器的信息多长时间。例行路由器通告消息定期发送，消息之间的时间可由管理员配置(通常在7到10分钟之间)。主机侦听这些消息；当收到通告时，主机会对其进行处理，并将有关路由器的信息添加到其路由表中。

没有手动配置的路由信息的主机在第一次开机时将不知道路由器。让它等待许多分钟来寻找例行的路由器通告消息是效率低下的。主机可以在其本地网络上发送路由器请求消息，而不是等待。这将提示任何听到它的路由器立即向该主机直接发送额外的路由器通告消息。

<u>**ICMPv4路由器通告消息格式**</u>

ICMPv4路由器通告消息格式如表98和图148所示

​                                                              **表98：ICMPv4路由器通告消息格式**

| **Field Name**                | **Size (bytes)**               | **Description**                                                                                       |
| ----------------------------- | ------------------------------ | ----------------------------------------------------------------------------------------------------- |
| ***Type\***                   | 1                              | ***Type:\*** 类型：标识ICMP消息类型。对于路由器通告消息，值为9。                                                             |
| ***Code\***                   | 1                              | ***Code:\*** 代码：通常设置为0。当移动IP代理使用代理广告扩展发送路由器广告时，如果设备仅为移动代理且不打算处理正常流量，则可以将值设置为16。有关详细信息，请参阅移动IP代理发现的讨论。 |
| ***Checksum\***               | 2                              | ***Checksum:\*** 校验和：ICMP报头的16位校验和字段，如ICMP公共消息格式主题中所述。                                                |
| ***Num Addrs\***              | 1                              | ***Number Of Addresses:\*** 地址数：此播发中包含的与此路由器关联的地址数。                                                   |
| ***Addr Entry Size\***        | 1                              | ***Address Entry Size:\*** 地址条目大小：每个地址包含的32位信息字数。由于在这种消息格式中，每个路由器地址都有一个32位地址和一个32位元优先级别，因此该值固定为2。     |
| ***Lifetime\***               | 2                              | ***Lifetime:\*** 生存时间：主机认为此消息中的信息有效的秒数。                                                               |
| ***Router Address Entries\*** | Value of *Num Addrs* field * 8 | ![img](http://www.tcpipguide.com/free/aa1f99a4.png)                                                   |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\icmprouteradvertisement.png)

​                                                                     **图148：ICMPv4路由器通告消息格式**

<u>**ICMPv4路由器请求消息格式**</u>

ICMPv4路由器请求消息要简单得多，因为它们只需要传达一条信息：“如果您是一台路由器，并且可以听到此消息，请向我发送路由器通告”。因此，该格式只是表99和图149所示的一组微不足道的字段。

​                                                             **表99：ICMPv4路由器请求消息格式**

| **Field Name**  | **Size (bytes)** | **Description**                                        |
| --------------- | ---------------- | ------------------------------------------------------ |
| ***Type\***     | 1                | ***Type:\*** 类型：标识ICMP消息类型。对于路由器请求消息，值为10。             |
| ***Code\***     | 1                | ***Code:\*** 代码：未使用；值设置为0。                             |
| ***Checksum\*** | 2                | ***Checksum:\*** 校验和：ICMP报头的16位校验和字段，如ICMP公共消息格式主题中所述。 |
| ***Reserved\*** | 4                | ***Reserved:\*** 保留：4个保留字节作为0发送。                       |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\icmproutersolicitation.png)

​                                                                   **图149：ICMPv4路由器请求消息格式**

<u>**路由器通告和路由器请求消息的寻址和使用**</u>

如果可能，为了提高效率，路由器通告和路由器请求消息都会通过组播发送。路由器通告使用“所有设备”组播地址(224.0.0.1)，因为它们旨在供主机监听，而路由器请求消息使用“所有路由器”组播地址(224.0.0.2)。如果本地网络不支持组播，消息将改为广播发送(地址为255.255.255.255)。

请务必记住，就像ICMP重定向消息一样，路由器通告消息不是交换路由信息的通用方法。它们只是一种支持机制，用于通知主机路由器的存在。有关路由的详细信息使用RIP和OSPF等路由协议在路由器之间进行通信。

我还应该提到，虽然我建议路由器发现是手动配置主机默认路由器的替代方案，但也有其他替代方案。例如，像DHCP这样的主机配置协议可以让主机获知本地网络中默认路由器的地址。

最后，请注意，在实施移动IP时，路由器通告消息被用作支持移动IP的路由器发送代理通告的基础。将一个或多个特殊分机添加到常规路由器通告格式以创建代理通告。这在关于移动IP代理发现的主题中进行了广泛的讨论。

**关键概念：**ICMP路由器通告消息由IP路由器定期发送，以通知主机它们的存在和特征，因此主机知道使用它们将数据报传递到远程主机。新加入网络并希望立即找出存在哪些路由器的主机可能会发送路由器请求，这将提示侦听路由器发出路由器通告。

###### 3.2.2.2-4 ICMPv4地址掩码请求和回复消息(第1部分：第2部分)

在最初开发Internet协议时，IP地址基于简单的两级结构，具有网络标识符和主机标识符。为了提供更大的灵活性，很快开发了一种称为子网划分的技术，该技术将寻址方案扩展为三级结构，每个地址包含一个网络标识符、一个子网标识符和一个主机标识符。子网掩码是一个32位数字，它告诉设备(和用户)哪些位是子网标识符的一部分，而不是主机标识符。所有这些都在IP寻址一节中进行了相当详细的描述。

要在子网划分环境中正常运行，每台主机必须知道与分配给它的每个地址对应的子网掩码-如果没有掩码，它就无法正确解释IP地址。就像确定本地路由器的身份一样，主机可以手动或自动获得本地网络的子网掩码。手动方法是将子网掩码手动分配给每台主机。自动方法使用一对ICMP消息来确定子网掩码，这些消息在RFC 950中定义，而RFC 950与定义子网划分本身的标准相同。

要使用此方法，主机在本地网络上发送地址掩码请求消息，通常是为了从路由器获得响应。如果它知道本地路由器的地址，它可以直接发送请求(单播)，否则会将其广播到任何侦听路由器。本地路由器(或其他设备)有望收到此消息，并返回包含本地网络的子网掩码的地址掩码回复。此过程与主机请求路由器使用路由器通告进行响应的机制有些类似，不同之处在于路由器不会定期发送子网掩码信息；必须请求该信息。

<u>**ICMPv4地址掩码请求和地址掩码回复报文格式**</u>

与其他一些请求/回复对一样，地址掩码请求和地址掩码回复具有相同的基本格式-主机创建请求时填写了除子网掩码值之外的所有字段，路由器提供掩码并将回复发送回主机。格式如表100和图150所示。

​                                                **表100：ICMPv4地址掩码请求和地址掩码回复消息格式**

| **Field Name**         | **Size (bytes)** | **Description**                                              |
| ---------------------- | ---------------- | ------------------------------------------------------------ |
| ***Type\***            | 1                | ***Type:\*** type：标识ICMP消息类型。对于地址掩码请求消息，值为17；对于地址掩码回复消息，它是18 |
| ***Code\***            | 1                | ***Code:\*** 代码：不用于任何消息类型；设置为0。                              |
| ***Checksum\***        | 2                | ***Checksum:\*** 校验和：ICMP报头的16位校验和字段，如ICMP公共消息格式主题中所述。       |
| ***Identifier\***      | 2                | ***Identifier:\***标识符：可用于帮助匹配地址掩码请求和地址掩码回复消息的标识字段。           |
| ***Sequence Number\*** | 2                | ***Sequence Number:\*** 序号：帮助匹配地址掩码请求和地址掩码回复消息的序号。           |
| ***Address Mask\***    | 4                | ***Address Mask:\*** 地址掩码：本地网络的子网掩码，由路由器在地址掩码回复消息中填写。        |

标识符字段和序列号字段可用于匹配请求和回复，就像它们用于Echo和Echo回复消息一样。然而，主机通常不会像发送用于测试的Echo消息那样发送多个子网掩码请求。出于这个原因，某些实现可以忽略标识符字段和序列号字段。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\icmpaddressmask.png)

​                                                      **图150：ICMPv4地址掩码请求和地址掩码回复消息格式。**

<u>**地址掩码请求和地址掩码回复消息的使用**</u>
地址掩码请求和地址掩码回复消息的使用是可选的，就像上一主题中描述的路由器发现一样。除了这些消息或手动配置之外，还可以使用其他方法来告诉主机要使用哪个子网掩码。同样，ICMP的一个常见替代方案是主机配置协议，如TCP/IP动态主机配置协议(DHCP)。路由器必须能够响应选择发送地址掩码请求的主机。

###### 3.2.2.2-5 ICMPv4跟踪路由消息**Traceroute**(第1部分：第2部分)

我们在本部分前面介绍的Echo和Echo回复消息用于可在两台设备之间执行的最基本类型的测试：检查它们是否可以通信。还可以执行更复杂的测试，不仅查看设备是否能够通话，还可以发现用于在它们之间传输数据报的路由器的确切顺序。在TCP/IP中，此诊断是使用Traceroute(或tracert)实用程序执行的。

Traceroute的第一个实现巧妙地应用了超时错误消息。通过首先将生存时间值为1、然后是2、然后是3的测试消息发送到目的地，源和目的地之间路径上的每台路由器将连续丢弃测试消息并发回超时消息，从而显示两台主机之间的路由器序列。总的来说，这种“诡计”效果不错，但在几个方面不是最优的。例如，它要求源设备为路径中的每台路由器发送一条测试消息，而不是仅发送一条测试消息。它也没有考虑到两个设备之间的路径在测试期间可能发生变化的可能性。

认识到这些局限性，1993年制定了一项新的实验标准，该标准定义了一种更有效地执行Traceroute的方法：RFC 1393，Traceroute使用IP选项。正如标题所示，这种执行Traceroute的方法的工作原理是使源设备向目的设备发送包含特殊Traceroute IP选项的单个数据报。当测试消息沿路由传递时，每台路由器都会看到该选项，并使用RFC 1393中定义的ICMP Traceroute消息响应原始源。

**ICMPv4 Traceroute消息格式**

由于Traceroute消息是专门为Traceroute实用程序设计的，因此可以在其中包含跟踪路由的主机使用的额外信息。消息格式如表101和图151所示。

​                                                                    **表101：ICMPv4 Traceroute消息格式**

| **Field Name**            | **Size (bytes)** | **Description**                                                           |
| ------------------------- | ---------------- | ------------------------------------------------------------------------- |
| ***Type\***               | 1                | ***Type:\*** 类型：标识ICMP消息类型，在本例中为30。                                       |
| ***Code\***               | 1                | ***Code:\*** 代码：如果源设备发送的数据报已成功发送到下一个路由器，则设置为0；如果设置为1，则表示数据报已丢弃（表示跟踪路由失败）。 |
| ***Checksum\***           | 2                | ***Checksum:\*** 校验和：ICMP报头的16位校验和字段，如ICMP公共消息格式主题中所述。                    |
| ***ID Number\***          | 2                | ***ID Number:\*** ID编号：用于将此跟踪路由消息与源发送的原始消息（包含跟踪路由IP选项的消息）匹配的标识字段。         |
| ***Unused\***             | 2                | ***Unused:\*** 未使用：未使用，设置为0。                                              |
| ***Outbound Hop Count\*** | 2                | ***Outbound Hop Count:\*** 出站跃点计数：原始邮件已通过的路由器数。                           |
| ***Return Hop Count\***   | 2                | ***Return Hop Count:\*** Return Hop Count：返回消息通过的路由器数。                    |
| ***Output Link Speed\***  | 4                | ***Output Link Speed:\*** 输出链路速度：发送跟踪路由消息的链路速度，单位为字节/秒                    |
| ***Output Link MTU\***    | 4                | ***Output Link MTU:\*** 输出链路MTU：发送跟踪路由消息的链路的最大传输单位（MTU），以字节为单位。           |

​              ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\icmptraceroute.png)                                                                                

​                                                       **图151：ICMPv4 Traceroute消息格式**

**为什么Traceroute报文没有被广泛使用**
**请注意，**虽然这种实施Traceroute的方法确实比旧的超时方法有优势，但它也有一个严重的缺陷：它需要更改主机和路由器以支持新的IP选项和Traceroute ICMP消息。人们对变化不大，特别是在知识产权的基本运营方面。出于这个原因，RFC 1393从未超过“实验”状态，而且大多数IP设备仍然使用实现Traceroute的旧方法。但是，您可能会遇到ICMP Traceroute消息，因此知道它们的存在是件好事。

**关键概念**：ICMP Traceroute报文旨在为实施Traceroute(Tracert)实用程序提供一种更有效的方式。但是，大多数TCP/IP实施仍然使用ICMP超时消息来执行此任务。

###### 3.2.2.3 ICMP版本6(ICMPv6)错误消息类型和格式

最初的ICMP为网际协议(IPv4)的版本4定义了许多错误消息，以允许在网际网络上通信问题。当开发IP版本6(IPv6)时，IPv4和IPv6之间的差异非常显著，以至于还需要一个新版本的ICMP：用于互联网协议版本6(IPv6)的互联网控制消息协议(ICMPv6)，目前在RFC 2463中指定。与ICMPv4一样，ICMPv6定义了几条错误消息，以便在出现错误时通知来源。

在本节中，我将介绍RFC 2463中定义的四条ICMPv6错误消息。我首先讨论ICMPv6目标不可达消息，用于告诉设备其发送的数据报由于各种原因而无法传递。我描述了Packet Too Big错误消息，当数据报由于对于它需要遍历的底层网络来说太大而无法发送时，将发送这些消息。我解释了超时消息的用法，超时消息表示完成传输花费了太多时间。最后，我来看一下消息，这些消息提供了报告前面任何ICMPv6错误消息类型都没有描述的错误的通用方法。

注：四条ICMPv6错误消息中的三条(数据包太大除外)与同名的ICMPv4错误消息相同。然而，为了使这一部分独立存在，除了指出ICMPv4和ICMPv6版本之间的任何重大差异外，我还对每一个版本进行了完整的描述。

###### 3.2.2.3-1 ICMPv6目标无法到达的消息(部分： 1 2 3)

互联网协议(IPv6)版本6在旧版本4的基础上进行了一些重要的增强，但这两种协议的基本操作仍基本相同。与IPv4一样，IPv6也是一种不可靠的网络协议，它会尽“最大努力”传递数据报，但不能保证它们会一直到达那里。就像在IPv4中的情况一样，IPv6网络上的设备不能假设发送到目的地的数据报总是会被接收。

当数据报不能被传送时，从这种情况下恢复通常落到更高层的协议，如TCP，它将检测错误通信并重新发送丢失的数据报。在某些情况下，例如由于路由器拥塞而丢弃的数据报，这就足够了，但在其他情况下，数据报可能由于发送方式的固有问题而无法传送。例如，源可能指定了无效的目的地址，这意味着即使多次重新发送，数据报也永远不会到达其预期的接收方。

一般来说，让源只重新发送未送达的数据报，而不知道它们为什么会丢失，这是效率低下的。最好有一种反馈机制，可以将无法传递的数据报告知源设备，并提供有关数据报传递失败原因的一些信息。与ICMPv4中一样，在ICMPv6中，这是通过无法到达目的地的消息来完成的。每条消息都包括一个代码，该代码指示导致数据报无法传送的问题的基本性质，并包括所有或部分未传送的数据报，以帮助源设备诊断问题。

<u>**ICMPv6目标不可达报文格式**</u>

表102和图152说明了ICMPv6目标不可达消息的特定格式：

​                                                             **表102：ICMPv6目的地不可达报文格式**

| **Field Name**                   | **Size (bytes)** | **Description**                                                                                                  |
| -------------------------------- | ---------------- | ---------------------------------------------------------------------------------------------------------------- |
| ***Type\***                      | 1                | ***Type:\*** 类型：标识ICMPv6消息类型；对于目标无法访问的邮件，此设置为1。                                                                  |
| ***Code\***                      | 1                | ***Code:\*** 代码：标识正在通信的无法访问错误的“子类型”。有关代码及其含义的完整列表，请参见表103。                                                       |
| ***Checksum\***                  | 2                | ***Checksum:\*** 校验和：ICMP报头的16位校验和字段，如ICMP公共消息格式主题中所述。                                                           |
| ***Unused\***                    | 4                | ***Unused:\*** 未使用：保留为空且未使用的4个字节。                                                                                |
| ***Original Datagram Portion\*** | Variable         | ***Original Datagram Portion:\*** 原始数据报部分：尽可能多的IPv6数据报，而不会导致ICMPv6错误消息（包括其自身的IP报头）的大小超过1280字节的最小IPv6最大传输单元（MTU）。 |

​                                                         ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\icmpv6destinationunreachable.png)        

​                                              **图152：ICMPv6目的地不可达消息格式**

<u>**ICMPv6目标无法到达消息子类型**</u>

目的地可能无法到达有许多不同的原因。为了向最初尝试发送数据报的设备提供有关问题性质的其他信息，需要在消息的代码字段中放置一个值。ICMPv4和ICMPv6 Destination Unreacable消息之间的一个有趣区别是ICMPv6的Code值要少得多。ICMPv6 Code值被“简化”，主要是因为几个ICMPv4代码与不适用于ICMPv6的相对鲜为人知的功能相关。

表103显示了不同的代码值、对应的消息子类型以及各自的简要说明：

​                                             **表103：ICMPv6目的地无法到达的消息子类型**

| **Code Value** | **Message Subtype**                                          | **Description**                                                              |
| -------------- | ------------------------------------------------------------ | ---------------------------------------------------------------------------- |
| **0**          | *No Route To Destination*                                    | 数据报未传递，因为它无法路由到目标。由于这意味着数据报无法发送到目标设备的本地网络，这基本上等同于ICMPv4中的“网络无法访问”消息子类型。      |
| **1**          | *Communication With Destination Administratively Prohibited* | 无法转发数据报，因为筛选会根据其内容阻止消息。等效于ICMPv4中具有相同名称（和代码值13）的消息子类型。                       |
| **3**          | *Address Unreachable*                                        | 试图将数据报传递到目标地址中指定的主机时出现问题。此代码相当于ICMPv4“主机无法访问”代码，通常表示目标地址不正确或将其解析为第二层地址时出现问题。 |
| **4**          | *Port Unreachable*                                           | UDP或TCP标头中指定的目标端口无效或在目标主机上不存在。                                               |

请注意，不使用代码值2。此外，只有在传送特定数据报出现根本问题时，才会发送无法到达目的地的消息；当仅仅由于路由器拥塞而丢弃数据报时，不会发送这些消息。

<u>**目标不可达消息的处理**</u>
如何处理该消息由ICMPv6目标不可达消息的接收方决定。然而，正如原始数据报可能无法到达其目的地一样，无法到达目的地的消息本身也是如此。因此，设备不能依靠收到这些错误消息之一来通知它每个传输问题。在某些无法到达的目的地问题可能无法检测到的情况下，情况尤其如此。

**关键概念：**ICMPv6 Destination Unreacable报文的使用方式与同名的ICMPv4报文相同：通知发送设备发送IP数据报失败。消息的Code字段提供有关传递问题的性质的信息(尽管Code值与ICMPv4中的值不同)。

###### 3.2.2.3-2 ICMPv6数据包太大消息(第1部分：第2部分)

在版本6中，对互联网协议的操作所做的最有趣的改变之一与数据报分段和重组过程有关。在IPv4中，主机可以将IP规范允许的任何大小的数据报发送到网际网络。如果路由器需要通过物理链路发送数据报，而该物理链路的最大传输单元(MTU)大小对于数据报的大小来说太小，则路由器将自动对数据报进行分段并逐个发送分段，以使其适合。目的设备将接收碎片并将其重新组装。我在关于IPv4数据报大小、MTU、分段和重组的一节中解释了这一点背后的基本知识。

**注意：**回想一下，“包”是“数据报”的同义词。我通常使用后一个术语，但这条消息的名称中有“Packet”，而且我不像是要更改它！

尽管主机能够依赖路由器根据需要自动分割消息是很方便的，但路由器花时间做这件事效率很低。出于这个原因，在IPv6中决定不允许路由器对数据报进行分段。这使得每台主机都有责任确保它们发送的数据报足够小，以适合其自身和任何目的地之间的每个物理网络。这可以通过使用每条物理链路都必须支持的IPv6默认最小MTU 1280来实现，也可以通过特殊路径MTU发现过程来确定一对设备之间的最小MTU。同样，完整的细节在IPv6数据报大小、MTU、分段和重组的讨论中介绍。

如果不允许IPv6路由器将过大的IPv6数据报分段到必须通过其转发的下一条物理链路上，路由器应该如何处理该数据报？数据报无法转发，因此路由器别无选择，只能将其丢弃。发生这种情况时，路由器需要使用ICMPv6 Packet Too Big(ICMPv6数据包太大)消息将这种情况报告给最初发送数据报的设备。源设备将知道它需要对数据报进行分段，才能使其成功到达目的地。

<u>**ICMPv6数据包太大消息格式**</u>

表104和图153显示了ICMPv6数据包太大消息的格式：

| **Field Name**                   | **Size (bytes)** | **Description**                                                                                                                       |
| -------------------------------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------- |
| ***Type\***                      | 1                | ***Type:\*** 标识ICMPv6消息类型；对于Packet Too Big消息，这被设置为2。                                                                                  |
| ***Code\***                      | 1                | ***Code:\*** 代码：此消息类型不使用；设置为0。                                                                                                        |
| ***Checksum\***                  | 2                | ***Checksum:\*** 校验和：ICMP报头的16位校验和字段，如ICMP公共消息格式主题中所述。                                                                                |
| ***MTU\***                       | 4                | ***MTU:\*** MTU：路由器想要发送数据报的物理链路的最大传输单元（MTU）大小，以字节为单位，但由于数据报的大小而无法发送。在Packet Too Big消息中包含此值会告诉源设备其下次传输到此目的地所需的大小，以避免将来出现此问题（至少对于此特定链路） |
| ***Original Datagram Portion\*** | Variable         | ***Original Datagram Portion:\*** 原始数据报部分：尽可能多的IPv6数据报，而不会导致ICMPv6消息（包括其自己的IP报头）的大小超过1280字节的最小IPv6 MTU。                               |

​                                                             **表104：ICMPv6数据包太大报文格式**

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\icmpv6packettoobig.png)

​                                                            **图153：ICMPv6数据包太大消息格式**

**关键概念：**在IPv6中，路由器不允许对太大而无法通过其连接的物理链路发送的数据报进行分段。丢弃过大的数据报，并将ICMPv6数据包太大消息发送回数据报的发起方，以通知它发生了这种情况。

<u>**数据包过大消息的应用**</u>

虽然数据包太大显然是一条错误消息，但它还有另一个用途：实现路径MTU发现。RFC 1981中描述的此过程定义了一种方法，用于设备确定通往目的地的路径的最小MTU。为了执行路径MTU发现，源设备发送一系列测试消息，从而减小数据报的大小，直到它不再收到响应其测试的Packet Too Big消息。有关这方面的更多详细信息，请参阅有关IPv6 MTU和碎片问题的主题。

**注：**数据包太大消息是ICMPv6中的新消息。然而，它的使用在某种程度上类似于ICMP4目的地不可达消息类型的分段所需和DF集版本的使用，后者被用作IPv4的路径MTU发现功能的一部分。

顺便说一句，数据包太大是ICMP消息仅在响应单播数据报时发送的规则的例外；它可能是在回复过大的多播数据报时发送的。如果发生这种情况，重要的是要认识到，如果多播到它们的路径没有经过导致错误的小MTU的链路，则多播的一些预期目标可能仍然收到了它。

###### 3.2.2.3-3 ICMPv6超时消息(第1部分：第2部分)

最初设计Internet协议的工程师认识到，由于网际网络中路由工作方式的本质，数据报可能会在系统中丢失，并花费太多时间从一台路由器传递到另一台路由器。它们在IPv4数据报中包含一个称为生存时间的字段，该字段旨在由发送数据报的设备设置为时间值，并用作计时器，以便在数据报到达目的地的时间过长时丢弃该数据报。

最终，此字段的含义发生了变化，因此它不再被用作以秒为单位的时间，而是被用作允许发送数据报的跳数。在IPv6中，此字段在重命名为Hop Limit时有了新的含义。无论名称如何，该字段仍具有相同的基本用途：它通过限制路由器可以转发数据报的次数来限制数据报在网际网络中可以存在的时间。这是专门为防止大型或配置不当的网际网络中可能出现的路由器环路而设计的。这种情况的一个例子是，路由器A认为发往网络X的数据报下一步应该发往路由器B；B认为发往路由器C；C认为发往A的数据报需要发往A。如果没有跳数限制，此类数据报将无休止地循环，阻塞网络，永远无法完成任何有用的任务，如图154所示。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\icmpv6routerloop.png)
                                                                           **图154：路由器环路示例。**

此图显示了一个由四个网络组成的简单网际网络，每个网络都由一台路由器提供服务。它是图93的改编，但在本例中，路由表设置不正确。R1认为它需要将发往网络N4的所有流量路由到R3；R3认为它发往R2；R2认为它发回R1。这意味着，当任何设备尝试发送到N4时，数据报将绕着这个“三角形”循环，直到达到其跳数限制，此时将生成ICMPv6超时消息。

路由器每次通过IPv6数据报时，都会减少跳数限制字段。如果该值达到零，则数据报到期并被丢弃。发生这种情况时，丢弃该数据报的路由器会向该数据报的始发者发回ICMPv6超时消息，通知它该数据报已被丢弃。这与ICMPv4超时消息基本相同。与ICMPv4的情况一样，接收消息的设备必须决定是否以及如何响应消息的接收。例如，由于错误可能是由于设备使用的跳数限制太低而导致的，因此该设备可能会尝试重新发送具有较高值的数据报，然后得出结论认为存在路由问题并放弃。(有关TTL到期工作原理的说明，请参阅ICMPv4超时消息主题。)。

与ICMPv4等效项一样，还有另一种使用ICMPv6超时消息的“超时”情况。当IP报文被分解成独立发送的片段时，目的设备负责将这些片段重新组合成原始报文。然而，一个或多个碎片可能无法到达目的地。为了防止设备永远等待，它会在第一个碎片到达时设置计时器。如果该计时器在所有其他片段也被接收之前超时，则设备放弃该消息。丢弃片段，并且还生成超时消息。

<u>**ICMPv6超时消息格式**</u>

ICMPv6超时报文的格式见表105和图155。

​                                                                   **表105：ICMPv6超时报文格式**

| **Field Name**                   | **Size (bytes)** | **Description**                                                                                                  |
| -------------------------------- | ---------------- | ---------------------------------------------------------------------------------------------------------------- |
| ***Type\***                      | 1                | ***Type:\***类型：标识ICMPv6消息类型；对于超出时间的消息，此设置为3。                                                                     |
| ***Code\***                      | 1                | ***Code:\*** 代码：标识正在通信的时间错误的“子类型”。值0表示跳限字段到期；值1表示已超过片段重新组装时间。                                                    |
| ***Checksum\***                  | 2                | ***Checksum:\*** 校验和：ICMP报头的16位校验和字段，如ICMP公共消息格式主题中所述。                                                           |
| ***Unused\***                    | 4                | ***Unused:\*** 未使用：4个字节留空，未使用。                                                                                   |
| ***Original Datagram Portion\*** | Variable         | ***Original Datagram Portion:\*** 原始数据报部分：尽可能多的IPv6数据报，而不会导致ICMPv6错误消息（包括其自身的IP报头）的大小超过1280字节的最小IPv6最大传输单元（MTU）。 |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\icmpv6timeexceeded.png)

​                                                                      **图155:ICMPv6超时消息格式**

**关键概念**：与ICMPv4同名一样，ICMPv6超时消息在两种不同的“时间相关”情况下发送。第一种情况是，如果数据报的跳数限制字段减少为零，则会导致数据报过期并丢弃数据报。第二种情况是，在接收方的重新组装计时器到期之前，未接收到碎片消息的所有片段。

<u>**超时消息的应用**</u>

在IPv4中，ICMP超时消息既用作错误消息，也用于实现TCP/IP traceroute命令的智能应用程序。这是通过首先发送一个“虚拟”数据报来完成的。该数据报的生存时间值为1，导致路由中的第一个跃点丢弃该数据报并发回一个ICMP超时。然后，将第二个TTL值为2的数据报发送到同一目的地，导致路由中的第二个设备报告超时，以此类推。

当然，有一个IPv6版本的traceroute，有时称为traceroute6。由于IPv6及其协议和应用程序仍在开发中，我无法确定traceroutes6是以上述方式使用ICMPv6超时消息实现的，但我相信情况确实如此（这肯定是有意义的）。)有关详细信息，请参阅讨论跟踪路由的主题。

###### 3.2.2.3-4 ICMPv6参数问题消息(部件：1 2 3)

本节前面主题中描述的ICMPv6目的地无法到达、数据包太大和超时消息用于向数据报的原始发送方指示特定的错误情况。ICMPv6认识到路由器或主机在处理未包含在这些消息类型中的数据报时可能会遇到其他问题，因此与ICMPv4一样，ICMPv6包含通用错误消息类型。这称为ICMPv6参数问题消息。

顾名思义，参数问题消息表示设备在尝试检查IPv6数据报中的一个或多个报头时发现参数(数据报字段的另一个名称)有问题。只有当遇到的错误严重到设备无法理解数据报并不得不将其丢弃时，才会生成此消息。也就是说，如果发现设备能够恢复且不丢弃数据报的错误，则不会创建参数问题消息。

与此消息的ICMPv4版本一样，ICMPv6消息被设计为通用的，因此它可以指示原始数据报中基本上任何字段中的错误。使用指向该数据报中遇到错误的位置的特殊指针字段。通过查看原始报文的结构(您可能还记得，ICMP报文格式中包含的报文大小不超过特定大小)，原始设备可以知道哪个字段包含问题。Code值还用于传达有关问题性质的其他一般信息。

<u>**ICMPv6参数问题消息格式**</u>

表106和图156显示了ICMPv4参数问题消息的格式：

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\icmpv6parameterproblem.png)

​                                                           **图156：ICMPv6参数问题报文格式**

​                                                          **表106：ICMPv6参数问题报文格式**

| **Field Name**                   | **Size (bytes)** | **Description**                                                                                                 |
| -------------------------------- | ---------------- | --------------------------------------------------------------------------------------------------------------- |
| ***Type\***                      | 1                | ***Type:\*** 类型：标识ICMPv6消息类型；对于“参数问题”消息，该值设置为4。                                                                 |
| ***Code\***                      | 1                | ***Code:\*** 代码：标识参数问题的一般类。详见表107。                                                                              |
| ***Checksum\***                  | 2                | ***Checksum:\*** 校验和：ICMP报头的16位校验和字段，如ICMP公共消息格式主题中所述。                                                          |
| ***Pointer\***                   | 4                | ***Pointer:\*** 指针：指向原始数据报中导致生成参数问题消息的字节位置的偏移量。接收ICMP消息的设备可以使用此值来了解原始消息中的哪个字段出现了问题。                             |
| ***Original Datagram Portion\*** | Variable         | ***Original Datagram Portion:\***原始数据报部分：尽可能多的IPv6数据报，而不会导致ICMPv6错误消息（包括其自身的IP报头）的大小超过1280字节的最小IPv6最大传输单元（MTU）。 |

<u>**参数问题消息解释代码和指针字段**</u>

ICMPv4中只有8位宽的指针字段在ICMPv6中已扩展到32位，以便在隔离错误方面提供更大的灵活性。与此消息类型的ICMPv4版本相比，在ICMPv6中使用Code值的方式也略有不同。在ICMPv4中，仅当Code字段为0时才使用指针，而其他代码值指示指针字段对其没有意义的其他问题类别。在ICMPv6中，指针字段与所有代码类型一起使用，以指示问题的一般性质。这意味着指针字段告诉参数问题的接收者在消息中问题发生的位置，而代码字段告诉它问题的性质。下表显示了三个代码值，并对每个值进行了简要说明：

​                                                                     **表107：ICMPv6参数问题报文解释代码**

| **Code Value** | **Message Subtype**                       | **Description**                                                                      |
| -------------- | ----------------------------------------- | ------------------------------------------------------------------------------------ |
| 0              | Erroneous Header Field Encountered        | 指针字段指向包含错误或无法处理的标头。                                                                  |
| 1              | Unrecognized Next Header Type Encountered | 回想一下，在IPv6中，数据报可以有多个报头，每个报头都包含一个指向数据报中下一个报头的Next Header字段。此代码表示指针字段指向包含无法识别值的下一个标题字段 |
| 2              | Unrecognized IPv6 Option Encountered      | 指针字段指向处理设备无法识别的IPv6选项。                                                               |

**关键概念：**ICMPv6参数问题消息是一种通用错误消息，可用于在IP数据报中传递任何类型的错误。指针字段用于向消息接收者指示原始数据报中的问题所在。

###### 3.2.2.4 ICMP版本6(ICMPv6)信息性消息类型和格式

在上一节中，我们研究了许多ICMPv6错误消息，当在IPv6数据报中检测到错误使其无法传递时，这些错误消息将被发送回IPv6数据报的发起者。与ICMP的原始版本(ICMPv4)一样，ICMPv6还定义了另一类消息：信息性消息。这些ICMPv6消息不是用来报告错误的，而是用来共享实施对IPv6运行至关重要的各种测试、诊断和支持功能所需的信息。

在本节中，我将在五个主题中描述八个不同的ICMPv6信息性消息(其中六个消息以匹配对的形式使用，这些消息对一起进行描述)。我首先描述用于网络连通性测试的ICMPv6回声请求和回声应答消息。我解释了路由器通告和路由器请求消息的格式，用于让主机发现本地路由器并从它们那里获取必要的参数。然后描述ICMPv6邻居通告和邻居请求消息，它们用于本地网络中主机之间的各种通信，包括IPv6地址解析。我将讨论IPv6重定向消息和IPv6路由器重新编号消息，IPv6重定向消息允许路由器通知主机更好的第一跳路由器。

几个ICMPv6信息性消息包括可选、建议或强制的附加信息，具体取决于消息生成的情况。其中一些是在消息类型之间共享的，因此在本节末尾的另一个主题中对它们进行了描述。

在IPv4中，各种不同的标准描述了许多ICMP信息性消息的使用。在IPv6中，使用信息消息的许多功能已经聚集在一起，并在IPv6邻居发现(ND)协议中进行了形式化。本地路由器和邻居主机的请求和通告以及重定向信息的通信都是ND负责的活动的示例。事实上，本节中描述的ICMP消息中有五个实际上是在邻居发现标准RFC 2461中定义的。

ND和ICMPv6显然是密切相关的，因为ND描述了几种ICMP消息的使用：路由器通告、路由器请求、邻居通告、邻居请求和重定向。因此，就像ICMPv4是IPv4的重要“助手”一样，ICMPv6和ND都是IPv6的重要助手。在本指南中，我在ND的详细部分中提供了有关如何使用这些消息的大部分说明。在本节中，我只简要概述它们的用法，而主要集中在消息格式和该格式中每个字段的含义。

注：在ICMPv6中，重定向消息是信息性的，不再像在ICMPv4中那样被视为错误消息。

###### 3.2.2.4-1 ICMPv6 Echo Request and Echo Reply Messages (Parts: 1 2 )

IP是一种相对简单的协议，其本身不包括在设备之间执行测试以帮助诊断网际网络问题的任何方法。这意味着，这项工作和其他支持任务一样，落在ICMP的肩上。当使用TCP/IP出现问题时，执行的最简单测试通常是检查一对设备是否能够相互发送数据报。这通常是由发起设备向第二设备发送测试消息来完成的，第二设备接收该测试消息并回复以告诉第一设备它接收到该消息。

与ICMPv4一样，ICMPv6包括一对专门用于连接测试的消息。要使用它们，设备A通过向设备B发送ICMPv4回应请求消息开始测试过程。设备B使用回应回复消息回应设备A。当设备A接收到该消息时，它知道它能够与设备B成功通信(发送和接收)。

**注意**：在ICMPv4中，第一个消息类型仅命名为Echo，但通常称为Echo Request.。在ICMPv6中，他们最终只是将“请求”添加到消息名称中，并完成了它。从清晰的角度来看，这是一个温和但有用的改进。

<u>**ICMPv6 Echo和Echo回复消息格式**</u>

ICMPv6回应请求和回应回复消息的格式与ICMPv4版本的格式非常相似，如表108和图157所示。

​                                                 **表108：ICMPv6回声请求和回声回复消息格式**

| **Field Name**         | **Size (bytes)** | **Description**                                                                              |
| ---------------------- | ---------------- | -------------------------------------------------------------------------------------------- |
| ***Type\***            | 1                | ***Type:\*** 类型：标识ICMPv6消息类型；对于回声请求消息，值为128，对于回声回复消息，值129。（回想一下，在ICMPv6中，信息消息的类型值始终为128或更高。） |
| ***Code\***            | 1                | ***Code:\*** 代码：未使用；设置为0。                                                                    |
| ***Checksum\***        | 2                | ***Checksum:\*** 校验和：ICMP报头的16位校验和字段，如ICMP公共消息格式主题中所述。                                       |
| ***Identifier\***      | 2                | ***Identifier:\*** 标识符：可选的标识字段，可用于帮助匹配回声请求和回声回复消息。                                           |
| ***Sequence Number\*** | 2                | ***Sequence Number:\*** 序号：有助于匹配回声请求和回声回复消息的序号。                                              |
| ***Optional Data\***   | Variable         | ***Optional Data:\*** 可选数据：与消息一起发送的其他可选数据。如果在回声请求中发送，则将其复制到 *Echo Reply*中，以发送回源。             |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\icmpv6echo.png)

​                                                                    **图157：ICMPv6回声请求和回声回复消息格式**

与ICMPv4一样，通常需要将Echo回复消息与导致生成该消息的Echo请求消息进行匹配。在这些消息的格式中使用了两个特殊字段，以允许将回声请求和回声应答消息匹配在一起，并允许交换一系列消息。提供了标识符字段，以便可以标识特定的测试会话，序列号字段允许对会话中的一系列测试进行编号。这两个字段的使用都是可选的。

<u>**Echo和Echo回复报文的应用**</u>
ICMPv6回应请求和回应回复消息通过通常称为ping6的IP ping实用程序的IPv6版本使用。与其IPv4前身一样，该实用程序允许管理员配置多个测试选项，以对一对设备之间的连接执行简单或严格的测试。有关完整解释，请参阅描述ping的主题。

**关键概念：**ICMPv6回声请求和回声应答消息用于促进网络可达性测试。设备通过向其发送Echo请求消息并等待响应的Echo回复来测试其与另一设备通信的能力。Ping实用程序是TCP/IP网际网络中广泛使用的诊断工具，它利用这些消息。

###### 3.2.2.4-2 ICMPv6路由器通告和路由器请求消息(Parts:  1 2 3 )

在最高级别，我们可以将IP设备分为两组：主机和路由器。两者都参与网际网络的使用，但它们扮演的角色不同。与这种划分相关的一个重要的IP原则是，路由器负责路由-在网络之间移动数据-而主机通常不需要担心这项工作。主机依靠其本地网络上的路由器来促进与除本地网络上的主机以外的所有其他主机的通信。

这一点的含义很明显：在知道至少一台本地路由器的身份以及使用该路由器的方法之前，主机无法真正使用网际网络。在IPv4中，发明了一种称为路由器发现的技术，它为主机提供了一种定位路由器并获取与本地网络运行相关的重要参数的方法。

IPv6中的路由器发现以非常类似的方式工作，让路由器定期发送路由器通告消息，并使用路由器请求消息响应主机提示它们。路由器发现功能已被合并到邻居发现(ND)协议中，它是我称为主机-路由器发现功能的更大类别工具的一部分。

<u>**ICMPv6路由器通告消息格式**</u>

ICMPv6路由器通告和路由器请求消息的格式与ICMPv4中的对应消息非常相似。主要区别在于传递的参数不同。由于路由器在IPv6中的功能比在IPv4中多几个，因此ICMPv6中的路由器通告消息比旧版本多了几个字段。

ICMPv6路由器通告消息的格式如表109所示，如图158所示

​                                                                **表109：ICMPv6路由器通告消息格式**

| **Field Name**          | **Size (bytes)** | **Description**                                                                                                                                                                                                                                                                                   |
| ----------------------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ***Type\***             | 1                | ***Type:\*** 类型：标识ICMPv6消息类型；对于路由器通告消息，该值为134。                                                                                                                                                                                                                                                    |
| ***Code\***             | 1                | ***Code:\*** 代码：未使用；设置为0。                                                                                                                                                                                                                                                                         |
| ***Checksum\***         | 2                | ***Checksum:\*** 校验和：ICMP报头的16位校验和字段，如ICMP公共消息格式主题中所述。                                                                                                                                                                                                                                            |
| ***Cur Hop Limit\***    | 1                | ***Current Hop Limit:\*** 当前跳数：这是一个默认值，路由器告诉本地网络上的主机，他们应该把他们发送的数据报的跳数字段中。如果是0，路由器不建议在这个路由器广告中使用Hop Limit值。                                                                                                                                                                                        |
| ***Autoconfig Flags\*** | 1                | ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\aa1fb6d6.png)                                                                                                                                                                                                              |
| ***Router Lifetime\***  | 2                | ***Router Lifetime:\*** 路由器生存期：告知接收此消息的主机此路由器应作为默认路由器使用多长时间（秒）。如果为0，则告知主机此路由器不应用作默认路由器。请注意，这是一个过期间隔，仅用于路由器的默认状态，而不是路由器通告消息中的其他信息。                                                                                                                                                                 |
| ***Reachable Time\***   | 4                | ***Reachable Time:\*** 可达时间：告诉主机在收到可达性确认后，应该多长时间（以毫秒为单位）将邻居视为可达。有关详细信息，请参阅讨论邻居不可达性检测的邻居发现主题。                                                                                                                                                                                                      |
| ***Retrans Timer\***    | 4                | ***Retransmission Timer:\*** 重传计时器：主机在重传邻居请求消息之前应等待的时间量（以毫秒为单位）。                                                                                                                                                                                                                                  |
| ***Options\***          | Variable         | ***Options:\*** 选项：路由器通告消息可能包含三个可能的选项（有关详细信息，请参阅ICMPv6选项主题）： ***Source Link-Layer Address:\*** 源链接层地址。当发送广告的路由器知道其链路层（第二层）地址时，包括在内。.[ ***MTU:\*** MTU：当网络上的主机可能不知道该信息时，用于告知本地主机本地网络的MTU。.[ ***Prefix Information:\*** T[前缀信息：告诉本地主机用于本地网络的前缀。（回想一下，“前缀”表示IPv6地址的哪些位与主机标识符相比是网络标识符；因此类似于IPv4子网掩码）。 |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\icmpv6routeradvertisement.png)

​                                                    **图158：ICMPv6路由器通告消息格式**

<u>**ICMPv6路由器请求消息格式**</u>

ICMPv6路由器请求消息的格式如表110和图159所示。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\icmpv6routersolicitation (1).png)

​                                                                **图159：ICMPv6路由器请求消息格式**

​                                                            **表110：ICMPv6路由器请求消息格式**

| **Field Name**  | **Size (bytes)** | **Description**                                                         |
| --------------- | ---------------- | ----------------------------------------------------------------------- |
| ***Type\***     | 1                | ***Type:\***类型：标识ICMPv6消息类型；对于路由器请求消息，该值为133。                           |
| ***Code\***     | 1                | ***Code:\*** 代码：未使用；设置为0。                                               |
| ***Checksum\*** | 2                | ***Checksum:\*** 校验和：ICMP报头的16位校验和字段，如ICMP公共消息格式主题中所述                   |
| ***Reserved\*** | 4                | ***Reserved:\*** 保留：4个保留字节设置为0。                                         |
| ***Options\***  | Variable         | ***Options:\*** 选项：如果发送路由器请求的设备知道其第二层地址，则应将其包含在源链路层地址选项中。选项格式在单独的主题中描述。 |

<u>**路由器通告和路由器请求消息的寻址**</u>
路由器请求消息通常发送到IPv6“所有路由器”组播地址；这是最有效的方法，因为路由器需要订阅此组播地址，而主机将忽略它。使用本地网络的“所有节点”组播地址向所有设备发送例行(未经请求的)路由器通告。响应路由器请求而发送的路由器通告将单播回发送请求的设备。

**关键概念**：IPv6路由器定期发送ICMPv6路由器通告消息，以通知主机它们的存在和特征，并为主机提供在本地网络上正常运行所需的参数。如果主机希望立即找出存在哪些路由器，则可能会发送路由器请求，这将提示侦听路由器发出路由器通告。

###### 3.2.2.4-3 ICMPv6邻居通告和邻居请求消息 (Parts: 1 2 3 4 )

上一个主题介绍了路由器通告和路由器请求消息，它们用于促进作为IPv6邻居发现(ND)协议一部分的主机-路由器发现功能。ND负责的另一组主要任务涉及同一网络中相邻主机之间的信息交换。我将这些称为主机-主机通信或主机-主机发现功能。

可以说，邻居发现协议最重要的补充是规范参数交换的功能，以及确定邻居主机是否存在的方法。这些任务包括IPv6中新的地址解析方法，以及下一跳确定和邻居不可达检测过程。它们需要使用两条ICMPv6消息：邻居请求消息和邻居通告消息。

邻居请求消息允许设备检查邻居是否存在以及是否可访问，并启动地址解析。邻居通告消息确认主机或路由器的存在，并在需要时提供第二层地址信息。如您所见，这两条消息与路由器通告和路由器请求消息相当，但用法不同，包含不同的参数。

<u>**ICMPv6邻居通告消息格式**</u>

邻居通告消息的格式如表111和图160所示

​                                                            **表111：ICMPv6邻居通告消息格式**

| **Field Name**        | **Size (bytes)** | **Description**                                                                                                                                                                                                            |
| --------------------- | ---------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ***Type\***           | 1                | ***Type:\*** 类型。确定ICMPv6消息的类型；对于邻居广告消息，其值为136。                                                                                                                                                                             |
| ***Code\***           | 1                | ***Code:\*** 代码。不使用；设置为0。                                                                                                                                                                                                  |
| ***Checksum\***       | 2                | ***Checksum:\*** 校验和：ICMP报头的16位校验和字段，在ICMP通用报文格式主题中有所描述。                                                                                                                                                                   |
| ***Flags\***          | 4                | ![img](http://www.tcpipguide.com/free/aa3623a5.png)                                                                                                                                                                        |
| ***Target Address\*** | 16               | ***Target Address:\*** 目标地址。如果邻里通告是为响应邻里请求而发送的，那么这个值与请求中的目标地址字段相同。这个字段通常包含发送邻居广告的设备的IPv6地址，但不是在所有情况下。例如，如果一个设备作为邻居请求的目标的代理进行响应，则目标地址字段包含目标的地址，而不是发送响应的设备。详情见地址解析代理主题。 如果邻里广告是未经请求而发送的，那么这就是发送设备的IPv6地址。                    |
| ***Options\***        | Variable         | ***Options:\*** 选项。当为响应多播邻居请求而发送时，邻居广告消息必须包含一个目标链路层地址选项，该选项携带发送消息的设备的链路层地址。这是一个 "选项 "的好例子，它并不是真正的 "可选"。J 当邻居广告是为了响应单播的邻居请求而发送的时候，这个选项在技术上是不需要的（因为请求的发送者必须已经有了目标的链路层地址才会单播发送）。尽管这样，它通常还是被包括在内，以确保目标的链路层地址在发送邻居请求的设备的缓存中被刷新。 |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\icmpv6neighboradvertisement.png)

​                                                                       **图160：ICMPv6邻居通告消息格式**

<u>**ICMPv6邻居请求消息格式**</u>

邻居请求消息格式要简单得多，如表112和图161所示

​                                                                          **表112：ICMPv6邻居请求消息格式**

| **Field Name**        | **Size (bytes)** | **Description**                                                                                                                 |
| --------------------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------- |
| ***Type\***           | 1                | ***Type:\*** 类型。确定ICMPv6消息类型；对于邻居请求消息，其值为135。                                                                                   |
| ***Code\***           | 1                | ***Code:\*** Not used; set to 0.                                                                                                |
| ***Checksum\***       | 2                | ***Checksum:\*** 校验和：ICMP报头的16位校验和字段，在ICMP通用报文格式主题中有所描述。                                                                        |
| ***Reserved\***       | 4                | ***Reserved:\*** 保留。4个保留字节，设置为0。                                                                                                |
| ***Target Address\*** | 16               | ***Target Address:\*** 目标地址。征求意见的目标的IPv6地址。对于IPv6地址解析，这是我们试图解析其第二层（链接层）地址的设备的实际单播IP地址。                                          |
| ***Options\***        | Variable         | ***Options:\*** 选项。如果发送邻居请求的设备知道自己的IP地址和第二层地址，它应该在源链接层地址选项中包括第二层地址。该选项的加入将允许邻居请求的目的地将该消息来源的第二层和第三层地址输入其自身的地址缓存。参见关于IPv6地址解析的讨论。 |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\icmpv6neighborsolicitation.png)

​                                                           **表112：ICMPv6邻居请求消息格式**

**关键概念:** ICMPv6邻居广告和邻居请求消息在许多方面与路由器广告和路由器请求消息相似。然而，它们不是用于从路由器到主机的通信参数，而是用于物理网络上主机之间的各种类型的通信，如地址解析、下一跳确定和邻居不可达性检测。

###### 3.2.2.4-4 ICMPv6 Redirect Messages (Parts: 1 2 )

由于路由器和主机在IPv6网际网络中扮演的角色不同，因此主机不需要非常了解路由。它们直接向本地网络上的目的地发送数据报，而将其他网络的数据报转储到本地路由器，并让本地路由器“驱动”，可以这么说。

如果本地网络只有一台路由器，则它会将所有此类非本地流量发送到该路由器。如果它有多个本地路由器，则主机必须决定将哪个路由器用于哪个流量。一般而言，主机不知道它可能需要发送的每种类型的数据报的最有效路由器选择。事实上，许多节点一开始都有一个有限的路由表，该表规定将所有内容发送到单个默认路由器，即使网络上有多个路由器也是如此。

当路由器收到发往某些网络的数据报时，它可能会意识到，如果此类流量由主机发送到本地网络上的另一台路由器，效率会更高。如果是，它将通过向发送原始数据报的设备发送ICMPv6重定向消息来调用重定向函数。这是IPv6中由邻居发现协议执行的最后一项功能，将在该部分的重定向功能主题中进行说明。重定向消息始终单播发送到最初发送导致创建重定向的数据报的设备的地址。

<u>**ICMPv6重定向消息格式**</u>

ICMPv6重定向消息的格式如表113和图162所示。

​                                                                **表113：ICMPv6重定向消息格式**

| **Field Name**             | **Size (bytes)** | **Description**                                                                                                                                                                                                                                                                                                                                                                       |
| -------------------------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ***Type\***                | 1                | ***Type:\*** 类型。确定ICMPv6消息类型；对于重定向消息，其值为137。                                                                                                                                                                                                                                                                                                                                          |
| ***Code\***                | 1                | ***Code:\*** Not used; set to 0.                                                                                                                                                                                                                                                                                                                                                      |
| ***Checksum\***            | 2                | ***Checksum:\*** Checksum：ICMP报头的16位校验字段，在ICMP通用报文格式主题中有所描述。                                                                                                                                                                                                                                                                                                                          |
| ***Reserved\***            | 4                | ***Reserved:\*** 4 bytes sent as zeroes.                                                                                                                                                                                                                                                                                                                                              |
| ***Target Address\***      | 16               | ***Target Address:\*** 目标地址。路由器的地址，创建重定向的路由器告诉重定向的接收者将其作为未来传输到目的地的第一跳。呵。举个例子：如果路由器R2产生了一个重定向，告诉主机A，将来向主机B的传输应首先发送到路由器R1，那么R1的IPv6地址将在这个字段中。                                                                                                                                                                                                                                           |
| ***Destination Address\*** | 16               | ***Destination Address:\*** 目的地地址。未来传输被重定向的设备的地址；这是最初导致产生重定向的数据报的目的地。重复上面的例子：如果路由器R2产生了一个重定向，告诉主机A，在未来对主机B的传输应该首先发送到路由器R1，那么主机B的IPv6地址将在这个字段中。                                                                                                                                                                                                                                        |
| ***Options\***             | Variable         | ***Options:\*** 选项。重定向信息通常包括两个ICMPv6选项字段。                                                   :[ ***Target Link-Layer Address:\*** [ 目标链路层地址。目标地址的第二层地址，如果知道的话。这使重定向消息的接收者无需对目标进行地址解析。                                                                         .[ ***Redirected Header:\*** [重定向报头。引起该重定向的IPv6数据报，在不导致ICMPv6错误消息的大小（包括其自身的IP头）超过1280字节的IPv6最大传输单元（MTU）的情况下，可以容纳尽可能多的内容。 |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\icmpv6redirect.png)

​                                                                            **图162：ICMPv6重定向消息格式。**

**注意**：顺便说一句，重定向消息一直都有些古怪。在ICMPv4中，它被视为错误消息，但这使其不同于其他错误消息。首先，这并不是一个真正的错误，因为它并不代表交付失败，而只是交付过程中的低效。出于这个原因，在ICMPv6中，它被“移动”到信息性报文类型集。在这里，它也不太适合其他类型，因为它是作为对常规IP消息的响应而发送的，而且它还包括产生它的数据报的副本(部分)，就像错误消息一样。

**关键概念：**ICMPv6重定向消息由路由器用来通知主机有更好的路由器，用于将来发送到特定主机或网络的数据报。但是，它们不用于更改路由器之间的路由。

###### 3.2.2.4-5 ICMPv6 Router Renumbering Messages (Parts: 1 2 ) 重新编号

在IPv6中做出的一个更有趣的决定是选择非常大的128位地址大小。这提供了比人类可能需要的地址空间大得多的地址空间，严格来说，也可能比IPv6所需要的地址空间大得多。这种丰富的位提供的是为地址结构中的不同位分配含义的灵活性。这反过来又是IPv6地址的自动配置和自动重新编号等重要功能的基础。

网络管理员对IPv6中的重新编号功能特别感兴趣，因为它有可能使大型网络迁移和合并变得更加简单。2000年8月，IETF发布了RFC 2894，即针对IPv6的路由器重新编号，它描述了一种类似的技术，通过为自治系统中的路由器提供新的前缀(网络标识符)，允许对它们进行重新编号。

路由器重新编号实际上是一个相当简单的过程-特别是如果我们避免血淋淋的细节，这正是我打算做的。网络管理员使用网际网络上的设备生成一条或多条路由器重新编号命令消息。这些消息提供要重新编号的路由器的前缀列表。每台路由器都会处理这些消息，以查看其任何接口上的地址是否与指定的前缀匹配。如果是，它们会将匹配的前缀更改为消息中指定的新前缀。路由器重新编号命令中还包含适当的附加信息，以控制重新编号的方式和时间。

如果命令消息请求，则处理该消息的每台路由器将使用路由器重新编号结果消息进行响应。此消息用作反馈，让命令的发起人知道重新编号是否成功，以及进行了哪些更改(如果有)。

路由器重新编号标准还定义了一些重要的管理功能。其中许多反映了可以对路由器进行大规模重新编号的东西的强大功能-因此，这种功能可能被滥用。可以在“测试模式”下发送命令，在这种模式下，命令会被处理，但不会实际执行重新编号。消息包括防止重放攻击的序列号，特殊的序列号重置消息可用于重置路由器先前存储的序列号信息。为了增加安全性，该标准指定对消息进行身份验证和身份检查。

**<u>ICMPv6路由器重新编号消息格式</u>**

路由器重新编号消息的格式如表114和图163所示。

​                                                                 **表114：ICMPv6路由器重新编号消息格式**

| **Field Name**         | **Size (bytes)** | **Description**                                                                                                                                                                                                                                                                                                                                    |
| ---------------------- | ---------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ***Type\***            | 1                | ***Type:\*** 类型。确定ICMPv6消息的类型；对于路由器重新编号的消息，其值为138。                                                                                                                                                                                                                                                                                                 |
| ***Code\***            | 1                | ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\aa3895e7.png)                                                                                                                                                                                                                                                               |
| ***Checksum\***        | 2                | ***Checksum:\*** 校验和：ICMP报头的16位校验和字段，在ICMP通用报文格式主题中有所描述。                                                                                                                                                                                                                                                                                           |
| ***Sequence Number\*** | 4                | ***Sequence Number:\*** 序列号。一个32位的序列号，用于防止 "重放 "攻击，允许接收者检测陈旧、重复或 "失序 "的命令。                                                                                                                                                                                                                                                                         |
| ***Segment Number\***  | 1                | ***Segment Number:\*** 段落号。区分同一序列号内的有效路由器重新编号信息。                                                                                                                                                                                                                                                                                                   |
| ***Flags\***           | 1                | ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\aa389616.png)                                                                                                                                                                                                                                                               |
| ***Max Delay\***       | 2                | ***Maximum Delay:\*** 最大延迟。告诉收到消息的路由器在发送回复前允许延迟的最大时间（以毫秒计）。                                                                                                                                                                                                                                                                                        |
| Reserved               | 4                | ***Reserved:\*** 4 reserved bytes.                                                                                                                                                                                                                                                                                                                 |
| Message Body           | Variable         | ***Message Body:\*** 信息主体。对于一个路由器重新编号命令，消息体包含两组信息。第一个是被重新编号的前缀的匹配-前缀部分。第二个是一个或多个Use-Prefix部分，描述每个匹配的新前缀。收到命令的路由器检查自己的接口地址，如果它们与匹配前缀部分相匹配，它们就使用使用前缀部分数据来完成重新编号。                                                                                                      对于路由器重新编号结果，消息主体包含零个或多个匹配结果条目，描述路由器从路由器重新编号命令中匹配的每个前缀。每个条目提供了关于前缀的重新编号是否成功的信息。 |

 ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\icmpv6renumbering.png)

​                                                 **图163: ICMPv6路由器重新编号消息格式**

**路由器重新编号消息的寻址**

由于这些消息是为一个站点上的所有路由器准备的，它们通常被发送到 "所有路由器 "组播地址，使用链接本地或站点本地范围。它们也可能被发送到本地单播地址。

###### 3.2.2.4-6 ICMPv6 Informational Message Options (Parts: 1 2 3 4 5 6 )

邻居发现(ND)协议定义和使用的五种ICMPv6信息消息类型中的每一种都具有可插入一个或多个选项的选项字段。这可能不是这些数据集的最佳名称，因为它们只在某些情况下是可选的。事实上，在某些情况下，“选项”实际上是信息的全部要点。例如，包含用于地址解析的链路层地址的邻居通告消息在“选项”中携带该地址，但如果没有它，该消息将不会有多大用处。

每个选项都有自己的子域结构，这些子域基于在许多消息格式中使用的经典的“类型、长度和值”三元组。类型子字段指示选项类型，而长度字段指示其长度，以便处理选项的设备可以确定其结束位置。“值”不是一个单独的字段，而是一个或多个包含选项正在使用的实际信息的字段。

有些选项仅用于一种ICMPv6消息，而另一些选项则用于多种类型。因此，最好将它们视为在不同类型的消息中根据需要使用的“模块化组件”。下面我将介绍这五个选项中的每个选项的格式。

<u>**源链路层地址选项格式**</u>

此选项携带发送ICMPv6消息的设备的链路层地址，如表115和图164所示。在路由器通告、路由器请求和邻居请求消息中使用：

​                                                       **表115：ICMPv6源链路层地址选项格式**

| **Field Name**                   | **Size (bytes)** | **Description**                                                    |
| -------------------------------- | ---------------- | ------------------------------------------------------------------ |
| ***Type\***                      | 1                | ***Type:\*** 类型。标明ICMPv6选项的类型。对于源链接层地址选项，其值为1。                     |
| ***Length\***                    | 1                | ***Length:\*** 长度。整个选项的长度（包括类型和长度字段），以8个字节（64位）为单位表示。              |
| ***Source Link-Layer Address\*** | Variable         | ***Source Link-Layer Address:\*** 源链路层地址。发送ICMPv6消息的设备的链路层（第二层）地址。 |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\icmpv6optionsa.png)

​                                                              **图164：ICMPv6源链路层地址选项格式**

<u>**目标链路层地址选项格式**</u>

与源链路层地址对应，此选项携带与邻居通告和重定向消息中的目标地址字段对应的链路层地址；参见表116和图165。

​                                                                   **表116：ICMPv6目标链路层地址选项格式**

| **Field Name**                   | **Size (bytes)** | **Description**                                            |
| -------------------------------- | ---------------- | ---------------------------------------------------------- |
| ***Type\***                      | 1                | ***Type:\*** 类型。标明ICMPv6选项的类型。对于目标链路层地址选项，其值为2。            |
| ***Length\***                    | 1                | ***Length:\*** 长度。整个选项的长度（包括类型和长度字段），以8个字节（64位）为单位表示。      |
| ***Target Link-Layer Address\*** | Variable         | ***Target Link-Layer Address:\*** 目标链路层地址。目标设备的链路层（第二层）地址。 |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\icmpv6optionta.png)

​                                                        **图165：ICMPv6目标链路层地址选项格式**

<u>**前缀信息选项格式**</u>

此选项在路由器通告消息中提供前缀和相关信息。这是最长也是最复杂的选项，如表117和图166所示。

​                                                                   **表117：ICMPv6前缀信息选项格式**

| **Field Name**            | **Size (bytes)** | **Description**                                                                                                 |
| ------------------------- | ---------------- | --------------------------------------------------------------------------------------------------------------- |
| ***Type\***               | 1                | ***Type:\* **类型。确定ICMPv6选项的类型。对于前缀信息选项，其值为3。                                                                    |
| ***Length\***             | 1                | ***Length:\*** 长度。整个选项的长度（包括类型和长度字段），以8个字节（64位）为单位。前缀信息选项的大小固定为32字节，所以长度字段的值为4。                                 |
| ***Prefix Length\***      | 1                | ***Prefix Length:\*** 前缀长度。前缀字段（如下）中被认为是网络标识符的一部分的位数（其余部分用于主机标识符并被忽略）。关于前缀长度的详细信息，请参见IPv6地址符号的概述讨论。             |
| ***Flags\***              | 1                | ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\aa1fa81c.png)                            |
| ***Valid Lifetime\***     | 4                | ***Valid Lifetime:\***有效寿命。包含该选项的消息的接收者认为该前缀在链路上有效的时间，以秒为单位（见上文对 "L "标志的描述）。一个全部为1的值意味着 "无限"（"永远"）。             |
| ***Preferred Lifetime\*** | 4                | ***Preferred Lifetime:\*** 首选寿命。当这个前缀的接收者使用它来自动生成地址时，指定这种地址保持 "首选"（意思是有效和自由使用）的时间，单位是秒。一个全部为1的值意味着 "无穷大"（"永远"）。 |
| ***Reserved\***           | 4                | ***Reserved:\*** 保留。4个未使用的字节，作为0发送。                                                                             |
| ***Prefix\***             | 16               | ***Prefix:\*** 前缀。在路由器广告消息中，从路由器到主机所传达的前缀。前缀长度字段表示该字段中128位中有多少位是重要的（网络ID的一部分）。只有这些位被放在前缀字段中，其余的位被清空为零。          |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\icmpv6optionprefix.png)

​                                                                     **图166: ICMPv6前缀信息选项格式**

<u>**重定向标头选项格式**</u>

在重定向消息中，提供导致生成重定向的原始消息(或其一部分)的副本。此选项可在表118和图167中找到。

​                                                                表118：ICMPv6重定向报头选项格式

| **Field Name**          | **Size (bytes)** | **Description**                                                                                              |
| ----------------------- | ---------------- | ------------------------------------------------------------------------------------------------------------ |
| ***Type\***             | 1                | ***Type:\*** 类型。标明ICMPv6选项的类型。对于Redirected Header选项，其值为4。                                                    |
| ***Length\***           | 1                | ***Length:\*** 长度。整个选项的长度（包括类型和长度字段），以8个字节（64位）为单位表示。                                                        |
| ***Reserved\***         | 6                | ***Reserved:\***保留。6个保留字节，以0的形式发送。                                                                           |
| ***IP Header + Data\*** | Variable         | ***IP Header + Data:\*** IP头+数据。在不导致ICMPv6错误消息（包括其自身的IP头）的大小超过1280字节的IPv6最大传输单元（MTU）的情况下，可以容纳尽可能多的原始IPv6数据报。 |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\icmpv6optionredirected.png)

​                                                                        **图167：ICMPv6重定向报头选项格式**

<u>**MTU选项格式**</u>

MTU选项允许路由器在路由器通告消息中传递推荐的MTU值。其格式如表119和图168所示。

​                                                                        **表119：ICMPv6 MTU选项格式**

| **Field Name**  | **Size (bytes)** | **Description**                                                                 |
| --------------- | ---------------- | ------------------------------------------------------------------------------- |
| ***Type\***     | 1                | ***Type:\*** 类型。标明ICMPv6选项的类型。对于MTU选项，其值为5。                                     |
| ***Length\***   | 1                | ***Length:\*** 长度。整个选项的长度（包括类型和长度字段），以8个字节（64位）为单位表示。MTU选项的长度固定为8字节，所以这个字段的值为1。 |
| ***Reserved\*** | 2                | ***Reserved:\*** 保留。2个保留字节以0的形式发送。                                              |
| ***MTU\***      | 4                | ***MTU:\*** MTU。路由器推荐在本地链路上使用的最大传输单元（MTU）值，单位为字节。                               |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\icmpv6optionmtu.png)

​                                                                     **图168：ICMPv6 MTU选项格式**

#### 3.3 TCP/IP IPv6邻接发现协议（ND）

新的互联网协议版本6(IPv6)代表了历史悠久的互联网协议的演变。它保持了与IPv4相同的基本工作原理，但做了一些重要的修改，特别是在寻址方面。事实上，IPv6中一些更显著的变化实际上不是在IP协议本身，而是在支持IP的协议上。其中最有趣的是创建了一个全新的IPv6支持协议。它结合了以前由IPv4中的其他协议执行的几项任务，添加了一些新功能，并对整个包进行了大量改进。这一新标准称为IPv6邻居发现(ND)协议。

在本节中，我将介绍IPv6中使用的新邻居发现协议。我首先概述该议定书，讨论它的历史、创建它的动机以及定义它的标准。然后，我概括地描述了它的操作，列出了ND执行的基本功能、这些功能所属的三个组以及用于执行这些功能的ICMPv6消息类型。我描述了ND与其功能在IPv4中的实现方式之间的主要区别。然后，我将提供有关ND中的三个功能组的更多信息：涉及从路由器发现重要网际网络信息的功能组，与地址解析和主机之间的邻居通信相关的功能组，以及最后是路由器重定向。

**背景信息：**本节假设对IP版本6有基本的理解，这反过来又要求理解IPv4。ND使用ICMP版本6(ICMPv6)消息，因此请参阅ICMP部分。最后，由于ICMP执行一些由IPv4中的地址解析协议(ARP)完成的功能，如果您不熟悉其操作，可能需要参考ARP的讨论。

##### 3.3.1 IPv6 ND概述、历史、动机和标准(第1部分：第2部分)

像Internet协议这样的网络层协议的目的是提供一种将各个本地网络连接在一起以创建更大的网际网络的方法。对于较高协议层和用户来说，这种网际网络在大多数方面的行为就像是一个单一的大型网络，因为较低层隐藏了将各个网络“粘合”在一起的细节。任何设备都可以向任何其他设备发送信息，而不管它位于哪里，而且它会像魔术一样工作。至少，大多数时候是这样。

网际网络的存在意味着设备可以将所有其他设备视为对等设备，至少从更高的协议层和应用程序的角度来看是这样。然而，从较低层的角度来看，主机本地网络上的设备和其他地方的设备之间有一个非常重要的区别。在一般意义上，大多数设备与其本地网络中的设备之间的关系比与远端网络中的设备更重要。设备必须专门与其本地网络上的其他设备一起执行的一些最明显的任务包括：

- 直接数据报传送：设备将数据直接传送到其本地网络上的其他设备，而发往远程设备的数据必须间接传送(路由)。
- 第二层寻址：为了便于直接传输，设备需要知道本地网络上其他设备的第二层地址；对于非本地设备，它们不需要知道这些地址。
- 路由器标识：要间接提供，设备需要在其本地网络上找到可与其通信的路由器。
- 路由器通信：本地路由器必须将信息传递给使用它的每个本地主机，以便它们知道如何最好地使用它。
- 配置：主机通常会查看本地设备提供的信息，以便它们执行配置任务，如确定自己的IP地址。

为了支持这些和其他要求，与最初的互联网协议(版本4)一起开发了几个特殊的协议和功能。IP寻址方案使设备能够区分本地地址和远程地址。地址解析协议(ARP)允许设备根据第3层地址确定第2层地址。互联网控制消息协议(ICMP)提供消息传递系统以支持本地设备之间的各种通信要求，包括主机查找本地路由器的能力以及路由器向本地主机提供信息的能力。

这些功能在IPv4中都能正常工作，但它们是以一种特别的方式开发的。它们不是在一个地方定义的，而是在各种不同的互联网标准中定义的。这些“本地设备”功能的实现方式也有一些限制。

<u>**形式化本地网络功能：邻居的概念**</u>

IP版本6代表着几十年来最大的变化，不仅是互联网协议本身，而且是整个TCP/IP协议簇。因此，它提供了一个理想的机会来正规化和集成与本地设备之间的通信相关的许多不同的功能和任务。其结果是创建了一种新协议：IP版本6的邻居发现，通常也称为IPv6邻居发现协议。由于此协议是版本6中的新协议，因此没有它的IPv4版本，因此该名称通常仅被视为邻居发现(ND)协议，没有进一步的限制；它与IPv6的使用是隐含的。

邻居一词多年来一直在各种网络标准和技术中使用，用来指代彼此本地的设备。在我们当前讨论的上下文中，如果两台设备位于同一本地网络中，则它们是邻居，这意味着它们可以直接相互发送信息；该术语可以指常规主机或路由器。我认为这是一个很好的类比，就像人类指的是在附近生活或工作的人一样。正如我们大多数人与邻居有一种特殊的关系，比起与远方的人，我们与邻居的交流更多，IP设备也是如此。

由于邻居是本地设备，邻居发现协议的名称似乎表明ND完全是关于邻居如何发现彼此的存在的。然而，在该协议的上下文中，术语发现具有更一般的含义：它不仅指发现我们的邻居是谁，还指发现关于他们的重要信息。除了让设备识别其邻居之外，ND还简化了上面项目符号列表中的所有任务，包括地址解析、参数通信、自动配置等功能，我们将在接下来的几个主题中看到更多功能。

<u>**邻居发现标准**</u>
邻居发现协议最初在RFC 1970中定义，于1996年8月发布，并在1998年12月发布的当前定义标准RFC 2461中进行了修订。ND协议的大部分功能是使用一组五个特殊的ICMPv6控制消息来实现的。因此，在某种程度上，ICMPv6标准RFC 2463部分描述了ND的操作。ICMPv4可以被认为是IPv4的“管理助手”，而IPv6实际上有两个这样的助手密切合作：ICMPv6和IPv6 ND协议。在这一节的后面，我将更多地讨论IPv4和IPv6实现ND功能的方式之间的差异。

**关键概念：**新的IPv6邻居发现协议为IPv6规范了许多与本地网络上的设备之间的通信相关的功能，这些功能在IPv4中由ARP和ICMP等协议执行。ND被认为是IPv6的另一个“助手”协议，与ICMPv6密切相关。

##### 3.3.1 IPv6 ND一般操作概述：ND功能、功能组和消息类型(部分：1 2 3)

正如我在前面的概述中提到的，邻居发现(ND)协议的名称确实不能很好地反映这一点。该协议不仅有助于发现相邻设备，还有助于实现与本地网络连接、数据报路由和配置相关的大量功能。IPv6环境中的常规主机和路由器都依赖ND协议来促进重要的信息交换，这些信息是正常网际网络运行所必需的。

邻居发现协议与Internet控制消息协议有许多相似之处。重要的一点是，与ICMP一样，ND也是一种消息传递协议。它不实现单个特定功能，而是通过交换消息来执行一组活动。这意味着我们不能通过“ND做什么”的具体描述来解释ND的操作，而必须通过ND提供的消息列表和这些消息的具体使用方式来定义其操作。

Internet上的任何本地网络都将同时具有常规主机和路由器，术语邻居可以指两者中的任何一个。当然，主机和路由器在网络中扮演不同的角色，因此邻居发现也各不相同。ND标准描述了该协议执行的九个特定功能。为了更好地了解这些功能以及它们之间的关系，我们可以根据通信类型和涉及的设备类型将它们分为三个功能组(参见图169)。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ndfunctions.png)

​                                                                          **图169：邻居发现协议(ND)功能组和功能**

<u>**主机-路由器发现功能**</u>

ND中的两组主要功能之一是促进本地路由器的发现以及它们与主机之间的信息交换。这包括四个具体功能：

- 路由器发现：这是此组的核心功能：主机在其本地网络上定位路由器的方法。
- 前缀发现：与路由器发现过程密切相关的是前缀发现。回想一下，术语“前缀”是指IP地址的网络部分。主机使用此功能来确定它们所在的网络，进而告诉它们如何区分本地和远程目的地，以及是尝试直接还是间接传送数据报。
- 参数发现：也与路由器发现密切相关，这是主机获取有关本地网络和/或路由器的重要参数的方法，例如本地链路的最大传输单位。
- 地址自动配置：IPv6中的主机设计为能够自动配置自身，但这需要通常由路由器提供的信息。

**主机-主机通信功能**
另一个主要功能组是与信息确定和节点(通常是主机)之间的直接通信相关的功能。其中一些功能可以在主机和路由器之间执行，但此组与路由器发现无关；它包括：

- 地址解析：设备根据本地网络中另一台设备的第三层(IP)地址确定该设备的第二层地址的过程。这是IP版本4中的ARP执行的工作。
- 下一跳确定：查看IP数据报的目的地址并确定其下一步应发送到何处的方法。
- 邻居不可达检测：确定是否可以直接联系邻居设备的过程。
- 重复地址检测：确定设备希望使用的地址是否已存在于网络上。

**重定向功能**

最后一个功能组只包含一个功能：重定向。路由器通知主机更好的下一跳节点以用于特定目的地的技术。

**关键概念：**邻居发现协议包含九个单独的功能，其中许多功能相互关联。它们被组织成三个功能组：主机-路由器发现功能、主机-主机通信功能和重定向功能。

**<u>功能之间的关系</u>**

将ND的总体功能划分为三组中的九个任务有点武断，但为理解协议的功能提供了一个很好的参考框架。显然，不同组中的一些功能是相关的；下一跳确定使用作为参数发现的一部分获得的信息。重定向功能也是路由器-主机通信的一种形式，但不同于路由器发现。

<u>**邻居发现协议使用的ICMPv6消息**</u>
就像ND在操作上类似于ICMP一样，这两个协议以另一种方式联系在一起：完成消息传递的方法。ND实际上使用ICMPv6消息来实现其功能。ND标准中描述了一组五种消息类型：

- 路由器通告消息：由路由器定期发送，以告知主机它们的存在，并向它们提供重要的前缀和参数信息。
- 路由器请求消息：由主机发送，以请求任何本地路由器发送路由器通告消息，以便它们不必等待下一个常规通告消息。
- 邻居通告消息：由主机发送，用于指示主机是否存在并提供有关该主机的信息。
- 邻居请求消息：用于验证另一台主机是否存在并要求其传输邻居通告。
- 重定向消息：由路由器发送，以告知主机有更好的方法将数据路由到特定目的地。

有关如何使用这些消息类型的更多详细信息，请参阅本节后面更详细描述上述三个功能组的主题。ND使用的五种ICMPv6报文类型的结构可在ICMPv6信息性报文类型和格式一节中找到。

##### 3.3.1 IPv6 ND Functions 与等效的IPv4 Functions 的比较

IPv6邻居发现协议的独特之处在于，它是唯一真正作为Internet协议版本6核心的一部分创建的新协议；根本没有“NDv4”。当然，ND向IPv6提供的大部分服务也是互联网协议版本4所要求的。它们只是在一套相当不同的协议和标准中提供的，ND协议对这些协议和标准进行了形式化、集成和改进。

这意味着，虽然ND是新的，但它所执行的任务与IPv4中的其他几个协议执行的任务相同。具体地说，大量ND功能对应于IPv4中的以下一组标准、功能和消息类型：

- ICMPv4路由器发现：与识别ND中的路由器并从其获取信息相关的大部分功能都基于RFC 1256中定义的ICMPv4路由器通告和路由器请求消息的使用。
- 地址解析协议：ND提供增强的地址解析功能，类似于ARP在IPv4中提供的功能。
- ICMPv4重定向：ND的重定向功能和重定向消息基于在IPv4和ICMPv4中定义的类似功能。

当然，ND的其他方面与IPv4中的工作方式只有一定程度的关联。与这些IPv4功能的工作方式相比，还有一些改进或新功能。其中一些原因实际上是由于与IPv4相比，IPv6本身的运作方式有所不同。例如，ND中的前缀发现在某种程度上与ICMPv4中的地址掩码请求和地址掩码回复消息传递有关。

总体而言，与IP版本4中的工作方式相比，ND的工作方式有了实质性的改进。与IPv6本身一样，ND通常比旧协议更适合现代网络的需求。与在IPv4中完成工作的方式相比，ND中所做的一些更重要的具体改进包括：

路由器发现的正规化：在IPv4中，路由器发现和请求的过程可以说是“事后才想到的”；ND将这一过程正式化，并使其成为TCP/IP协议组的核心的一部分。

- 地址解析的形式化：以类似的方式，在ND中以更好的方式处理地址解析。ND在第三层运行，与ICMP一样与IP紧密绑定。不再需要像ARP这样的“模棱两可的分层”协议，它的实现非常依赖于底层物理层和数据链路层。
- 能够安全地执行功能：ND在网络层运行，因此它可以利用IPSec的身份验证和加密功能来执行地址解析或路由器发现等任务。
- 自动配置：与IPv6中内置的功能相结合，ND允许许多设备自动配置自己，即使不需要像DHCP服务器这样的东西(尽管也存在DHCPv6)。
- 动态路由器选择：设备使用ND来检测邻居是否可访问。如果设备正在使用无法访问的路由器，它将检测到这一点并自动切换到另一台路由器。
- 基于组播的地址解析：使用特殊的组播地址而不是广播来执行地址解析，从而在必须发送解析消息时减少对“无辜旁观者”的不必要干扰。
- 更好的重定向：对生成和使用重定向的方法进行了改进。

##### 3.3.1 IPv6 ND主机-路由器发现功能：路由器发现、前缀发现、参数发现和地址自动配置(第1部分：2 3)

网际网络是通过将各个网络连接在一起来创建的。负责这种网络连接的设备是路由器，它将数据从一个网络发送到另一个网络。主机必须依靠路由器将传输转发到本地网络上的设备以外的所有设备。因此，在主机可以正确使用网际网络之前，它需要找到本地路由器并了解有关该路由器和网络本身的重要信息。启用这种信息交换是IPv6邻居发现协议最重要的工作之一。

用于描述本地网络中主机和路由器之间的大部分ND通信的通用术语是发现。正如我们在本部分前面讨论的，该术语不仅包括路由器的发现，还包括重要参数的通信。这些通信大部分从路由器流向主机，因为路由器实际上控制着每个网络的使用方式。它们向主机提供信息，以便主机知道如何最好地操作。

与主机-路由器通信相关的各种发现功能都是通过两种不同ICMPv6消息类型的相同交换实现的。路由器通告消息仅由路由器发送，其中包含有关路由器及其所在网络的信息。路由器请求消息是可选的，由主机在需要查找本地路由器时发送。ICMPv6信息性报文一节介绍了每条报文的格式。

<u>**主机-路由器执行的路由器发现功能**</u>

使用这些消息的机制并不真的那么复杂。要全面了解发现过程的工作原理，最好的方法是查看ND中路由器和主机执行的特定任务。让我们从路由器执行的操作开始：

- 例行通告：路由器在ND中的主要工作是定期传输路由器通告消息。每台路由器都有一个定时器，用于控制发出通告的频率。当出现任何特殊情况时，也会发送广告。例如，如果有关路由器的关键信息发生更改，例如其在本地网络上的地址，则会发送一条消息。
- 路由器通告消息包括有关路由器和网络的关键信息。有关路由器通告消息格式的完整说明，请参阅ICMPv6部分中的相关主题。
- 参数维护：路由器负责维护有关本地网络的关键参数，以便在通告中发送。其中包括网络上的主机应使用的默认跃点限制、网络的默认MTU值，以及用于主机的第一跳路由和自动配置的网络前缀等信息。
- 此外，在讨论路由器通告字段的主题中可以找到有关这些字段的更多详细信息。
- 请求处理：路由器侦听路由器请求消息，当收到消息时，将立即向请求主机发送路由器通告。

<u>**主机-主机执行的路由器发现功能**</u>

就其本身而言，主机负责三个主要功能

- 通告处理：主机监听其本地网络上的通告并对其进行处理。然后，他们根据这些消息中的信息设置适当的参数。这包括维护各种数据结构，如前缀和路由器列表，随着新广告信息的到来而定期更新。
- 请求生成：在特定条件下，主机将生成路由器请求并将其发送到本地网络。这条非常简单的消息只是请求任何听到它的本地路由器立即向发出请求的设备发回路由器通告消息。这通常是在主持人第一次开机的时候完成的，所以它不必坐等下一个例行公事的广告。
- 自动配置：当需要时，如果网络支持该功能，主机将使用来自本地路由器的信息，以允许其使用IP地址和其他参数自动配置自身。

**关键概念：**邻居发现协议的两个主要功能组之一是主机-路由器发现功能集。它们允许本地网络上的主机发现本地路由器的身份，并了解有关如何使用网络的重要参数。主机路由器发现操作使用ICMPv6路由器通告和路由器请求消息执行。

**注意：**路由器通告和路由器请求消息都可以包括发送该消息的设备的可选第2层地址。这用于更新地址解析缓存，以便在以后需要地址解析时节省时间。

##### 3.3.1 IPv6 ND主机-主机通信功能：地址解析、下一跳确定、邻居不可达检测和重复地址检测(第1部分：2 3)

IP中数据报的传递可以分为直接和间接两种方式。间接数据报传输需要路由器为主机提供帮助，这导致了我们在上一主题中研究的主机-路由器发现功能。数据报直接从同一网络上的一台主机传输到另一台主机。这不需要使用路由器，但需要其他IPv6 ND协议功能，这些功能直接涉及本地主机之间的下一跳确定通信。

<u>**下一跳确定**</u>
任何主机在发送数据报时必须执行的第一个任务是确定下一跳。这是设备查看数据报中的目的地址并决定需要直接传输还是间接传输的过程。在早期的IPv4中，这是通过查看地址的类别，然后使用子网掩码来实现的。在IPv6中，将从本地路由器获得的前缀信息与数据报的目的地进行比较，以确定目的地设备是本地设备还是远程设备。如果它是本地的，则下一跳与目的地址相同；如果它是非本地的，则从设备的本地路由器列表中选择下一跳(通过手动配置或使用ND的主机路由器发现功能确定)。

为了提高效率，主机不会为每个数据报执行此下一跳确定。它们维护一个目的地缓存，其中包含有关数据报已发送到的最新设备的下一跳应该是什么的信息。每次对特定目的地执行下一跳确定时，该确定的信息都会输入到缓存中，以便在下一次将数据报发送到该设备时使用。

<u>**地址解析**</u>

如果主机确定数据报的目的地实际上是本地的，则需要将该数据报发送到该设备。实际传输将使用任何物理层和数据链路层技术来实施本地网络。这要求我们知道目的地的第2层地址，即使我们通常只有来自数据报的第3层地址。从第3层地址获取第2层地址称为地址解析问题。

在IPv6中，ND协议负责地址解析。当主机想要获取数据报目的地的第2层地址时，它会发送邻居请求ICMPv6消息，其中包含要确定其第2层地址的设备的IP地址。该设备使用包含其第2层地址的邻居通告消息进行响应。请求不是使用会扰乱本地网络上的每个设备的广播，而是使用特殊的组播发送到目标设备的请求节点地址。有关IPv6中地址解析的更完整描述，请参阅有关地址解析的一般部分。

另请注意，即使此讨论集中在主机之间的通信上，当主机需要向本地路由器发送数据报并且其目的缓存中没有相应的条目时，也可以进行地址解析。在地址解析环境中，目的设备“只是一个邻居”。它是主机还是路由器，仅与发送和接收数据报后发生的情况有关。换句话说，这些“主机到主机”功能之所以这样命名，只是因为它们不像上一个主题中的任务那样特定于主机和路由器之间的通信。

<u>**使用邻居通告消息更新邻居**</u>
设备通常不会像路由器发送路由器通告那样发送邻居通告。这真的没有任何必要：邻居不会随着时间的推移而发生太大变化，随着时间的推移，当设备相互发送数据报时，解析将自然发生。此外，让网络上如此多的设备定期发送广告将是浪费的。

然而，主机可以在其认为有必要立即向本地网络上的其他邻居提供更新信息的某些条件下发送未经请求的邻居通告。硬件故障就是一个很好的例子--尤其是网络接口卡的故障。更换卡时，设备的第二层(MAC)地址将更改。假设设备的IP层可以检测到这一点，它可以发送未经请求的邻居通告消息，告诉其他设备使用新的MAC地址更新它们的解析缓存。

<u>**邻居不可达检测与邻居缓存**</u>

邻居请求和邻居通告消息最常与地址解析相关联，但也有其他用途。其中之一是邻居不可达检测。每台设备维护有关其每个邻居的信息，并随着网络条件的变化动态更新信息。作为本地网络邻居的主机和路由器设备的信息都会保留。

知道设备已变得无法访问非常重要，因为主机可以相应地调整其行为。在主机无法访问的情况下，设备可能会在尝试向无法访问的主机发送数据报之前等待一段时间，而不是通过反复尝试向主机发送数据报来淹没网络。另一方面，无法到达的路由器是设备需要寻找新路由器使用的信号(如果有备用路由器可用)。

每台主机都维护一个邻居缓存，其中包含有关邻居设备的信息。主机每次从邻居收到数据报时，都知道该邻居在该特定时刻是可访问的，因此该设备在缓存中为该邻居创建了一个条目来指示这一点。当然，现在从邻居那里收到数据报只意味着该邻居现在是可到达的；自收到最后一个数据报以来经过的时间越长，发生使该邻居不再可达的事情的可能性就越大。

因此，邻居连通性信息必须被视为临时信息。每次将邻居作为可访问邻居输入缓存时，都会启动计时器。当计时器超时时，该邻居的可达性信息被认为是过时的，并且不再假定该邻居的可达性。当从所讨论的邻居接收到新的数据报时，计时器被重置，并且缓存再次被设置以指示该设备是可到达的。本地路由器使用路由器通告消息中的一个字段传递在过期之前主机应将邻居视为可访问的时间量。

如果主机需要了解其可达性状态，它还可以动态查找邻居。它向设备发送邻居请求，并等待邻居通告作为响应。然后，它相应地更新缓存。

**重复地址检测**
我们在这里讨论的两个消息的最后一个用途是重复地址检测。当主机使用IPv6自动配置功能时，该过程中的一个步骤是确保它试图使用的地址在网络上不存在。这是通过向设备希望使用的地址发送邻居请求消息来实现的。如果收到邻居通告作为回复，则该地址已在使用中。

**关键概念：**邻居发现协议的两个主要功能组中的第二个是主机-主机通信功能集。定义了两个ICMPv6消息：邻居通告和邻居请求，它们支持本地网络中相邻主机之间的各种基本通信。其中包括地址解析、确定数据报应发送到的下一跳，以及评估相邻设备的可达性。

##### 3.3.1 IPv6 ND重定向功能

IPv6邻居发现协议的最后一项主要职责是重定向功能。路由器使用它来通知主机用于将数据报发送到特定目的地的更好的路由。可以论证重定向功能应该是主机-路由器组的一部分，因为它代表路由器和常规主机之间的一种通信形式。但是，它与其他“发现”功能有些不同，因此标准将其分开处理。

路由器负责检测本地网络中的主机做出低效的第一跳路由决定的情况，然后尝试纠正该决定。例如，假设网络上有两台路由器，即R1和R2。主机H1想要将数据报发送到通过路由器R2连接到H1网络的另一个网络上的设备X2。如果H1将数据报发送到R1，则R1当然知道它必须经过R2并将其发送到那里。由于R2也在本地网络中，因此R1知道H1的初始路由决定很糟糕：数据报应该直接发送到R2，而不是R1。如果这听起来与ICMPv4重定向功能非常相似，那是因为它确实如此。

作为响应，R1将创建特殊的重定向ICMPv6消息。此消息将告诉H1，对于要发送到X2的任何后续数据报，应首先将其发送到R2，而不是R1。路由器也可能确定来自特定主机的第一跳应该不同的其他情况，并使用重定向消息通知主机。这一点如图170所示。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ndredirection.png)

​                                                          **图170：使用ICMPv6重定向消息的ND主机重定向。**

H1向R1发送发往网络N2上的设备的IPv6数据报。但是，R1注意到R2与源设备位于同一网络中，因此是通向N2的更直接的路由。它会将数据报转发到R2，但也会将ICMPv6重定向消息发送回H1，告知其下次使用R2。

只有路由器发送重定向消息，而不是主机。主机负责查找这些重定向消息并对其进行处理。收到此类消息的主机将查看该消息，以查看哪个目的地的数据报导致了重定向，以及路由器表示主机将来应该为该目的地使用哪个新的第一跳。在本例中，H1将看到R1表示发往X2的任何进一步数据报都应发送到R2，而不是R1。H1将相应地为X2更新其目标高速缓存。

**关键概念：**邻居发现协议重定向功能允许路由器通知主机使用不同的路由器进行将来到特定目的地的传输。它类似于IPv4重定向功能，并使用ICMPv6重定向消息实施。

当路由器发送重定向时，它还可以在消息中包括它要重定向到的目的地的数据链路层地址。如有必要，主机使用此地址来更新其地址解析缓存。当重定向的主机尝试发送到新的、重定向的位置时，这可以通过消除地址解析周期来节省将来的带宽。在我们的示例中，R1可能会在重定向中包含R2自己的第2层地址。这可由H1在下次具有X2的数据报时使用。

IPv6还支持重定向消息的身份验证，以防止未经授权的设备通过发送不适当的重定向来造成严重破坏。主机可以配置为丢弃未正确验证的重定向。

#### 3.4 TCP/IP路由协议（网关协议）

路由不仅仅是发生在网络层的最重要的活动之一：它是真正定义 OSI 参考模型第三层的功能。路由使小型本地网络能够连接在一起，形成可能跨越城市、国家甚至全球的巨大互联网。这是由称为路由器的特殊设备完成的工作，它将数据报从一个网络转发到另一个网络，允许任何设备发送到任何其他设备，即使源不知道目的地在哪里。

路由是一个复杂的主题。该过程的简短摘要是路由器根据其目标地址决定如何转发数据报，该地址与路由器保存在特殊路由表中的信息进行比较。这些表包含路由器知道的每个网络的条目，告诉路由器应该将数据报发送到哪个相邻路由器，以便它到达其最终目的地。

可以想象，路由表对于路由过程至关重要。这些表可以由网络管理员手动维护，但这是乏味、耗时的，并且不允许路由器处理网际网络中的变化或问题。相反，大多数现代路由器都设计有允许它们与其他路由器共享路由信息的功能，因此它们可以自动更新其路由表。这种信息交换是通过使用路由协议来完成的。

在本节中，我将描述 TCP/IP 中使用的最常见的路由（或网关）协议。我首先概述了了解路由协议如何工作的各种重要概念。然后，我分两个小节描述 TCP/IP 路由协议本身。第一个涵盖了在自治系统中的路由器之间使用的内部路由协议，第二个关注在自治系统之间使用的外部路由协议。

如果您不了解自治系统是什么或内部协议和外部协议之间的区别，那么您就会知道为什么我首先包含一个关于概念的概述主题。事实上，一旦你对路由的整个过程有了很好的了解，理解路由协议真的要容易得多。

您可能会注意到，在本节的标题中，我指的是路由协议和网关协议。这些术语是可以互换的，事实上，网关这个词出现在几个协议的名称中。这是早期 TCP/IP 标准中网关一词的历史使用的产物，用于指代我们现在称为路由器的设备。今天，术语网关通常不是指路由器，而是指不同类型的网络互连设备，因此这可能特别令人困惑。现在首选术语“路由协议”，并且是我使用的那个。

**注意：**本节中的一些协议足够通用，可以应用它们来支持任何网络层协议的路由。然而，它们通常与 IP 相关联，因为 TCP/IP 是迄今为止最流行的互联网协议套件，这是我在描述它们时的假设。此外，本节主要关注 Internet 协议版本 4 中使用的路由协议。目前对协议的 IPv6 版本的讨论有限。

**注意：**严格来说，可以提出一些路由协议不属于第三层的论点。例如，他们中的许多人在第四层使用 TCP 或 UDP 发送消息。尽管如此，路由本质上是第三层活动，因此，传统上将路由协议视为第三层的一部分。

**注意：**与所有与路由相关的主题一样，路由协议通常非常复杂。我在这里比大多数一般的网络参考更详细地介绍了主要的，但即便如此，您应该认识到我只是触及了表面，尤其是像 OSPF 这样更复杂的网络。如果您愿意，可以查看参考的 Internet 标准 (RFC) 以获取更多详细信息。我还应该指出，在 IP 网络上使用的路由协议还有更多，我在此不做介绍，例如 **IS-IS**（它实际上是 OSI 协议，不是 TCP/IP 的正式组成部分）。

##### 3.4.1 关键路由协议概念概述：架构、协议类型、算法和指标（部分：1 2 3）

路由协议在互联网中的整个路由过程中起着重要作用。因此，在对路由的整体讨论范围内理解它们是最容易的。如果没有一些关于路由协议如何工作的背景信息，就很难描述各个TCP/IP路由协议。出于这个原因，我认为值得在这里简要介绍一下关键的路由协议概念，这样你就能更顺利地理解本节中其余的路由协议主题了。

<u>**路由协议架构**</u>
让我们先来看看路由协议的架构。在这里，架构这个词指的是互联网的结构方式。一旦我们有了一些我们希望连接在一起的网络和路由器，我们就有很多方法可以做到这一点。我们选择的架构是基于路由器的连接方式，这对路由的完成方式和路由协议的运行方式有影响。

**核心架构**
TCP/IP和互联网是同时开发的，因此TCP/IP路由协议随着互联网本身的发展而发展。早期的互联网架构由少量的核心路由器组成，其中包含了关于互联网的全面信息。当互联网非常小的时候，它是通过向这个核心添加更多的路由器来扩展的。然而，每次核心路由器被扩大，需要维护的路由信息量也随之增加。

最终，核心变得太大，所以形成了一个两级的层次结构，以允许进一步扩展。非核心路由器位于核心的外围，只包含部分路由信息；它们依靠核心路由器进行跨互联网的传输。在互联网核心内使用一种特殊的路由协议，称为网关到网关协议（GGP），而在非核心和核心路由器之间使用另一种协议，称为外部网关协议（EGP）。非核心路由器有时是单一的、独立的路由器，将一个网络连接到核心，或者它们可能是一个组织的一组路由器。

这种架构在一段时间内发挥了作用，但随着互联网的发展，它本身并没有很好地扩展。这个问题主要是由于这个架构只有一个层次：核心区的每一个路由器都必须与其他的路由器通信。即使外围路由器被保留在核心区之外，核心区的流量也在不断增长。

<u>**自治系统（AS）架构**</u>
为了解决早期核心系统的局限性，创建了一个新的架构，从核心的集中概念转向一个更适合更大和不断增长的国际网络的架构。这种分散的架构将互联网视为一组独立的组，每个组称为一个自治系统（AS）。一个AS由一组路由器和网络组成，由一个特定的组织或行政实体控制，它使用一个统一的政策进行内部路由选择。

这个系统的强大之处在于，整个互联网的路由发生在AS之间，而不是单个路由器之间。信息只在每个AS中的一个或几个路由器之间共享，而不是每个AS中的每个路由器。一个AS内的路由细节也是隐蔽的，不为国际网络的其他部分所知。这既为每个AS提供了灵活性，使其能够按照自己的意愿进行路由选择（因此被称为自治），也为整个互联网提供了效率。每个AS都有自己的号码，这些号码是全局管理的，以确保它们在整个国际网络（如互联网）中是唯一的。

**关键概念。**大型的、现代的TCP/IP网络可能包含成千上万的路由器。为了更好地管理这样一个环境中的路由，路由器被分组为称为自治系统的结构。每个自治系统（AS）由一组路由器组成，由一个特定的组织或实体独立管理。

<u>**现代协议类型：内部和外部路由协议**</u>

AS内和AS之间的路由的不同性质可以从以下事实中看出：每种类型使用不同的TCP/IP路由协议组：

- 内部路由协议：这些协议用于在自治系统内的路由器之间交换路由信息。AS之间不使用内部路由协议。
- 外部路由协议：这些协议用于在自治系统之间交换路由信息。在某些情况下，它们可以在AS内的路由器之间使用，但主要处理自治系统之间的信息交换。

**关键概念：**内部路由协议用于在自治系统内共享路由信息；每个AS可能使用不同的内部路由协议，因为顾名思义，该系统是自治的。外部路由协议在自治系统之间传输路由数据；每个AS必须使用相同的外部协议以确保它们可以通信。

由于自治系统只是路由器的集合，这意味着通过将一个AS中的路由器链接到另一个AS中的路由器来连接AS。从架构上看，AS由一组具有两种不同连接类型的路由器组成：

- 内部路由器：AS中的某些路由器仅连接到同一AS中的其他路由器。它们运行内部路由协议。
- 边界路由器：AS中的一些路由器既连接到AS中的路由器，也连接到一个或多个其他AS中的路由器。这些设备负责在AS和网际网络的其余部分之间传递流量。它们同时运行内部和外部路由协议。

由于其优势，自主系统体系结构(如图171所示)已成为TCP/IP网络的标准，尤其是因特网。因此，将路由协议划分为内部和外部类别也已成为标准，并且所有现代的TCP/IP路由协议首先以这种方式按类型细分。您可以在本节其余部分关于路由协议的小节标题中看到这一点。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\routingas.png)

​                                                             **图171：TCP/IP自治系统(AS)路由体系结构。**

此图显示了一个组织成三个自治系统(AS)的简化互联网，每个自治系统都独立于其他系统进行管理。每个AS内的通信使用由AS管理员选择的内部路由协议(蓝色链路)来完成；AS之间的通信必须使用公共外部路由协议(红色链路)来完成。内部路由器显示为蓝色，边界路由器显示为红色。

**路由协议算法和度量。**

路由协议的另一个关键区别是它们使用的算法和度量。算法是指协议用于确定任意网络对之间的最佳路由以及用于在路由器之间共享路由信息的方法。度量是用来评估特定路由效率的“开销”度量。由于网际网络可能非常复杂，因此协议的算法和度量非常重要，并且可能是决定一种协议优于另一种协议的决定因素。

**最常遇到的路由协议算法有两种：距离向量和链路状态。也有结合使用这些方法或其他方法的协议。**

<u>**距离向量(Bellman-Ford)路由协议算法**</u>
距离矢量路由算法，也称为贝尔曼-福特算法，以其两位发明者的名字命名，是一种根据网络之间的距离来选择路由的算法。距离度量很简单--通常是“跳数”，即它们之间的路由器数。

使用此类协议的路由器将有关到所有已知网络的距离信息保存在一个表中。它们会定期将该表发送给它们立即连接的每台路由器(它们的邻居或对等体)。然后，这些路由器更新它们的表并发送给它们的邻居。这会导致距离信息在网际网络中传播，因此最终每台路由器都会获得有关互联网上所有网络的距离信息。

距离矢量路由协议在选择最佳路由方面存在一定的局限性。它们在操作中也会遇到某些问题，必须通过添加特殊的启发式方法和功能来解决这些问题。它们的主要优势是简单性和历史性(它们已经被使用了很长时间)。

<u>**链路状态(最短路径优先)路由协议算法：**</u>
链路状态算法根据对任意两个网络之间的最短路径的动态评估来选择路由，因此也称为最短路径优先方法。每台路由器都维护一张描述网际网络当前拓扑的地图。该映射通过测试互联网不同部分的可达性以及通过与其他路由器交换链路状态信息来定期更新。可以基于指示在特定路由上发送数据报的真实成本的各种度量来确定最佳路径(最短路径)。

链路状态算法比距离向量算法强大得多。它们能够动态适应不断变化的网际网络条件，并且还允许根据更现实的成本度量来选择路由，而不仅仅是网络之间的跳数。然而，与距离向量算法相比，它们设置和使用更多的计算机处理资源更加复杂，而且没有那么成熟。

<u>**混合路由协议算法**</u>
还有一些混合协议结合了这两种算法的功能，还有一些协议使用了完全不同的算法。例如，边界网关协议(BGP)是一种路径向量算法，它在某种程度上类似于距离向量算法，但可以传递更详细的路由信息。它包括距离向量协议和链路状态协议的一些属性，但不仅仅是这两者的组合。

<u>**静态和动态路由协议**</u>
您可能偶尔会看到按类型将路由协议分为静态和动态两类，因此这是我在本概述中要讨论的最后一个概念。这个术语有些误导。术语“静态路由”只是指手动设置路由表，因此它们保持静态的情况。相反，“动态路由”是整个部分的主题：使用路由协议动态更新路由表。因此，所有的路由协议都是“动态的”。除非您将编辑路由表的网络管理员视为“协议”，否则根本就没有“静态路由协议”这回事。

##### 3.4.2 TCP/IP 内部路由协议（RIP、OSPF、GGP、HELLO、IGRP、EIGRP）

现代的TCP/IP路由体系结构将路由器分组为自治系统(AS)，这些自治系统由不同的组织和公司独立控制。用于促进AS内路由器之间的路由信息交换的路由协议称为内部路由协议(或历史上称为内部网关协议)。由于大多数网络管理员负责特定组织内的路由器，因此这些是您最有可能处理的路由协议，除非您成为主要的互联网大亨。J。

自主系统架构的好处之一是AS内发生的细节对网际网络的其余部分是隐藏的。这意味着，不需要像外部路由协议那样，在互联网的单一“语言”上达成统一的协议。作为AS的网络管理员，您可以自由选择最适合您的网络的任何内部路由协议。其结果是没有就使用单一的TCP/IP内部路由协议达成一致。今天有几个常用的词，尽管像往常一样，其中一些比另一些更受欢迎。

在本部分中，我将介绍六种不同的协议，这些协议用于在TCP/IP中的自治系统内进行路由。前两节全面介绍了两种最常用的TCP/IP内部路由协议：路由信息协议(RIP)和开放最短路径优先协议(OSPF)。第三节更简要地讨论了网络领导者思科系统公司开发的两个历史内部路由协议和两个专有协议。

###### 3.4.2.1 TCP/IP路由信息协议(RIP、RIP-2和RIPng)

最常用的TCP/IP内部路由协议是路由信息协议(RIP)。名称的简单性与协议的简单性相匹配-RIP是所有路由协议中配置最容易且对资源要求最低的协议之一。它的流行既是因为它的简单性，也是因为它的悠久历史。事实上，只要TCP/IP本身存在，对RIP的支持就已经内置于操作系统中。

在本部分中，我将介绍TCP/IP路由信息协议(RIP)的特征和操作。RIP有三个版本：IP版本4的RIP版本1和版本2以及IP版本6的RIPng(下一代)。这三个版本的协议的基本操作基本相同，但它们之间也有一些显著的差异，特别是在发送消息的格式方面。

因此，我将我对RIP的描述分为两个小节。首先，我描述了RIP的基本属性及其在所有三个版本中的一般操作。在第二个版本中，我将仔细查看每个版本，显示每个版本使用的消息格式，并讨论特定于版本的功能。

###### 3.4.2.1-1 RIP基础知识和一般操作

路由信息协议(RIP)是最早在TCP/IP中使用的内部路由协议之一。20多年后，它继续被广泛使用。尽管RIP具有重要的局限性，导致一些人对其进行恶意攻击，并实际上导致了在技术上优于RIP的较新路由协议的开发，但直到今天，RIP仍在TCP/IP路由中占有重要地位。RIP有未来的证据可以从协议的IPv6版本RIPng的创建中看到。

在本部分中，我将全面介绍RIP的特点以及它的一般工作原理。我从协议的概述和历史开始，包括对其不同版本和定义它们的标准的简要讨论。我将介绍RIP用于确定路由的方法和用于评估路由开销的度量。我描述了协议的一般操作，包括消息类型和发送时间。然后，我将介绍RIP最重要的限制和问题，以及为解决基本RIP算法的几个问题而添加到该协议中的特殊功能。

###### 3.4.2.1-1-1 RIP概述、历史、标准和版本(部分：1 2 3)

多年来，路由信息协议(RIP)一直是TCP/IP协议簇中最受欢迎的内部路由协议。该协议的历史以及它是如何获得突出地位的是一个相当有趣的历史。与TCP/IP协议簇中的许多其他重要协议不同，RIP最初并不是使用RFC标准化过程正式开发的。相反，它演变成了事实上的行业标准，后来才成为互联网标准。

<u>**RIP的早期历史**</u>
RIP的历史与另一个网络重量级企业--以太网--有一些共同之处。与强大的局域网技术一样，RIP的根源可以追溯到施乐的帕洛阿尔托研究中心(PARC)。在开发用于连接局域网的以太网的同时，PARC创建了在以太网上运行的高层协议，称为Xerox Parc通用协议(PUP)。PUP需要一个路由协议，所以施乐创建了一个称为网关信息协议(GWINFO)的协议。它后来被重命名为路由信息协议，并用作Xerox网络系统(XNS)协议组的一部分。

当加州大学伯克利分校的开发人员将其修改为用于Unix操作系统的Berkeley标准分发版(BSD)时，RIP进入了主流。RIP最早出现在1982年的BSD版本4.2中，在那里它被实现为被路由的UNIX程序(发音为“route-dee”，而不是“rout-ed”--“d”代表守护程序，这是一个常见的表示服务器进程的Unix术语)。

BSD过去是(现在仍然是)非常流行的操作系统，尤其是对于连接到早期互联网的机器而言。因此，RIP得到了广泛部署，并成为内部路由协议的行业标准。它既用于TCP/IP，也用于其他协议组。事实上，许多其他路由协议，例如AppleTalk套件中的RTP协议，都是基于此早期版本的RIP的。

<u>**RIP标准化。**</u>
有一段时间，Routed的BSD实现实际上被认为是协议本身的标准。然而，这并不是一个正式定义的标准，这意味着它的确切运作方式没有正式的定义。随着时间的推移，这会导致协议的各种实现略有不同。为了解决实施之间潜在的互操作性问题，IETF在1988年6月发布的互联网标准RFC 1058(路由信息协议)中正式指定了RIP。该RFC直接基于BSD Routed程序。RIP的原始版本现在有时也称为RIP版本1或RIP-1，以区别于以后的版本。

RIP的流行在很大程度上是因为它包含在BSD中；这反过来又是协议相对简单的结果。RIP使用距离向量算法(也称为贝尔曼-福特算法，以其两位发明者的名字命名)来确定路线。每台路由器维护一个包含网际网络中各种网络或主机条目的路由表。每个条目都包含两条主要信息：网络或主机的地址，以及到网络或主机的距离，单位为跳数，这就是数据报到达目的地所必须经过的路由器数。

<u>**RIP操作概述、优点和限制**</u>

在定期的基础上，国际网络中的每个路由器在它所连接的每个网络上用UDP的特殊消息发送其路由表。其他路由器收到这些表并使用它们来更新自己的表。这是通过把它们收到的每一条路由，增加一个额外的跳数来完成的。例如，如果路由器A收到路由器B的指示，网络N1离它有4跳，那么由于路由器A和路由器B是相邻的，从路由器A到N1的距离是5跳。 路由器更新其表后，它反过来将这些信息发送给其本地网络的其他路由器。随着时间的推移，所有网络的路由距离信息会在整个互联网上传播。

RIP操作简单，易于实现，对路由器的处理能力要求不高，这使得它在较小的自治系统中特别有吸引力。然而，由于该协议的简单性，也有一些重要的限制。首先，在选择路由时，跳数往往不是最佳指标。算法本身也有一些问题。这些问题包括收敛速度慢（让所有路由器同意相同的路由信息的延迟）和处理网络链接故障的问题。

RIP包括几个特殊的功能来解决其中的一些问题，但其他的是协议的固有限制。例如，RIP只支持目的地之间最多15跳，这使得它不适合非常大的自治系统，而且这一点不能改变。

**关键概念**：路由信息协议（RIP）是最古老和最流行的内部路由协议之一。它使用距离矢量算法，每个路由器维护一个表，表明如何到达自治系统中的各种网络，以及到它的距离（跳数）。RIP很受欢迎，因为它是完善和简单的，但也有一些重要的限制。

<u>**RIP第二版（RIP-2）和RIPng for IPv6的发展**</u>

RIP的其他一些问题是由于它是在20世纪80年代初开发的，当时TCP/IP还处于起步阶段。随着时间的推移，随着TCP/IP协议的使用发生变化，RIP变得过时了。作为回应，RIP第二版，即RIP-2，在20世纪90年代初创建。RIP-2为RIP定义了一种新的消息格式，并包括一些新的功能，包括支持无类寻址、认证，以及使用组播而不是广播来提高网络性能。它首先在1993年1月发表的RFC 1388，RIP第二版携带附加信息中定义。该RFC在RFC 1723中进行了修订，并在1998年11月的RFC 2453, RIP Version 2中最终确定。

在它首次创建的二十多年后，RIP仍然是一个受欢迎的内部路由协议。它的局限性导致许多互联网专家希望该协议最终会 "消失"，以支持像OSPF这样在严格的技术基础上更优越的新协议。有些人甚至讽刺地建议，也许最好让RIP "R. I. P."（"安息"）。("安息")。 然而，一旦一个协议变得流行，就很难抵挡其势头，而且RIP可能会在未来许多年继续使用。

为了确保RIP在未来能与TCP/IP一起工作，有必要定义一个能与新的互联网协议版本6（IPv6）一起工作的版本。1997年，RFC 2080发表，标题为RIPng for IPv6。ng代表下一代--请注意，IPv6有时也被称为IPng。RIPng不只是RIP的一个新版本，如RIP-2，而是被定义为一个新的独立的协议。然而，它是紧密基于原始RIP和RIP-2标准的。由于IPv4和IPv6之间的变化，需要一个独立的协议（而不是原始协议的修订），尽管RIP和RIPng的基本工作方式相同。RIPng有时也被称为RIPv6。

**关键概念。**RIP的原始版本具有最少的功能，现在被称为RIP-1。RIP-2的创建是为了增加对无类寻址和其他功能的支持。RIPng是为了与IPv6兼容而创建的版本。

###### 3.4.2.1-1-2 RIP路由确定算法和度量(第1部分：第2部分)

正如我在关于TCP/IP路由协议的概述主题中提到的，任何路由协议的决定性特征之一是它用于确定路由的算法。RIP属于使用距离向量或Bellman-Ford路由算法的一类协议。为了帮助你更好地理解RIP到底是如何确定路由的，我现在将讨论RIP算法的具体实现，并提供一个例子，这样你就可以看到RIP到底是如何确定路由并在网络中传播信息的。

<u>**RIP的路由信息和路由距离度量**</u>
像任何路由协议一样，RIP的工作是提供一个交换路由信息的机制，以便路由器能够保持他们的路由表是最新的。RIP网络中的每个路由器都在其路由表中跟踪网络中的所有网络（可能还有个别主机）。对于每个网络或主机，该设备包括各种信息，其中最重要的是以下信息。

- 网络或主机的地址。

- 从该路由器到该网络或主机的距离。

- 路由的第一跳：数据报必须首先发送到哪个设备才能最终到达该网络或主机。

理论上，距离指标可以是对成本的任何评估，但在RIP中，距离是以跳数计算的。你可能已经知道，在TCP/IP术语中，当数据报通过路由器时，它就会有一跳。因此，路由器和网络之间的RIP距离是衡量数据报到达网络所必须经过的路由器的数量。如果一个路由器直接连接到一个网络，那么这个距离就是一跳。如果它经过一个路由器，距离是2跳，以此类推。在RIP中，任何网络或主机最多允许有15跳。数值16被定义为无穷大，所以一个包含16的条目意味着 "这个网络或主机是不可到达的"。

<u>**RIP路由确定算法**</u>
在定期的基础上，每个运行RIP的路由器将发送它的路由表条目，向其他路由器提供关于它知道如何到达的网络和主机的信息。与发送该信息的路由器在同一网络上的任何路由器将能够根据它们收到的信息更新它们自己的表。任何路由器如果收到同一网络上的另一个路由器的信息，说它能以N的代价到达网络X，就知道它能以N+1的代价到达网络X，方法是向它收到信息的那个路由器发送。

<u>**RIP 路由确定和信息传播实例**</u>

让我们举一个具体的例子来帮助我们更好地理解如何使用 RIP 确定路由。考虑一个相对简单的内联网，有四个独立的网络，连接方式如下。

- 路由器A（RA）将网络1（N1）连接到网络2（N2）

- 路由器B（RB）和C（RC）将网络2连接到网络3（N3）

- 路由器D（RD）将网络3连接到网络4（N4）

这个自治系统的例子如图172所示。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ripas.png)

​                                                                                        <u>**图172: RIP自治系统的例子**</u>

这是一个简单自治系统的例子，它包含四个物理网络和四个路由器。

现在，让我们假设我们刚刚打开了路由器RA。它看到它与N1和N2直接相连，所以它的路由表中会有一个条目，表明它可以以1的成本到达N1，我们可以表示为{N1,1}。关于网络1的信息将通过以下步骤从Router RA传播到整个国际网络（你可以在图173中观察到图形）。

1. 路由器A在它所连接的每个网络上发送一个包含{N1,1}条目的RIP消息。N1上没有其他路由器，所以那里没有发生任何事情。但是RB和RC在N2上，所以他们收到了这个信息。

2. RB和RC将查看他们的路由表，看看他们是否已经有N1的条目。假设都没有，他们将各自为路由器A创建一个路由表项{N1,2}。这意味着 "我可以通过向路由器A发送，以2跳的代价到达网络1"。

3. RB和RC将各自把自己的路由表通过他们所连接的网络发送出去。N2和N3。这将包含{N1,2}这个条目。RA将在N2上收到该信息，但会忽略它，因为它知道它可以直接到达N1（成本为1，小于2）。但是Router D将在N3上收到该信息。

4. RD将检查它的路由表，看到没有N1的条目，将为RB或RC添加{N1,3}条目。当然，任何一个都可以，所以选择哪一个完全取决于RD是先从RB还是RC收到关于N1的信息。

5. RD将在网络4上发送{N1,3}条目，当然，那里没有其他路由器可以听到它。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ripalgorithm.png)

​                                                                                  <u>**图173：使用RIP传播网络路由信息**</u>

这个综合图说明了将网络N1的路由信息从RA传播到自治系统的其他部分的五个步骤。在步骤#1中，信息从RA发送到它的两个连接网络。在步骤2中，信息到达路由器RB和RC，然后它们知道它们可以通过RA到达N1，但要多花一跳。在步骤#3中，这两个路由器将此信息发送到他们的网络上，在步骤#4中，信息到达RD。在步骤#5中，RD将信息发送出去，但周围没有其他路由器可以接收它。

RIP的设计使得仅在收到有关较短路线的信息时才更换路由条目；如果您愿意，纽带将进入现任者。这意味着，一旦RD创建了N1的条目，成本为3，如果它收到可以以3到RC相同的成本到达N1的信息，它将忽略它。同样，如果首先获取RC的信息，它将忽略RB的信息。

当然，这种相同的传播方案也会发生在所有其他网络中；我只是展示了关于N1的信息如何从路由器移动到路由器。例如，路由器A最终将为N4安装一个条目，说它可以通过RB或RC以3的代价到达：这将是{N4,RB,3}或{N4,RC,3}。

这种网络路由信息的传播是定期发生的，当网络结构发生变化时也会发生（由于地形的有意改变或链接或路由器的失败）。当这种情况发生时，变化信息将在国际网络中移动，使所有路由器最终得到更新。例如，假设从路由器C到网络1增加了一个连接。如果路由器D以前有{N1,RB,3}条目，它最终会把这个条目改为{N1,RC,2}，因为它现在可以通过路由器C更快地到达N1。

<u>**默认路由**</u>

在某些情况下，大型网络中的每个网络或主机要完全指定自己的路由条目并不方便。在这种情况下，为网络指定一个默认路由，用于到达他们没有信息的主机或网络，可能是有利的。这方面最常见的例子是，一个自治系统通过一个路由器连接到公共互联网。除了该路由器，本地网络的其他部分不需要知道如何访问互联网。

在RIP中，关于默认路由的信息是通过让旨在处理这种流量的路由器发送关于地址为0.0.0.0的 "假 "网络的信息来传达的。当关于路由的信息用RIP消息在国际网络上传播时，这被当作一个普通的网络，但是其他设备可以识别这个特殊的地址并理解它意味着默认路由。

注意：本主题中的算法描述是RIP使用的基本算法。这在某些方面进行了修改，以解决在特殊情况下由于算法的工作方式而可能出现的一些问题。本章后面的主题描述了这些问题以及 RIP 为解决这些问题所包括的特殊功能。

**关键概念:** 在RIP中，路由信息是通过一个简单的算法在路由器之间传播的。在定期的基础上，每个路由器发送RIP消息，指定它可以到达哪些网络，以及到达这些网络需要多少跳。与该路由器直接相连的其他路由器知道，它们可以通过该路由器到达这些网络，但需要增加一跳。因此，如果路由器A发送消息说它可以以N跳的代价到达网络X，那么其他直接连接到A的路由器可以以N+1跳的代价到达网络X。它将把这一信息放入其路由表，除非它知道通过另一个路由器有一个成本更低的替代路由。

###### 3.4.2.1-1-3 RIP一般操作、报文传送和计时器(部分：1 2 3)

RIP是一个交换路由信息的协议，所以它的操作最好用来交换这种信息的消息以及消息发送的规则来描述。每个路由器中的RIP软件都会发送消息并采取其他行动，以对某些事件作出反应，并对定时器所触发的事件作出反应。计时器还被用来确定何时应丢弃未更新的路由信息。

<u>**RIP消息和基本消息类型**</u>
互联网上路由器中的RIP软件元素之间的通信是通过使用RIP消息完成的。这些消息使用用户数据报协议（UDP）发送，RIP-1和RIP-2的UDP端口号为520，RIPng为521。因此，即使RIP像其他路由协议一样被认为是第三层的一部分，但就其发送消息的方式而言，它的行为更像一个应用程序。消息的确切格式与版本有关，所有三种格式（用于RIP、RIP-2和RIPng）都在各自的章节中详细描述。RIP消息既可以被发送到一个特定的设备，也可以被发送出去供多个设备接收。如果指向一个设备，它们是单播发送；否则，它们是广播（在RIP中）或组播（RIP-2和RIPng）。

<u>**所有三个版本的RIP只有两种基本消息类型**</u>

- RIP请求。一个路由器向另一个路由器发送的消息，要求它送回其路由表的全部或部分内容。

- RIP响应。由一个路由器发送的包含其全部或部分路由表的消息。请注意，尽管有这个名字，这个消息并不只是为了响应RIP请求消息而发送的，我们会看到。因此，它并不是一个真正的好名字......哦，好吧。

**注意：**最初的RIP还定义了一些其他的消息类型。Traceon、Traceoff和一个保留给Sun Microsystems使用的特殊消息类型。这些都是过时的，不再使用，并从RIP-2和RIPng标准中删除。

<u>**RIP更新消息和30秒定时器**</u>

RIP 请求消息是在特殊情况下发送的，当一个路由器需要它提供即时的路由信息时。最常见的例子是当路由器第一次上电的时候。在初始化之后，路由器通常会在其连接的网络上发送一个RIP请求，要求从任何邻近的路由器获得最新的路由信息。RIP请求消息也有可能被用于诊断目的。

收到RIP请求的路由器将对其进行处理，并发送一个RIP响应，其中包含其所有的路由表，或者只包含请求所要求的条目，视情况而定。然而，在正常情况下，路由器通常不发送RIP请求消息，专门询问路由信息。相反，每个 RIP 路由器上都有一个特殊的定时器，每隔 30 秒就会关闭。(这个定时器在 RIP 标准中没有给出具体的名称；它只是 "30秒定时器"）。

每次定时器过期，就会有一个未经请求的（未被请求的）广播/多播的RIP响应消息，其中包含路由器的整个路由表。然后计时器被重置，30秒后再次响起，导致另一个常规的RIP响应被发送。这个过程确保路由信息定期在互联网上发送，因此路由器总是保持最新的路由信息。

**关键概念:** RIP使用两种基本的消息类型，即RIP请求和RIP响应，它们都是使用用户数据报协议（UDP）发送的。RIP响应消息，尽管其名称是RIP Response，但它既用于常规的定期路由表更新，也用于回复RIP请求消息。请求只在特殊情况下发送，例如，当一个路由器第一次加入一个网络时。

<u>**防止陈旧的信息。超时定时器**</u>
当路由器收到路由信息并将其输入路由表时，该信息不能被视为无限期有效。在我们上一主题的例子中，假设在路由器B通过路由器A安装了一条到网络1的路由后，RA和N2之间的链接出现故障。一旦发生这种情况，N1就不再能从RB到达，但RB有一个路由表明它可以到达网络1。

为了防止这个问题，路由只在路由表中保留有限的时间。每当路由被安装在路由表中，一个特殊的超时计时器就会启动。每当路由器收到另一个含有该路由信息的RIP响应时，该路由被认为是 "刷新 "的，其超时计时器被重置。只要路由继续被刷新，定时器就不会过期。

然而，如果包含该路由的RIP响应停止到达，定时器将最终过期。当这种情况发生时，路由将被标记为删除，方法是将路由的距离设置为 16 (你可能记得这是 RIP 的无穷大，表示一个不可达的网络)。**超时定时器的默认值通常是180秒**。这允许在路由器得出该路由不再可达的结论之前，错过一个路由的几个周期性更新。

<u>**删除陈旧的信息-垃圾收集定时器**</u>

当一个路由被标记为删除时，一个新的垃圾收集定时器也被启动。"垃圾收集 "是计算机行业的一个短语，指的是寻找已删除或无效的信息并将其清理掉的任务。因此，这是一个计算新的无效路由从表中实际删除前的秒数的定时器。这个定时器的默认值是120秒。

使用这种两阶段的删除方法的原因是给宣布路由不再可达的路由器一个机会，把这个信息传播给其他路由器。在垃圾收集定时器过期之前，路由器将在自己的RIP响应中包括该路由，其 "不可达 "度量为16跳，因此其他路由器被告知该路由的问题。当定时器过期时，该路由被删除。如果在垃圾收集期间收到该路由的新 RIP 响应，那么正如你所期望的那样，删除过程被终止：垃圾收集计时器被清除，该路由被再次标记为有效，并且一个新的超时计时器开始。

<u>**触发的更新**</u>
除了已经描述的两种情况外，RIP 响应被发送--回复 RIP 请求和 30 秒计时器到期时--RIP 响应也在路由改变时被发送。这个动作是对基本 RIP 操作的增强，称为触发式更新，目的是确保有关路由变化的信息尽可能快地在内部网络中传播，以帮助减少 RIP 中的 "缓慢收敛 "问题。例如，在我们刚才看到的情况下，一条路由超时了，垃圾收集定时器开始了，一个触发的更新将被立即发送出去，关于现在无效的路由。这将在 RIP 特殊功能的主题中详细描述。

###### 3.4.2.1-1-4 RIP协议限制和问题(部分：1 2 3 4)。

路由信息协议的简单性常常被认为是其受欢迎的主要原因；我在本节中当然已经提到过很多次。在大多数情况下，简单性是很好的，但在很多情况下，简单性的一个不幸的 "代价 "是问题的出现，通常是在不寻常的情况下或特殊情况下。RIP也是如此：直截了当的距离向量算法和运行机制在大多数情况下运行良好，但它们有一些重要的弱点。我们需要研究这些问题，以了解RIP的局限性和为解决这些问题而添加到协议中的一些复杂性。

<u>**RIP的基本算法和实现的问题**</u>
我们发现RIP存在严重问题的最重要领域是本节前面描述的距离向量算法的基本功能，以及使用消息来实现它的方式。这里有四个主要问题：缓慢收敛、路由循环、"无限计数 "和 "小无限"。

**<u>缓慢收敛</u>**
距离向量算法的设计使所有的路由器定期分享他们所有的路由信息。随着时间的推移，所有路由器最终都会得到相同的网络位置信息，以及哪些是到达这些网络的最佳路线。这就是所谓的收敛。不幸的是，基本的RIP算法在实现收敛方面相当缓慢。所有路由器需要很长时间才能得到相同的信息，特别是需要很长时间来传播有关拓扑结构变化的信息。

考虑一下最坏的情况，即两个网络被15个路由器分开。由于路由器通常每30秒才发送一次RIP响应消息，这对网络中的一个变化可能要到许多分钟后才会被离另一个网络最近的路由器看到--以网络术语来说，这是一个永恒的过程。

当涉及到路由失败的传播时，缓慢的收敛问题就更加明显了。路由失败只有在180秒的超时定时器过期时才会被检测到，因此在收敛开始之前，会增加三分钟的延迟。

<u>**路由环路**</u>
当路由器A有一个条目告诉它把网络1的数据报发送到路由器B，而路由器B有一个条目说网络1的数据报应该发送到路由器A时，就会出现路由循环。路由器A说要发送至B，B说要发送至C，C说要发送至A。

虽然在正常情况下，这些循环不应该发生，但在特殊情况下，它们可能发生。RIP不包括任何具体的机制来检测或防止路由环路；它能做的最好的事情就是尽量避免它们。

<u>**"数到无穷大"**</u>

缓慢收敛的一个特殊情况会导致路由环路的情况，即一个路由器将坏信息传给另一个路由器，后者又将更多的坏信息传给另一个路由器，如此反复。这导致了协议有时被描述为不稳定的情况；这个问题被称为 "无限计数"，原因我们很快就会看到。

为了理解这种情况是如何发生的，让我们修改一下我们在描述RIP算法的专题中所看到的例子（你可能会发现在你跟随这个讨论时参考图174很有帮助）。假设网际网络正常运行了一段时间。路由器B有一个条目表明它可以通过路由器A以2的代价到达网络1。现在，假设从网络1到路由器A的链接出现故障。在Router A上的网络1的超时定时器过期后，RA将把N1的度量改为16，以表明它是不可达的。在没有任何机制迫使RA立即通知其他路由器这一故障的情况下，他们将继续 "蒙在鼓里"。路由器B将继续认为它可以通过路由器A到达网络1。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ripcounting (1).png)

​                                                                              **图174: RIP的 "无限计数 "问题**

这个合成图显示了图172中所示的自治系统的一部分。顶部面板（#1）显示了网络的正常状态，RB能够以2的代价通过RA到达N1。 在#2中，RA和N1之间的链接被破坏。RA将其到达N1的成本改为16（RIP无穷大）。在#3中，在RA向RB发送这个更新之前，它从RB收到了一个常规的RIP消息，表明可以以2的代价到达N1，然后RA被愚弄了，以为它可以使用RB作为到达N1的备用路由，尽管RB的信息最初来自RA。在#4中，RA将这一虚假信息发送出去，在#5中被RB收到。然后，RB将其成本增加到4，并在其下一个周期将此信息发送给RA，RA将其成本增加到5，以此类推。这个循环将继续下去，两个路由器都 "数到无穷大"(16)。

现在，假设RB的常规30秒计时器在RA的下一次广播前熄灭。路由器A看到后会说："嘿，看，路由器B有一条到网络1的路由，成本是2！"这意味着我可以用2元钱到达那里。这意味着我可以用3的成本到达那里，这肯定比我目前16的成本要好；让我们使用它！" 于是，路由器A安装了这个路由，并取消了它的超时计时器。当然，这是虚假的信息--路由器A没有意识到，路由器B声称能够到达网络1是基于来自路由器A本身的旧信息！这是不可能的。

从那以后，情况变得更糟。当Router A定期更新路由表时，它将广播一条到网络1的路由，成本为3。 现在，Router B将看到这个，并说："嗯，我到网络1的路由是通过Router A的，Router A之前说它的成本是1，但现在它说成本是3，这意味着我必须把成本改为4。

随后，RB会发回给RA，他们会来回走动，每次都会增加两个成本。这不会停止，直到 "无穷大"（16）的值被击中--这就是所谓的计算到无穷大。在这一点上，两个路由器将最终同意网络1是不可达的，但正如你所看到的，它需要很长的时间才能发生。

<u>**"小的无限大"**</u>

使用一个相对较小的 "无穷大 "值限制了缓慢收敛的问题。即使在我们刚才看到的 "数到无穷大 "的情况下，经过的总时间至少也是可控的；想象一下，如果 "无穷大 "被定义为比如1000 不幸的是，这样做的缺点是，它限制了可用于RIP的国际网络的规模。

许多人对RIP中15个路由器的跨度限制提出异议，但说实话，我认为这是在夸夸其谈，好吧，如果不是什么都没有，那么至少是 "没什么"。15个值不是对你可以使用的路由器总数的限制，只是对任何两个网络之间的路由器数量的限制。考虑到大多数国际网络是分层设置的；即使你有一个相当复杂的四级层次结构，你也不会接近15个路由器的限制。事实上，你可以创建一个有数千个路由器的巨大自治系统，而在任何两个设备之间的路由器都不会超过15个。所以这只是对最大的自治系统的限制。

另一方面，RIP需要每小时多次发送它的整个路由表，这使得它可能成为一个大型网络的不良选择，而不考虑 "无穷大=16 "的问题。在一个有许多路由器的网络中，RIP产生的流量可能会过大。

**关键概念:** RIP运行中最重要的问题之一是收敛速度慢，它描述了这样一个事实，即网络变化的信息可能需要很长时间才能在路由器之间传播。这个问题的一个具体例子是计算到无穷大的问题，在这个问题中，过时的信息导致许多假的RIP消息在路由器之间交换，而这些消息是关于一个无法到达的网络。

公平地说，这些问题大多是距离矢量路由算法的普遍问题，而不是RIP的特殊问题。其中一些是通过对算法或发送RIP消息的规则进行具体修改来纠正的，正如下一个主题所描述的。根据RFC 2453，实际上曾有一个建议，将RIP的 "无穷大 "增加到大于16的数字，但这将导致与旧设备的兼容性问题（它们会将任何公制为16或更高的路由视为不可达），所以它被拒绝了。

<u>**RIP度量的问题**</u>

除了这些对算法本身的关注，RIP还经常因为它对度量的选择而受到批评。这里有两个相关的问题。

- 作为距离度量的跳数：简单地说，跳数是在两个网络之间发送数据报的成本的一个糟糕的度量。我相信在RIP中使用跳数作为度量，部分是由于对简单性的渴望（当跳数是路由器需要考虑的全部问题时，很容易使协议工作），部分是由于RIP是一个有20多年历史的协议。几十年前，计算机速度很慢，所以每次数据报通过路由器时，都可能有很大的延迟。即使在那时，跳数也不是一个完美的指标，但我认为它与一个数据报在互联网上移动所需的时间比今天有更多的对应关系。

- 现代路由器的速度快如闪电，使得跳数成为衡量网络距离的一种错误方式。所花费的跳数通常与在一条路线上移动数据所需的实际时间没有关系。举个极端的例子，考虑两个网络，它们通过使用56K调制解调器的直接拨号电话网络链接连接，也通过使用高速DS-3线路的三个路由器序列连接。RIP会认为56K链接是一条更好的路线，因为它的跳数更少，尽管它显然要慢得多。

- 缺少对动态（实时）指标的支持。即使 RIP 使用比跳数更有意义的度量，该算法也要求每个链接的度量是固定的。没有办法让RIP像OSPF这样的协议那样，根据各种链路的实时数据计算出最佳路由。
  这些问题是RIP内置的，不能轻易解决。有趣的是，一些RIP的实现显然可以让管理员 "修改 "某些路由，以弥补跳数指标的限制。例如，上面提到的56K链路两端的路由器可以被配置成认为56K链路的跳数是10，而不是1，这将导致使用该链路的任何路由比DS-3路径更 "昂贵"。这很聪明，但不是一个优雅或普遍的解决方案。

**注意：**除了上述相当长的问题清单外，RIP的第一个版本也有一些具体的问题。其中一些更重要的问题包括缺乏对CIDR的支持，缺乏认证，以及由于使用广播进行信息传递而造成的性能下降。这些问题主要通过RIP-2的扩展来解决。

###### 3.4.2.1-1-5 **用于解决 RIP 算法问题的 RIP 特殊功能**(部分：1 2 3 4)

路由信息协议的简单性是其最吸引人的品质，但也导致其运行方式存在某些问题。这些限制大多与用于确定路由的基本算法以及用于实现该算法的消息传递方法有关。为了使 RIP 成为一种有用的协议，有必要解决其中的一些问题，以改变我们在本节前面探讨的基本 RIP 算法和操作方案的形式。

由于 RIP 过于简单而出现的问题的解决方案是增加复杂性，其形式是为 RIP 操作方式增加更多智能的功能。让我们看一下其中的四个：水平分割、带毒反向的水平分割、触发更新和hold-down。

**水平分割**
“计数到无穷大”问题是基本 RIP 算法中最严重的问题之一。在上一主题的示例中，问题的原因很明显：在网络 1 发生故障并且路由器 A 注意到它出现故障后，路由器 B 通过发送路由器 A “欺骗”路由器 A 认为它具有到网络 1 的备用路径到 N1 的路由通告。

如果您考虑一下，在任何情况下，让路由器 B 向路由器 A 发送关于路由器 B 最初只能通过路由器 A 访问的网络的广告都没有任何意义。在路由失败的情况下，它会导致这个问题，这显然是一个很好的理由不这样做。但是即使路由是可操作的，路由器 B 告诉路由器 A 有什么意义呢？路由器 A 已经与网络建立了较短的连接，因此无论如何都不会将用于网络 1 的流量发送到路由器 B。

显然，最好的解决方案是让路由器 B 在它发送给路由器 A 的任何 RIP 响应消息中不包括任何到网络 1 的路由。我们可以通过在 RIP 操作中添加一条新规则来概括这一点：当路由器发出在它所连接的任何网络上的 RIP 响应，它会忽略最初从该网络获知的任何路由信息。此功能称为水平分割，因为路由器有效地分割了其对互联网的视图，在某些链接上发送的信息与在其他链接上发送的信息不同。

使用这个新规则，让我们考虑路由器 B 的行为。它在网络 2 上有一个与路由器 A 共享的接口。因此，当在 N2 上发送时，它不会包含有关它最初从路由器 A 获得的路由的任何信息。这将防止我们在上一个主题中看到的“计数到无穷大”循环。同样，由于路由器 D 在网络 3 上，路由器 B 在网络 3 上发送时不会发送任何有关从路由器 D 获得的路由的信息。

然而，请注意，分割地平线不一定能解决 "无限计数 "问题，特别是在多个路由器间接连接的情况下。典型的例子是三个路由器配置成一个三角形。在这种情况下，由于数据在任何两个路由器之间双向传播，仍然可能产生问题。在这种情况下，"按住 "功能可能会有帮助（见下文）。

但是请注意，水平分割可能并不总能解决“计数到无穷大”的问题，尤其是在多个路由器间接连接的情况下。经典的例子是三个路由器配置成三角形。在这种情况下，由于数据在任意两个路由器之间沿两个方向传播，仍可能导致问题。在这种情况下，“hold down”功能可能会有所帮助（见下文）。

<u>**带毒性逆转的水平分割**</u>

这是对基本分割地平线功能的增强。当在某个接口上发送 RIP 响应消息时，我们不是省略从该接口学到的路由，而是包括这些路由，但把它们的度量设置为 "RIP infinity"，即 16。所以在上面的例子中，Router B将在其网络2的传输中包括到网络1的路由，但它会说到达N1的成本是16，而不是它的真实成本（是2）。

毒性逆转 "指的是，我们正在毒化我们想要确保该接口上的路由器不使用的路由。路由器A将看到路由器B发布网络1的广告，但其成本为16，这是向路由器A发出的明确信息："你绝对没有办法通过路由器B到达网络1"。这比普通的分割水平线功能提供了更多的保险，因为如果从Router A到网络1的链接像我们在上一主题中描述的那样失效，Router A将肯定地知道它不能试图通过Router B获得新的路由。

这种技术在正常情况下也能起作用（意思是，当没有问题时，如与网络的链接中断）。在这种情况下，Router A将定期收到RB的更新，成本为16，但RA无论如何不会尝试通过Router B到达网络1，因为它直接连接到网络1（成本为1）。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\rippoisonedreverse.png)

​                                                                        图175: 使用毒性逆转的分割地平线解决RIP问题

此图中的顶部面板（#1）显示了与图174相同的例子。在#2中，和以前一样，RA和N1之间的链路被破坏，就在RB准备发送其常规更新时。然而，具有毒性逆转功能的水平分割意味着它在两条链路上发送不同的消息；在连接它和RA的网络上，它发送了一个成本为16的路由组播。在#3中，Router A收到了这个消息，它将丢弃这个消息，以确保不会发生计数到无穷大的问题。在RA的下一个周期，它将更新RB，告诉它N1不再可达。

<u>**触发的更新**</u>

我们在上一主题中看到的路由循环问题是由于Router B将Router A的路由广告回给Router A而发生的。这个问题还有一个方面也很重要：在Router A发现与Network 1的链接失败后，它不得不等待长达30秒的时间，直到它的下一个预定传输时间才告诉其他路由器这个故障。

为了使RIP工作得好，当有重大事件发生时，我们要立即告诉国际网络上的其他路由器。出于这个原因，应该在基本的RIP路由器操作中加入一条新的规则：每当一个路由器改变一条路由的度量时，它需要（几乎）立即发送一个RIP响应来告诉它的近邻路由器这一变化。如果这些路由器看到这一变化，就会更新它们的路由信息，它们又被要求发送更新。因此，任何网络路由信息的改变都会导致级联更新在整个互联网上发送，大大减少了缓慢的收敛问题。请注意，这包括由于超时定时器过期而删除一条路由，因为删除路由的第一步是将路由的度量设置为16，这就触发了更新。

你可能注意到，我说过，触发的更新 "几乎 "是立即发送的。事实上，在发送触发式更新之前，路由会等待一个随机的时间，从1秒到5秒。这样做是为了减少许多路由器几乎同时发送更新信息所带来的网络负荷。

<u>**抑制计时（holddown timer）**</u>

Split horizon试图通过抑制传输失败的路由的无效信息来解决 "数到无穷大 "的问题。为了获得额外的保险，我们可以实现一个功能，在路由失败的情况下改变接收路由信息的设备的处理方式。搁置功能的工作原理是，当每个路由器第一次收到一个无法到达的网络信息时，让它们启动一个计时器。在定时器过期之前，路由器将丢弃任何表明该路由实际上是可达的后续路由信息。一个典型的搁置定时器运行60或120秒。

这种技术的主要优点是，当路由器最近刚被告知路由不再有效时，它不会因为收到路由可达的虚假信息而感到困惑。它为过时的信息提供了一段从系统中刷新的时间，这在复杂的互联网上尤其有价值。在水平分割上增加保持功能，也有助于在水平分割本身不足以防止计数到无穷大的情况下，例如前面讨论的三个路由器连接成一个 "三角形 "的情况。

Hold-down的主要缺点是，一旦路由被固定，它就会迫使路由器对其做出延迟反应。假设一个网络 "小插曲 "导致一条路由宕机五秒钟。在网络再次启动后，路由器将想再次知道这件事。然而，在路由器再次尝试使用该网络之前，保持计时器必须过期。这使得使用hold-down的国际网络对纠正路由的反应相对缓慢，并可能导致访问间歇性故障的网络的延迟。

**关键概念。**四个特殊功能代表了对RIP操作的改变，改善或消除了基本协议操作中的问题。分裂地平线和分裂地平线与中毒反向防止路由器将无效的路由信息发回给它最初学习路由的路由器。触发式更新通过使改变的路由信息立即传播，减少了缓慢的收敛问题。最后，当收到一个失败的路由信息时，hold-down可被用来提供稳健性。

同样，虽然我把上面的项目称为 "功能"，但至少其中一些确实是确保RIP功能正常的必要条件。因此，它们通常被认为是 RIP 的标准部分，而且大多数甚至在最早的 RIP 文档中都有描述。然而，在使用这些技术时，有时可能会出现性能或稳定性问题，特别是结合使用时。由于这个原因，不同的 RIP 实现可能会省略一些功能。例如，hold-down会减慢路由恢复速度，当使用其他功能（如分割水平线）时，可能不需要。一如既往，必须注意确保所有的路由器都使用相同的功能，否则可能会出现更大的问题。

另外，请看关于RIP-2的具体章节，了解在使用RIP时有助于减少收敛和路由问题的Next Hop功能的描述。

 <u>**RIP协议定时器**</u>

RIP在更新和维护路由信息时主要使用以下4个定时器：

1. 更新定时器：当此超时器超时时，立即发送路由更新报文，缺省每30s发送一次。
2. 老化定时器：RIP设备如果在老化时间内没有收到邻居发来的路由更新报文，则认为该路由不可达。当学到一条路由并添加到RIP路由表中时，老化定时器启动，如果老化定时器超时，设备仍没有收到邻居发来的更新报文，则把该路由的度量值置为16，并启动垃圾收集定时器。
3. 垃圾收集定时器：如果在垃圾收集时间内仍没有收到原来不可达到路由的更新，该路由将被从RIP路由表彻底删除。
4. 抑制定时器：当RIP设备收到对端的路由更新，其度量值为16。则对应路由进入抑制状态，并启动抑制定时器，缺省值为180s。这时，为了防止路由震荡，在抑制定时器超时之前，即使再收到对端路由度量值小于16的更新，也不接受。当抑制超时器超时后，就重新接受对端发送的路由更新报文。

<u>**防止网络环路**</u>

由于路由器可能收到它自己发送的路由信息而造成网络环路，为了提高RIP协议性能而使用以下措施：

- 水平分割：水平分割指的是RIP从某个接口学到的路由，不会从该接口再发回给邻居设备。在帧中继和X.25等NBMA网络中，水平分割功能缺省为禁止状态。
- 毒性逆转：毒性逆转指的是RIP从某个接口学到路由后，将该路由的开销设置为16（即指明该路由不可达），并从原接口发回邻居设备。
- 滞留计时器(Hold-down timer):一但抑制计时器被触发后，那么将会引起该路由进入长达180秒（即6个路由更新周期）的抑制状态阶段。在抑制计时器超时前，路由器不再接收关于这条路由的更新信息。
- 触发更新：触发更新是指路由信息发生变化时，立即向邻居设备发送触发更新报文，通知变化的路由信息。（触发更新不会触发接收路由器重置自己的更新定时器）

###### 3.4.2.1-2 RIP版本特定的消息格式和功能

路由信息协议（RIP）已经被广泛使用了二十多年。在这期间，互联网网络和网络技术发生了变化。为了与时俱进，RIP也在不断发展，如今有三个不同的版本。这三个版本的基本操作是相当相似的，因此在概念和操作的共同部分进行了描述。正如你所期望的那样，这些版本之间也有一些区别（否则我们就不需要版本了！）其中更重要的是每个版本中用于 RIP 消息的格式，以及该格式中各字段的含义和用途。

在这一节中，我将描述三个版本的 RIP 各自使用的消息格式，以及某些不为所有版本所共有的特定功能。我从最初的RIP开始，现在也被称为RIP版本1。然后我描述了RIP的更新版本，称为RIP Version 2或RIP-2。最后，我讨论了RIPng，有时也称为RIPv6，是用于IP版本6（IPv6）的RIP版本。(请注意，从技术上讲，这不是原始 RIP 协议的新版本，而是紧密基于 RIP 版本 1 和 2 的新协议）。

###### 3.4.2.1-2-1 RIP 版本 1 (RIP-1) 消息格式（部分：1 2 3 ）

RIP发展成为一个行业标准，并因其被纳入UNIX的伯克利标准分布（BSD UNIX）而得到普及。这个RIP的第一个版本（现在有时称为RIP-1，以区别于后来的版本），最终在RFC 1058中被标准化。作为这个标准的一部分，最初的RIP-1消息格式被定义了，这当然是为RIP-1本身服务的，同时也是后来版本中使用的格式的基础。

<u>**RIP-1消息传递**</u>
正如在关于RIP操作的一般讨论中所解释的，路由信息在RIP中是通过发送两种不同类型的RIP消息来交换的。RIP请求和RIP响应。这些消息是作为使用用户数据报协议（UDP）的常规 TCP/IP 消息传输的，使用 UDP 保留的端口号 520。这个端口号的使用方法如下。

- RIP请求消息被发送到UDP目的端口520。它们的源端口可能是520，也可能使用一个随机的端口号。

- 为回复 RIP 请求而发送的 RIP 响应消息，其源端口为 520，目的端口等于 RIP 请求使用的任何源端口。

- 非请求的 RIP 响应消息（在常规基础上发送，而不是为了响应请求）在发送时，**源端口和目的端口都设置为 520。**

<u>**RIP-1消息格式**</u>

RIP-1的基本消息格式在表120中描述，在图176中说明。

​                                                                       <u>**表120: RIP版本1（RIP-1）消息格式**</u>

| **Field Name**              | **Size (bytes)**                           | **Description**                                                                                                                             |
| --------------------------- | ------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------- |
| ***Command\***              | 1                                          | ***Command Type:\***命令类型：标识发送的RIP消息的类型。值为1表示RIP请求，而2表示RIP响应。最初，还定义了其他三个值和命令：TraceOn和TraceOff命令的3和4，以及5个保留用于Sun Microsystems使用的值。这些已过时，不再使用。 |
| ***Version\***              | 1                                          | ***Version Number:\*** 版本编号：RIP版本1设置为1。                                                                                                     |
| ***Must Be Zero\***         | 2                                          | ***Reserved:\*** 保留：保留场；值必须设置为所有零。                                                                                                          |
| ***RIP Entries\*****RIP条目** | 20 to 500, in increments of 2020至500，增量为20 | ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\aa1faa63.png)                                                        |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ripformatv1.png)

​                                                                     <u>**图 176: RIP 版本 1 (RIP-1) 消息格式**</u>

RIP-1消息格式最多可以包含25个RIP条目。这里，RIP条目#1与它的每个组成子字段一起显示在这里。

如果您像我一样，首先考虑到这种消息格式的第一件事是：所有额外的空间是什么？我的意思是，我们有四个保留的不同字段（必须为零），甚至其他大多数字段都比它们所需的大（1至16的度量只需要4位，而不是32。）命令类型而且版本号也可以轻松制作，每个版本也只有4位（如果不是更少的话）。为什么当我们只打算处理IP地址时，要识别两个字节字段来识别地址类型呢？

这种看似浪费实际上是原始RIP设计的一般性的工件。该协议旨在支持各种不同的互联网工作协议的路由，而不仅仅是IP。 （请记住，它最初还没有考虑到IP。）因此，包括地址家族标识符以指定地址类型，并且RIP条目被制成了足够大以处理大型地址。 IP每个地址仅需要4个字节，因此不使用某些空间。

<u>**RIP-1 版本的特定功能**</u>

由于RIP版本1是该协议的第一个版本，它的功能构成了未来RIP版本的基础；它实际上没有任何特定版本的功能。RIP-1有一些限制，如不支持指定无类地址和没有认证手段。RIP第2版是为了解决RIP-1的一些不足之处而创建的。正如我们将在下一个主题中看到的，RIP-2的功能很好地利用了RIP-1格式中那些 "必须为零 "的字节。

关键概念。RIP-1是路由信息协议的第一个版本，在操作和功能方面是最简单的。RIP-1消息的大部分由RIP条目集组成，这些条目指定路由地址和以跳数为单位的路由距离。

###### 3.4.2.1-2-2 RIP 版本 2 (RIP-2) 消息格式和特征（部分：1 2 3 ）

最初的路由信息协议（RIP-1）有许多问题和限制。随着TCP/IP协议套件的发展和变化，RIP-1的问题变得更加复杂，它变得有些不合时宜，无法处理更新的IP功能。有一些人认为，更新更好的内部路由协议的存在意味着最好是完全放弃RIP，转而使用像开放最短路径优先（OSPF）这样的协议。

然而，RIP的吸引力从来不是它的技术优势，而是它的简单性和在工业中的普遍性。到20世纪90年代初。RIP已经在成千上万的网络中使用。对于那些喜欢RIP的人来说，迁移到一个能解决RIP-1的一些缺点的较新版本，比迁移到一个完全不同的协议更有意义。为此，开发了该协议的新版本，即RIP第二版（RIP-2），并在1993年的RFC 1388中首次发布。它现在被定义在RFC 2453中，即1998年11月发布的RIP版本2。

<u>**RIP-2版本的具体特点**</u>

RIP-2代表了对基本路由信息协议的一个非常小的改变。RIP-2的工作方式与RIP-1的基本方式相同（这也是为什么我能够在同一总节中描述两者的操作的部分原因）。事实上，在RIP-2中引入的新功能被描述为对基本协议的扩展，表达了它们是在常规的RIP-1功能上分层的事实。五个关键的RIP-2扩展是。

- 无类别地址支持和子网掩码规范。当RIP-1开发时，IP中子网的使用（如RFC 950中所述）还没有正式定义。通过使用启发式方法来确定目的地是一个网络、子网还是主机，仍然可以使用RIP-1的子网。然而，没有办法使用RIP-1消息为一个地址明确指定子网掩码。

- RIP-2增加了对子网的明确支持，允许在每个网络地址的路由条目中设置子网掩码。它还提供了对可变长度子网掩码（VLSM）和无类别寻址（CIDR）的支持。

- 下一跳规范。在RIP-2中，每个RIP条目包括一个空间，可以输入一个明确的IP地址作为该条目中网络的数据报的下一跳路由器。这个功能可以通过消除发送到某些目的地的数据报的不必要的额外跳数来帮助提高路由的效率。

- 这个字段的一个常见用途是，当到一个网络的最有效路由是通过一个没有运行RIP的路由器。这样的路由器不会交换 RIP 消息，因此通常不会被 RIP 路由器选择为任何网络的下一跳。明确的下一跳字段允许路由器被选择为下一跳，而不考虑这种情况。

- 认证。RIP-1不包括认证机制，这是一个问题，因为它有可能允许恶意的主机通过发送假的RIP消息来搅乱一个网络。RIP-2提供了一个基本的认证方案，它允许路由器在接受来自一个路由器的RIP消息之前确定该路由器的身份。

- 路由标签。每个RIP-2条目包括一个Route Tag字段，在那里可以存储关于一个路由的额外信息。当RIP条目在互联网上发送时，这个信息会和其他关于路由的数据一起传播。这个字段的一个常见用途是当一个路由从一个不同的自治系统中学习时，以确定从哪个自治系统获得该路由。

- 使用组播。为了帮助减少网络负载，RIP-2允许路由器被配置为使用组播而不是广播来发送非请求的RIP响应消息。这些数据报是使用特别保留的多播地址224.0.0.9发送的。如果要正常工作，一个互联网上的所有路由器显然都必须使用组播。
  正如你所看到的，许多这样的扩展需要更多的信息包括在每个组播报文的路由中。这就是RIP-1路由条目的消息格式中所有 "额外空间 "的用处，我们很快就会看到。

**关键概念:**RIP-2是用于IPv4的RIP的最新版本。它包括比原来的RIP-1更多的改进，包括支持子网掩码和无类寻址、显式下一跳规范、路由标记、认证和组播。为了兼容，它使用与RIP-1相同的基本消息格式，将其新功能所需的额外信息放入RIP-1消息格式的一些未使用的字段。

<u>**RIP-2消息传递**</u>
RIP-2消息是使用与RIP-1消息相同的基本机制来交换的。存在两种不同的消息类型，RIP请求和RIP响应。它们使用用户数据报协议（UDP）发送，使用UDP保留端口号520。使用这个端口的语义与RIP-1的相同。为方便起见，我在这里重复描述。

- RIP请求消息被发送到UDP目的端口520。它们可能有一个520的源端口，也可能使用一个短暂的端口号。

- 为回复RIP请求而发送的RIP响应消息，其源端口为520，目的端口等于RIP请求使用的任何源端口。

- 非请求的 RIP 响应消息（在常规基础上发送，而不是为了响应请求）在发送时，源端口和目的端口都设置为 520。

<u>**RIP-2消息格式**</u>

RIP-2 的基本报文格式也与 RIP-1 基本相同，版本字段当然设置为 2，以明确标识该报文是 RIP-2。真正的区别在于各个 RIP 条目，你可以在表 121 和图 177 中看到。

​                                                                                            **表121: RIP 版本 2 (RIP-2) 消息格式**

| **Field Name**                    | **Size (bytes)**               | **Description**                                                                      |
| --------------------------------- | ------------------------------ | ------------------------------------------------------------------------------------ |
| ***Command\***                    | 1                              | ***Command Type:\*** 命令类型：标识发送的RIP消息的类型。值为1表示RIP请求，而2表示RIP响应。                        |
| ***Version\***                    | 1                              | ***Version Number:\*** 版本编号：RIP版本2设置为2。                                              |
| ***Must Be Zero\***               | 2                              | ***Reserved:\*** 保留：保留场；值必须设置为所有零。                                                   |
| ***Route Table Entries (RTEs)\*** | 20 to 500, in increments of 20 | ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\aa1fab95.png) |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ripformatv2.png)

​                                                               **图177: RIP第2版（RIP-2）消息格式**

RIP-1的RIP条目在RIP-2中被称为路由表条目（RTE）；消息格式最多可以包含25个。这里显示了 RTE #1 的格式和它的每个子字段（为了节省空间，其他子字段被总结出来了）。

正如你所看到的，未使用的字段允许在不改变 RIP 条目格式的基本结构的情况下实现新的 RIP-2 功能。这允许 RIP-1 和 RIP-2 消息和设备在同一个网络中共存。一个 RIP-2 设备可以同时处理 RIP-1 和 RIP-2 消息，并将查看版本号以了解该消息是哪个版本。RIP-1设备应该以同样的方式处理RIP-2和RIP-1消息，只是忽略它不理解的额外RIP-2字段。

**注意：**注意，如果使用认证，其中一个RTE包含认证信息，将消息限制在24个 "真正的 "RTE。

###### 3.4.2.1-2-3 RIPng ("RIPv6") 消息格式和特征 (Parts: 1 2 3 )

TCP/IP的未来是新的互联网协议版本6（IPv6），它对IP做了一些非常重要的改变，特别是在寻址方面。由于IPv6地址与IPv4地址不同，所有与IP地址相关的工作都必须改变，以便在IPv6下发挥作用。这包括交换寻址信息的路由协议。

为了确保路由信息协议的未来，必须开发一个与IPv6兼容的新版本。这个新版本于1997年在RFC 2080中发布，RIPng for IPv6，其中ng代表下一代（IPv6有时也被称为 "IP下一代"）。

RIPng，由于明显的原因，偶尔也被看作是RIPv6，被设计为尽可能地类似于当前用于IPv4的RIP版本，也就是RIP版本2（RIP-2）。事实上，RFC 2080将RIPng描述为对RIP的 "最小改动"，使其能够在IPv6上工作。尽管做出了这样的努力，但不可能像RIP-2那样，将RIPng仅仅定义为旧版RIP协议的一个新版本。RIPng是一个新的协议，这是必要的，因为IPv4和IPv6之间的变化非常大，特别是IPv6中32位地址到128位地址的变化，这就需要一个新的消息格式。

<u>**RIPng 版本的特定功能**</u>

尽管 RIPng 是一个新的协议，但为了使 RIPng 与它的前辈们一样，我们做了特别的努力。它的基本操作几乎完全相同，它使用相同的整体算法和操作，正如关于RIP操作的一般章节中所描述的那样。与 RIP-2 相比，RIPng 也没有引入任何特定的新功能，除了那些在 IPv6 上实现 RIP 所需的功能。

RIPng 保留了 RIP-2 中引入的大多数增强功能；有些是按 RIP-2 中的方式实现的，而有些则是以修改后的形式出现。以下是RIP-2中的五个扩展在RIPng中的具体实现方式。

- 无类地址支持和子网掩码规范。在IPv6中，所有的地址都是无类别的，并且使用地址和前缀长度来指定，而不是使用子网掩码。因此，每个条目都有一个前缀长度字段，而不是一个子网掩码字段。

- 下一跳规范。这一功能在RIPng中得到了保留，但实现方式不同。由于 IPv6 地址的尺寸很大，在 RIPng RTEs 的格式中包括一个 Next Hop 字段几乎会使每个条目的尺寸增加一倍。由于 Next Hop 是一个可选的功能，这将是一种浪费。相反，当需要下一跳时，它被指定在一个单独的路由条目中。

- 认证。RIPng不包括它自己的认证机制。我们认为，如果需要认证和/或加密，它们将使用在IP层为IPv6定义的标准IPSec功能来提供。这比让 RIPng 等单个协议执行认证更有效。

- 路由标签。这个字段的实现方式与 RIP-2 中的相同。

- 使用组播。RIPng 使用组播进行传输，使用保留的 IPv6 组播地址 FF02::9。

<u>**RIPng 消息传递**</u>
有两种基本的 RIPng 消息类型：RIP 请求和 RIP 响应，与 RIP-1 和 RIP-2 一样，使用用户数据报协议（UDP）进行交换。由于RIPng是一个新协议，它不能使用用于RIP-1/RIP-2的相同的UDP保留端口号520。相反，RIPng使用众所周知的端口号521。使用这个端口的语义与RIP-1和RIP-2中用于端口520的语义相同。为方便起见，这里再次列出规则。

- RIP请求消息被发送到UDP目的端口521。它们可能有一个521的源端口，也可能使用一个临时端口号。

- 为回复 RIP 请求而发送的 RIP 响应消息，其源端口为 521，目的端口等于 RIP 请求使用的任何源端口。

- 未经请求的 RIP 响应消息（在常规基础上发送，而不是为了响应请求）在发送时，源端口和目的端口都设置为 521。

<u>**RIPng消息格式**</u>

RIPng的报文格式与RIP-1和RIP-2相似，但路由表项的格式除外；它显示在表122和图178中。

​                                                                               <u>**表122: RIPng消息格式**</u>

| **Field Name**                    | **Size (bytes)** | **Description**                                                                                                                                     |
| --------------------------------- | ---------------- | --------------------------------------------------------------------------------------------------------------------------------------------------- |
| ***Command\***                    | 1                | ***Command Type:\*** Identifies the type of RIPng message being sent. A value of 1 indicates an *RIPng Request*, while 2 means an *RIPng Response*. |
| ***Version\***                    | 1                | ***Version Number:\*** Set to 1 (not 6, since this is the first version of the new protocol RIPng.)                                                 |
| ***Must Be Zero\***               | 2                | ***Reserved:\*** Field reserved; value must be set to all zeroes.                                                                                   |
| ***Route Table Entries (RTEs)\*** | Variable         | ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\aa1faca4.png)                                                                |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ripformatv6.png)

​                                                                                    <u>**图 178: RIPng 消息格式**</u>

RIPng 保留了 RIP-2 中的路由表项 (RTE) 的使用，但是它们的格式已经被改变，以适应更大的 IPv6 地址大小。每条消息 25 条的限制也被取消了。

RIPng中RTE的最大数量不像RIP-1和RIP-2那样限制在25个。它只受到发送消息的网络的最大传输单元（MTU）的限制。

**关键概念:** RIPng是为在IPv6网络上使用而开发的RIP版本。从技术上讲，它是一个不同于RIP-1和RIP-2的协议，但与两者非常相似。它保留了RIP-2中对RIP的增强功能，并在需要时对这些功能和RIP消息格式进行了修改，以便与IPv6兼容。

当需要指定下一跳时，正如我之前提到的，一个特殊的RTE被包括在内。这个 RTE 被包含在它所适用的所有 RTE 之前。它的基本结构与表 122 中显示的常规 RTE 相同，IPv6 前缀子字段包含下一跳地址，路由标签和前缀列字段设置为 0，公制字段设置为 255 (0xFF)。

###### 3.4.2.2 开放最短路径优先(OSPF)

使用距离矢量路由算法的内部路由协议，如路由信息协议（RIP），有很长的历史，在小规模的路由器群中运行良好。然而，它们在可扩展性和性能方面也有一些严重的限制，这使得它们不大适合于较大的自治系统或有特殊性能问题的系统。许多开始使用RIP的组织很快就发现，它的限制和问题使它不太理想。

为了解决这个问题，在20世纪80年代末开发了一个新的路由协议，它使用能力更强（也更复杂）的链路状态或最短路径优先路由算法。这个协议被称为开放最短路径优先（OSPF）。它修复了RIP的许多问题，并允许根据网络的当前状态动态地选择路由，而不仅仅是路由器连接方式的静态图。它还包括许多高级功能，包括支持分层拓扑结构和路由之间的自动负载分担。缺点是，它是一个复杂的协议，这意味着除非真的需要，否则通常不会使用它。这使得它成为RIP的补充，也是它们在TCP/IP路由协议中都占有一席之地的原因。

在这一节中，我对OSPF背后的概念和操作进行了简要的解释。像往常一样，我从该协议的概述开始，讨论它是如何开发的，它的版本和定义它们的标准。我描述了OSPF背后的概念，包括基本拓扑结构和链路状态数据库。然后，我讨论了更复杂的路由器的可选分层拓扑结构，以及使用这种拓扑结构时路由器所扮演的角色。我简要地解释了OSPF中用于确定路由的方法，以及该协议中使用的一般操作和消息传递，包括对五种OSPF消息类型的描述。最后，我对OSPF消息使用的格式进行了说明。

**注：**网络的困难之处在于，许多协议和技术都涉及到了，以至于每一种都值得有自己的书。OSPF本身当然就是这种情况，它足够复杂，以至于定义OSPF第二版的RFC有240多页。因此，正如你以前听我说过的，本节尽管包括六个主题，但只能被认为是OSPF的高级描述。

###### 3.4.2.2-1 OSPF概述、历史、标准和版本（部分：1 2）

在TCP/IP的早期，路由信息协议（RIP）几乎默认成为自治系统（AS）内路由的标准协议。RIP有两大优点：它简单而容易使用，而且从1982年开始，它被包含在流行的UNIX的伯克利标准分布（BSD）中。大多数使用TCP/IP的组织一开始都有相对较小的网络，并且能够使用RIP并取得一定程度的成功。

然而，正如我们在看RIP时讨论的那样，该协议有一些严重的技术问题，当它被用在一个较大的AS上时，这些问题就更严重了。它的许多问题是由于它是一个距离矢量协议--算法本身简单地限制了RIP选择最佳路由和适应变化的网络条件的能力。RIP的其他问题是基于它的实施，例如，对 "无穷大 "的数值选择为16，使得在设备之间可能出现超过15跳的情况下无法使用RIP。诸如缺乏无类寻址支持等问题在RIP的第二版中得到了解决，但该协议作为一个整体的基本困难仍然存在。

<u>**OSPF的发展和标准化**</u>
互联网工程任务组（IETF）认识到，RIP本身根本无法满足互联网上所有自治系统的需要。他们在1988年成立了一个工作组，以开发一个基于更强大的链路状态算法的新路由协议，也称为最短路径优先（SPF）。对这种协议的研究早在20世纪70年代就已经开始了，其中一些是在ARPA网络上进行的，该网络是互联网的前身，TCP/IP的大部分内容就是在此基础上发展起来的。

这种新协议被称为开放最短路径优先，或OSPF，它的名字传达了它的两个最重要的特征。第一个词指的是，该协议和所有 TCP/IP 标准一样，是通过开放和公开的 RFC 过程开发的，所以它不是专有的，使用它不需要许可证。名称中的SPF部分指的是它使用的算法类型，其目的是让路由器动态地确定任何两个网络之间的最短路径。

OSPF的第一个版本是在1989年10月发表的RFC 1131中描述的。1991年7月，该版本很快被RFC 1247中描述的OSPF第二版取代。从那时起，在RFCs 1583、2178和2328中对OSPF第2版标准进行了几次修订，其中最后一次修订是目前的标准。OSPF第2版是目前唯一使用的版本，所以当人们（包括我自己）提到 "OSPF "时，通常是指它。

<u>**OSPF操作概述**</u>

OSPF背后的基本概念是一种称为Link-State数据库（LSDB）的数据结构。自主系统中的每个路由器都维护了该数据库的副本，该副本包含有向图的形式的信息，该图形描述了自治系统的当前状态。指向网络或另一个路由器的每个链接都由数据库中的条目表示，并且每个链接都有相关的成本（或度量）。可以将该指标包括在内，包括路由性能的许多不同方面，而不仅仅是RIP中使用的简单跳跃计数。

有关自主系统的信息以链接状态广告（LSA）的形式围绕自主系统移动，允许每个路由器告诉其他路由器当前对AS状态的信息。随着时间的流逝，每个路由器都有关于自主系统与其他系统收敛的信息，并且它们都具有相同的数据。当对Internetwork进行更改时，路由器会发送更新，以确保所有路由器都保持最新状态。

为了确定实际路线，每个路由器都使用其链接状态数据库来构造最短路径树。该树显示了从路由器到彼此路由器和网络的链接，并允许最低成本的路由到任何要确定的位置。随着有关Internetwork状态到达的新信息，可以重新计算此树，因此，根据网络条件，最好调整最佳路线。当存在多个具有相等成本的路线时，可以在路线之间共享流量。

<u>**OSPF的特点和缺点**</u>
除了链接状态算法的这些明显好处外，OSPF还包括其他几个价值功能，尤其是对大型组织的价值。它支持对安全性的身份验证，以及所有三种主要类型的IP地址（分类，子标准的分类和无类）。对于非常大的自主系统，OSPF还允许将路由器分组，并排列为层次拓扑。这可以通过减少链接状态广告流量来改善组织和提高绩效。

当然，OSPF 的卓越功能和许多特性并非没有代价。在这种情况下，主要成本是复杂性。 RIP 是一种简单易用的协议，而 OSPF 需要更多的工作和更多的专业知识才能正确配置和维护。这意味着即使 OSPF 在技术上被广泛认为比 RIP 更好，但它并不适合所有人。 OSPF 的明显作用是作为更大或更高性能自治系统的路由协议，让 RIP 覆盖更小和更简单的互联网。

**关键概念**：开放最短路径优先 (OSPF) 是在 1980 年代后期开发的，旨在为 RIP 无法很好地服务的更大或更复杂的自治系统提供更强大的内部路由协议。它使用动态最短路径优先或链路状态路由算法，每个路由器维护一个数据库，其中包含有关互联网状态和拓扑的信息。随着互联网络发生变化，路由器会发送更新的状态信息，这允许每个路由器在任何时间点动态计算到任何网络的最佳路由。 OSPF 是对 RIP 的补充，因为 RIP 简单但有限，而 OSPF 功能更强大但更复杂。

###### 3.4.2.2-2 OSPF基本拓扑结构和链路状态数据库（LSDB）（部分：1 2 3）

OSPF被设计为便于在较小和较大的自治系统（AS）中进行路由。为此，该协议支持两种拓扑结构。当只有少量的路由器时，整个AS被作为一个单一实体来管理。这没有一个具体的名称，但我称它为OSPF基本拓扑，以表达拓扑的简单性质，并与我们将在接下来的主题中探讨的分层拓扑进行对比。

当使用OSPF基本拓扑结构时，AS中的所有路由器都作为对等体发挥作用。每个路由器都与其他路由器交流路由信息，并且每个路由器都维护一个关键的OSPF数据结构的副本：链路状态数据库（LSDB）。LSDB本质上是自治系统拓扑结构的计算机化表示。它是路由器 "看到 "自治系统中链路状态的方法--因此被称为链路状态数据库（就这一点而言，也是整个链路状态算法类别的名称，OSPF是其中的一部分）。

LSDB有点难以形象化，但最好被看作是一组数据，相当于显示自治系统拓扑结构的图画。在这样的图中，我们通常把路由器和网络显示为节点，而把路由器和网络之间的连接显示为连接它们的线。OSPF LSDB把这些信息放到一个表中，以使路由器能够维护AS中所有路由器和网络之间的连接的虚拟图。

因此，LSDB指出了哪些路由器可以直接到达其他哪些路由器，以及每个路由器可以到达哪些网络。此外，它还为这些链接中的每一个存储了到达网络的成本。这个成本是一个任意的度量，可以根据管理员认为重要的任何标准来设置。OSPF不限于RIP中使用的过于简单的跳数度量。

<u>**OSPF 基本拓扑结构和 LSDB 示例**</u>

例如，让我们考虑一下我们在研究RIP路由确定算法时看到的同一个自治系统。这个内部网络有四个独立的网络，连接方式如下。

- 路由器A（RA）将网络1（N1）连接到网络2（N2）。

- 路由器B（RB）和C（RC）连接网络2和网络3（N3）。

- 路由器D（RD）将网络3连接到网络4（N4）。

为了使这个例子更加有趣，我还要在RB和RC之间添加一个直接链接；由此产生的AS如图179所示。这个自治系统的LSDB将看起来像表123。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ospfas.png)

​                                                                       **图179: OSPF自治系统示例**

这是我们在RIP中看到的同一个AS（如图172所示），但在两个路由器RB和RC之间增加了一个链接。

​                                                          **表123: OSPF链接状态数据库（LSDB）示例**

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\aaaaa4.jpg)

在实践中，表123中的每一个圆点（"["）都将被一个度量值所取代，表示从特定的路由器向另一个路由器或网络发送数据报的成本。请注意，这个图表是对称的，因为如果RB可以到达RC，RC也可以到达RB。然而，成本不一定是对称的。RB向RC发送的指标有可能比RC向RB发送的指标要高。

还要注意的是，从一个网络到达一个路由器是没有成本的。这确保了一个路由器通过网络向另一个路由器发送时，只有一个成本被 "收取"--从路由器到达网络的成本。这是有道理的，因为每个路由器都是它所连接的网络中的一个成员。

<u>**LSDB信息存储和传播**</u>

关于LSDB，需要记住的重要一点是，即使每个路由器都维护它，数据库也不是从单个路由器的角度构建的。一个路由器的LSDB代表了整个AS的拓扑结构，包括可能离它相当远的路由器之间的链接。因此，例如，RA将把整个数据库保存在它的存储区，包括关于RC和RD的信息，它并不直接与之连接。

由于在基本的拓扑结构中，所有的路由器都是对等的，并为整个AS维护信息，因此在理论上它们应该有完全相同的LSDB内容。当一个路由器第一次被打开时，它的LSDB信息实际上可能与它的邻居不同，但这将通过包含链路状态广告（LSA）的更新消息的交换得到纠正。最终，所有的路由器应该收敛到相同的信息。我们将在关于OSPF消息传递的主题中看到这是如何工作的。

OSPF，作为一个内部路由协议，当然只在自治系统内使用。在大多数情况下，AS将通过其一个或多个路由器与其他AS连接。连接AS和其他AS的路由器通常被称为边界路由器。这些设备将使用OSPF在AS内进行通信，并使用外部路由协议（通常是BGP）与AS外的路由器对话。边界路由器这一名称是指这些设备通常位于AS的外围。

**关键概念:**在基本的OSPF拓扑结构中，运行OSPF的每个路由器都被认为是其他路由器的对等体。每个人都维护一个链路状态数据库（LSDB），其中包含整个自治系统的拓扑信息。路由器和网络之间或两个路由器之间的每个链接都由LSDB中的一个条目表示，该条目表示通过该链接发送数据的成本。LSDB通过OSPF链路状态广告（LSA）的交换而定期更新。

###### 3.4.2.2-3 OSPF分层拓扑结构、区域和路由器角色（部分：1 2 3）

当一个自治系统（AS）中的路由器数量相对较少时，使用上一主题中描述的基本拓扑结构效果良好。每个路由器都以相同的链路状态数据库（LSDB）的形式维护着网络拓扑结构的共同画面。路由器使用链路状态广告（LSA）作为对等体进行通信。虽然AS的变化可能会导致一个路由器暂时拥有与它的同伴不同的信息，但日常的数据交换将使所有的LSDB保持同步和最新，而且由于AS很小，没有那么多信息需要被发送。

这种较简单的拓扑结构确实有合理的扩展性，可以支持许多较小甚至中等规模的自治系统。然而，随着路由器数量的增加，更新LSDB所需的通信量也随之增加。在一个有几十个甚至几百个路由器的非常大的互联网中，让所有的路由器成为使用基本拓扑结构的OSPF对等体，会导致性能下降。这个问题的出现既是由于需要传递的路由信息量，也是由于每个路由器需要维护一个包含整个AS中每个路由器和网络的大型LSDB。

<u>**OSPF分层拓扑结构和区域**</u>
为了更好地支持这些更大的内部网络，OSPF支持使用更先进的分层拓扑结构。在这种技术中，自治系统不再被认为是一个由相互连接的路由器组成的单一、扁平的结构，所有这些路由器都是对等的。相反，构建了一个两级的分层拓扑结构。自治系统被划分为称为区域的结构，每个区域包含一些连续的路由器和网络。这些区域被编号，并由其中的路由器独立管理，因此每个区域几乎就像它本身是一个自治系统一样。这些区域是相互连接的，因此区域之间和整个AS之间可以共享路由信息。

理解这种分层拓扑结构的最简单方法是把每个区域看作是整个自治系统中的一个 "子自治系统"。任何区域内的路由器都维护一个链路状态数据库，其中包含关于该区域内的路由器和网络的信息。在一个以上的区域内的路由器维护关于它们所属于的每个区域的LSDB，并且还将这些区域连接起来，在它们之间共享路由信息。

**关键概念:** 为了更好地控制和管理更大的国际网络，OSPF允许将一个大型自治系统结构化为一个层次化的形式。连续的路由器和网络被分组为区域，使用逻辑主干线连接在一起。这些区域相当于大AS中的小自治系统，产生了与自治系统为组织间的大型互联网提供的本地化控制和流量管理相同的好处。

<u>**OSPF分层拓扑结构中的路由器角色**</u>

上面描述的拓扑结构是分层的，因为AS中的路由器不再是单一组中的所有对等者。两级层次结构由包含单个区域的低级层次和将它们连接在一起的高级层次组成，它被称为骨干网，被指定为 "Area 0"。路由器不再都是对等的，事实上，根据它们的位置和连接方式，它们扮演着不同的角色。在这种配置中，有三种不同的标签应用于路由器。

- 内部路由器。这些是只与单一区域内的其他路由器或网络相连的路由器。它们只为该区域维护一个LSDB，而对其他区域的拓扑结构一无所知。

- 区域边界路由器。这些是连接到一个以上区域的路由器或网络的路由器。它们为它们所处的每个区域维护一个LSDB。它们也参与骨干网的工作。

- 骨干网路由器。这些是属于OSPF骨干网的路由器。根据定义，这包括所有区域边界路由器，因为这些路由器在区域之间传递路由信息。然而，骨干路由器也可能是一个只连接到其他骨干（或区域边界）路由器的路由器，因此不属于任何区域（除了0区）。

总结一下：一个区域边界路由器总是也是一个骨干路由器，但一个骨干路由器不一定是一个区域边界路由器。
**注意**：上面的分类是独立于指定一个路由器为边界路由器与否的，如上一主题中所述。边界路由器是指与AS以外的路由器或网络对话的路由器。现在，一个边界路由器通常也是一个区域边界路由器或一个骨干路由器，但这不一定，一个边界路由器可能是一个区域的内部路由器。

好吧，我打赌你现在想知道......这一切的重点是什么？嗯，这个问题与首先使用自治系统架构的问题完全一样。每个区域的拓扑结构只对该区域的设备重要。这意味着该拓扑结构的变化只需要在该区域内传播。这也意味着，区域1内的内部路由器不需要知道区域2内发生的任何事情，也不需要维护除自己区域外的任何区域的信息。只有骨干路由器（每个区域内至少包括一个区域边界路由器）需要知道整个自治系统的细节。这些骨干路由器浓缩了有关区域的信息，因此只需要在骨干网上公布每个区域的拓扑结构的 "摘要"。

分层拓扑AS中的路由是以两种方式之一进行的，这取决于设备的位置。如果源点和目的地在同一地区，那么路由只发生在该地区的网络和路由器上。如果它们在不同的区域，那么数据报就会从源头路由到源头区域的区域边界路由器，再通过骨干网到目的地区域的区域边界路由器，最后再送到目的地。同样，这也类似于在大的国际网络中AS之间的路由工作方式。

<u>**OSPF分层拓扑结构实例**</u>

我相信这一切在你第一次阅读时是完全有意义的。嗯，嗯。J 让我们举一个例子来帮助使事情变得更具体。我们可以使用前面的主题中的自治系统。这个AS真的很小，不太可能使用分层拓扑结构，但为了说明问题，它已经足够了。让我们把这个AS分成两个区域，如下所示（见图180）。

- 区域1：这个区域将包含N1、RA、N2、RB和RC。

- 区域2：这个区域将包含RB、RC、N3、RD和N4。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ospfareas.png)

​                                                        **图180: OSPF分层拓扑结构自治系统的例子**

这是我们在图179中看到的同一个AS，但被安排在OSPF分层拓扑结构中。该AS被平均分成区域1和区域2。区域0包含RB和RC，它们是这个非常简单的AS例子中区域1和区域2的区域边界路由器。

在这个例子中，Router A和Router D是内部路由器。Router B和Router C是区域边界路由器，并构成了互联网的骨干网（0区）。路由器A、B和C将维护一个描述区域1的LSDB，而路由器B、C和D将维护一个描述区域2的LSDB。路由器B和C为骨干网维护一个单独的LSDB。除了区域边界路由器B和C之外，没有任何骨干路由器。然而，假设我们有一个路由器E，它只与RB和RC有直接连接。这将只是一个骨干路由器。

你可能已经发现了分层拓扑结构的主要缺点：复杂性。然而，对于大型自治系统来说，它比让每个路由器成为对等体有明显的优势。同时，由于需要非常仔细的设计，特别是骨干网的设计，使概念上的复杂性变得更糟。如果层次结构设置不当，路由器之间的一个链路故障就会破坏主干网，并隔离一个或多个区域（包括该区域内所有网络上的所有设备！）。

![image-20221030215242722](C:\Users\zy\AppData\Roaming\Typora\typora-user-images\image-20221030215242722.png)

###### 3.4.2.2-4 使用SPF树的OSPF路由确定（部分：1 2 3 4）

OSPF自治系统（AS）中每个路由器维护的关键数据结构是链接状态数据库（LSDB）。LSDB包含了整个AS（基本拓扑）或单个区域（分层拓扑）的拓扑结构的表示。正如我们在本节前面所看到的，AS或区域中的每个路由器都有相同的LSDB，所以它代表了路由器和网络之间连接的一个中立观点。

当然，每个路由器都需要参与保持LSDB的更新，但它也有自己的 "自私 "考虑。它需要能够确定它从其连接的网络中收到的数据报应该使用什么路由--毕竟这是路由协议的全部意义所在。

<u>**SPF树**</u>
为了找到来自任何路由器的最佳路由，它必须确定自己与AS或区域内的每个路由器或网络之间的最短路径。为此，它需要的不是对互联网的中立看法，而是从自己的角度来看待它。

路由器通过使用LSDB中的信息并将其转换为最短路径优先树或SPF树来创建这个视角。术语 "树 "指的是一种数据结构，它有一个根，它的分支出来，通向其他节点，而这些节点又有分支。该结构作为一个整体看起来像一棵倒置的树。在这种情况下，SPF树显示了AS或地区的拓扑信息，构建该树的路由器位于顶部。每一个直接连接的路由器或网络在树上是一个台阶；每一个连接到这些一级路由器或网络的路由器或网络再被连接起来，以此类推，直到整个 AS 或地区都被代表。

同样，路由器并没有真正制造树；它只是由路由器内的计算机进行的一种算法计算。然而，一旦这样做了，这个逻辑结构就可以用来计算该路由器到达AS（或区域）中任何路由器或网络的成本。在某些情况下，到达一个路由器或网络的方式可能不止一种，所以树的构造只显示到达网络的最短（最低成本）路径。

当然，每个路由器只负责在其旅程的下一站发送数据报，而不负责整个旅程的情况。在SPF树完成后，路由器将创建一个路由表，其中有每个网络的条目，显示到达它的成本，以及到达它的下一跳路由器。

SPF树是根据LSDB的当前状态动态创建的。如果LSDB发生变化，SPF树和路由信息将被重新计算。

**关键概念:**为了确定它应该使用什么路由来到达其自治系统中的网络，路由器从其链路状态数据库中生成一个最短路径优先树（SPF树）。该树包含与LSDB相同的基本信息，但从进行计算的路由器的角度来呈现，因此路由器可以看到通往不同网络的各种路径的成本。

<u>**OSPF路由确定的例子**</u>

我几乎可以看到你的眼睛在发亮，所以让我们再次回到我们在本节中使用的例子。为了简单起见，我将假设我们是把整个AS作为一个基本的拓扑结构来看待的。在表124中，我重复了这个AS的LSDB，我冒昧地把"["替换成了成本指标；这些也显示在图181中。同样，请记住，从一个网络到达一个路由器是没有成本的，所以这些链接只有从路由器到网络才有非零成本。

​                                                        **表124: 有成本的OSPF链接状态数据库（LSDB）示例**

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\aaaaaa5.jpg)

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ospfascost.png)

​                                                                       **图181: 带有成本的OSPF自治系统示例**

这是图179中所示的同一示例AS，但为路由器和网络之间的每个链接分配了费用。路由器和网络之间的成本只在从路由器到网络的方向上应用。

现在，让我们为RC构建SPF树。我们可以以迭代的方式进行，如下所示（为方便起见，图182中也有图形显示）。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ospftreecalc.png)

​                                                                      **图182: 使用最短路径优先算法的OSPF路由确定**

这张图以图形方式显示了一个路由器，在本例中是RC，如何确定通往各种网络的最佳路径。这里的箭头代表的不是数据的传输，而是检查从一个路由器到其他路由器或网络的各种链接。在面板#1中，RC检查其LSDB并确定其每个直接连接的设备的成本。在#2中，SPF树的第二层是通过将所有连接到#1面板中的路由器/网络的成本加入到这些数字中来构建的。(红色箭头代表我们在上一步中 "回头看 "的方向，我们没有继续。） 在#3中，这个过程继续进行，结果是确定RC到达N1的成本为5，到达N4的成本为10。

<u>**第一层**</u>
为了构建树的第一层，我们寻找所有RC可以直接到达的设备。我们发现。

- RB，成本为5。

- N2，成本为3。

- N3，成本为6。

<u>**第二层**</u>

为了构建第二层，我们寻找第一层的设备可以直接到达的所有设备。然后我们把到达第一层的每个设备的成本加到第二层的每个设备的成本上。

- RB：RB的成本为5，可以到达。
  RC，成本为5，总成本为10。

- N2，成本为4，总成本为9。

- N3，费用为5，总费用为10。

- N2: N2的费用为3，可以达到。
  RA，费用为0，总费用为3。

- RB，费用为0，总费用为3。

- RC，费用为0，总费用为3。

- N3：N3的费用为6，可以到达。
  RB，费用为0，总费用为6。

- RC，费用为0，总费用为6。

- RD，费用为0，总费用为6。

你可能马上就能看到，我们最后有许多不同的路径通向相同的设备或网络，其中一些是没有意义的。例如，我们并不关心任何通向RC的路径，因为我们就是RC！我们可以把这些路径的成本降到最低。同样，我们可以立即剔除某些路径，因为我们已经有了一条更短的路径；当我们可以直接在第一层以6的成本走到N3时，通过RB走一条成本为10的路径是没有意义的。 所以，在分离出糠秕之后，我们最终在第二层得到了以下 "小麦"。

- N2到RA，费用为3。

- N3到RD，费用为6。

<u>**第三层**</u>
我们继续这个过程，寻找连接到我们在第二层发现的 "被剔除的 "设备的设备（这次我只显示有意义的设备）。

- RA：RA连接到N1，成本为2，总成本为5

- RD：RD连接到N4，成本为4，总成本为10

<u>**最短路径树和路由计算结果**</u>

在这个简单的例子中，我们只需要三层来构建RC的树（然而对于RA或RD，我们需要更多的层次）。 最终的结果是图183中的树，以及表125中所示的RC到四个网络的路由信息。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ospftree.png)

​                                                                      **图183: OSPF计算的最短路径优先树**

这是图 182 中计算的 SPF 树的图形表示，只显示计算过程的最终结果。

​                                                                            **表 125: 计算的 OSPF 路由实例**

| **Destination Network** | **Cost** | **Next Hop** |
| ----------------------- | -------- | ------------ |
| **N1**                  | 5        | RA           |
| **N2**                  | 3        | (local)      |
| **N3**                  | 6        | (local)      |
| **N4**                  | 10       | RD           |

这当然是你在这个非常简单的例子中所期望的。注意，没有其他路由器的具体条目，因为它们是到达网络的 "手段"。然而，如果其他路由器之一是连接AS和外部世界的边界路由器，就会有边界路由器所连接的网络的条目，所以RC知道要把这些网络的流量发送到该边界路由器。

###### 3.4.2.2-5 OSPF一般操作和消息类型（部分：1 2）

作为一个路由协议，OSPF的主要工作是促进路由器之间的路由信息交换。OSPF自治系统中的每个路由器，运行OSPF软件，负责各种任务，如设置定时器，控制某些必须定期发生的活动，以及维护重要的数据结构，如链路状态数据库（LSDB）。最重要的是，每个OSPF路由器必须同时产生和响应OSPF消息。正是这个消息传递系统允许重要的路由信息在AS或区域内共享，这使得它对理解OSPF的工作方式至关重要。因此，值得看一下消息类型以及它们是如何被使用的。

<u>**OSPF消息类型**</u>
与RIP不同，OSPF不使用用户数据报协议（UDP）发送其信息。相反，OSPF直接形成IP数据报，在IP协议字段中使用协议号89来包装它们。OSPF定义了五种不同的消息类型，用于各种类型的通信。

1. ***Hello:\***顾名思义，这些消息是作为一种问候形式，让路由器发现其本地链路和网络上的其他相邻路由器。这些消息在相邻设备之间建立关系（称为邻接），并传达关于如何在自治系统或区域内使用OSPF的关键参数。
2. ***Database Description:\***这些消息包含AS或区域的拓扑结构的描述。也就是说，它们将自治系统或区域的链路状态数据库的内容从一个路由器传达给另一个路由器。传达一个大的LSDB可能需要发送几个消息；这是通过将发送设备指定为主设备并依次发送消息，由从属设备（LSDB信息的接收者）用确认来响应。
3. ***Link State Request:\***这些消息是由一个路由器用来请求另一个路由器提供关于LSDB的一部分的更新信息。该消息确切地指定了请求设备希望得到更多的最新信息的链路（s）。
4. ***Link State Update\*** ：这些消息包含LSDB上某些链接状态的更新信息。它们是作为对链路状态请求消息的响应而发送的，也是由路由器定期广播或组播的。它们的内容被用来更新收到它们的路由器的LSDB中的信息。
5. ***Link State Acknowledgment:\*** 这些消息通过明确地确认收到链路状态更新消息，为链路状态交换过程提供可靠性。

<u>**OSPF消息传递和一般操作**</u>

这些消息的使用情况大致如下。当一个路由器第一次启动时，它将发送一个Hello消息，看看周围是否有运行OSPF的邻居路由器，它还将定期发送这些消息，以发现任何可能出现的新邻居。当与一个新的路由器建立了邻接关系后，数据库描述消息将被发送，以初始化路由器的LSDB。

已经被初始化的路由器进入稳定状态模式。它们将定期用链路状态更新消息 "覆盖 "它们的本地网络，宣传它们的链路状态。当它们检测到需要通信的拓扑结构变化时，它们也会发出更新。当然，它们会收到其他设备发送的链路状态更新信息，并相应地以链路状态确认来回应。路由器也可以使用链路状态请求消息请求更新。

关键概念: OSPF的运行涉及五种消息类型。Hello消息用于在路由器之间建立联系，而数据库描述消息用于初始化路由器的链路状态数据库。常规的LSDB更新是使用链路状态更新消息发送的，这些消息使用链路状态确认来确认。一个设备也可以使用链路状态请求来请求一个特定的更新。

当使用分层拓扑结构时，内部路由器维护一个LSDB，并且只在一个区域内执行消息传递。区域边界路由器有多个LSDB，并在一个以上的区域执行信息传递。它们与其他OSPF骨干路由器一起，也在骨干网上交换信息，包括它们边界区域的汇总链路状态信息。

同样，所有这些都是高度简化的；OSPF标准包含了数页详细的规则和程序，规定了发送和接收消息的确切时间。

<u>**OSPF消息认证**</u>
OSPF标准规定，所有的OSPF消息都要经过安全认证。然而，这有点误导，因为支持的认证 "方法 "之一是 "空认证"--意思是不使用认证。通过使用可选的简单密码认证方法可以提供更多的安全，通过使用加密认证可以提供最大的安全。这些方法在RFC 2328的附录D中描述。

注意：OSPF中使用的Hello消息有时也被称为Hello协议。这是特别糟糕的术语，因为有一个实际的路由协议，在下一节描述，叫做HELLO协议。这两个协议并不相关。然而，我怀疑OSPF的Hello消息可能被如此命名，因为它们的目的与独立的HELLO协议中使用的消息相似。

###### 3.4.2.2-6 OSPF消息格式（部分：1 2 3 4 5 6 7）

OSPF使用五种不同类型的消息，在一个自治系统或区域内的路由器之间交流链路状态和一般信息。为了帮助更好地说明OSPF消息是如何使用的，值得快速看一下这些消息的格式。好吧，我想我在这里对 "快速 "一词的使用是有些宽松的。J

<u>**OSPF通用报头格式**</u>
自然，每种类型的OSPF消息都包括一套稍微不同的信息--否则，它们就不会是不同的消息类型了！但是，它们都有一个类似的消息格式。然而，它们都有一个类似的消息结构，以一个共享的24字节的头开始。这个共同的头允许以一致的方式传达某些标准信息，例如产生该消息的OSPF版本的编号。它还允许收到OSPF消息的设备快速确定它所收到的消息类型，因此它知道是否需要费力地检查消息的其余部分。表126和图184显示了通用的OSPF头格式。

​                                                               <u>**表126: OSPF通用报头格式**</u>

| **Field Name**        | **Size (bytes)** | **Description**                                                                      |
| --------------------- | ---------------- | ------------------------------------------------------------------------------------ |
| ***Version #\***      | 1                | ***Version Number:\*** Set to 2 for OSPF version 2.                                  |
| ***Type\***           | 1                | ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\aa1fdc38.png) |
| ***Packet Length\***  | 2                | ***Packet Length:\*** 数据包长度。信息的长度，以字节为单位，包括这个头的24字节。                                 |
| ***Router ID\***      | 4                | ***Router ID:\*** 路由器ID。产生此信息的路由器的ID（一般是它在发送信息的接口上的IP地址）。                            |
| ***Area ID\***        | 4                | ***Area ID:\*** 区域ID。在使用区域的情况下，该报文所属的OSPF区域的标识。                                      |
| ***Checksum\***       | 2                | ***Checksum:\*** 校验和。以类似于标准IP校验的方式计算的16位校验和。除了验证字段，整个消息都包括在计算中。                      |
| ***AuType\***         | 2                | ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\aa1fdce3.png) |
| ***Authentication\*** | 8                | ***Authentication:\***认证。一个64位的字段，用于根据需要对信息进行认证。                                     |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ospfgeneralformat.png)

​                                                                                    **图184: OSPF通用报头格式**

<u>**具体的信息格式**</u>

在这个头之后，消息的主体包括一个数量不等的字段，这取决于消息的类型。每个消息格式在RFC 2328中都有详细描述；由于有些格式相当长，我在这里只简单描述其字段。

***Hello\* Message Format**
这些消息在头中的类型值为1，消息正文中的字段结构如表127和图185所示。

​                                                                 **表127：OSPF Hello消息格式**

| **Field Name**                  | **Size (bytes)** | **Description**                                                           |
| ------------------------------- | ---------------- | ------------------------------------------------------------------------- |
| ***Network Mask\***             | 4                | ***Network Mask:\*** 网络掩码：路由器所发送的网络的子网掩码。                                 |
| ***Hello Interval\***           | 2                | ***Hello Interval:\*** 路由器在发送Hello信息之间等待的秒数。                              |
| ***Options\***                  | 1                | ***Options:\*** 表示路由器支持哪些可选的OSPF功能。                                       |
| ***Rtr Pri\***                  | 1                | ***Router Priority:\*** 路由器优先级。表示路由器的优先级，当选择一个备份指定路由器时。                   |
| ***Router Dead Interval\***     | 4                | ***Router Dead Interval:\*** 路由器在被认为失败前可以 "沉默 "的秒数。                       |
| ***Designated Router\***        | 4                | ***Designated Router:\*** 指定的路由器。在某些网络中为某些特殊功能指定的路由器的地址。如果没有指定路由器，则设置为零。  |
| ***Backup Designated Router\*** | 4                | ***Backup Designated Router:\***后备指定的路由器。后备指定路由器的地址。如果没有后备指定路由器，则设置为全部为零。 |
| ***Neighbors\***                | Multiple of 4    | ***Neighbors:\*** 邻居。该路由器最近收到Hello信息的每个路由器的地址。                            |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ospfhelloformat.png)

​                                                                           **图185: OSPF Hello消息格式**

<u>b</u>

这些消息的头中的Type值为2，正文结构如表128和图186所示。

​                                                                       **表128：OSPF数据库描述报文格式**

| **Field Name**            | **Size (bytes)** | **Description**                                                                      |
| ------------------------- | ---------------- | ------------------------------------------------------------------------------------ |
| ***Interface MTU\***      | 2                | ***Interface MTU:\*** 接口MTU。在不分片的情况下，可以在该路由器的接口上发送的最大IP信息的大小。                        |
| ***Options\***            | 1                | ***Options:\*** 选项。表示路由器支持几种可选的OSPF功能中的哪一种。                                          |
| ***Flags\***              | 1                | ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\aa1fddf6.png) |
| ***DD Sequence Number\*** | 4                | ***DD Sequence Number:\*** DD序列号。用于对数据库描述信息的序列进行编号，使其保持顺序。                           |
| ***LSA Headers\***        | Variable         | ***LSA Headers:\*** LSA头信息。包含链路状态通告头，它携带关于LSDB的信息。关于LSA的更多信息，请参见本主题的最后。              |

![image-20221031100658228](C:\Users\zy\AppData\Roaming\Typora\typora-user-images\image-20221031100658228.png)

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ospfdatabasedescriptionformat.png)

​                                     **Figure 186: OSPF \*Database Description\* Message Format**

<u>**链接状态请求消息格式**</u>

这些消息的头中有一个类型值为3。在报头之后是一组或多组三个字段，每个字段都标识一个路由器请求更新的链路状态广告（LSA），如图187所示。每个LSA标识的格式在表129中描述。

​                                                         **表129: OSPF链路状态请求消息格式**

| **Field Name**            | **Size (bytes)** | **Description**                                         |
| ------------------------- | ---------------- | ------------------------------------------------------- |
| ***LS Type\***            | 4                | ***Link State Type:\*** 链接状态类型。正在寻找的链接状态广告（LSA）的类型。     |
| ***Link State ID\***      | 4                | ***Link State ID:\*** 链接状态ID：LSA的标识符，通常是链接的路由器或网络的IP地址。 |
| ***Advertising Router\*** | 4                | ***Advertising Router:\*** 广告路由器。创建LSA的路由器的ID，其更新正在被寻求。 |

![image-20221031101259206](C:\Users\zy\AppData\Roaming\Typora\typora-user-images\image-20221031101259206.png)

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ospflinkstaterequestformat.png)

​                                                  **图187: OSPF链接状态请求消息格式**

<u>**链接状态更新信息格式**</u>

这些报文的标题中的类型值为4，字段见表130和图188。

​                                                            **表130: OSPF链路状态更新消息格式**

| **Field Name** | **Size (bytes)** | **Description**                                   |
| -------------- | ---------------- | ------------------------------------------------- |
| ***# LSAs\***  | 4                | ***Number of LSAs:\*** LSAs的数量。该消息中包含的链接状态广告的数量。. |
| ***LSAs\***    | Variable         | ***LSAs:\*** LSAs。一个或多个链接状态广告。更多细节见下文。            |

![image-20221031101555659](C:\Users\zy\AppData\Roaming\Typora\typora-user-images\image-20221031101555659.png)

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ospflinkstateupdateformat.png)

​                                                                    **图188: OSPF链路状态更新消息格式**

**<u>链接状态确认消息格式</u>**

这些消息的头中有一个类型值为5。然后它们包含一个与被确认的LSA相对应的LSA头的列表，如表131和图189所示。

​                                                                  **表131：OSPF链路状态确认消息格式**

| **Field Name**     | **Size (bytes)** | **Description**                                  |
| ------------------ | ---------------- | ------------------------------------------------ |
| ***LSA Headers\*** | Variable         | ***LSA Headers:\*** LSA头信息。包含链路状态广告头，用于识别确认的LSA。 |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ospflinkstateackformat.png)

​                                                                  **图189: OSPF链接状态确认消息格式**

<u>**链接状态通告（LSA）和LSA头格式**</u>

正如我们在上面看到的，几种消息类型包括链路状态广告（LSA），这是实际携带LSDB拓扑信息的字段。有几种类型的LSA，它们被用来传达关于不同类型链接的信息。像OSPF消息本身一样，每个LSA都有一个20字节的普通头，然后是描述链路的一些附加字段。

**<u>LSA头</u>**
LSA头包含足够的信息来识别链路。它使用表132和图190中的子字段结构。

​                                                                       **表132: OSPF链路状态广告头格式**

| **Subfield Name**         | **Size (bytes)** | **Description**                                                                      |
| ------------------------- | ---------------- | ------------------------------------------------------------------------------------ |
| ***LS Age\***             | 2                | ***LS Age:\*** LS Age: 自LSA创建以来经过的秒数。                                                |
| ***Options\***            | 1                | ***Options:\*** 选项。表示路由器支持几种可选的OSPF能力中的哪一种。                                          |
| ***LS Type\***            | 1                | ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\aa1fdfb2.png) |
| ***Link State ID\***      | 4                | ***Link State ID:\*** 链路状态ID: 识别链路。这通常是路由器或链接所代表的网络的IP地址。                            |
| ***Advertising Router\*** | 4                | ***Advertising Router:\*** 广告路由器。发起LSA的路由器的ID。                                       |
| ***LS Sequence Number\*** | 4                | ***LS Sequence Number:\*** LS序列号。用来检测旧的或重复的LSA的序列号。                                  |
| ***LS Checksum\***        | 2                | ***LS Checksum:\*** LS校验和。LSA的校验和，用于保护数据损坏。                                          |
| ***Length\***             | 2                | ***Length:\*** 长度。LSA的长度，包括头的20字节。                                                   |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ospflsaheaderformat.png)

​                                                                     **图190: OSPF链路状态广告头格式**

![image-20221031102616426](C:\Users\zy\AppData\Roaming\Typora\typora-user-images\image-20221031102616426.png)

**LSA Body**

在LSA头之后是LSA的主体，其具体字段取决于LS类型字段的值。要描述所有这些子字段需要好几页的篇幅，而且我在描述每个消息类型时可能已经过头了，所以如果你想了解所有的细节，我将推荐你到RFC 2328的附录A。通过快速总结的方式。

- 对于到路由器的正常链接，LSA包括路由器的标识和到达它的度量，以及关于路由器的细节，如它是一个边界还是区域边界路由器。
- 网络的LSA包括一个子网掩码和关于网络上其他路由器的信息。
- 概要LSA包括一个度量和一个概要地址，以及一个子网掩码。
- 外部LSA包括一些额外的字段，以使外部路由器能够被沟通。

参考: https://en.wikipedia.org/wiki/Link-state_advertisement

###### 3.4.2.3 其他内部路由协议

路由信息协议（RIP）和开放最短路径优先（OSPF）是TCP/IP套件中使用的两个最著名的内部路由协议，为此我对每个协议进行了相当详细的描述。除此以外，还有一些其他的TCP/IP内部路由协议，属于两类中的一类。有些是今天不再使用的协议，但从历史的角度来看是很有趣的，还有一些是RIP和OSPF的专有替代协议，你今天在网络世界中可能会遇到，但也许不那么经常。

在这一节中，我对另外四个TCP/IP内部路由协议进行了简要描述。我首先介绍了在早期互联网中发挥重要作用的两个过时的协议：网关到网关协议（GGP）和HELLO协议。然后，我介绍了由Cisco系统公司开发的两个内部路由协议，它们在今天的行业中有时被视为RIP和OSPF的替代品：内部网关路由协议（IGRP）和增强型内部网关路由协议（EIGRP）。

**背景信息:** 在本节的某些情况下，我酌情与RIP和OSPF进行了比较，以显示这些协议与 "两大 "的相似或不同之处。在继续阅读之前，你可能希望对RIP和OSPF有一些了解。

###### 3.4.2.3-1 TCP/IP网关到网关协议（GGP）（部分：1 2 )

在关于关键路由协议概念的概述专题中，我描述了TCP/IP路由架构的演变。现代互联网是基于独立的自治系统（AS）的概念，在这些系统内运行内部路由协议，在它们之间运行外部路由协议。然而，早期的互联网有些简单；它由相对较少的核心路由器组成，这些路由器携带着关于整个互联网的详细信息，而位于核心周围的非核心路由器只知道部分信息。

这些核心路由器使用一种特殊的路由协议进行通信，称为网关到网关协议（GGP）。GGP最初是由Bolt, Beranek和Newman（BBN）在20世纪80年代初开发的，是互联网和TCP/IP的先驱之一。它被记录在1982年9月出版的RFC 823《DARPA INTERNET GATEWAY》中。这个协议现在已经过时了，但它在早期的互联网中发挥了重要作用，而且还引入了某些概念，这些概念被用于多年后开发的路由协议中。这使得了解一点它的情况是值得的。

<u>**操作概述**</u>
GGP在一般操作上与路由信息协议（RIP）类似，它使用距离矢量算法来确定设备间的最佳路由。与RIP一样，公因子是一个简单的跳数，因此GGP将选择跳数最短的路由。虽然我们在讨论RIP时看到，跳数并不总是衡量路由器成本的最佳指标，但它实际上是当年确定路由的一个相当好的方法。这是因为早期互联网使用的计算机和链路以今天的标准来看都是非常慢的，因此与现代路由相比，每一跳都相当 "昂贵"。

使用GGP的路由器一开始处于空状态，假设与其他路由器和本地网络的所有链接都已关闭。然后，它通过查看是否能在网络上发送和接收信息来测试本地网络的状态。每隔15秒，路由器向其每个邻居发送一个GGP Echo消息。如果邻居收到该消息，它就会用GGP Echo回复消息进行回应。发送Echo消息的路由器如果收到一定比例的消息回复，就认为邻居已经启动，默认为50%。

**注意：**这些消息的功能与ICMPv4 Echo和Echo Reply消息类似，但并不一样。

实际的路由信息是通过发送GGP路由更新报文进行通信的。这些消息的性质类似于RIP中使用的RIP响应消息。每个路由更新消息都包含发送路由器路由表中的信息，其中规定了路由器可以到达哪些网络，以及每个网络的成本（以跳数计）。

每个收到路由更新信息的路由器都知道，既然它能到达发送更新的路由器，它也能以额外一跳的代价到达这些路由器的所有可达网络。它使用这些信息来更新自己的内部目的地和指标表。然后，它在自己的附属网络上发出自己的路由更新，以传播从自己网络上的其他路由器学到的信息。这个过程一直持续到最后，所有GGP路由器的路由在整个国际网络中传播，就像在RIP中那样。

<u>**路由表信息的传播**</u>

GGP和RIP之间一个有趣的区别是，在GGP中，网络和开销不是成对发送。相反，GGP路由器以组为单位发送其路由表。如果它有三个成本为1的网络，它就把这些网络放在一个距离值为1的组中发送，如果它有几个成本为2的网络，它就把这些网络放在一个距离值为2的组中发送，以此类推。另一个区别是，GGP的路由更新消息是被确认的。每个路由更新消息都有一个序列号，用于确保过时的信息不被传播。如果收到的路由更新有一个新的序列号（表示是最近的信息），处理该信息的路由器会向发起者发回一个GGP确认信息。如果序列号表明该信息是陈旧的，则会发送一个否定的确认信息，并将该信息丢弃。

作为一种使用跳数作为度量的距离矢量算法，GGP与RIP有大部分相同的优点和缺点。它的优点是简单，但也有各种问题，如收敛速度慢和 "无限计数 "等问题。然而，GGP是一个比RIP更初级的协议，不包括RIP中处理此类问题的许多功能，如分割水平线。由于年代久远，GGP也只限于非子网的类群网络。

**目前在TCP/IP中的作用**
当互联网架构转向使用自治系统时，GGP就被淘汰了。虽然它是TCP/IP历史上的一个重要部分，但今天它已不被正式视为TCP/IP协议套件的一部分。

**关键概念:** 网关到网关协议（GGP）用于在早期互联网的核心路由器之间传递路由信息。它是一个距离矢量协议，其运行方式与RIP非常相似。每个路由器定期向邻近的路由器发送其路由表，因此每个路由器可以了解到达自治系统中每个网络的成本，以跳数为单位。GGP现在被认为是一个历史协议，不再是TCP/IP的一部分。

###### 3.4.2.3-2 HELLO协议（HELLO）（部分：1 2）

我们今天所知道的TCP/IP互联网是在几十年间发展起来的。它最初是由美国国防部高级研究计划局（DARPA或ARPA）启动的一个实验性研究项目，称为ARPA网。ARPA网络最终通过增加其他网络而发展起来，例如由国家科学基金会（NSF）开发的重要的NSF网络。NSFnet主干网经过多年的发展，对现代互联网的最终建立起到了重要作用。

最初的NSFnet主干网由分布在美国各地的六台数字设备公司（DEC，多年前被康柏公司吸收）LSI-11计算机组成。这些计算机运行的特殊软件被俗称为 "fuzzball"，使它们能够作为路由器发挥作用。这些 "fuzzball路由器 "将各种网络连接到NSFnet和ARPAnet。

六台NSFnet路由器作为一个自治系统（AS）工作，像任何AS一样，使用内部路由协议来交换路由信息。这些早期路由器使用的路由协议被称为HELLO协议。它是在20世纪80年代初开发的，并记录在1983年12月出版的RFC 891，DCN本地网络协议中。HELLO "这个名字是大写的，但不是一个缩写；它只是指Hello这个词，因为该协议使用的消息有点类似于路由器之间的对话。

**注：**开放最短路径优先（OSPF）路由协议有一个消息类型，叫做Hello。这些消息的使用有时被称为 "Hello协议"。OSPF与本节中描述的HELLO协议没有直接关系，只是这两个协议都用于AS中的路由。OSPF有可能从HELLO协议中借用了Hello这个名字，但我在这个问题上找不到任何明确的说法。

<u>**操作概述**</u>
HELLO协议使用距离矢量算法，就像路由信息协议（RIP）和网关到网关协议（GGP）。然而，有趣的是，与RIP和GGP不同，HELLO不使用跳数作为度量。相反，它试图通过评估网络延迟和选择延迟最短的路径来选择最佳路线。

使用HELLO的路由器的关键工作之一是计算与邻居之间发送和接收数据报的时间延迟。在定期的基础上，路由器交换包含时钟和时间戳信息的HELLO消息。通过使用特殊算法将消息中的时钟值和时间戳与自己的时钟进行比较，接收设备可以计算出在链路上发送数据报所需的估计时间。

像RIP和GGP一样，HELLO消息也包含路由信息，其形式是发送路由器能够到达的一组目的地和每个目的地的度量。但是在这种情况下，指标是对每个目的地的往返延迟成本的估计。这一信息被添加到计算出的接收信息的链路的往返延迟时间中，并用于更新接收路由器自己的路由表。

这似乎有点令人困惑，但实际上与RIP等跳数距离矢量协议的工作方式相似。使用RIP的路由器A收到来自路由器B的RIP响应消息时，知道它可以到达路由器B可以到达的每个目的地，但要付出额外一跳的代价（从路由器A到路由器B的一跳）。同样，路由器A从路由器B收到HELLO消息时，知道它可以到达路由器B可以到达的每一个目的地，但要付出路由器A和路由器B之间链路的计算延迟的额外近似成本。

<u>**使用延时作为衡量标准的问题**</u>

从理论上讲，使用延迟计算应该比单纯使用跳数更有效地选择路由，但代价是比跳数算法更复杂。这使得HELLO确实非常有趣，特别是对于一个已经有20多年历史的协议。然而，由于一条链路的延迟往往与它的带宽无关，使用时间延迟作为链路指标可能导致虚假的结果。

此外，任何链路的延迟随时间变化是正常的；在有两条成本相似的路由的情况下，每条路由的延迟的波动可能导致路由之间的快速变化（这种现象有时被称为路由拍打）。需要对上述HELLO协议运行的基本概述进行调整，以避免这类问题。

<u>**目前在TCP/IP中的作用**</u>
像其他早期的路由协议一样，HELLO不包括任何花哨的认证等等；这些功能在互联网的早期并不是真正需要的，那时的互联网网络很小，很容易控制。随着互联网的发展，HELLO最终被更新的路由协议（如RIP）所取代。现在它被认为是一个历史性的协议（阅读：过时），不再使用。

**关键概念。**HELLO协议被用于互联网前身的早期路由器上，以交换路由信息。它是一个像RIP和GGP一样的距离矢量协议，但不同的是，它使用计算的延迟作为度量，而不是跳数。与GGP一样，它现在被认为是一个历史协议，不再是TCP/IP的一部分。

###### 3.4.2.3-3 内部网关路由协议（IGRP） (Parts: 1 2 )

如果你已经阅读了本指南的大部分内容，你可能已经注意到我非常喜欢通用的、开放的标准，而不是专有标准。(我在关于标准的网络基础部分解释了其中的原因）。我并不是唯一这样认为的人，事实上，可以毫不夸张地说，TCP/IP和互联网的成功与它们都是通过开放的RFC程序开发出来的，而且直到今天仍然如此。

也就是说，在某些情况下，如果至少有两个因素是真实的，那么专有协议可以是有益的，甚至可以取得相当的成功。首先，必须缺少合适的开放协议，或者现有的开放协议在功能覆盖方面存在空白，这为专有协议的成功创造了 "机会"。其次，专有协议必须由行业中的 "大玩家 "发起或大力支持，以帮助确保其他公司注意到并给该协议一个成为标准的机会。

这种情况出现在20世纪80年代的路由协议世界中。当时，最流行的内部路由协议是路由信息协议（RIP）。正如本指南的RIP部分所描述的，RIP基本上做得很好，但有一些限制和问题，是协议所固有的，不容易解决。在20世纪80年代中期，像OSPF这样的开放式替代方案还不存在；即使有，OSPF也比RIP复杂得多，因此有时不是一个好的替代方案。

思科系统公司，绝对是网络特别是互联网和路由方面的 "大人物 "之一，决定开发一种新的路由协议，它与RIP相似，但能提供更大的功能并解决RIP的一些固有问题：内部网关路由协议（IGRP）。IGRP--在其名称中方便地使用了 "网关 "和 "路由 "两个词，以表达这两个词在互联网标准中的等同性--被专门设计为RIP的替代品。它在许多方面都很相似，并保持了RIP的简单性，这是它的主要优势之一。同时，IGRP克服了RIP的两个关键限制：只使用跳数作为路由度量，以及跳数限制为15。

<u>**操作概述**</u>
与RIP一样，IGRP是一个距离矢量路由协议，设计用于自治系统，因此使用相同的基本机制来确定路由。每个路由器定期向它所连接的每个本地网络发送一个包含其路由表副本的消息。这个消息包含一对可到达的网络和到达每个网络的成本（度量）。收到该消息的路由器知道，只要它能到达发送该消息的路由器，就能到达消息中的所有网络。它计算出到达这些网络的成本，把它们的成本加上到达发送消息的路由器的成本。路由器相应地更新它们的表，并在它们的下一次例行更新中把这些信息发送出去。最终，自治系统中的每个路由器都有关于到达它的每个网络的成本信息。

<u>**特征和能力**</u>

然而，RIP和IGRP之间的一个重要区别是，RIP只允许用跳数来表示到达一个网络的成本，而IGRP提供了一个更复杂的指标。在IGRP中，到达一个网络的总成本是根据几个单独的指标来计算的，包括网络延迟、带宽、可靠性和负载。成本的计算可以由管理员定制，他可以为各部分指标设置相对权重，以反映该自治系统的优先级。因此，如果一个特定的管理员认为通过强调可靠性而不是带宽来最小化路由成本，他或她可以这样做。这样的系统比RIP的僵硬的跳数系统提供了巨大的灵活性。与RIP不同，IGRP也没有任何网络间15跳的固有限制。

在这个基本算法中，IGRP增加了一个叫做多路径路由的功能。这允许在路由之间自动使用多条路径，并在它们之间共享流量。流量可以平均共享，也可以根据每条路径的相对成本指标不平均地分配。这提供了更好的性能，并再次提供了灵活性。

由于IGRP是一个像RIP一样的距离矢量协议，它分享了RIP的许多算法 "问题"。因此，不难理解，IGRP必须纳入许多与RIP相同的稳定性特征，包括使用分割水平线、带有毒性逆转的水平分割（在某些情况下）和使用保留计时器。与RIP一样，IGRP也使用计时器来控制更新的发送频率、路由器被 "搁置 "的时间，以及路由在过期前在路由表中被保留的时间。

思科最初为IP网络开发了IGRP，由于IP在业界占主导地位，这是它最常出现的地方。然而，IGRP并不是专门针对IP的，如果为其他网络协议实施，也可以与这些协议一起使用。正如我们在下一主题中所看到的，思科公司也使用IGRP作为改进的路由协议的基础，该协议被称为EIGRP，是在最初的几年后开发的。

**关键概念。**在20世纪80年代，思科系统公司创建了内部网关路由协议（IGRP），作为对工业标准协议RIP的一种改进。IGRP是一个像RIP一样的距离矢量协议，在许多方面与RIP相似，但包括一些改进。其中最重要的是取消了路由器之间的15跳限制，并能够使用跳数以外的指标来确定最佳路由。

###### 3.4.2.3-4 增强型内部网关路由协议（EIGRP） (Parts: 1 2 )

思科系统公司是世界互联网和路由技术的领导者，在20世纪80年代中期开发了内部网关路由协议（IGRP），作为RIP的替代协议用于TCP/IP自治系统。IGRP代表了对RIP的重大改进，但像任何成功的公司一样，思科并不满足于安于现状。思科知道IGRP有很大的改进空间，所以他们在20世纪90年代初开始着手创建一个更好的IGMP版本。其结果是增强型内部网关路由协议（EIGRP）。

<u>**IGRP和EIGRP的比较**</u>
与最初的协议相比，EIGRP更像是一种进化，而不是一场革命。EIGRP仍然是一个距离矢量协议，但比其他距离矢量协议（如IGRP或RIP）更复杂，并包括某些通常与OSPF等链路状态路由协议有关的功能，而不是距离矢量算法。另外，由于思科意识到许多决定使用EIGRP的组织将从IGRP迁移到EIGRP，他们采取了特别的措施来最大限度地提高两者的兼容性。

IGRP和EIGRP的主要区别不在于它们做什么，而在于它们如何做。EIGRP改变了计算路由的方式，以提高效率和路由收敛的速度（网络中不同路由器之间的路由协议）。EIGRP是基于一种新的路由计算算法，称为扩散更新算法（DUAL），由J.J. Garcia-Luna-Aceves博士在一家名为SRI国际的公司开发。

<u>**EIGRP的DUAL路由计算算法**</u>
DUAL与典型的距离矢量算法的不同之处主要在于，它比RIP或IGRP等协议所使用的拓扑信息维护更多的网络信息。它使用这些信息来自动选择网络间成本最低、无环路的路由。EIGRP使用一个指标，结合评估一个链接的带宽和通过该链接发送的总延迟。(其他指标也是可以配置的，但不推荐使用。)当一个邻居路由器发送改变了的指标信息时，路由会被重新计算，并根据需要发送更新。如果需要，DUAL将查询邻近路由器的可达性信息（例如，如果现有路由失败）。

这种 "根据需要 "的操作突出了EIGRP比IGRP提高性能的一个重要方式。EIGRP不发送常规的路由更新，只在需要时发送部分更新，减少了路由器之间产生的流量。此外，这些更新被设计成只有需要更新信息的路由器才会收到它们。

<u>**EIGRP的其他特点**</u>

为了建立计算路由所需的信息表，EIGRP要求每个路由器与本地网络中的其他路由器建立并保持联系。为了促进这一点，EIGRP包含了一个邻居发现/恢复过程。这个系统涉及到小型Hello消息的交换，让路由器发现本地网络中的其他路由器，并定期检查它们的可达性。这与OSPF中使用相同名称的Hello消息非常相似，而且对带宽使用的影响很低，因为这些消息很小，而且不经常发送。

IGRP中的一些特性一直延续到它的后继者，如使用水平分割和毒性逆转提高稳定性。除了算法本身带来的效率和路由收敛的基本改进外，EIGRP还包括一些其他功能。这些包括对可变长度子网掩码（VLSM）的支持和对多个网络层协议的支持。这意味着EIGRP可以被配置为在一个运行IP和另一个第三层协议的网络上运行。

**关键概念。**增强型内部网关路由协议（EIGRP）开发于20世纪90年代，是思科公司IGRP的一个改进版本。它在许多方面与IGRP相似，但使用了一种更复杂的路由计算方法，称为扩散更新算法（DUAL）。EIGRP还包括一些功能，使其在计算路由时更加智能，借用了链路状态路由协议的概念，并使用更有效的部分更新，而不是发送整个路由表。

##### 3.4.3 TCP/IP 外部网关/路由协议（BGP 和 EGP）

为了便于管理，大型互联网上的路由器被分组为自治系统（AS），由不同的组织和公司独立控制。内部路由协议，如RIP和OSPF，被用来在一个自治系统内的路由器之间交流路由信息。显然，如果在AS内使用内部路由协议，我们需要另一套路由协议在AS之间发送该信息。这些被称为外部路由协议。

自治系统架构的整个要点在这个短语的第一个词的含义中传达出来：自治。一个AS内部发生的细节对其他AS是隐藏的，这使得AS的管理员可以独立地控制他或她如何运行它，包括从各种不同的内部路由协议中选择一个或多个。相反，为了可靠地将AS连接在一起，每个AS都必须运行相同的外部路由协议，否则结果将类似于巴别塔。这样做的结果是，在TCP/IP中，通常只有一个外部路由协议在特定时间内被广泛使用。

在本节中，我将介绍两种不同的TCP/IP外部路由协议。第一个是边界网关协议（BGP），它是现代TCP/IP中使用的协议。BGP非常重要，因为它被用于当前的互联网和其他更大的互联网网络，所以它被介绍得相当详细。第二个是外部网关协议（EGP）。这是一个过时的协议，在早期的互联网中用于非核心路由器和路由器核心之间的通信，为了完整性和历史意义，我们对其进行了简单的描述。

**背景信息:** 在这一节中，我假设你至少已经对内部路由协议有了一定的了解，至少在基本术语上理解了它们的作用。如果你还没有读过RIP，即最常见的内部路由协议，你可能希望略过这一部分。至少，要确保你熟悉路由协议架构的概述。

###### 3.4.3.1 TCP/IP边界网关协议（BGP/BGP-4）

现代TCP/IP网络是由独立运行的自治系统（AS）组成的。每个系统都可以使用内部路由协议，如RIP、OSPF、IGRP或EIGRP来选择AS内网络间的路由。为了形成更大的国际网络，特别是 "所有国际网络之母"--互联网，这些自治系统必须连接在一起。这就需要使用一个所有AS都能同意的一致的外部路由协议，在今天的TCP/IP中，这个协议就是边界网关协议（BGP）。

在本节中，我将描述边界网关协议（BGP）的特点、一般操作和详细操作。讨论分为两个小节。第一部分概述了BGP的运行情况，包括对关键概念的讨论，如拓扑结构、邻居关系、路由确定和一般消息传递。第二部分更详细地分析了不同的消息类型及其使用方法，并描述了每种消息的格式。

BGP是一个相当大的协议和技术群体中的另一个，它是如此复杂，需要几十个主题才能做到公正。因此，我在这里包括我的标准免责声明，即在本节中你将看到对BGP的一个相对高层次的了解。如果你需要更多细节，你需要参考BGP标准（在BGP标准和版本专题中描述）。

注意：BGP的当前版本是第4版，也叫BGP-4。这是目前广泛使用的唯一版本，因此除非另有说明，否则只要看到 "BGP"，就认为是BGP-4。

###### 3.4.3.1-1 BGP基础知识和一般操作

如果让普通的互联网用户，甚至是典型的网络管理员来列举十个最重要的TCP/IP协议，很可能BGP不会经常出现。路由协议是TCP/IP套件中的 "工蜂"，并不令人兴奋。然而，现实情况是，BGP是一个对大型互联网网络和互联网本身的运行至关重要的协议。它是将小型国际网络（自治系统）连接在一起的 "粘合剂"，它确保每个组织都能共享路由信息。正是这种功能使我们能够把不同的网络和互联网放在一起，并找到从任何主机到任何其他主机的有效路由，而不管其位置如何。

在这一节中，我将通过介绍BGP协议的基本概念和一般操作，开始我们对这个非常重要的BGP协议的研究。像往常一样，我首先概述了该协议，并讨论了其历史、标准和版本，包括对其主要特征和特性的讨论。然后我介绍了基本的操作概念，包括拓扑结构、BGP 通告的概念和邻居关系。我讨论了BGP流量类型，以及如何使用策略来控制互联网上的流量。我解释了BGP路由器如何存储和发布路由，以及路由信息库（RIB）的功能。我描述了BGP使用的基本算法以及路径属性如何描述路由。然后，我对BGP路由选择过程的运作方式进行了总结。最后，我对BGP的运行和各种消息的高级使用进行了总体描述。

###### 3.4.3.1-1-1 BGP概述、历史、标准和版本（部分：1 2 3 4 )

正如我在路由协议概念概述中简要描述的那样，早期互联网中路由器的连接方式与今天有很大不同。早期的互联网有一组集中式的路由器，像一个 "核心 "自治系统一样运作。这些路由器在AS内使用网关到网关协议进行通信，而与核心系统外的路由器进行通信则使用名称恰当的外部网关协议（EGP）。

<u>**BGP的动因和发展**</u>
当互联网发展到自治系统（AS）架构时，EGP仍然能够作为互联网的外部路由协议发挥作用。然而，随着互联网中自治系统数量的增加，它们之间通信的重要性也在增加。EGP是有效的，但有几个弱点，随着互联网规模的扩大，这些弱点变得更加棘手。有必要定义一个新的外部路由协议，为不断增长的互联网提供增强的功能。

1989年6月，随着RFC 1105《边界网关协议（BGP）》的发布，这个新的路由协议的第一个版本被正式确定。这个初始版本的BGP标准定义了协议背后的大部分概念，以及关键的基础知识，如消息传递、消息格式和设备的一般操作。它确立了BGP作为未来互联网外部路由协议的地位。

<u>**BGP的演变、版本和定义标准**</u>

由于一个跨越互联网的协议的重要性，在最初的标准发布后，BGP的工作持续了很多年。BGP的开发者必须纠正最初协议中的问题，完善BGP的运行，提高效率，并增加功能。此外，还必须进行调整，使BGP能够跟上TCP/IP协议套件中的其他变化，例如无类别寻址和路由的发明。

这种持续工作的结果是，BGP已经经历了几个版本和标准的演变。这些版本有时被称为BGP-N，其中N是版本号。表133显示了BGP标准的历史，提供了RFC编号和名称以及每个版本所做修改的简要总结。

​                                                       **表133：边界网关协议（BGP）的版本和定义标准**

| **RFC Number** | **Date**     | **Name**                              | **BGP Version** | **Description**                                                                                                                                                                                                                                                                                                                                  |
| -------------- | ------------ | ------------------------------------- | --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **1105**       | June 1989    | *A Border Gateway Protocol (BGP)*     | BGP-1           | BGP协议的初始定义。                                                                                                                                                                                                                                                                                                                                      |
| **1163**       | June 1990    | *A Border Gateway Protocol (BGP)*     | BGP-2           | 该版本清理了BGP-1的一些问题，并完善了一些消息类型的含义和使用。它还增加了路径属性的重要概念，用于传递路由信息。                                                BGP-1是围绕定向拓扑结构的概念设计的，某些路由器相对于对方是 "向上"、"向下 "或 "水平 "的；BGP-2删除了这个概念，使BGP更适合于任意的AS拓扑结构。                                                                                                                 请注意，RFC的标题不是打错的，他们没有把 "版本2 "放在标题中。 |
| **1267**       | October 1991 | *Border Gateway Protocol 3 (BGP-3)*   | BGP-3           | 该版本优化并简化了路由信息交换，在用于建立BGP通信的消息中加入了识别功能，并加入了其他一些改进和修正。 (由于某些原因，这个版本的标题中没有 "A"。）                                                                                                                                                                                                                                                                    |
| **1654**       | July 1994    | *A Border Gateway Protocol 4 (BGP-4)* | BGP-4           | BGP-4的初始标准，在RFC 1771中修订。见下文。                                                                                                                                                                                                                                                                                                                     |
| **1771**       | March 1995   | *A Border Gateway Protocol 4 (BGP-4)* | BGP-4           | BGP-4的现行标准。BGP-4的主要变化是支持无类别域间路由（CIDR）。该协议被修改为允许指定代表一组聚合网络的前缀。该协议还做了其他小的改进。                                                                                                                                                                                                                                                                       |

正如你所想象的，改变像BGP这样的协议的版本并不是一件容易的事情。对协议的任何修改都需要许多不同组织的协调。互联网发展得越大，这就越困难。因此，尽管在20世纪90年代初经常更换版本，但BGP-4今天仍然是当前的标准版本，而且是被广泛使用的版本。除非另有说明，本指南中提到的BGP都是指BGP-4。

<u>**BGP补充标准**</u>

作为RFC 1771的补充，与它同时发布的还有另外三个连续编号的RFC，它们提供了关于BGP功能和使用的支持信息，如表134所示。

​                                                                                    **表134: BGP-4的补充定义标准**

| **RFC Number** | **Name**         | **Description**                      |
| -------------- | ---------------- | ------------------------------------ |
| **1772**       | *边界网关协议在互联网中的应用* | 提供了关于BGP运行以及如何在互联网上应用和使用BGP的额外概念性信息。 |
| **1773**       | *使用BGP-4协议的经验*   | 该文件有时被认为是RFC 1771的配套文件，其对定义了BGP-4。   |
| **1774**       | *BGP-4协议分析*      | 提供关于BGP-4协议运行的更详细的技术信息。              |

<u>**BGP的功能和特点概述**</u>

如果要用一句话来概括BGP的工作，那就是 "在自治系统之间交换网络可达性信息，并根据这些信息确定网络的路由"。在一个典型的国际网络中（以及在互联网中），每个自治系统都指定了一个或多个运行BGP软件的路由器。每个自治系统中的BGP路由器都与一个或多个其他自治系统中的路由器相连。每个BGP都在一组路由信息库（RIB）中存储有关网络和通往这些网络的路由的信息。这些路由信息在BGP路由器之间交换，并在整个国际网络中传播，使每个AS都能找到通往其他AS的路径，从而实现整个国际网络的路由。

**关键概念:** 现代TCP/IP网络中使用的外部路由协议是边界网关协议（BGP）。BGP最初是在20世纪80年代末开发的，作为EGP的继承者，BGP已经过多次修订；目前的版本是4，所以BGP也通常被称为BGP-4。BGP的主要功能是在自治系统之间交换网络可达性信息，以使互联网上的每个自治系统都能有效地向其他每个自治系统发送消息。

BGP支持任意的AS拓扑结构，即它们可以以任何方式连接。一个AS必须至少有一个运行BGP的路由器，但可以超过一个。也可以使用BGP在同一自治系统内的BGP路由器之间进行通信。

BGP使用一个相当复杂的系统来确定路由。该协议超越了像RIP等距离矢量算法那样只考虑网络的下一跳的有限概念。相反，BGP路由器存储了关于从它自己到网络的路径（自治系统序列）的更完整信息。特殊的路径属性描述了路径的特性，并在路由选择过程中使用。由于BGP不仅存储了下一跳，还存储了路径信息，因此有时被称为路径向量协议。

BGP使用确定的算法选择路由，评估路径属性并选择有效的路由，同时避免路由器循环和其他问题状况。BGP路由器对路由的选择也可以通过一套BGP策略来控制，例如，指定一个AS是否愿意承载来自其他AS的流量。但是，BGP不能保证到任何目的地的最有效的路由，因为它不能知道每个AS内部的情况，因此不能知道穿越每个AS的成本是多少。

BGP的运行是基于执行不同功能的消息的交换。BGP路由器使用开放消息与相邻的路由器联系并建立BGP会话。它们交换Update消息来交流可达网络的信息，只在需要时发送部分信息。它们还使用Keepalive和Notification消息来维护会话，并通知对等体的错误情况。这些消息的使用在BGP一般操作专题中进行了总结，详细内容（包括消息格式）在详细操作部分。

BGP使用TCP作为可靠的传输协议，因此它可以利用该协议的许多连接建立和维护功能。这也意味着BGP不需要担心消息排序、确认或传输丢失等问题。由于未经授权的BGP消息可能会对互联网的运行造成破坏，因此BGP包括一个用于安全的认证方案。

**关键概念。**BGP支持自治系统的任意拓扑结构。每个使用BGP的自治系统都会指定一个或多个路由器来执行该协议。然后，这些设备交换消息以建立彼此之间的联系，并使用TCP分享关于通过国际网络的速率的信息。BGP采用了复杂的路径向量路由计算算法，从描述如何到达不同网络的路径属性中确定路由。

**注**：BGP与较早的外部路由协议EGP保持向后兼容。

###### 3.4.3.1-1-2 BGP拓扑结构、通告、边界路由器和邻居关系（内部和外部同行）（部分：1 2 )

在我对BGP的概述中，我将边界网关协议（BGP）的功能归纳为：在路由器和网络的自治系统（AS）之间交换网络可达性信息，并根据这些信息确定路由。然而，BGP用来完成这一任务的实际方法是相当复杂的。为了帮助我们理解BGP的工作原理，我们应该先看看BGP网络的结构，以及对BGP关键术语的讨论。

<u>**BGP拓扑结构和发言人**</u>
BGP最重要的特点之一是其灵活性。该协议可以使用任意的拓扑结构将任何自治系统的网络连接起来。唯一的要求是，每个AS至少有一台能够运行BGP的路由器，并且该路由器至少要连接到另一个AS的BGP路由器。除此之外，就像他们说的那样，"天空是无限的"。BGP可以处理以全网状拓扑结构连接的一组AS（每个AS对另一个AS）、部分网状结构、一个连接一个的AS链，或任何其他配置。它还可以处理随着时间推移可能发生的拓扑结构的变化。

BGP的另一个重要假设是，它对AS内部发生的事情一无所知。这当然是AS是自治的概念的一个重要前提--它有自己的内部拓扑结构，并使用自己选择的路由协议来确定路由。BGP只接受AS传达给它的信息并与其他AS共享。

创建BGP内部网络，首先要指定每个AS中的某些路由器来运行该协议。在BGP术语中，这些人被称为BGP发言人，因为他们讲BGP "语言"。一个协议可以合理地被称为一种语言，但我在其他协议中没有遇到过 "发言人 "这个概念，所以这个术语有点意思。

<u>**BGP路由器的角色和邻居**</u>
一个自治系统可以包含许多路由器，它们以任意的拓扑结构连接。我们可以区分AS中只与AS内其他路由器连接的路由器和与其他AS连接的路由器。前一组的路由器通常被称为内部路由器，而后一组的路由器在BGP中被称为边界路由器，在其他协议中也有类似名称。例如，在OSPF中，它们被称为边界路由器。

当然，边界的概念是BGP协议本身名称的基础。为了实际创建BGP网，每个AS边界的BGP扬声器与其他AS中的一个或多个BGP扬声器进行物理连接，具体拓扑结构由网路设计师决定。当一个AS的BGP发言人与另一个AS的BGP发言人相连时，他们被视为邻居。他们之间的直接连接使他们能够交换有关他们所属AS的信息。

**BGP内部和外部对等体**

大多数BGP发言人将与一个以上的其他发言人连接。这既提供了通往不同网络的更多直接路径的更大效率，也提供了允许互联网应对设备或连接故障的冗余性。BGP发言人有可能（而且在很多情况下有可能）与本AS内和本AS外的其他BGP发言人建立邻居关系。AS内的邻居被称为内部对等体，而AS外的邻居是外部对等体。内部对等体之间的BGP有时被称为内部BGP（IBGP），而在外部对等体之间使用该协议是外部BGP（EBGP）。两者相似，但在某些方面有所不同，特别是路径属性和路由选择。你可以在图191中看到一个BGP拓扑结构的例子以及内部和外部对等体的指定。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\bgptopology.png)

​                                                             **图191: BGP拓扑结构和指定的例子**

该图是图171的一个变体，显示了BGP用来指代不同类型的路由器和自治系统的名称。内部路由器显示为蓝色，而边界路由器为红色。在AS内通信的BGP发言人是内部对等体，而在AS之间通信的是外部对等体。这个高度简化的国际网络显示了两个存根AS，它们都只连接到多宿主AS #2。

**关键概念。**每个被配置为使用BGP的路由器被称为BGP发言人；这些设备使用BGP消息系统交换路由信息。只与同一自治系统中的其他路由器连接的路由器称为内部路由器，而与其他AS连接的路由器称为边界路由器。同一AS中相邻的BGP发言人被称为内部对等体，而不同AS中的对等体是外部对等体。

BGP发言人之间的对等连接可以是使用某种形式的二层技术的直接链接，也可以是使用TCP的间接链接。这允许BGP发言人建立BGP会话，然后使用我们将在本节后面看到的消息传递系统交换路由信息。当然，它也是实际的 "最终用户 "流量在自治系统之间移动的手段。外部对等体通常是直接连接的，而内部对等体往往是间接连接的。

在下一个主题中，我们将看到AS的连接方式对互联网的整体功能以及流量的传输方式有重要影响。

###### 3.4.3.1-1-3 BGP自治系统类型、流量和路由策略（部分：1 2 3）

当我们把自治系统（AS）连接在一起形成一个国际网络时，AS边界路由器之间的路径形成了信息从一个AS到另一个AS的通道。仔细控制AS之间的信息流是非常重要的。根据情况，我们可能希望限制甚至禁止某些类型的消息进入或来自某个AS。这些决定又会对BGP路由确定产生直接影响。

<u>**BGP流量和流量类型**</u>
国际网络中的消息流有时被统称为流量。这个术语是一个很好的比喻，因为我们可以把BGP网络中的流量控制问题与城市街道上的流量控制问题相提并论。你可能在过去看到过住宅街道上的标志，上面写着 "禁止通行 "或 "仅限本地交通"。这些都是为了控制这些街道上的交通流。一个更极端的例子是我以前住的地方的一条街道，在那里，有人故意在中间竖起路障，把一条繁忙的通街变成一对死胡同。同样，其目的是控制交通。

这些措施突出了本地流量和通过流量之间的关键区别。这种分类方法在BGP中也很重要。

- 本地流量。在一个自治系统内传输的流量，要么源自同一自治系统，要么打算在该自治系统内交付。这就像街道上的本地交通。

- 转运流量。在该AS之外产生并打算在该AS之外交付的流量。这就像我们通常所说的街道上的过境流量。

<u>**BGP自治系统类型**</u>
在上一主题中，我们讨论了AS中内部路由器和边界（或边境）路由器之间的区别。如果我们看一下整个BGP内部网络，我们可以根据不同类型的AS在整个BGP拓扑中的相互连接方式，对它们进行类似的区分。主要有两种类型的AS。

- 存根AS：这是一个只与另一个AS相连的AS。它相当于我们道路比喻中的死胡同（死胡同）；通常，只有来自或去往该街道上的房屋的车辆才会在该街道上出现。

- Multihomed AS：这是一个连接到两个或更多其他AS的AS。它相当于我们道路类比中的一条通街，因为汽车有可能进入这条街并通过它，而不在这条街上的任何房子里停留。

在图191的BGP网络示例中，我将AS #2中的边界路由器与AS #1和AS #3相连。虽然来自AS #2的流量可以流向或来自AS #1和AS #3，但来自AS #1的流量也可能流向AS #3，反之亦然。AS #2充当这些数据报的 "直通车"。

<u>**BGP自治系统路由策略**</u>

BGP对流量类型和AS类型进行区分的原因与在街道上进行区分的原因相同：许多人对直通车的看法很模糊。在一个社区中，每个人都希望能够从自己的家到城市中需要去的任何地方，但他们不希望有很多其他人使用他们的街道。同样，每个自治系统都必须使用至少一个其他自治系统来与远处的自治系统进行通信，但许多自治系统对成为大量外部流量的通道并不热心。

这种不情愿的态度在很多情况下确实是有道理的，无论是在街区还是在BGP的情况下。在居民区的街道上有大量的汽车和卡车，在很多方面都是一个问题：安全问题、道路磨损、污染等等。同样，如果一个多宿主AS被迫承载其他AS想发给它的所有过境流量，它可能会变得过载。

为了控制过境流量的承载，BGP允许AS建立和使用路由策略。这些是管理AS如何处理过境流量的规则集。在AS决定如何处理过境流量方面存在很大的灵活性。许多选项中的一些包括。

- 无中转政策: 一个AS可以有一个完全不处理过境流量的政策。

- 限制性AS转接政策：一个AS可以允许处理来自某些AS的流量，但不允许其他AS。在这种情况下，它告诉它要处理的AS，它们可以发送流量，但不对其他AS说。

- 基于标准的过境政策: 一个AS可以使用一些不同的标准来决定是否允许过境流量。例如，它可能只在某些时间允许过境流量，或者只在它有足够的备用容量时允许过境流量。

**注：**一个愿意承载过境流量的自治系统有时被称为过境AS。

以类似的方式，可以设置策略来控制一个AS如何让其他自治系统处理自己的流量。显然，一个存根AS将始终使用它所连接的单一AS连接到整个国际网络。然而，一个多宿主的AS可能有一些政策，通过指定在什么条件下应该使用一个AS而不是另一个AS来影响路由选择。这些政策可能是基于安全（如果一个连接的AS被认为比另一个更安全）、性能（一个AS比另一个快）、可靠性或其他因素的考虑。

<u>**路由策略和网络设计的问题**</u>

如果一个城市的每条街道都只允许本地交通，会发生什么？这将是非常困难的事情。当然，这个问题在设计良好的城市中从未发生过，因为交通规划者了解住宅区的连接性和避免直通车的双重需要。城市是以某种等级方式布局的，因此本地交通 "漏斗 "到专门用于承载非本地交通的大道上。

同样的基本情况也存在于国际网络中。如果每个AS都宣布它对承载过境流量不感兴趣，那么它就不能很好地工作了。通常，国际网络的设计是为了让某些自治系统承载大量的过境流量。这通常是高速、高容量骨干网的功能，它为其他AS的客户提供服务。一个自治系统通常只在安排好的情况下承载另一个自治系统的流量。

关键概念。BGP的一个重要问题是如何处理自治系统之间的流量。BGP网络中的每个自治系统，如果只与一个其他自治系统相连，则是一个存根自治系统，如果与两个或更多其他自治系统相连，则是一个多宿主自治系统。BGP允许多宿主AS的管理员建立路由策略，指定该AS在什么条件下愿意处理过境流量（通过AS发送的消息，其源头和目的地都在该AS之外。）

###### 3.4.3.1-1-4 BGP路由存储和广告，以及BGP路由信息库（RIB）（部分：1 2）

边界网关协议的工作是促进BGP设备之间的路由信息交换，以便每个路由器能够确定通往IP网中每个网络的有效路由。这意味着路由的描述是BGP设备工作的关键数据。每个BGP发言人都负责根据BGP标准中确立的具体准则来管理路由描述。

<u>**BGP路由信息管理功能**</u>
从概念上讲，可以认为路由信息管理的整体活动包含四个主要任务。

- 路由存储。每个BGP都在一组特殊的数据库中存储关于如何到达网络的信息。它还使用数据库来保存从其他设备收到的路由信息。

- 路由更新：当BGP设备收到来自其一个对等体的更新时，它必须决定如何使用这些信息。应用特殊的技术来决定何时以及如何使用从对等体收到的信息，以正确地更新设备的路由知识。

- 路由选择。每个BGP都使用其路由数据库中的信息来选择通往国际网络中每个网络的良好路由。

- 路由通告。每个BGP发言人定期告诉其对等者它对各种网络的了解以及到达这些网络的方法。这被称为路由广告，通过BGP更新消息来完成。我们将在接下来的几个主题中进一步了解这些消息，并在关于BGP消息格式的详细章节中详细研究这些消息。

<u>**BGP路由信息库(RIB)**</u>

BGP的路由信息管理和处理系统的核心是存储路由的数据库。该数据库统称为路由信息库(RIB)，但它实际上并不是一个整体。它由三个单独的部分组成，由BGP发言人用来处理路由信息的输入和输出。其中两个部分本身由几个单独的部分或副本组成。

三个章节部分(使用BGP标准赋予它们的神秘名称，抱歉！)。包括：

- Adj-ribs-in：保存从对等BGP说话者接收的有关路由的信息的一组输入数据库部分。
- 本地-RIB：当本地的RIB    。这是存储由该BGP设备选择并被认为对其有效的路由的核心数据库。
- Adj-ribs-out：一组输出数库部分，保存有关此BGP设备已选择要传播给其对等设备的路由的信息。

因此，RIB可以被视为单个数据库，也可以被视为一组相关数据库，具体取决于您如何看待它。(上面的划分本质上是概念性的；整个RIB可以实现为具有代表不同组件的内部结构的单个数据库，也可以实现为单独的数据库。)。

RIB是一种相当复杂的数据结构，这不仅是因为这种多段结构，还因为BGP设备存储的关于路由的信息比更简单的路由协议要多得多。路由在BGP中也称为路径，其详细描述以特殊的BGP路径属性的形式存储。

RIB的三个部分是BGP发言人管理信息流的机制。从对等BGP说话者发送的更新消息接收的数据保存在Adj-RIB-In中，每个Adj-RIB-In保存来自一个对等体的输入。然后对这些数据进行分析，并选择其中的适当部分来更新Loc-RIB，该Loc-RIB是该BGP发言人正在使用的路线的主要数据库。在常规基础上，来自Loc-RIB的信息被放置到Adj-RIB-Out中，以使用更新消息发送给其他对等体。该信息流作为称为BGP决策过程的路由更新、选择和通告系统的一部分来完成。

**关键概念：**BGP的常规操作需要BGP发言人存储、更新、选择和通告路由信息。用于此目的的中心数据结构是BGP路由信息库(RIB)。RIB实际上由三个部分组成：一组输入数据库(ADJ-RIB-In)，用于保存从对等方接收的路由信息；一个本地数据库(Loc-RIB)，用于包含路由器的当前路由；以及一组输出数据库(ADJ-RIB-OUT)，由路由器用来将其路由信息发送到其他路由器。

###### 3.4.3.1-1-5 BGP路径属性和算法概述（部分：1 2 3）

使用距离矢量算法的路由协议，如RIP，相对简单，这在很大程度上是因为每个设备存储的关于每个路由的信息本身就很简单。每个路由器只知道它可以通过一个特定的下一跳路由器以特定的成本到达一个网络。它不知道数据包到达任何这些网络所要走的路线。这种知识水平根本无法满足BGP等协议的需要。

<u>**BGP的路径矢量路由算法和路径属性**</u>
为了在任意的自治系统拓扑结构中处理高效、非循环路由的计算，我们需要知道的不仅仅是 "为了到达网络N7，向路由器R4发送"；我们还需要对自己和网络N7之间的整个路径的特性有一定的了解。通过存储这些额外的信息，就有可能利用路由器和网络之间的整个路径的知识，对如何计算和改变路由做出决定。

因此，在BGP中，BGP设备不是以目的地和到该目的地的距离来宣传网络，而是以目的地地址和到达这些目的地的路径描述来宣传网络。这意味着BGP使用的不是距离矢量算法，而是路径矢量算法。可达网络的每次通信都提供了关于通往目的地的整个路由器序列的大量信息。由于包含了拓扑信息，路径矢量协议有时被描述为距离矢量和链路状态算法的结合。然而，这并没有真正做到公正，因为它们的功能与这些算法类型中的任何一种都不相同。

在网络上。如果你对有关路径向量算法的其他一般信息感兴趣，你可以在RFC 1322《域间路由的统一方法》中找到一些。警告：请勿在操作重型机械前阅读。J

每个路由的路径信息以BGP路径属性的形式存储在每个BGP发言人的路由信息库（RIB）中。当BGP设备发出更新消息时，这些属性被用来向网络公布路由。路径属性的存储、处理、发送和接收是路由器决定如何创建路由的 "方法"，因此理解它们显然相当重要。

有几个不同的路径属性，每个属性都描述了路由的一个特定特征。属性根据其重要程度和旨在管理其传播的具体规则被分为不同的类别。最重要的路径属性被称为众所周知的属性；每个BGP发言人都必须识别和处理这些属性，但只有一些属性需要与每条路由一起发送。其他属性是可选的，可以实施也可以不实施。这些属性根据不认识它们的设备收到它们时的处理方式进一步区分。

<u>**BGP路径属性的分类**</u>

路径属性的四个正式分类是。

- 知名的强制性。这些是最重要的路径属性；它们必须包含在更新消息中的每个路由描述中，并且必须由接收它们的每个BGP设备处理。

- 知名的不确定的（Well-Known Discretionary）。BGP设备在收到这些路径属性时必须予以识别，但它们可能会也可能不会被包含在更新消息中。因此，它们对信息发送方来说是可选的，但对接收方来说是必须处理的。

- 可选的过渡性。这些路径属性可以被BGP路由器识别，并可以包含在更新消息中。在发布路由时，它们必须被传递给其他BGP发言人，即使被不认识该属性的设备收到。

- 可选非递归。可选的属性，可能被BGP设备识别，并可能被包含在更新消息中。如果被不认识该属性的设备收到，则会被丢弃，不会传递给下一个路由器。

**注意**：正如你所想象的，所有众所周知的属性在定义上都是传递性的--它们必须从一个BGP发言人传递到下一个发言人。

**关键概念:** 较简单的路由协议只存储关于如何到达某个网络的有限信息，如成本和到达该网络的下一跳，而BGP则不同，它存储关于通往各种网络的完整路由的详细信息。这些信息以路径属性的形式出现，描述了通过AS连接路由器和目标网络的路径（路由）的各种特征。

<u>**BGP路径属性特性**</u>

表135包含了用于描述到目的地的路由的每个最常见的BGP路径属性的特征摘要，以及在BGP更新消息中分配给每个属性的属性类型代码。

​                                                                                **表135: BGP路径属性概要**

| **BGP Path Attribute**       | **Classification**                  | ***Attribute Type\* Value** | **Description**                                                                                                                                                          |
| ---------------------------- | ----------------------------------- | --------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| ***Origin\***                | Well-Known Mandatory知名的强制性          | 1                           | 指定路径信息的来源。这个属性表示该路径最初是来自内部路由协议、较早的外部路由协议EGP，还是其他来源。                                                                                                                      |
| ***AS_Path\***               | Well-Known Mandatory                | 2                           | 一个自治系统号码的列表，描述了这个路由描述所经过的AS的序列。这是一个极其重要的属性，因为它包含了自治系统到网络的实际路径。它被用来计算路由和检测路由循环。                                                                                           |
| ***Next_Hop\***              | Well-Known Mandatory                | 3                           | 用来到达该目的地的下一跳路由器。                                                                                                                                                         |
| ***Multi_Exit_Disc (MED)\*** | Optional Non-Transitive可可选非递归。可选的属性 | 4                           | 当一个路径包括通往AS的多个出口或入口点时，这个值可以作为一个指标来区分它们（也就是说，选择一个出口或入口点而不是其他的）。                                                                                                           |
| ***Local_Pref\***            | Well-Known Discretionary知名的不确定的     | 5                           | 在同一AS的BGP发言人之间的通信中使用，表示对某一特定路由的偏好程度。                                                                                                                                     |
| ***Atomic_Aggregate\***      | Well-Known Discretionary知名的不确定的     | 6                           | 在某些情况下，BGP发言人可能会收到一组重叠的路由，其中一条比另一条更具体。例如，考虑一个到网络34.15.67.0/24和到网络34.15.67.0/26的路由。后者是前者的一个子集，这使得它更具体。如果BGP发言人使用了不太具体的路由（在这种情况下，34.15.67.0/24），它就会把这个路径属性设置为1的值，以表示这已经完成。 |
| ***Aggregator\***            | Optional Transitive可选的过渡性           | 7                           | 包含执行路由聚合的路由器的AS号和BGP ID；用于故障排除。                                                                                                                                          |

这些路径属性中，有些是直接理解的；有些则相当隐晦，可能令人困惑。深入研究路径属性的任何细节都会使我们进入对详细的AS间路线计算的全面描述。我们将在下一个主题中对其进行一定程度的研究。

关于用于通信路径属性的消息格式的全部细节，请参阅BGP更新消息的格式。

**关键概念:** 较简单的路由协议只存储关于如何到达某个网络的有限信息，如成本和到达该网络的下一跳，而BGP则不同，它存储关于通往各种网络的完整路由的详细信息。这些信息以路径属性的形式出现，描述了通过AS连接路由器和目标网络的路径（路由）的各种特征。

###### 3.4.3.1-1-6 BGP路线确定和BGP决策过程（部分：1 2 3）

上两个主题已经描述了BGP设备如何存储和管理网络路由信息的基本原理。这包括概述了BGP发言人进行的四种路由信息管理活动：路由存储、更新、选择和通告。路由存储是每个BGP扬声器中的路由信息库（RIB）的功能。路径属性是BGP存储路由细节的机制，同时也向BGP对等体描述这些细节。

<u>**BGP决策过程的各个阶段**</u>
正如我们所看到的，RIB还包含一些部分，用于保存从BGP对等体收到的输入信息，以及保存每个BGP设备想要发送给这些对等体的输出信息。路由更新、选择和广告的功能涉及分析这些输入信息，决定在本地数据库中包括什么，更新该数据库，然后选择从数据库中向对等设备发送什么路由。在BGP中，一个称为决策过程的机制负责这些任务。它由三个总体阶段组成。

- 第1阶段：对从相邻AS的BGP发言人处收到的每条路由进行分析，并分配一个偏好级别。然后根据偏好对路由进行排序，并将每个网络的最佳路由公布给自治系统内的其他BGP发言人。

- 第二阶段：根据偏好等级从传入的数据中选择每个目的地的最佳路由，并用于更新本地路由信息库（Loc-RIB）。

- 第3阶段：选择Loc-RIB中的路由，将其发送给其他AS中的相邻BGP发言人。

<u>**为路由分配首选项的标准**</u>

显然，如果BGP发言人只知道一条通往某个网络的路由，它就会安装并使用该路由（假设它没有问题）。只有当BGP发言人收到一条以上的特定网络的路由时，分配路由的优先权才变得重要。优先权可以根据一些不同的标准来确定。一些典型的标准包括。

- 路由器和网络之间的自治系统的数量（通常越少越好）。

- 某些政策的存在可能使某些路由无法使用；例如，一个路由可能通过一个AS，而这个AS不愿意信任其数据。

- 路径的来源--也就是它来自哪里。

在一组通往同一网络的路由都被计算为具有相同的优先权的情况下，一个 "打破平局 "的方案被用来从它们中选择。额外的逻辑被用来处理特殊情况，比如网络重叠的情况（参见Atomic_Aggregate路径属性的描述，了解这方面的例子）。

在第三阶段，选择路由以传播给其他路由器是基于一个相当复杂的算法，我在这里无法公正地描述。路由通告是由我们在本节前面讨论的路由策略指导的。与外部对等体相比，不同的规则被用来选择向内部对等体发布的路由。

**关键概念:** BGP发言人用来决定接受哪些来自其对等体的新路由以及向其公布哪些路由的方法称为BGP决策过程。它是一种复杂的算法，分为三个阶段，涉及根据预先存在的和传入的路径信息计算最佳路由。

<u>**BGP选择高效路由的能力的局限性**</u>

在考虑路由选择过程时，记住BGP是一个在自主系统间运行的路由协议，这一点非常重要。因此，路由是在AS之间选择的，而不是在AS内单个路由器的层面上选择的。因此，例如，当BGP存储到一个网络的路径信息时，它是以自治系统的序列来存储的，而不是以特定路由器的序列来存储的。BGP不能处理AS中的单个路由器，因为根据定义，AS中发生的细节应该是对外界 "隐藏 "的。它不知道自己以外的AS的结构。

然而，这对BGP选择路由的方式有重要影响。BGP不能保证它将选择到每个网络的最快、最低成本的路由。它可以选择一条使自己与某个网络之间的AS数量最小化的路由，但当然，AS并不都是一样的。一些ASes很大，由许多慢速链接组成，而另一些ASes则很小，速度很快。选择一条通过后一类AS的路由将比选择一条通过前一类AS的路由要好，但BGP不能知道这一点。政策可以在一定程度上影响AS的选择，但一般来说，由于BGP不知道AS中发生了什么，所以它不能保证路由的整体效率。(顺带一提，这也是BGP中没有一般 "成本 "或 "距离 "路径属性的原因）。

**关键概念:** 作为一个外部路由协议，BGP在自治系统层面上运行。它的路由是根据AS之间的路径计算的，而不是单个路由器。根据定义，BGP不知道AS中路由器的内部结构，因此它无法确定发送数据报的成本。这又意味着BGP不能总是保证在任何两个网络之间选择绝对最低成本的路由。

<u>**发起新的路由和撤回不可达的路由**</u>
当然，存在一种设施，允许BGP发言人向网络发起新的路由。BGP发言人可以从其直接连接的AS上的内部路由协议中获得关于新路由的知识，并选择与其他AS分享这一信息。它将在其RIB中为该网络创建一个新条目，然后将有关信息发送给其他BGP同伴。

BGP还包括一种机制，不仅可以公布它能到达的路由，也可以公布它不能到达的路由。后者被称为不可行的或已撤销的路由，并在更新消息中提到，以表明路由器不再能够到达特定的网络。

###### 3.4.3.1-1-7 BGP的一般操作和消息传递 (Parts: 1 2 )

在前面的主题中，我们看到了BGP是如何存储路由信息并利用它来确定通往各种网络的路径的。现在让我们高屋建瓴地了解一下BGP的总体运行情况。与本指南中涉及的许多其他协议一样，BGP的运行主要可以用消息传递的形式来描述。消息的使用是BGP对等体之间交流路由信息的手段。这最终使得如何到达网络的知识在整个互联网上传播。

<u>**发言人的指定和连接的建立**</u>
在消息传递开始之前，必须指定BGP发言人，然后将其连接起来。BGP标准没有规定如何确定相邻的发言人，这必须在协议之外完成。一旦完成，AS就被连接成一个支持BGP的网络。拓扑连接提供了物理连接和数据报在AS之间流动的方法。这时，舞池已经准备好了，但没有人跳舞；BGP可以运行，但还没有投入使用。

BGP的运行始于BGP对等体形成一个传输协议连接。BGP使用TCP作为其可靠的传输层，因此两个BGP发言人建立一个TCP会话，在随后的消息交换过程中保持不变。完成这些工作后，每个BGP发言人都会发送一个BGP开放消息。这个消息就像一个 "跳舞的邀请"，并开始在设备之间建立BGP链接的过程。在该报文中，每个路由器都要识别自己和自己的自治系统，并告诉其对等体它想在链接中使用什么参数。这包括认证参数的交换。假设每个设备都认为其对等体的开放消息的内容可以接受，那么它就用Keepalive消息来确认，BGP会话开始。

在正常情况下，大多数BGP发言人会与其他一个以上的BGP发言人同时保持会话，包括在自己的AS内和AS外。AS之间的链接当然是使BGP路由器能够学习如何通过国际网络进行路由。AS内的链接对于确保AS内的每个BGP发言人保持一致的信息非常重要。

<u>**路线信息交换**</u>

假设链接已被初始化，两个对等体开始不断地告诉对方他们所知道的网络和如何到达这些网络。每个BGP发言人将其路由信息库（RIB）中的信息编码为BGP更新消息。这些消息包含已知网络地址的列表，以及以路径属性形式描述的通往各种网络的路径信息。这些信息随后被用于前述主题中描述的路由确定。

当两个对等体之间首次建立链接时，它们通过交换完整的路由表来确保每个路由器都持有完整的信息。随后，更新消息被发送，其中只包含关于路线变化的增量更新。只在需要时交换更新信息，减少了网络上不必要的带宽，使BGP比定期发送完整的路由表信息更有效率。

<u>**连接性维护**</u>
BGP发言人之间的TCP会话可以保持很长时间的开放，但只有在路由发生变化时才需要发送更新，而这种变化通常是不频繁的。这意味着更新信息的传输可能会间隔很多秒。为了确保对等体之间保持联系，它们都会在没有其他信息要发送时定期发送Keepalive消息。这些是空信息，不包含数据，只是告诉对等设备 "我还在这里"。这些消息的发送频率不高--不超过每秒一次，但定期发送，使对等设备不会认为会话被中断。

<u>**错误报告**</u>
BGP消息的最后一种类型是BGP通知消息。这是一个错误消息；它告诉对等体发生了问题并描述了错误情况的性质。发送BGP通知消息后，发送消息的设备将终止对等体之间的BGP连接。然后需要协商一个新的连接，可能在导致通知的问题被纠正之后。

**关键概念**。BGP是通过BGP发言人之间交换四种不同的消息类型来实现的。一个BGP会话的开始是在两个路由器之间建立TCP连接，并各自向对方发送一个开放消息。BGP更新消息是设备之间交换路由信息的主要机制。小型的BGP Keepalive消息用于维持设备之间需要交换信息时的通信。最后，通知消息用于报告问题。

关于四种BGP消息类型的更多细节以及每种消息使用的格式描述，请参考详细的BGP操作部分。

###### 3.4.3.1-2 BGP详细的消息传递、操作和消息格式

上一节介绍了边界网关协议（BGP）的概念和一般操作。为了更好地了解BGP的具体工作方式，深入了解其四种不同的消息类型以及它们的使用方式是很有帮助的。当我们这样做时，我们可以检查每个消息类型中的字段，以帮助我们不仅理解完成消息传递的方式，而且理解路由数据的实际通信方式。

在这一节中，我通过提供BGP消息类型、如何使用它们以及它们所包含的数据元素的细节，对BGP发言人之间的通信进行了全面描述。我首先描述了BGP消息生成和传输的共同属性，以及所有BGP消息使用的一般格式。然后，我对四种BGP消息类型分别进行了详细描述。Open、Update、Keepalive和Notification消息。

**背景信息。**如果你还没有这样做，你应该阅读关于一般BGP操作和消息传递的高级描述，它显示了这些消息是如何结合在一起的。

###### 3.4.3.1-2-1 BGP消息的生成和传输，以及一般消息格式（部分：1 2 3）

运行BGP的每个路由器都会生成消息来实现协议的各种功能。其中一些消息是由BGP软件在其正常运行过程中定期创建的。这些消息一般由定时器控制，这些定时器被设置并倒计时，以使它们被发送。其他消息是为了响应从BGP对等体收到的消息而发送的，可能是在一个处理步骤之后。

<u>**BGP消息传输**</u>
BGP与其他大多数路由协议不同，因为它从一开始就被设计为使用可靠的消息传输方法来运行。传输控制协议（TCP）存在于每个IP路由器的软件中，因此它是TCP/IP互联网中可靠数据通信的明显选择，而这正是BGP所使用的。路由协议通常被认为是第三层的一部分，但这个协议是在第四层协议上运行的，这使得BGP成为一个很好的例子，说明为什么架构模型最好只作为一个指导原则使用。

TCP为BGP提供了许多优势，它负责会话设置和管理的大部分细节，使BGP能够专注于它需要发送的数据。TCP负责会话的建立和协商，确保消息被接收和确认、流量控制、拥塞处理和任何必要的丢失消息的重传。BGP使用著名的TCP 179端口进行连接。

<u>**BGP的一般消息格式**</u>

TCP的使用对BGP消息的结构方式也有有趣的影响。当你看BGP消息格式时，有一点很突出（我们很快就会看到），那就是BGP消息的字节数可以是奇数的。大多数路由协议的大小是以4或8字节为单位的，但由于TCP以八进制流的形式发送数据，所以BGP消息没有必要在32位或64位边界上断开。另一个影响是需要一个特殊的Marker字段，以帮助确保BGP报文在TCP流中能够相互区分（关于这一点，稍后再谈）。

与大多数消息传递协议一样，BGP对其四种消息类型中的每一种都使用一种通用的消息格式。每条BGP消息在概念上分为报头和正文（在BGP标准中称为数据部分）。报头有三个字段，长度固定为19字节。主体的长度是可变的，事实上在Keepalive消息中完全省略，因为不需要它。

所有BGP消息类型的一般格式见表136和图192。

​                                                                           **表136：BGP通用消息格式**

| **Field Name**                     | **Size (bytes)** | **Description**                                                                          |
| ---------------------------------- | ---------------- | ---------------------------------------------------------------------------------------- |
| ***Marker\***                      | 16               | ***Marker:\*** 标记。每个BGP报文开始时的这个大字段，用于同步和认证。                                              |
| ***Length\***                      | 2                | ***Length:\*** 长度。消息的总长度，以字节为单位，包括报头的字段。对于Keepalive报文，该字段的最小值是19；它可能高达4,096。             |
| ***Type\***                        | 1                | ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\aa1fe415 (1).png) |
| ***Message Body / Data Portion\*** | Variable         | ***Message Body / Data Portion:\*** 信息主体/数据部分。包含用于实现每种消息类型的特定字段，用于开放、更新和通知消息。            |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\bgpgeneralformat.png)

​                                                                          **图192：BGP一般消息格式**

<u>**标记字段、消息同步和认证**</u>

Marker字段是BGP报文格式中最有趣的字段，如表中所述，它用于同步和认证。BGP使用一个TCP会话来连续发送许多消息。TCP是一个面向流的传输协议，它只是在链路上发送字节，而不知道这些字节代表什么。这意味着使用TCP的协议负责决定数据单元之间的界线，在这种情况下就是BGP消息。

通常情况下，Length字段会告诉每个BGP设备在一条消息的结束和下一条消息的开始之间划线的位置。但是，由于各种原因，设备可能会失去对消息边界位置的跟踪。标记字段被填入一个可识别的图案，清楚地标明每个消息的开始，以保持BGP对等体的同步。

在建立BGP连接之前，Marker字段只是填满了所有的1。因此，这就是用于Open消息的模式。一旦BGP会话协商完成，如果两个设备之间就认证方法达成协议，Marker字段就会承担认证的额外作用。BGP设备不再寻找包含所有1的Marker，而是寻找使用商定的认证方法产生的模式。对该模式的检测同时使设备同步，并确保消息是真实的。

在极端情况下，BGP对等体可能无法保持同步，如果是这样，就会产生一个通知消息并关闭会话。如果启用认证时，Marker字段包含错误的数据，也会发生这种情况。

**关键概念。**所有四种BGP消息类型都使用一种通用的消息格式，其中包含三个固定的头字段--Marker、Length和Type，以及每个消息类型不同的消息体空间。大的Marker字段用于表示新BGP消息的开始，也用于促进BGP认证方法。

###### 3.4.3.1-2-2 BGP连接的建立。open 消息（部分：1 2）

在BGP会话用于交换路由信息之前，必须首先在BGP对等体之间建立连接。这个过程首先是在设备之间建立一个TCP连接。完成后，BGP设备将试图通过交换BGP开放消息来建立BGP会话。

开放消息有两个主要目的。首先是识别和启动两个设备之间的链接；它允许一个对等体告诉另一个对等体 "我是自治系统Y上名为X的BGP发言人，我想开始与你交换BGP信息"。其次是会话参数的协商。这些是进行BGP会话的条件。使用Open消息协商的一个重要参数是每个设备要使用的认证方法。BGP的重要性意味着认证是必不可少的，以避免不良信息或恶意的人破坏路由。

每个收到Open消息的BGP都会处理它。如果其内容可以接受，包括其他设备想要使用的参数，它就会用Keepalive消息作为确认来回应。每个对等体都必须发送Open消息并收到Keepalive确认，才能初始化BGP链接。如果任何一方不愿意接受 "开放 "的条款，链接就不会被建立。在这种情况下，可以发送Notification消息来传达问题的性质。

<u>**BGP open报文格式**</u>

BGP Open消息的具体格式见表137和图193。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\bgpopenformat.png)

​                                                                               **图193：BGP开放报文格式。**

​                                                                                **表137：BGP开放报文格式**

| **Field Name**              | **Size (bytes)** | **Description**                                                                                                                                                                                                                 |
| --------------------------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ***Marker\***               | 16               | ***Marker:\*** 标记。每个BGP消息开始时的这个大字段，用于同步和认证。详见BGP一般消息格式的讨论。                                                                                                                                                                      |
| ***Length\***               | 2                | ***Length:\*** 长度。消息的总长度，以字节为单位，包括报头的字段。开放消息的长度是可变的。                                                                                                                                                                            |
| ***Type\***                 | 1                | ***Type:\***类型。BGP消息的类型，开放消息的值为1。                                                                                                                                                                                               |
| ***Version\***              | 1                | ***Version:\***版本。表示Open消息的发送者使用的BGP版本。这个字段允许设备拒绝与使用它们可能无法理解的版本的设备连接。当前的值是4，表示BGP-4，被大多数（如果不是全部）当前的BGP实现所使用。                                                                                                                    |
| ***My Autonomous System\*** | 2                | ***My Autonomous System:\*** 我的自治系统。识别Open消息发送方的自治系统号码。AS号码在整个互联网上集中管理，其方式类似于IP地址的管理方式。                                                                                                                                         |
| ***Hold Time\***            | 2                | ***Hold Time:\***保持时间：该设备建议用于BGP保持计时器的秒数，它规定了BGP对等体在收到BGP消息之间允许连接保持沉默的时间。如果BGP设备不喜欢其对等体建议的值，可以拒绝连接；但是，通常两个设备会同意使用每个设备建议的较小值。 该值必须至少是3秒，或者是0。如果是0，则表示不使用保持定时器。关于如何使用保持定时器的更多信息，请参见Keepalive消息的讨论。                                |
| ***BGP Identifier\***       | 4                | ***BGP Identifier:\*** BGP标识符。识别特定的BGP发言人。回顾一下，IP地址与接口有关，而不是与设备有关，因此每个路由器至少有两个IP地址。通常情况下，BGP标识符被选为其中一个地址。一旦选定，这个标识符将用于与BGP对等体的所有BGP通信。这包括选择标识符的接口上的BGP对等者，也包括其他接口上的BGP对等者。因此，如果一个有两个接口的BGP发言人有IP1和IP2地址，它将选择一个作为其标识符并在其两个接口上使用。 |
| ***Opt Parm Len\***         | 1                | ***Optional Parameters Length:\*** 可选参数长度。用于可选参数的字节数（见下文）。如果为0，则该信息中没有可选参数。                                                                                                                                                     |
| ***Optional Parameters\***  | Variable         | ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\aa1fe611.png)                                                                                                                                            |

BGP开放消息目前只使用一个可选参数。认证信息。其参数值子字段包含一个字节的认证代码子字段，用于指定设备希望使用的认证类型。在这之后是一个可变长度的认证数据子字段。认证码规定了如何进行认证，包括认证数据字段的含义，以及计算标记字段的方式。

**关键概念:** BGP会话开始时，连接中的每个对等体向对方发送BGP开放消息。该消息的目的是在设备之间建立联系，确定消息的发送者及其自治系统，并协商决定会话如何进行的重要参数。

###### 3.4.3.1-2-3 BGP路由信息交换。更新消息 (Part: 1 2 )

一旦BGP发言人取得联系并使用开放消息建立了联系，设备就开始交换路由信息的实际过程。每个BGP路由器使用BGP决策过程来选择某些路由，并将其公布给其同伴。然后将这些信息放入BGP更新消息中，这些消息被发送到已经建立会话的每个BGP设备上。这些消息是网络可及性知识在国际网络中传播的方式。

- 每条更新消息都包含以下一项或两项内容。

- 路由广告。单个路由的特性。

路由撤消。一个不再可达的网络列表。
在一个更新信息中只能公布一个路由，但可以撤销几个。这是因为撤销一个路由很简单；它只需要被撤销的网络的地址。相反，一个路由广告需要描述一组相当复杂的路径属性，这需要占用大量的空间。(请注意，Update有可能只指定撤销的路由，而根本不发布路由广告）。

<u>**BGP更新消息格式**</u>

由于其包含的信息量以及信息的复杂性，BGP更新消息使用了所有TCP/IP中最复杂的结构之一。消息的基本结构在表138中描述，并在图194中说明。正如你在该表中看到的，有几个字段有自己的子结构。路径属性字段的属性类型子字段本身有一个复杂的子结构，我在表139中单独显示，以避免表138的负荷过重。

当你检查这个格式时，你可能会发现NLRI字段中可以有一个以上的前缀，这是令人困惑的，因为我刚才说过，一个更新信息只公布一条路由。事实上，这里没有不一致的地方。一个路由可能与一个以上的网络相关联；或者，换一种说法，多个网络可能有相同的路径和路径属性。在这种情况下，在同一个更新中指定多个网络前缀比为每个网络生成一个新的前缀更有效。

​                                                                                     **表138：BGP更新消息格式**

| **Field Name**                                | **Size (bytes)** | **Description**                                                                                         |
| --------------------------------------------- | ---------------- | ------------------------------------------------------------------------------------------------------- |
| ***Marker\***                                 | 16               | ***Marker:\*** 标记。每个BGP消息开始时的这个大字段，用于同步和认证。详见BGP一般消息格式的讨论。                                              |
| ***Length\***                                 | 2                | ***Length:\*** 长度。消息的总长度，以字节为单位，包括报头的字段。更新消息的长度是可变的。                                                    |
| ***Type\***                                   | 1                | ***Type:\*** BGP message type, value is 2 for *Update* messages.                                        |
| ***Unfeasible Routes Length\***               | 2                | ***Unfeasible Routes Length:\*** 不可行的路由长度。Withdrawn Routes字段的长度，字节数。如果是0，说明没有路由被撤回，省略Whedrawn Routes字段。 |
| ***Withdrawn Routes\***                       | Variable         | ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\aa2015af-1.png)                  |
| ***Total Path Attribute Length\***            | 2                | ***Total Path Attribute Length:\*** 总的路径属性长度。路径属性字段的长度，以字节为单位。如果是0，表示这个消息中没有公布路由，所以省略了路径属性和网络层可达性信息。    |
| ***Path Attributes\***                        | Variable         | ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\aa2015d3-2.png)                  |
| ***Network Layer Reachability Information\*** | Variable         | ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\aa2015fe-3.png)                  |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\bgpupdateformat.png)

​                                                                                       **图194: BGP更新消息格式**

该图显示了完整的BGP更新消息格式，包括一组撤销的路由、路径属性和NLRI条目。爆炸式视图显示了路径属性的属性类型子字段的子结构，如表139所述。

​                                                                              **表139：BGP更新报文属性类型子字段详情**

| **Sub-subfield Name**      | **Size (bytes)** | **Description**                                                                        |
| -------------------------- | ---------------- |:--------------------------------------------------------------------------------------:|
| ***Attribute Flags\***     | 1                | ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\aa201638-4.png) |
| ***Attribute Type Code\*** | 1                | ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\aa201668-5.png) |

**关键概念。**BGP中最重要的消息类型是更新消息，它用于在BGP设备之间发送有关路由的详细信息。它使用一个复杂的结构，允许BGP发言人有效地指定新的路由，更新现有的路由，并撤回不再有效的路由。每条消息可能包括一条现有路由的完整描述，也可能从使用多个路由的列表中撤回。

###### 3.4.3.1-2-4 BGP连接维护。Keepalive消息 (Parts: 1 2 )

一旦使用Open消息建立了BGP连接，BGP对等体最初将使用Update消息向对方发送大量的路由信息。然后，他们将进入一个例行程序，即维持BGP会话，但只在需要时发送更新消息。由于这些更新对应于路由变化，而路由变化通常并不频繁，这意味着在收到连续的更新消息之间可能会间隔很多秒。

<u>**BGP保持计时器和保持信息间隔**</u>
当一个BGP对等体在等待下一个更新消息时，它就像一个被 "搁置 "的电话一样。现在，几秒钟对我们来说可能不算什么，但对计算机来说却是很长的时间。像你一样，被搁置太久的BGP发言人可能会变得不耐烦，并开始怀疑对方是否挂断了他们的电话。计算机不会因为被搁置而生气，但它们可能会想，也许出现了问题，导致连接被中断。

为了跟踪其被搁置的时间，每个BGP设备都有一个特殊的搁置计时器。每次其对等体发送BGP消息时，该保持计时器被设置为一个初始值。然后进行倒计时，直到收到下一条消息，这时它被重置。如果保持定时器过期，则认为连接已经中断，BGP会话也终止。

保持定时器的长度是在使用Open消息进行会话设置时协商确定的。它必须至少有3秒长，或者可以协商为0值。如果为零，则不使用保持计时器；这意味着设备是 "无限耐心 "的，不关心消息之间的时间间隔是多少。

为了确保即使长时间没有更新需要发送，定时器也不会过期，每个对等体定期发送BGP Keepalive消息。这个名字说明了一切：该消息只是保持BGP连接的活力。发送Keepalive消息的速度取决于实施情况，但标准建议它们的发送间隔为保持定时器值的三分之一。因此，如果保持定时器的值为3秒，则每个对等体每秒钟发送一次Keepalive（除非它需要在该秒内发送一些其他消息类型）。为了防止过度使用带宽，Keepalive的发送频率必须不超过每秒一次，所以即使保持定时器短于三秒，这也是最小的间隔时间。

<u>**BGP Keepalive报文格式**</u>

Keepalive消息的重点是消息本身；没有任何数据可供交流。事实上，我们希望保持消息的简短和温馨。因此，它实际上是一个只包含BGP头的 "假 "消息--这是在令人难以置信的长更新消息格式之后的一个很好的变化。Keepalive消息的格式见表140和图195。

​                                                                             **表140: BGP Keepalive报文格式**

| **Field Name** | **Size (bytes)** | **Description**                                                |
| -------------- | ---------------- | -------------------------------------------------------------- |
| ***Marker\***  | 16               | ***Marker:\*** 标记。每个BGP消息开始时的这个大字段，用于同步和认证。详见BGP一般消息格式的讨论。     |
| ***Length\***  | 2                | ***Length:\*** 长度。消息的总长度，以字节为单位，包括报头的字段。Keepalive消息的长度固定为19字节。 |
| ***Type\***    | 1                | ***Type:\*** 类型。BGP消息类型，Keepalive消息的值为4。                       |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\bgpkeepaliveformat.png)

​                                                                       **图195: BGP Keepalive消息格式**

Keepalive报文还有一个特殊用途：在初始BGP会话建立过程中，作为对收到有效Open报文的确认。

**关键概念。**BGP Keepalive消息是在空闲期间定期发送的，此时不需要在连接的BGP发言人之间发送真正的信息。它们只是为了保持会话的活力，因此只包含BGP头，没有数据。

###### 3.4.3.1-2-5 BGP错误报告。通知消息 (Part: 1 2 3 )

一旦建立，BGP会话将在相当长的时间内保持开放，允许设备之间定期交换路由信息。在运行过程中，可能会出现某些错误情况，可能会干扰BGP对等体之间的正常通信。其中有些情况严重到必须终止BGP会话。当这种情况发生时，检测到错误的设备将通过发送BGP通知消息通知其对等体问题的性质，然后关闭连接。

当然，让别人告诉你 "我发现了一个错误，所以我退出了 "是没有什么价值的。因此，BGP通知消息包含一些字段，提供有关导致发送该消息的错误性质的信息。这包括一组主要的错误代码，以及其中一些错误代码中的子代码。根据错误的性质，还可能包括一个额外的数据字段以帮助诊断问题。

除了使用通知信息来传达错误的发生，这种信息类型也被用于其他目的。例如，如果两个设备不能就如何协商会话达成一致，可能会发送一个，严格来说，这不是一个错误。通知消息也被用来允许设备因与错误无关的原因而关闭BGP会话。

<u>**BGP通知消息格式**</u>

BGP通知消息的格式详见表141和图196。

​                                                                                **表141: BGP通知消息格式**

| **Field Name**       | **Size (bytes)** | **Description**                                                                                                                            |
| -------------------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------ |
| ***Marker\***        | 16               | ***Marker:\*** Marker: 每个BGP消息开始时的这个大字段，用于同步和认证。详见BGP一般消息格式的讨论。                                                                            |
| ***Length\***        | 2                | ***Length:\*** 长度：消息的总长度（以字节为单位），包括标头的字段。通知消息的长度可变。                                                                                        |
| ***Type\***          | 1                | ***Type:\*** 类型。BGP消息类型，通知消息的值为3。                                                                                                          |
| ***Error Code\***    | 1                | ***Error Code:\*** 错误代码：指定错误的一般类。表142显示了可能的错误类型，并简要描述了每种类型。                                                                                |
| ***Error Subcode\*** | 1                | ***Error Subcode:\*** 错误子代码：此字段为三个错误代码值提供更具体的错误原因指示。每个错误代码值的该字段的可能值如表143所示。                                                                |
| ***Data\***          | Variable         | ***Data:\*** 数据。这个字段包含额外的信息以帮助诊断错误；它的意义取决于在Error Code和Error Subcode字段中指定的错误类型。在大多数情况下，这个字段被填入导致错误发生的任何坏值。例如，对于 "消息头错误/坏消息类型"，坏类型字段的值被放在这里。 |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\bgpnotificationformat.png)

​                                                                                         **图196: BGP通知消息格式**

<u>**BGP通知消息的错误代码和错误子代码**</u>

表142和表143分别显示了错误代码和错误子代码字段所允许的值，从而很好地总结了Notification消息可以报告的错误类型（同时也展示了该消息类型的其他非错误用途）。

​                                                 **表142: BGP通知消息错误代码**

| ***Error Code\* Value** | **Code Name**              | **Description**                                                                                      |
| ----------------------- | -------------------------- | ---------------------------------------------------------------------------------------------------- |
| **1**                   | Message Header Error       | 检测到BGP标头的内容或长度有问题。错误子代码提供了有关问题性质的更多详细信息。                                                             |
| **2**                   | Open Message Error         | 在打开邮件的正文中发现问题。错误子类型字段更详细地描述了问题。请注意，这里包括身份验证失败或无法就参数（如保持时间）达成一致。                                      |
| **3**                   | Update Message Error       | 在更新信息的主体中发现了一个问题。同样，错误子类型提供了更多信息。许多属于这个代码的问题与在更新消息中发送的路由数据或路径属性中检测到的问题有关，因此这些消息向发送错误数据的设备提供关于这些问题的反馈 |
| **4**                   | Hold Timer Expired         | 在保持时间到期之前未收到消息。有关此计时器的详细信息，请参阅Keepalive消息的描述。                                                        |
| **5**                   | Finite State Machine Error | BGP有限状态机是指对等端上的BGP软件基于事件从一个操作状态移动到另一个操作模式的机制（有关此概念的一些背景，请参阅TCP有限状态机描述）。如果发生对等方当前所处状态的意外事件，则会生成此错误。   |
| **6**                   | Cease                      | 当BGP设备由于与其他代码描述的任何错误条件无关的原因想要断开与对等方的连接时使用。                                                           |

​                                                                     **表143：BGP通知消息错误子代码**

| **Error Type**                              | **Error Subcode Value**           | **Subcode Name**                                                                                                            | **Description**                     |
| ------------------------------------------- | --------------------------------- |:---------------------------------------------------------------------------------------------------------------------------:| ----------------------------------- |
| **Message Header Error (\*Error Code\* 1)** | **1**                             | Connection Not Synchronized                                                                                                 | 在“标记”字段中找不到预期值，表明连接已不同步。请参见标记字段的说明。 |
| **2**                                       | Bad Message Length                | The message was less than 19 bytes, greater than 4096 bytes, or not consistent with what was expected for the message type. | 消息小于19字节，大于4096字节，或者与消息类型的预期值不一致。   |
| **3**                                       | Bad Message Type                  | The *Type* field of the message contains an invalid value.                                                                  | 信息的类型字段包含一个无效的值。                    |
| **Open Message Error (\*Error Code\* 2)**   | **1**                             | Unsupported Version Number                                                                                                  | 该设备不会“说出”其对等方试图使用的版本号。              |
| **2**                                       | Bad Peer AS                       | 路由器无法识别对等方的自主系统号或不愿意与其通信。                                                                                                   |                                     |
| **3**                                       | Bad BGP Identifier                | BGP标识符字段无效。                                                                                                                 |                                     |
| **4**                                       | Unsupported Optional Parameter    | Open消息包含消息接收者无法理解的可选参数。                                                                                                     |                                     |
| **5**                                       | Authentication Failure            | 无法对Authentication Information可选参数中的数据进行身份验证。                                                                                |                                     |
| **6**                                       | Unacceptable Hold Time            | 其中一个强制的已知属性未被识别。                                                                                                            |                                     |
| **Update Message Error (\*Error Code\* 3)** | **1**                             | Malformed Attribute List                                                                                                    | 消息路径属性的总体结构不正确，或者某个属性出现了两次。         |
| **2**                                       | Unrecognized Well-Known Attribute | 其中一个强制的已知属性未被识别。                                                                                                            |                                     |
| **3**                                       | Missing Well-Known Attribute      | 未指定强制的已知属性之一。                                                                                                               |                                     |
| **4**                                       | Attribute Flags Error             | 属性的标志设置为与属性的类型代码冲突的值。                                                                                                       |                                     |
| **5**                                       | Attribute Length Error            | 属性的长度不正确。                                                                                                                   |                                     |
| **6**                                       | Invalid Origin Attribute          | Origin属性具有未定义的值。                                                                                                            |                                     |
| **7**                                       | AS Routing Loop                   | 检测到路由循环。                                                                                                                    |                                     |
| **8**                                       | Invalid Next_Hop Attribute        | Next_Hop属性无效。                                                                                                               |                                     |
| **9**                                       | Optional Attribute Error          | 在选项中检测到错误                                                                                                                   |                                     |
| **10**                                      | Invalid Network Field             | 网络层可达性信息字段不正确。                                                                                                              |                                     |
| **11**                                      | Malformed AS_Path                 | AS_Path属性不正确。                                                                                                               |                                     |

请注意，也许具有讽刺意味的是，在Notification消息本身中不存在报告错误的机制。这可能是因为在发送这样的消息后，连接通常会被终止

**关键概念：**BGP通知消息用于BGP对等体之间的错误报告。每条消息都包含一个错误代码字段，用于指示发生了什么类型的问题。对于某些错误代码，错误子代码字段提供了有关问题特定性质的其他详细信息。尽管有这些字段名，通知消息也用于其他类型的特殊非错误通信，例如终止BGP连接。

###### 3.4.3.2 TCP/IP外部网关协议（EGP）（部分：1 2 )

早期互联网的路由是通过少数集中式核心路由器完成的，这些路由器维护着互联网上网络可达性的完整信息。它们使用历史上的内部路由协议--网关到网关协议（GGP）来交换信息。在这个核心的外围分布着其他非核心路由器，有时是独立的，有时是集合成组。这些路由器使用第一个TCP/IP外部路由协议：外部网关协议（EGP）与核心路由器交换网络可达性信息。

<u>**历史和发展**</u>
与内部路由协议GGP一样，EGP由互联网先驱Bolt, Beranek和Newman（BBN）在20世纪80年代初开发。在1982年10月发布的RFC 827《外部网关协议（EGP）》中，它首次被正式描述为互联网标准。该文件草案于1984年4月被RFC 904《外部网关协议正式规范》所取代。与GGP一样，EGP现在被认为已经过时，被边界网关协议（BGP）所取代。然而，和GGP一样，它也是TCP/IP路由历史的一个重要部分，因此值得简单研究一下。

注：正如我在关于TCP/IP路由协议的这一整体部分的介绍中所解释的，路由器在过去通常被称为网关。因此，外部路由协议是 "外部网关协议"。这里讨论的EGP协议是外部网关协议的一个具体实例，其缩写也是EGP。因此，你可能偶尔会看到BGP也被称为 "外部网关协议 "或 "EGP"，这是该术语的一般用法。

<u>**操作概述**</u>
EGP负责在相邻的路由器之间进行网络可达性信息的通信，这些路由器可能在不同的自治系统中，也可能不在。EGP的运行与BGP的运行有些类似。每个EGP路由器都维护一个数据库，其中包括它能到达哪些网络以及如何到达这些网络的信息。它定期向与之直接相连的每个路由器发送这些信息。路由器收到这些信息后更新其路由表，然后使用这些新信息更新其他路由器。关于如何到达每个网络的信息会在整个互联网上传播。

<u>**路由信息交换过程**</u>

交换路由信息的实际过程包括几个步骤，以发现邻居，然后建立和维持通信。简而言之，这些步骤是：。

1. 邻居的获取。每个路由器通过发送 "邻居获取请求 "消息，试图与每个邻居路由器建立连接。听到请求的邻居可以用 "邻居获取确认 "来回应，表示它认可该请求并希望进行连接。它也可以用 "邻居获取拒绝 "消息来拒绝获取。要在一对邻居之间建立EGP连接，每个邻居都必须首先用确认消息成功获取对方。

2. 邻居可及性。获取邻居后，路由器会定期检查，以确保邻居可以到达并正常工作。这是通过向已经建立连接的每个邻居发送EGP Hello消息来实现的。邻居会用IHU（I Heard You）消息进行回复。这些消息有点类似于BGP的Keepalive消息，但是是成对使用的。

3. 网络可达性更新：路由器定期向其每个邻居发送Poll消息。邻居以更新消息作为回应，其中包含关于它能够到达的网络的细节。这些信息被用来更新发送轮询的设备的路由表。

邻居可以通过发送Cease消息来决定终止连接（称为邻居取消）；邻居则以Cease-ack（确认）消息来回应。

正如我前面提到的，早期互联网的主要功能是将外围路由器或路由器群连接到互联网核心。因此，它的设计假设是，互联网被连接成一棵分层树，核心是根。EGP的设计不是为了像BGP那样处理任意的自治系统拓扑结构，如果相邻路由器的互连中存在路由环路，EGP也不能保证不存在这种环路。这也是为什么在互联网转向更任意的自治系统连接结构时需要开发BGP的部分原因；现在它已经完全取代了EGP。

<u>**错误报告**</u>
还定义了一个错误消息，其作用和结构与BGP通知消息类似。邻居在收到EGP报文时可能会发送该报文，要么是报文本身有问题（如报文长度不好或某个字段中的数据未被识别），要么是表明报文的使用方式有问题（如收到Hello或Poll报文的速度过快）。与BGP通知消息不同，EGP路由器在发送错误消息时不一定关闭连接。

**关键概念**：外部网关协议（EGP）是第一个TCP/IP外部路由协议，在早期的互联网上与GGP一起使用。它的功能与BGP类似：EGP路由器与相邻的路由器进行联系，并与它们交换路由信息。还提供了一种机制来维护会话和报告错误。EGP在能力上比BGP更有限，现在被认为是一种历史性的协议。

### **第四章、TCP/IP传输层协议**

OSI参考模型的前三层-物理层、数据链路层和网络层-对于了解网络的工作原理非常重要。物理层通过线路传输比特；数据链路层在网络上传输帧；网络层在网际网络上传输数据报。作为一个整体，它们是协议栈的一部分，负责将数据从一个地方传送到另一个地方的实际细节。

紧接在这些层之上的是OSI参考模型的第四层：传输层，在TCP/IP模型中称为主机到主机传输层。这一层很有趣，因为它位于模型的建筑中心。因此，它代表了一个重要的转换点，在它下面与硬件相关的层执行“繁琐的工作”，而上面的层更面向软件和更抽象。

在传输层运行的协议负责提供几项重要服务，以使更高层的软件应用程序能够在网际网络上工作。它们通常负责允许在可能远程的机器上的软件服务之间建立和维护连接。也许最重要的是，它们充当了许多高层应用程序以可靠方式发送数据而无需担心纠错、丢失数据或流管理的需求与网络层协议之间的桥梁，而网络层协议通常是不可靠和未确认的。传输层协议通常与其正下方的网络层协议非常紧密地捆绑在一起，并且专门设计来处理它们不处理的功能。

在这一部分中，我描述了在TCP/IP协议中使用的传输层协议和相关技术，这一层有两个主要协议：传输控制协议(TCP)和用户数据报协议(UDP)。我还将讨论如何在TCP/IP中以端口和套接字的形式实现传输层寻址。

**注意：**我这里只有一个小节，这可能看起来很奇怪，那一个小节涵盖了TCP和UDP。这是因为《TCP/IP指南》摘自更大的网络参考。

### 4.1 传输控制协议(TCP)和用户数据报协议(UDP)

TCP/IP是世界上最重要的互联协议套件；它是互联网的基础，也是世界上绝大多数联网计算机使用的“语言”。TCP/IP包括一组在网络层及以上操作的协议。整个套件由互联网协议（IP）锚定在第三层，许多人认为IP是网络世界中最重要的协议。

当然，网络层和在上面运行的应用程序之间存在一定的架构距离。虽然IP是一种协议，它执行了构成互联网络所需的大部分功能，但它不包括应用程序所需的许多功能。在TCP/IP中，这些任务由一对在传输层运行的协议执行：传输控制协议（TCP）和用户数据报协议（UDP）。

在这两种情况中，TCP最受关注。它是最常与TCP/IP关联的传输层协议，而且，它的名字就在那里，“up in lights”。它也是许多互联网最流行的应用程序所使用的传输协议，而UDP是第二种计费方式。然而，TCP和UDP实际上是在TCP/IP中扮演相同角色的对等体。它们的功能非常不同，为使用它们的应用程序提供了不同的优点和缺点，这使得它们对整个协议套件都很重要。这两个协议也有某些相似之处，这使得我在同一个整体部分中描述它们最为有效，突出它们的共同特点和操作方法，以及它们的分歧。

在本节中，我将详细介绍两种TCP/IP传输层协议：传输控制协议（TCP）和用户数据报协议（UDP）。我首先简要概述了这两个协议在TCP/IP协议套件中的作用，并讨论了为什么它们都很重要。我描述了两种协议使用传输层端口和套接字寻址的方法。然后，我对UDP和TCP分别有两个详细的部分。最后，我对两者进行了简要的快速比较。

顺便说一句，我在TCP之前描述UDP的原因很简单：它更简单。UDP的操作更像是一种经典的基于消息的协议，事实上，它更类似于IP本身，而不是TCP。这也是为什么TCP部分比UDP部分大得多的原因：TCP比UDP复杂得多，并且比UDP做得多。

#### 4.1.1 TCP和UDP概述及其在TCP/IP中的作用（部分：1 2 3）

一个协议套件中的传输层负责一组特定的功能。由于这个原因，人们可能期望TCP/IP套件会有一个单一的主要传输协议来执行这些功能，就像它在网络层将IP作为其核心协议一样。那么，有两个不同的、被广泛使用的TCP/IP传输层协议是一个奇怪的现象。这种安排可能是协议分层的力量的最好例子之一--因此，说明你花了那么多时间来学习理解那讨厌的OSI参考模型是值得的。😄

<u>**TCP/IP中不同的传输层要求**</u>
让我们先来回顾一下第三层。在我对互联网协议的主要运行特点的概述中，我描述了IP工作方式的几个重要限制。其中最重要的是，IP是无连接的、不可靠的和不被承认的。数据在IP网络上发送时不需要首先建立连接，而是采用 "尽力而为 "的模式。信息通常会到达它们需要去的地方，但没有任何保证，而且发送方通常甚至不知道数据是否到达了目的地。

这些特点给软件带来了严重的问题。许多（如果不是大多数）应用程序需要能够指望他们发送的数据能够无损失或无错误地到达目的地的事实。他们还希望两个设备之间的连接能够被自动管理，并在需要时处理诸如拥堵和流量控制等问题。除非在较低层提供一些机制，否则每个应用程序都需要执行这些工作，这将是一个大规模的重复工作。

事实上，有人可能会说，建立连接、提供可靠性、处理重传、缓冲和数据流是非常重要的，最好是直接将这些能力纳入互联网协议。有趣的是，在TCP/IP的早期，情况正是如此。"一开始"，只有一个叫做 "TCP "的协议，它将互联网协议的任务与刚才提到的可靠性和会话管理功能结合起来。

然而，这里面有一个很大的问题。建立连接、提供可靠性机制、管理流量控制、确认和重传：这些都是有代价的：时间和带宽。将所有这些功能建立在一个跨越第三和第四层的单一协议中，意味着所有的应用都能得到可靠性的好处，但也有成本。虽然这对许多应用来说是好的，但还有一些应用既不需要可靠性，也 "负担不起 "提供可靠性所需的开销。

<u>**解决方案: 两个非常不同的传输协议**</u>

解决这个问题很简单：让网络层（IP）负责网络上的基本数据移动，并在传输层定义两个协议。其中一个将为那些需要该功能的应用提供丰富的服务，并理解为需要一些开销来完成这些工作。另一个是简单的，几乎不提供经典的第四层功能，但它将是快速和容易使用的。因此，产生了两个TCP/IP传输层协议。

- 传输控制协议（TCP）。一个功能齐全、面向连接、可靠的传输协议，用于TCP/IP应用。TCP提供传输层寻址，允许多个软件应用程序同时使用一个IP地址。它允许一对设备建立一个虚拟连接，然后双向传递数据。传输是通过一个特殊的滑动窗口系统来管理的，未被确认的传输会被检测到并自动重传。附加功能允许管理设备之间的数据流，并处理特殊情况。

- 用户数据报协议（UDP）。一个非常简单的传输协议，提供像TCP一样的传输层寻址，但没有其他功能。UDP仅仅是一个 "包装 "协议，为应用程序访问互联网协议提供了一种方式。没有建立连接，传输是不可靠的，数据可能丢失。
  打个比方，TCP是一辆满载的豪华性能轿车，配有司机和卫星跟踪/导航系统。它提供了大量的装饰和舒适，以及良好的性能。它几乎可以保证你在没有任何问题的情况下到达你需要去的地方，而且任何出现的问题都可以得到纠正。相比之下，UDP是一辆脱胎换骨的赛车。它的目标是简单和速度，速度，速度；其他一切都在其次。你可能会到达你需要去的地方，但是，嘿，赛车可能是很难保持运行的。

**关键概念：**为了适应许多 TCP/IP 应用程序的不同传输要求，存在两种 TCP/IP 传输层协议。传输控制协议 (TCP) 是一种功能齐全、面向连接的协议，可在管理流量和处理拥塞和传输丢失等问题的同时提供确认的数据传递。相比之下，用户数据报协议 (UDP) 是一个更简单的协议，它只专注于传递数据，以便在不需要 TCP 的特性时最大限度地提高通信速度

<u>**TCP和UDP的应用**</u>

拥有两个优缺点互补的传输层协议，为网络软件的创建者提供了相当大的灵活性。

- TCP的应用。大多数 "典型的 "应用需要TCP提供的可靠性和其他服务，而不在乎少量的性能损失和开销。例如，大多数在机器之间传输文件或重要数据的应用都使用TCP，因为文件的任何部分丢失都会使整个事情变得无用。这方面的例子包括万维网（WWW）使用的超文本传输协议（HTTP）、文件传输协议（FTP）和简单邮件传输协议（SMTP）等知名应用。我在TCP部分更详细地描述了TCP应用。

- UDP应用。我相信你一定在想。"什么样的应用不关心它的数据是否到达那里，我为什么要使用它？" 你可能会感到惊讶。UDP被很多TCP/IP协议所使用。在两种情况下，UDP是应用程序的良好匹配。第一种情况是，应用程序并不真正关心一些数据是否丢失；流媒体视频或多媒体就是一个很好的例子，因为丢失一个字节的数据甚至不会被注意。另一种情况是，应用程序本身选择提供一些其他机制来弥补UDP功能的不足。例如，发送极少量数据的应用程序经常使用UDP，其假设是如果发送了一个请求而没有收到回复，客户端将在以后发送一个新的请求。这提供了足够的可靠性，而没有TCP连接的开销。我在UDP部分讨论了一些常见的UDP应用。

**关键概念。**大多数经典的应用，特别是那些发送文件或消息的应用，要求数据被可靠地传递，因此使用TCP进行传输。使用UDP的应用通常是那些不担心少量数据丢失的应用，或者使用他们自己的特定应用程序来处理TCP更普遍地处理的潜在交付问题。

在接下来的几节中，我们将首先研究TCP和UDP使用的共同传输层寻址方案，然后详细研究这两种协议中的每一种。在这些部分之后是一个总结性的比较，以帮助你一目了然地看到TCP和UDP之间的差异所在。顺便说一下，如果你想用一个很好的 "现实世界 "来说明为什么同时拥有UDP和TCP是有价值的，考虑一下域名系统（DNS）下的消息传输，它实际上在某些类型的通信中使用UDP，而在其他的通信中使用TCP。

在离开比较UDP和TCP的话题之前，我想明确指出，即使TCP经常被描述为比UDP慢，这也是一个相对的测量。TCP是一个写得非常好的协议，能够进行高效的数据传输。与UDP相比，它之所以慢，只是因为建立和管理连接的开销。差别可能很大，但不是很大，所以要记住这一点。

#### 4.1.2 TCP/IP传输层协议（TCP和UDP）寻址：端口和套接字

互联网协议（IP）地址是TCP/IP网络上普遍使用的主要寻址形式。这些网络层地址唯一地识别每个网络接口，因此，作为一种机制，数据被路由到互联网上的正确网络，然后是该网络上的正确设备。然而，有些人没有意识到的是，在TCP/IP的传输层还有一个额外的寻址层次，高于IP地址。TCP/IP传输协议中的TCP和UDP都使用了端口和套接字的概念来进行虚拟软件寻址，以使许多应用程序在一个IP设备上同时发挥作用。

在本节中，我描述了TCP和UDP中用于寻址的特殊机制。我首先讨论了TCP/IP的应用进程，包括通信的客户/服务器性质，这为解释如何使用端口和套接字提供了一个背景。然后，我概述了端口的概念，以及它们是如何在一个IP地址上实现数据复用的。我描述了端口号在范围内的分类方式，以及分配给普通应用的服务器进程的方式。我解释了用于客户端的短暂端口号的概念。然后，我讨论了套接字及其在连接识别方面的用途，包括多个设备可以与另一个设备上的单个端口对话的方法。然后，我提供了一个最常见的知名和注册端口号的汇总表。

##### 4.1.2.1 TCP/IP进程、多路复用和客户/服务器应用角色（部分：1 2 3 )

我相信，开始学习TCP/IP协议套件如何工作的最明智的地方是研究互联网协议（IP）本身，以及在网络层与之协同工作的支持协议。IP是基础，TCP/IP的大部分其他部分都是在此基础上建立的。它是数据在整个TCP/IP网络中被打包和路由的机制。

因此，当我们从互联网协议的角度审查TCP/IP的运行时，我们非常笼统地谈论发送和接收数据报，是有道理的。对于发送和接收IP数据报的IP层软件来说，它们来自于哪一个更高层次的应用，其实并不重要：对于IP来说，"数据报就是数据报"，差不多就是这样。所有的数据报都是以同样的方式打包和路由的，而IP主要关注的是以有效的方式在设备之间移动数据报的低层次方面。

然而，重要的是要记住，这实际上是一个抽象概念，是为了方便描述第三层的操作。它没有考虑数据报是如何在第三层以上真正产生和使用的。第四层代表了OSI模型硬件相关层（一、二、三）和软件相关层（五至七）之间的一个过渡点。这意味着TCP/IP传输层协议，即TCP和UDP，确实需要注意软件使用TCP/IP的方式，即使IP真的没有。

归根结底，拥有网络、国际网络和像TCP/IP这样的协议套件的全部意义是为了实现网络应用。大多数互联网用户每天都在使用这些应用程序。事实上，我们大多数人都会同时运行许多不同的应用程序。例如，你可能正在使用万维网浏览器查看新闻，使用FTP客户端上传一些图片与家人分享，并使用互联网中继聊天程序与朋友或同事讨论一些问题。事实上，一个应用程序有多个实例是很常见的。最常见的例子是打开多个网络浏览器窗口（我有时发现自己同时有多达30个窗口！）。

**多路复用和解复用**

TCP/IP中的大多数通信是在一个设备上运行的程序和另一个设备上的匹配程序之间进行信息交换的形式。一个应用程序的每个实例代表该应用软件的一个副本，需要发送和接收信息。这些应用实例通常被称为进程。一个TCP/IP应用进程是任何使用TCP/IP协议套件发送和接收信息的网络软件。这既包括 "经典 "的最终用户应用程序，如上面描述的那些，也包括在发送信息时表现为应用程序的支持协议。后者的例子包括像SNMP这样的网络管理协议，甚至是路由协议BGP（它像应用程序一样使用TCP发送消息）。

因此，一个典型的TCP/IP主机有多个进程，每个进程都需要发送和接收数据报。然而，所有这些都必须使用同一个接口来发送，使用IP层的网络。这意味着，来自所有应用程序的数据（可能有一些例外）都是 "漏斗式 "的，最初是到传输层，在那里由TCP或UDP处理。从那里，信息传递到设备的IP层，在那里它们被打包成IP数据报，并通过国际网络发送到不同的目的地。这方面的技术术语是多路复用。这个术语的意思是组合，它在这里的使用是对信号方式的一种软件模拟。

一个互补的机制负责接收数据报。在IP层复用来自许多应用进程的数据报并将其发送出去的同时，它也收到了许多打算用于不同进程的数据报。IP层必须接受这些不相关的数据报流，并最终将它们传递给正确的进程（通过它上面的传输层协议）。这就是多路复用的反面：解复用。你可以在图197中看到TCP/IP进程复用和解复用背后的基本概念的说明。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\portsmultiplexing.png)

​                                                               **图197：TCP/IP中的进程多路复用和解复用**

在一台运行TCP/IP的典型机器中，有许多不同的协议和应用程序同时运行。这个例子显示了四个不同的应用程序在一台客户机和服务器之间进行通信。所有四个程序都使用相同的IP软件和物理连接进行多路传输；收到的数据被解复用并传递给适当的应用程序。IP、TCP和UDP提供了使每个应用程序的数据保持不同的手段。

**关键概念。**TCP/IP的设计是为了允许许多不同的应用程序在一个特定的设备上使用相同的互联网协议软件同时发送和接收数据。为了实现这一目标，有必要对来自许多来源的传输数据进行复用，因为它被传递到IP层。当收到IP数据报流时，它被解复用，并将适当的数据传递给接收主机上的每个应用软件实例。

<u>**TCP/IP客户进程和服务器进程**</u>

TCP/IP软件还有一个特点，对于理解该套软件的传输层和更高层的运作方式非常重要：它通常是不对称的。这意味着，当一台计算机上的TCP/IP应用进程试图与另一台计算机上的应用进程交谈时，这两个进程通常并不完全相同。相反，它们是相互补充的，旨在作为一个团队一起运作。

正如我在TCP/IP的概述描述中所解释的那样，大多数网络应用程序使用客户/服务器的操作模式。这个术语可以用来指代计算机的角色，其中服务器是一个相对强大的机器，为大量用户操作的客户端提供服务。它也适用于软件。在这种情况下，一个客户进程通常是指运行在客户机上并发起联系以执行某种功能的进程。一个服务器进程通常运行在一个硬件服务器上，听从客户的请求并对其作出响应。

这方面的典型例子当然是万维网。万维网使用超文本传输协议（HTTP），这是一个应用协议的好例子。网络浏览器是一个HTTP客户端，通常运行在终端用户客户端机器上，比如你现在可能正在使用的机器。它通过向一个网络（HTTP）服务器发送请求来启动HTTP（网络）数据的交换。该网络服务器上的一个服务器进程听到该请求，并以所请求的项目--网页或其他数据--或错误信息作为答复。服务器通常是专门为处理许多传入的客户请求而设计的，在许多情况下几乎没有其他用途。

好吧，我几乎可以看到你脸上不耐烦的表情，因为你想知道自己。"为什么他要在一个应该解释TCP和UDP端口的章节中告诉我这些呢"？答案很快就会清楚，我保证。我从这里开始，因为许多应用进程同时运行并将其数据多路传输的事实，是促使更高级别的寻址在TCP/IP中成为必要的原因。TCP/IP使用的客户/服务器安排对使用端口的方式以及如何分配端口的机制有重要影响。接下来的两个主题将更全面地探讨这些概念。

##### 4.1.2.2 TCP/IP端口。传输层（TCP/UDP）寻址（部分：1 2 3 )

一个典型的TCP/IP网络上的主机有许多不同的软件应用程序同时运行。每个程序都产生数据，并将其发送给TCP或UDP，后者再将其传递给IP进行传输。这种多路复用的数据报流由IP层发送至各个目的地。同时，每个设备的IP层都在接收源自其他主机上众多应用进程的数据报。这些数据报需要被解复用，以便它们最终到达接收它们的设备上的正确进程。

<u>**使用端口进行多路复用和解复用**</u>
问题是：我们如何对需要进入许多不同应用进程的IP数据报序列进行解复用？让我们来考虑一个具有单一网络接口的特定主机，其IP地址为24.156.79.20。通常情况下，IP层收到的每个数据报在IP目标地址字段中都会有这个值。IP层收到的连续数据报可能包含你正在用网络浏览器下载的一个文件，你哥哥发给你的一封电子邮件，以及你的朋友在IRC聊天频道中写的一行文字。如果这些数据报都有相同的IP地址，那么IP层如何知道哪些数据报去了哪里？

答案的第一部分在于每个IP数据报的头中包含的协议字段。这个字段带有一个代码，用于识别向IP发送数据报中的数据的协议。由于大多数终端用户应用在传输层使用TCP或UDP，因此收到的数据报中的协议字段告诉IP将数据传递给TCP或UDP（视情况而定）。

当然，这只是把问题推给了传输层：TCP和UDP都被许多应用同时使用。这意味着TCP或UDP必须弄清楚要把数据发给哪个进程。为了使之成为可能，需要一个额外的寻址元素。这个地址允许在一个特定的IP地址内确定一个更具体的位置--软件进程。在TCP/IP中，这个传输层地址被称为端口。

**关键概念。**TCP/IP传输层寻址是通过TCP和UDP端口完成的。在一个特定的IP设备中，每个端口号都能识别一个特定的软件进程。

<u>**源端口和目的端口号码**</u>

在UDP和TCP报文中都出现了两个寻址字段，即源端口和目的端口。这类似于IP层面上的源地址和目的地址字段，但细节程度更高。它们识别源机器上的源进程和目的机器上的目的进程。它们在传输前由TCP或UDP软件填写，并用于将数据引导到目的设备上的正确进程。

TCP和UDP端口号的长度为16位，因此有效的端口号理论上可以从0到65,535的值。正如我们在下一主题中所看到的，这些数值被划分为不同的用途，某些端口被保留用于特定用途。

有一个事实有时让人有点困惑，那就是UDP和TCP都使用相同的端口号范围，而且它们是独立的。因此，从理论上讲，UDP端口号77有可能指的是一个应用进程，而TCP端口号77指的是一个完全不同的进程。至少对计算机来说，这并不含糊，因为如上所述，每个IP数据报都包含一个协议字段，指定它是携带TCP消息还是UDP消息。IP将数据报传递给TCP或UDP，然后由它们使用TCP或UDP头中的端口号将消息发送到正确的进程。这一机制在图198中得到了说明。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\portsaddressing.png)

​                                                         <u>**图198: 使用TCP/UDP端口的TCP/IP进程复用/解复用**</u>

这是图197的一个更 "具体 "的版本，显示了如何使用TCP和UDP端口来完成软件复用和解复用。这里同样有四个不同的TCP/IP应用程序在通信，但这次我只显示了从客户端到服务器的流量。其中两个应用程序使用TCP，两个使用UDP。客户端上的每个应用程序都使用一个特定的TCP或UDP端口号发送消息。这些端口号被服务器的UDP和TCP软件用来将数据报传递给相应的应用进程。

在实践中，让TCP和UDP使用不同的端口号是令人困惑的，特别是对于常见的应用程序使用的保留端口号。由于这个原因，按照惯例，大多数保留的端口号都是同时为TCP和UDP保留的。例如，80号端口是为TCP和UDP的超文本传输协议（HTTP）保留的，尽管HTTP只使用TCP。我们将在下一主题中更详细地研究这个问题。

<u>**数据报传输和接收的端口使用总结**</u>

因此，总结一下，以下是传输层寻址（端口寻址）在TCP和UDP中的基本工作原理。

- 发送数据报。一个应用程序指定它希望用于通信的源端口和目的端口。这些被编码到TCP或UDP头，取决于应用程序使用的传输层协议。当TCP或UDP向IP传递数据时，IP在IP数据报的协议字段中指出适合TCP或UDP的协议类型。源端口号和目的端口号被封装为TCP或UDP消息的一部分，在IP数据报的数据区。

- 接收数据报。IP软件接收数据报，检查协议字段并决定数据报属于哪个协议（在这种情况下，是TCP或UDP，当然也有其他直接使用IP的协议，如ICMP）。TCP或UDP接收数据报，并根据目的端口号将其内容传递给适当的进程。

**关键概念。**TCP/IP中的应用进程复用和解复用是通过IP协议字段和UDP/TCP源端口和目的端口字段实现的。传输时，协议字段被赋予一个数字，以表明是否使用了TCP或UDP，端口号被填入，以表明发送和接收软件进程。接收数据报的设备使用协议字段来确定是否使用了TCP或UDP，然后将数据传递给由目标端口号指示的软件进程。

**注意：**作为一个旁观者，我应该指出，除了TCP/IP中的这个术语外，端口还有许多含义。例如，网络设备中的一个物理出口通常被称为端口。通常情况下，人们可以从上下文中分辨出有关的 "端口 "是指硬件端口还是软件端口，但你可能希望注意这一点。

##### 4.1.2.2 TCP/IP应用程序的分配和服务器端口号范围。知名、注册和动态/私人端口（部分：1 2）

我们在上一主题中讨论的端口号提供了一种传输层寻址的方法，使许多应用程序可以同时使用TCP和UDP。通过指定适当的目标端口号，发送数据的应用程序可以确保目标设备上的正确进程将收到该消息。不幸的是，在这个寻址系统发挥作用之前，我们仍然有一个问题需要解决。

<u>**问题：识别服务器上的特定进程**</u>
为了解释这个问题，我需要回到一个熟悉的例子：使用万维网。我们启动我们的网络浏览器，它是使用超文本传输协议（HTTP）发送请求的客户端软件。我们需要知道我们想要访问的网站的IP地址，或者我们可以使用DNS自动提供IP地址。一旦我们有了这个地址，网络浏览器就可以生成一个HTTP信息并将其发送到网站的IP地址。

这个HTTP信息不是在该IP地址上的 "任何地方 "发送的：它是为我们试图到达的网站的网络服务器进程准备的。问题是：网络浏览器（客户端进程）如何知道哪个端口号被分配给网站的服务器进程？端口号的范围可以从0到65,535，这意味着有很多选择。而且从理论上讲，每个网站都可以为其网络服务器进程分配一个不同的端口号。

<u>**解决办法。保留的端口号**</u>
有几种不同的方法来解决这个问题。TCP/IP采取的可能是最简单的方法：它为特定的应用程序保留某些端口号。每个常见的应用程序都有一个特定的端口号，分配给服务器进程使用，这些进程监听该应用程序的请求，然后对其作出响应。为了避免混乱，实现特定服务器进程的软件通常在每个IP设备上使用相同的保留端口号，因此客户可以很容易地找到它。

在我们的例子中，HTTP的保留端口号是80。每个网络浏览器都 "知道"，网站被设计为监听发送到80端口的请求。因此，他们会在请求中使用这个值，以确保网络浏览器的IP和TCP软件将这些HTTP信息导向网络服务器软件。一个特定的网络服务器有可能使用不同的端口号，但在这种情况下，网络浏览器的用户必须以某种方式被告知这个端口号，并且必须明确告诉网络浏览器使用这个端口号而不是默认的端口号（80）。

**关键概念。**为了让客户设备更容易建立与TCP/IP服务器的连接，普通应用程序的服务器进程使用通用的服务器端口号，客户预先被编程知道默认使用这些端口号。

<u>**TCP/UDP端口号的范围**</u>

为了使这一系统顺利工作，对端口分配的普遍认同是必不可少的。因此，这就成为另一种情况，需要一个中央机构来管理每个人都使用的端口分配列表。对于TCP/IP来说，它是负责分配和协调其他中央管理的号码，包括IP地址、IP协议号码等的同一机构：互联网号码分配机构（IANA）。

正如我们所看到的，有65,536个端口号可用于进程。但也有相当多的TCP/IP应用，而且这个名单每年都在增长。IANA需要仔细管理端口号的 "地址空间"，以确保端口号不会浪费在不会被广泛使用的协议上，同时也为需要利用晦涩的应用的组织提供灵活性。为此，TCP和UDP端口号的全部范围被划分为三个范围，如表144所示。

这些范围的存在确保了在如何访问最常见的TCP/IP协议的服务器进程方面会有普遍的共识，同时也为特殊应用提供了灵活性。大多数TCP/IP应用和应用协议为其服务器使用众所周知的端口号范围内的数字。这些端口号一般不用于客户进程，但也有一些例外。例如，端口68被保留给使用Boostratp协议（BOOTP）或动态主机配置协议（DHCP）的客户。

​                                                             **表144：TCP和UDP端口号的范围**

| **Port Range Name**                      | **Port Number Range** | **Description**                                                                                                                                                                                                                                                                                                                             |
| ---------------------------------------- | --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Well-Known (Privileged) Port Numbers** | 0 to 1,023            | 这些端口号由 IANA 管理，并仅为最通用的 TCP/IP 应用程序保留。 IANA 仅将这些端口号分配给已使用 TCP/IP RFC 流程标准化、正在标准化或将来可能标准化的协议。 在大多数计算机上，这些端口号仅由系统管理员或特权用户运行的服务器进程使用。这些通常对应于实现关键IP应用程序的进程，例如Web服务器、FTP服务器等。因此，这些有时称为系统端口号。                                                                                                                                                      |
| **Registered (User) Port Numbers**       | 1,024 to 49,151       | 有许多应用程序需要使用 TCP/IP，但在 RFC 中没有指定，或者没有被广泛使用，以至于它们需要一个全球知名的端口号。为确保这些不同的应用程序不会相互冲突，IANA 将整个端口号范围的大部分用于注册端口号。创建可行的 TCP/IP 服务器应用程序的任何人都可以请求保留这些端口号之一，如果获得批准，IANA 将注册该端口号并将其分配给应用程序 。                                                                                                                             这些端口号通常可由系统上的任何用户访问，因此有时称为用户端口号。 |
| **Private/Dynamic Port Numbers**         | 49,152 to 65,535      | 这些端口既不保留也不由 IANA 维护。它们无需注册即可用于任何目的，因此它们适用于仅由特定组织使用的私有协议                                                                                                                                                                                                                                                                                     |

**关键概念。**端口号的分配由IANA管理，以确保全球互联网的普遍兼容性。这些号码分为三个范围：用于最常见应用的知名端口号码，用于其他应用的注册端口号码，以及无需IANA注册即可使用的私有/动态端口号码。

##### 4.1.2.3 TCP/IP客户端（短暂的）端口和客户端/服务器应用程序端口的使用（部分：1 2 3）

当我们详细研究端口号的使用方法时，TCP/IP中客户和服务器之间不对称的意义就变得很明显。由于客户使用TCP和UDP启动应用数据传输，他们需要知道服务器进程的端口号。因此，服务器被要求使用众所周知的端口号。因此，知名的和注册的端口号可以识别服务器进程。它们被用作客户发送的请求中的目标端口号。

相比之下，服务器对客户作出回应；它们不会主动与客户联系。因此，客户端不需要使用保留的端口号。事实上，这确实是一个轻描淡写的说法：服务器不应该使用知名或注册的端口号来向客户发送响应。原因是，一个特定的设备有可能在同一台机器上同时运行同一协议的客户端和服务器软件。如果一个服务器在其机器的80端口上收到一个HTTP请求，并将回复发送到客户机的80端口上，它将把回复发送到客户机的HTTP服务器进程（如果存在），而不是发送初始请求的客户进程。

为了知道向哪里发送回复，服务器必须知道客户端使用的端口号。这是由客户在请求中提供的源端口，然后由服务器作为目标端口来发送回复。客户端进程不使用知名或注册的端口。相反，每个客户进程被分配一个临时端口号供其使用。这通常被称为短暂的端口号。

<u>**临时的端口号的分配**</u>

短暂的端口号是由TCP/IP软件根据需要分配给进程的。显然，每个同时运行的客户进程都需要使用一个独特的临时端口号，因此TCP和UDP层必须跟踪哪些端口正在使用。这些端口号通常是从一个保留的号码池中以伪随机的方式分配的。我说 "伪随机 "是因为分配给一个进程的临时端口号没有具体的含义，所以可以为每个客户进程选择一个随机的端口号。然而，由于有必要随着时间的推移重复使用这个池子里的端口号，许多实现使用了一套规则，以尽量减少由于重复使用而造成的混乱的机会。

考虑到一个客户进程刚刚使用短暂的端口号4,121来发送一个请求，收到一个回复，然后终止。假设我们立即将4,121重新分配给其他进程。然而，由于某种原因，4,121端口的先前用户所访问的服务器发送了一个额外的回复。它将进入新的进程，造成混乱。为了避免这种情况，在为另一个客户进程重新使用端口号4,121之前尽可能地等待是明智的。因此，一些实现将循环使用端口号，以确保连续使用同一短暂的端口号之间有最大的时间间隔。

**关键概念**。服务器进程需要知名的和注册的端口号，因为客户必须知道服务器的端口号才能开始联系。相反，客户进程可以使用任何端口号。每次客户进程启动UDP或TCP通信时，都会被分配一个临时的或短暂的端口号，用于该对话。这些端口号是以伪随机方式分配的，因为所使用的确切号码并不重要，只要每个进程有一个不同的号码。

<u>**临时的端口号范围**</u>
设备上用于瞬时端口的端口号范围也取决于实现。经典的 "瞬时端口范围 "是由BSD（Berkeley Standard Distribution）UNIX中的TCP/IP实现建立的，它被定义为1,024到4,999，提供3,976个瞬时端口。这似乎是一个非常大的数字，而且对于一个典型的客户来说，它通常确实是绰绰有余。然而，这个数字的大小可能具有欺骗性。许多应用程序使用一个以上的进程，理论上在一个非常繁忙的IP设备上有可能耗尽短暂的端口号。由于这个原因，大多数时候，临时端口号的范围是可以改变的。其他操作系统的默认范围可能不同。

正如知名的和注册的端口号用于服务器进程一样，短暂的端口号只用于客户端进程。这意味着使用1,024到4,999的地址范围，与上一主题中看到的使用相同范围的注册端口号并不冲突。

<u>**在客户机/服务器交换过程中使用端口号**</u>

那么，让我们回到客户机/服务器应用信息交换的问题上。一旦分配了一个短暂的端口号，它就被用作客户端请求的TCP/UDP消息的源端口。服务器收到该请求，然后生成一个响应。在形成这个响应信息时，它交换了源和目的端口号，就像它交换了源和目的IP地址一样。因此，服务器的回复是从服务器进程上的知名或注册的端口号发回客户机上的临时端口号。

呵，真让人困惑......快，回到我们的例子上来 J 我们的网络浏览器，IP地址为177.41.72.6，想向IP地址为41.199.222.3的某个网站发送一个HTTP请求。这个HTTP请求是通过TCP发送的，目标端口号为80（为HTTP服务器保留的端口）。源端口号是从一个短暂的端口池中分配的；我们假设它是端口3022。当HTTP请求到达Web服务器时，它被传送到80端口，HTTP服务器在那里接收它。该进程产生一个回复，并将其送回177.41.72.6，使用目标端口3,022和源端口80。这两个进程可以来回交换信息；每次源端口号和目的端口号与源和目的IP地址互换。这个例子在图199中说明。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\portsclientserver.png)

​                                                                 **图199：TCP/IP客户/服务器应用端口机制**

这个高度简化的例子显示了客户和服务器如何使用端口号进行请求-回复交换。客户端提出了一个HTTP请求，并将其发送到HTTP的著名端口号80的服务器上。这个交换的端口号是伪随机选择的3022。服务器将其回复发回该端口号，该端口号是它从请求中读取的。

**关键概念。**在大多数TCP/IP客户/服务器通信中，客户使用一个随机的临时端口号，并向服务器IP地址的适当保留端口号发送请求。服务器将其回复发送到它在请求的源端口字段中发现的任何端口号。

##### 4.1.2.4 TCP/IP套接字和套接字对:进程和连接识别（部分：1 2）

前面的主题已经说明了互联网协议层面的寻址和应用进程所看到的寻址之间的关键区别。总而言之，在第三层，一个IP地址对于在IP设备之间正确地传输数据是真正重要的。相比之下，应用协议必须关注分配给每个应用实例的端口，因此它们可以正确使用TCP或UDP。

<u>**套接字:进程识别**</u>
这一切意味着，应用程序进程的整体识别实际上使用了它所运行的主机的IP地址--或者更准确地说，它所使用的网络接口--和分配给它的端口号的组合。这个组合地址被称为套接字。套接字是用以下符号指定的。

​                <IP Address>:<Port Number>
因此，例如，如果我们有一个在IP地址41.199.222.3上运行的网站，对应于该网站的HTTP服务器的套接字是41.199.222.3:80。

**关键概念:** 一个设备上的TCP/IP应用进程的总标识符是其IP地址和端口号的组合，这被称为套接字。

你有时也会看到用主机名而不是IP地址来指定一个套接字，像这样。

<Host Name>:<Port Number>
要使用这个描述符，首先必须使用DNS将名称解析为一个IP地址。例如，你可能会发现一个网站的URL是这样的。"http://www.thisisagreatsite.com:8080"。这告诉Web浏览器首先使用DNS将名称 "www.thisisagreatsite.com "解析为一个IP地址，然后使用非标准的服务器端口8080向该地址发送请求，由于该端口与80端口相似，所以偶尔也会使用80端口。(参见使用URL的应用层寻址的讨论，了解更多内容）。

套接字是TCP/IP应用软件运行的一个非常基本的概念。事实上，它是同名的重要的TCP/IP应用程序接口（API）的基础：套接字。这个API在Windows的一个版本被称为Windows Sockets或WinSock，你可能以前听说过。这些API允许应用程序轻松使用TCP/IP进行通信。

 <u>**Socket Pairs: 连接识别**</u>

因此，一对设备之间的数据交换包括从一个设备上的套接字到另一个套接字的一系列消息。每个设备通常都会有多个这样的同时对话在进行。在TCP的情况下，每对设备在通信会话期间都会建立一个连接。这些连接必须被管理，这要求它们被唯一地识别。这是用连接的两个设备中的每一个的套接字标识符来完成的。

**关键概念:** 每个设备在任何时候都可能有多个活跃的TCP连接。每个连接都是使用客户端套接字和服务器套接字的组合来唯一识别的，而客户端套接字又包含四个元素：客户端IP地址和端口，以及服务器IP地址和端口。

让我们回到我们在上一主题中使用的例子（图199）。我们正在从177.41.72.6的客户端发送一个HTTP请求到41.199.222.3的网站上。该网站的服务器将使用众所周知的80号端口，所以它的套接字是41.199.222.3:80，正如我们之前看到的那样。我们的网络浏览器使用的是短暂的端口号3022，所以客户端的套接字是177.41.72.6:3022。这些设备之间的整体连接可以用这个套接字对来描述。

(41.199.222.3:80, 177.41.72.6:3022)
关于TCP如何识别连接的更多信息，请参见TCP基本原理一节中的TCP端口和连接识别专题。

与TCP不同，UDP是一个无连接协议，所以它显然不使用连接。发送和接收设备上的一对套接字仍可用于识别交换数据的两个进程，但由于没有连接，套接字对不具有TCP中的意义。

##### 4.1.2.5 常见的TCP/IP应用和分配的知名和注册端口号（部分：1 2）

TCP/IP协议套件的大受欢迎导致了数以千计的不同应用和协议的发展。其中大多数使用我们在本节前面讨论的客户/服务器操作模式。一个特定应用的服务器进程被设计为使用一个特定的预留端口号，客户使用一个短暂的（临时）端口号来启动与服务器的连接。

<u>**保留端口号的管理**</u>
为了确保每个人都同意每个应用程序的服务器应用程序应该使用哪些端口号，它们由互联网号码分配机构（IANA）集中管理。最初，IANA在一份冗长的文本文件中保留了众所周知的和已注册的端口号列表，以及IANA集中负责的所有其他参数（如IP协议字段号、ICMP的类型和代码字段值，等等）。这些都是定期在互联网（RFC）标准文件中公布的，标题为《分配的号码》。

这个系统在互联网的早期运作良好，但到了90年代中期，这些数值的变化如此之快，以至于使用RFC程序是不可行的。继续发布它们的工作量太大，而且RFC在发布的第二天实际上就已经过时了。

最后一个分配号码标准是RFC 1700，发表于1994年10月。在那之后，IANA转向了一套包含他们管理的参数的万维网文件。这使得IANA能够不断地更新列表，并使TCP/IP用户能够获得更多的最新信息。RFC 1700于2002年被正式废除。

**互联网上:** 由IANA维护的所有参数的完整信息可以在http://www.iana.org/numbers.html。包含TCP/UDP端口分配的文件的URL是http://www.iana.org/assignments/port-numbers。

上面提到的文件是所有著名的和已注册的TCP和UDP端口分配的权威列表。每个端口号都被分配了一个简短的关键词，并对使用该端口的协议进行了简要描述。这个文件有两个问题。第一个问题是，它长得令人难以置信：超过10,000行文字。在这几千行中提到的大多数协议都是为那些你可能从未听说过的晦涩的应用而设的（我当然也从未听说过其中的大多数！）这使得我们很难轻易地看到最常用的协议的端口分配。

这份文件的另一个问题是，它显示同一个端口号同时为一个应用程序的TCP和UDP保留。正如我前面提到的，TCP和UDP端口号实际上是独立的，所以理论上可以把TCP端口80分配给一个服务器应用类型，而把UDP端口80分配给另一个。人们认为这将导致混乱，所以除了极少数例外，同一应用程序的TCP和UDP的端口号都显示在列表中。这是有道理的，但在列表中显示这一点有一个缺点：你无法知道应用程序实际使用的是哪一个协议，而哪一个只是为了保持一致性而保留的。

考虑到这一切，我决定在这里包括几个汇总表，显示最常见的TCP/IP应用程序的知名和注册的端口号，并指出该协议是使用TCP、UDP还是两者。

<u>**常见的知名端口号和应用**</u>

​                                                                       **表145列出了最常见的TCP/IP应用协议的知名端口号**

| **Port #** | **TCP / UDP** | **Keyword** | **Protocol Abbreviation** | **Application or Protocol Name / Comments**                       |
| ---------- | ------------- | ----------- | ------------------------- | ----------------------------------------------------------------- |
| **7**      | TCP + UDP     | echo        | —                         | Echo Protocol                                                     |
| **9**      | TCP + UDP     | discard     | —                         | Discard Protocol                                                  |
| **11**     | TCP + UDP     | systat      | —                         | Active Users Protocol                                             |
| **13**     | TCP + UDP     | daytime     | —                         | Daytime Protocol                                                  |
| **17**     | TCP + UDP     | qotd        | QOTD                      | Quote Of The Day Protocol                                         |
| **19**     | TCP + UDP     | chargen     | —                         | Character Generator Protocol                                      |
| **20**     | TCP           | ftp-data    | FTP (data)                | File Transfer Protocol (default data port)                        |
| **21**     | TCP           | ftp         | FTP (control)             | File Transfer Protocol (control / commands)                       |
| **23**     | TCP           | telnet      | —                         | Telnet Protocol                                                   |
| **25**     | TCP           | smtp        | SMTP                      | Simple Mail Transfer Protocol                                     |
| **37**     | TCP + UDP     | time        | —                         | Time Protocol                                                     |
| **43**     | TCP           | nicname     | —                         | Whois Protocol (also called “Nicname”)                            |
| **53**     | TCP + UDP     | domain      | DNS                       | Domain Name Server (Domain Name System)                           |
| **67**     | UDP           | bootps      | BOOTP / DHCP              | Bootstrap Protocol / Dynamic Host Configuration Protocol (Server) |
| **68**     | UDP           | bootpc      | BOOTP / DHCP              | Bootstrap Protocol / Dynamic Host Configuration Protocol (Client) |
| **69**     | UDP           | tftp        | TFTP                      | Trivial File Transfer Protocol                                    |
| **70**     | TCP           | gopher      | —                         | Gopher Protocol                                                   |
| **79**     | TCP           | finger      | —                         | Finger User Information Protocol                                  |
| **80**     | TCP           | http        | HTTP                      | Hypertext Transfer Protocol (World Wide Web)                      |
| **110**    | TCP           | pop3        | POP                       | Post Office Protocol (version 3)                                  |
| **119**    | TCP           | nntp        | NNTP                      | Network News Transfer Protocol                                    |
| **123**    | UDP           | ntp         | NTP                       | Network Time Protocol                                             |
| **137**    | TCP + UDP     | netbios-ns  | —                         | NetBIOS (Name Service)                                            |
| **138**    | UDP           | netbios-dgm | —                         | NetBIOS (Datagram Service)                                        |
| **139**    | TCP           | netbios-ssn | —                         | NetBIOS (Session Service)                                         |
| **143**    | TCP           | imap        | IMAP                      | Internet Message Access Protocol                                  |
| **161**    | UDP           | snmp        | SNMP                      | Simple Network Management Protocol                                |
| **162**    | UDP           | snmptrap    | SNMP                      | Simple Network Management Protocol (Trap)                         |
| **179**    | TCP           | bgp         | BGP                       | Border Gateway Protocol                                           |
| **194**    | TCP           | irc         | IRC                       | Internet Relay Chat                                               |
| **443**    | TCP           | https       | HTTP over SSL             | Hypertext Transfer Protocol over Secure Sockets Layer             |
| **500**    | UDP           | isakmp      | IKE                       | IPSec Internet Key Exchange                                       |
| **520**    | UDP           | router      | RIP                       | Routing Information Protocol (RIP-1 and RIP-2)                    |
| **521**    | UDP           | ripng       | RIPng                     | Routing Information Protocol - “Next Generation”                  |

​    

<u>**常见的注册端口号和应用**</u>
根据定义，注册的端口号是为那些没有使用RFC程序进行标准化的协议准备的，所以它们大多是一些深奥的应用，我觉得没有必要详细列出。表146显示了我觉得特别感兴趣的几个。

​                                                            **表146：常见的TCP/IP注册端口号和应用**

| **Port #**      | **TCP / UDP** | **Keyword** | **Protocol Abbreviation** | **Application or Protocol Name / Comments** |
| --------------- | ------------- | ----------- | ------------------------- | ------------------------------------------- |
| **1512**        | TCP + UDP     | wins        | WINS                      | Microsoft Windows Internet命名服务              |
| **1701**        | UDP           | l2tp        | L2TP                      | 第二层隧道协议                                     |
| **1723**        | TCP           | pptp        | PPTP                      | 点对点隧道协议                                     |
| **2049**        | TCP + UDP     | nfs         | NFS                       | 网络文件系统                                      |
| **6000 - 6063** | TCP           | x11         | X11                       | X窗口系统                                       |

#### 4.1.3 TCP/IP用户数据报协议（UDP）

TCP/IP协议套件以互联网协议和传输控制协议为名，这一事实表明这是套件中的两个关键协议。IP在网络层，TCP在传输层。因此，难怪许多人甚至不知道TCP/IP中还有第二个传输层协议。就像一个害羞的弟弟，用户数据报协议（UDP）坐在阴影中，而TCP则获得了荣耀。由于TCP可以说是两个传输层协议中更重要的一个，所以它的兄弟姐妹应该得到更多的关注。然而，UDP本身填补了TCP/IP协议套件中的一个重要空白，当使用TCP不理想时，它允许许多应用程序以最佳状态工作。

在本节中，我将介绍更简单、更不为人知的TCP/IP传输协议：用户数据报协议（UDP）。我首先概述了该协议并讨论了其历史和标准。我概述了UDP的运作方式，并描述了UDP消息的格式。最后，我讨论了哪些类型的应用程序使用UDP，以及分配给它们的知名或注册端口。

注意：还有一个协议是NetBIOS/NetBEUI协议套件的一部分，叫做用户数据报协议，也缩写为UDP。这两者当然是不一样的。

##### 4.1.3.1 UDP概述、历史和标准

我想我在本节介绍中所作的 "兄弟姐妹之争 "的比喻可能有点愚蠢。我非常怀疑协议会在晚上担心我们使用它们的次数而睡不着觉。J 然而，发现用户数据报协议（UDP）到底有多重要是很有意思的，因为与传输控制协议（TCP）相比，它很少受到关注。事实上，以真正的兄妹关系、抢夺焦点的方式，如果不先讨论TCP，我们甚至无法真正理解UDP的历史。

在描述TCP/IP历史的专题中，我解释说，在协议套件发展的早期，只有一个协议可以处理现在由IP和TCP执行的功能。这个协议本身叫做TCP，它像IP一样提供网络层的连接，同时也建立连接，提供可靠性，并负责典型的传输层 "质量 "要求，如我们与现代TCP相关的流量控制和重传处理。

没过多久，刚刚起步的组合协议的开发者就迅速意识到，把这些功能混在一起是一个错误。虽然大多数传统应用需要经典的传输层可靠性功能，但有些却不需要。这些功能引入了开销，即使是那些根本不需要可靠性功能的应用也必须忍受这些开销。更糟糕的是，在一些应用中，这些功能不仅没有价值，而且实际上是一种损害，因为即使是由于开销造成的少量性能损失，也是一个问题。

解决办法是将原始协议分为IP和TCP。基本的网络连接由IP完成，而可靠性功能由TCP完成。这为创建一个替代的传输层协议铺平了道路，以满足那些不希望或不需要TCP提供的功能的应用。当然，这就是用户数据报协议（UDP）。

在描述UDP的时候，有两个主要的属性被反复提及：简单和快速。它是一个简单的协议，使用非常直接的信息传递结构，与许多其他TCP/IP协议使用的信息格式相似（与TCP使用的更复杂的数据结构--流和段相反）。事实上，当你把它归结为，该协议的唯一真正目标是作为运行在更高层的网络应用程序和IP的网络功能之间的接口。像TCP一样，UDP通过使用UDP端口号，在IP之上建立了一个传输层寻址方法（因此也是进程识别）。它确实包括一个用于错误检测的可选校验功能，但几乎没有增加其他功能。

事实上，要想知道UDP的简单性，最好的办法是看一下定义它的标准。或者说，我应该说是单数的标准，因为只有一个。UDP是在1980年的RFC 768，用户数据报协议中定义的。这份文件只有三页长，而且从未需要修订。

UDP是一个快速协议，特别是因为它没有TCP的所有功能和特点。这使得它不适合于许多（如果不是大多数）典型的网络应用。但对某些应用来说，这正是他们希望从传输层协议中得到的东西：它能获取他们的数据，并以最小的代价将其快速传送到IP层。在选择使用UDP时，应用程序的编写者需要自己来处理诸如可靠性和重传等问题，如果需要的话。这可能是成功的秘诀，也可能是失败的秘诀，这取决于应用和对UDP的使用是否谨慎。

**关键概念:** 用户数据报协议（UDP）是为那些在传输层不需要可靠性、确认或流量控制功能的应用协议所开发的。它被设计成简单和事实，只提供UDP端口形式的传输层寻址和可选的校验功能，而没有其他功能。

##### 4.1.3.2 UDP操作

呃......呃......看了这么多页，我几乎发现自己已经无话可说了。(嘿，不要跳到下一个话题，我说的是几乎！）用户数据报协议的简单性意味着在描述其操作时没有太多可说的。它被设计成尽可能不做什么，而不做什么正是它所做的。

<u>**UDP做什么**</u>
UDP唯一真正的任务是把来自高层协议的数据放在UDP报文中，然后将其传递给互联网协议进行传输。使用UDP进行传输的基本步骤是。

1. 高层数据传输。一个应用程序向UDP软件发送一个消息。

2. UDP消息封装。上层消息被封装到UDP消息的数据域中。UDP消息的标题被填入，包括向UDP发送数据的应用程序的源端口，以及预期接收者的目标端口。也可以计算校验和值。

3. 将信息传输到IP：UDP信息被传递到IP进行传输。

就这样了。当然，在目的地设备上接收时，这个简短的程序会被颠覆。

<u>**UDP没有什么作用**</u>
事实上，UDP是如此简单，以至于它的操作经常被描述为它不做什么，而不是它做什么。作为一个传输协议，UDP不做的一些最重要的事情包括以下几点。

- UDP在发送数据之前不建立连接。它只是将数据打包，然后......发送出去。

- UDP不提供确认，以显示数据被收到。

- UDP不提供任何保证，它的消息会到达。

- UDP不检测丢失的信息并重新传输它们。

- UDP不确保数据按照它们被发送的相同顺序被接收。

- UDP不提供任何机制来管理设备间的数据流，或处理拥堵。

**关键概念。**用户数据报协议（UDP）可能是所有TCP/IP中最简单的。它所做的就是接受传递给它的应用层数据，将其包装成简化的消息格式，并将其发送到IP进行传输。

如果这些特征听起来与我描述的IP的局限性相似，你就会注意了。UDP基本上只是带有传输层端口地址的IP。(正是由于这个原因，UDP有时被称为 "包装wrapper "协议，因为它所做的只是将应用数据包装成其简单的消息格式，并将其发送到IP上）。

我应该指出，尽管有上面的清单，但UDP中确实存在一些有限的反馈和错误检查机制。一个是可选的校验功能，它可以检测到传输中的错误或UDP消息被传递到错误的地方的情况；详情见下一主题。另一个是ICMP错误报告。例如，如果发送的UDP报文包含目的地设备无法识别的目的地端口号，这将导致目的地主机发送一个ICMP目的地不可达消息回给原始源。当然，ICMP存在于所有这类IP错误中，所以我在这里有点牵强；这并不是UDP的真正组成部分。

##### 4.1.3.3 UDP消息格式（部分：1 2 )

谈到UDP，有什么妙招？对，简单。协议的运行是如此，UDP消息的格式也是如此。然而，有趣的是，在这里，我们实际上会遇到可能是UDP的唯一不简单的方面。我打赌这让你很感兴趣，是吗？好吧，好吧，这值得一试。J

为了保持效率的目标，UDP头只有8个字节的长度；这与TCP头的20个字节或更多形成鲜明对比。表147和图200显示了UDP消息的格式。

​                                                                                        <u>**表147：UDP消息格式**</u>

| **Field Name**          | **Size (bytes)** | **Description**                                                                                                                |
| ----------------------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------ |
| ***Source Port\***      | 2                | ***Source Port:\*** 源端口：在源设备上启动UDP消息的过程的16位端口号。对于客户发送到服务器的请求或服务器发送给客户端的答复，这通常是临时（客户端）端口号，或者是已知/已注册（服务器）端口号。有关详细信息，请参见描述端口号的部分。 |
| ***Destination Port\*** | 2                | 目标端口：该过程的16位端口号是目标设备上消息的最终预期收件人。这通常是客户端请求的知名/注册（服务器）端口号，或服务器回复服务器的短暂（客户端）端口号。同样，有关详细信息，请参见描述端口号的部分。                            |
| ***Length\***           | 2                | ***Length:\*** 长度：整个UDP数据报的长度，包括标题和数据字段。                                                                                       |
| ***Checksum\***         | 2                | ***Checksum:\*** 校验和：在整个UDP数据报上计算的可选16位校验和一个特殊的字段“伪标题”。请参阅下面的详细信息。                                                             |
| ***Data\***             | Variable         | ***Data:\*** 数据：要发送的封装的高层消息。                                                                                                   |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\udpformat.png)

​                                                                                **图200：UDP消息格式**

 <u>**校验和字段和UDP伪报头**</u>

UDP校验和字段是该协议实际上有点混乱的一个领域。校验和的概念本身并不新鲜；它们被广泛用于网络协议中，以提供防错保护。有点奇怪的是，在常规数据报和伪报头上计算校验和的概念。这意味着，UDP软件不是只在UDP数据报本身的字段上计算校验和，而是首先构建一个 "假 "的附加头，包含以下字段（图201）。

- IP源地址字段。

- IP目标地址字段。

- IP协议字段。

- UDP长度字段。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\udppseudoheader (1).png)

​                                                                                     <u>**图201: UDP伪报头格式**</u>

这个 "伪头 "的总长度是11字节。它用一个字节的零填充到12个字节，然后预置到真正的UDP消息中。然后在伪报头和真正的UDP消息的组合上计算校验和，并将其值放入校验和字段中。伪报头只用于计算，然后被丢弃；它实际上并没有被传输。目的地设备中的UDP软件在计算其校验和时创建相同的伪头，以便与UDP头中传输的校验和进行比较。

在常规的UDP字段上计算校验和可以防止UDP消息本身的位错误。添加伪头使校验和也能防止其他类型的问题，最明显的是将信息意外地传递到错误的目的地。UDP中的校验和计算，包括伪报头的使用，与TCP中使用的方法完全相同（除了TCP中的长度字段不同）。参见描述TCP校验计算的主题，以全面了解为什么伪报头很重要，以及在传输层数据报计算中使用IP字段的一些有趣影响。

<u>**关键概念。**</u>UDP将应用层数据打包成一种非常简单的消息格式，只包括四个头字段。其中一个是可选的校验字段；当使用时，校验是通过真正的头和来自UDP和IP头的 "伪头 "字段计算的，其方式与TCP校验的计算方式非常相似。

请注意，在UDP中使用校验和字段是可选的。如果不使用它，它将被设置为一个全部为零的值。然而，这有可能造成混乱，因为当使用校验和时，计算结果有时可能为零。为了避免目的地认为在这种情况下没有使用校验和，这个零值被表示为所有的1值（65,535十进制）。

##### 4.1.3.4 UDP常见应用和服务器端口分配（部分：1 2 3）

正如我们在探索用户数据报协议时看到的那样，UDP包含的功能非常少。除了UDP端口所代表的重要寻址能力之外，使用UDP非常像直接使用IP。这意味着UDP具有和IP一样的大部分缺点。它不在设备之间建立持久的连接；它不确认收到的数据或重发丢失的信息，当然也不关心诸如流量控制和拥塞管理等深奥的问题。

由于缺乏这些功能，UDP根本不适合大多数 "经典 "网络应用。这些应用通常需要能够建立一个连接，以便两个设备能够来回交换数据。许多人还需要偶尔甚至定期发送非常大量的数据，这些数据必须被完整地接收才有价值。例如，考虑像HTTP这样的消息传输协议。如果一个网页只有部分内容从服务器传回网络浏览器，那么它就没有用。HTTP和其他类似的文件和消息传输协议需要我们上面提到的能力。

我读过一些过去在使用UDP的应用程序中发生的问题。有时程序员没有意识到UDP的作用有多大，它让应用程序负责处理互联网环境中所有潜在的变化无常。编写基于UDP的应用程序的人必须始终牢记，不能假设任何消息如何或甚至是否会被其目的地接收，并且必须相应地计划。在更大的互联网上，特别是在互联网上，不充分的测试会导致最坏情况下的灾难。

<u>**为什么一些TCP/IP应用使用UDP**</u>

那么哪些应用程序使用UDP呢？嗯，UDP的经典 "免责声明 "是，由于它不提供我们前面看到的功能，所以使用UDP的应用程序要对这些功能负责。实际上，如果一个应用程序需要TCP提供的功能，而UDP不提供，那么让应用程序实现这些功能是低效的，除非在特殊情况下。如果应用程序需要TCP提供的功能，它就应该直接使用TCP! 然而，那些只需要TCP实现的部分功能的应用程序，有时最好使用UDP，并在应用程序层面实现这些有限的功能。

因此，通过UDP运行的应用程序通常是那些不需要TCP所有甚至大部分功能的应用程序，它们可以从避免与TCP相关的设置和开销而提高的效率中受益。应用程序通常（但不总是）符合这种描述，因为它们发送的数据属于两类中的一类。

**<u>性能比完整性更重要的数据</u>**
这一类的典型例子是多媒体应用。如果你在互联网上传输视频片段，最重要的是视频流开始快速流动并保持流动。人类只会注意到这种类型的信息流的重大中断，因此，由于数据报丢失而丢失几个字节的数据不仅不是一个大问题，甚至不太可能被注意到。

此外，即使TCP被用来做这样的事情，并且丢失的数据报被注意到并被重传，它也是无用的，因为它属于片段中早已过去的部分--重传所花费的时间可能使片段中实际的当前部分晚点到达。显然，UDP最适合这种情况。

<u>**"短小精悍 "的数据交换**</u>
有许多TCP/IP应用的底层协议只包括一个非常简单的请求/回复交换。一个简短的请求信息从客户端发送到服务器，一个简短的回复信息从服务器返回到客户端。在这种情况下，并不真正需要像TCP那样建立连接。此外，如果只发送一个短消息，它可以在一个IP数据报中传输。这意味着不需要担心数据不按顺序到达，也不需要担心设备之间的流量控制等等。

请求或回复的丢失情况如何？这些都可以在应用层面用计时器简单地处理。如果客户端发送了一个请求，而服务器没有收到，它就不会回复，而客户端最终会发送一个替换请求。如果服务器发送的响应从未到达，同样的逻辑也适用。

<u>**其他需要UDP的情况**</u>
正如我之前所说，这些是使用UDP的最常见情况，但还有其他原因。例如，如果一个应用程序需要组播或广播数据，它必须使用UDP，因为TCP只支持两个设备之间的单播通信。

**关键概念。**在两种情况下，UDP最常被协议使用，而不是TCP。第一种情况是当一个应用重视及时交付而不是可靠交付，并且TCP对丢失数据的重传价值有限甚至没有价值时。第二种情况是当一个简单的协议能够在应用层使用定时器/重传策略来处理IP数据报本身的潜在丢失，并且不需要TCP的其他功能时。UDP也用于需要多播或广播传输的应用，因为这些都是TCP不支持的。

<u>**常见的UDP应用和服务器端口使用**</u>

表148显示了一些比较有趣的使用UDP的协议，以及每个协议的服务器进程所使用的知名和注册的端口号。它还提供了关于这些协议为什么使用UDP而不是TCP的非常简短的描述。更多细节请参见专门针对每个应用程序的章节或主题。

​                                                                       **表148: 常见的UDP应用和服务器端口分配**

| **Port #**      | **Keyword**     | **Protocol**                                                              | **Comments**                                                                                                                                                        |
| --------------- | --------------- | ------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **53**          | domain          | Domain Name Server (DNS)                                                  | 对大多数交换使用简单的请求/回复消息系统（但对于较长的交换也使用 TCP）。                                                                                                                              |
| **67 and 68**   | bootps / bootpc | Bootstrap Protocol (BOOTP) and Dynamic Host Configuration Protocol (DHCP) | 由短请求和回复交换组成的主机配置协议。                                                                                                                                                 |
| **69**          | tftp            | Trivial File Transfer Protocol (TFTP)                                     | TFTP 是专门为 UDP 设计的协议的一个很好的例子，尤其是与常规 FTP 相比时。后一种协议使用 TCP 在两个设备之间建立会话，然后利用它自己的大型命令集和 TCP 的特性来确保可能非常大的文件的可靠传输。相比之下，TFTP 专为快速轻松地传输小文件而设计。它包括一些 TCP 功能的简单版本，例如确认，以避免文件损坏。 |
| **161 and 162** | snmp            | Simple Network Management Protocol                                        | 使用相对较短消息的管理协议。                                                                                                                                                      |
| **520 and 521** | router / ripng  | Routing Information Protocol (RIP-1, RIP-2, RIPng)                        | 与 BGP 等更复杂的路由协议不同，RIP 使用简单的请求/回复消息系统，不需要连接，并且确实需要多播/广播。这使其成为 UDP 的自然选择。如果由于请求而发送路由更新并丢失，则可以通过发送新请求来替换它。丢失的常规（主动）更新在下一个周期中被替换。                                       |
| **2049**        | nfs             | Network File System                                                       | NFS 是一个有趣的案例。由于它是一种文件共享协议，有人会认为它会使用 TCP 而不是 UDP，但出于性能原因，它最初设计为使用 UDP。很多人觉得这不是最好的设计决定，后来的版本转而使用 TCP。最新版本的 NFS 仅使用 TCP。                                               |

<u>**同时使用UDP和TCP的应用**</u>
有一些协议实际上同时使用UDP和TCP。这通常是指那些被设计为使用两种传输层协议接受连接的实用协议，或者那些在某些情况下需要TCP的好处，但在其他情况下不需要的应用。

后者的典型例子是DNS，它通常使用UDP端口53来处理简单的请求和回复，这些请求和回复通常很短。需要可靠传递的较大信息，如区域传输，则使用TCP端口53。请注意，在上表中，我省略了一些不太重要的协议，比如用于诊断的协议（Echo、Discard、CharGen等）。 关于所有常见应用的完整列表，请参见常见TCP/IP应用和端口号专题。

#### 4.1.4 TCP/IP传输控制协议（TCP）

在我对互联网协议的描述中，我称它为TCP/IP协议套件的 "主力"。事实上，IP是该套协议中的其他协议所建立的基础。好吧，如果IP是 "工作马"，那么骑在这匹马上的 "工人 "就必须是TCP/IP传输控制协议（TCP）。就像马和骑手一样，TCP和IP组成了一个团队，共同工作，使应用程序能够在互联网上轻松运行。

TCP和IP共享套件名称中的标牌，并且是彼此非常重要的补充。IP关注传统的网络层任务，如寻址、数据报打包和路由，提供基本的网络功能。TCP为应用程序提供了一种轻松使用IP的方法，同时填补了IP所缺乏的能力。它允许TCP/IP设备建立和管理连接，可靠地发送数据，并负责处理传输过程中可能出现的所有 "麻烦"，因此每个应用程序都不需要担心这些问题。因此，对于应用程序来说，TCP几乎可以被认为是IP相当初级的能力的一个漂亮的用户界面。

本节对传输控制协议（TCP）的概念、特点和功能进行了全面描述。TCP是一个相当复杂的协议，包括一些复杂的功能，以确保应用程序在大型互联网的潜在困难环境中发挥作用。正如我上面所说，它也是TCP/IP协议套件的一个非常重要的部分。由于这个原因，这一节相当大，并被分为五个小节。

第一小节提供了TCP的概述，描述了它的历史、它的作用以及它的工作方式。第二小节描绘了一些重要的背景信息，这些信息对于理解TCP的运行方式是必要的。这是通过解释关键概念来完成的，如流和段、滑动窗口和TCP端口和连接。第三小节描述了TCP用于建立、维护和终止会话的过程。第四小节描述了TCP消息，以及它们如何被格式化和传输。最后一小节介绍了TCP如何为应用提供可靠性和其他重要的传输层功能，如流量控制、丢失数据的重传和避免拥堵。

**背景信息。**由于TCP是建立在IP之上的，在描述TCP时，我假设读者至少对IP有基本的熟悉。如果你在阅读本节时没有首先了解IP，我建议先阅读该节。由于本节内容较多，回顾描述IP概念的部分可能就足以作为背景资料了。

##### 4.1.4.1 TCP概述、功能和特点

正如我在上一节概述中提到的，传输控制协议（TCP）是TCP/IP套件的一个极其重要的部分。它也是一个相当复杂的协议，有很多重要的概念和机制需要理解。老笑话说，吃大象的最好方法是 "一次咬一口"。在这里也是一样，我们可以通过慢慢来理解这个复杂的协议的运作，从高层次上看它，看它从哪里来，看它一般做什么。

在这一节中，我从TCP协议的介绍开始对其进行考察。我首先提供了一个TCP的概述和历史，并描述了定义它的标准。然后，我通过两种重要的方式对TCP进行了 "鸟瞰式 "的描述。我通过列出TCP的功能来说明它的实际作用，然后通过描述TCP最重要的特征来解释它是如何工作的。这将使你感受到TCP是怎么回事，并希望为后续章节中更复杂的技术讨论做好铺垫。

###### 4.1.4.1.1 TCP概述、历史和标准（部分：1 2 3 )

在它们之间，OSI参考模型的第三和第四层代表了网络软件（需要在网络上移动数据的应用程序）和网络硬件（在网络上传输数据的设备）之间的接口。任何协议套件都必须有一个协议或一组协议来处理这些第三层和第四层的功能。

TCP/IP协议套件以提供这些功能的两个主要协议命名，允许软件在互联网上运行：传输控制协议（TCP）和互联网协议（IP）。IP处理网络数据报的传送和路由，而TCP处理连接并提供可靠性。然而，有趣的是，在协议套件的早期，实际上根本就没有 "TCP/IP"。

<u>**TCP的历史**</u>
由于其突出的作用，如果不回溯到整个协议套件的早期，就无法描述TCP的历史。在20世纪70年代初，我们今天所知道的全球互联网是一个小型的研究网络，叫做ARPAnet，以美国国防部高级研究计划局（DARPA或ARPA）命名。这个网络使用一种叫做网络控制协议（NCP）的技术来允许主机相互连接。NCP所做的工作大约相当于今天TCP和IP所做的工作。

由于NCP的局限性，开始开发一种新的协议，以更好地适应不断增长的互联网。这个新协议在RFC 675中首次正式确定，被称为互联网传输控制程序（TCP）。与它的前身NCP一样，TCP基本上负责允许应用程序在互联网上运行所需的一切。因此，TCP最初既是TCP也是IP。

正如我在描述整个TCP/IP历史的专题中详细解释的那样，花了几年时间对TCP进行调整和修订，该协议的第二版于1977年被记录下来。虽然TCP的功能得到了稳定的改善，但协议背后的基本概念却存在问题。让TCP自己处理数据报传输和路由（第三层功能）以及连接、可靠性和数据流管理（第四层功能）意味着TCP违反了协议分层和模块化的关键概念。TCP强迫所有的应用程序使用第四层的功能，以便使用第三层的功能。这使得TCP缺乏灵活性，而且不适合那些只需要低层功能而不需要高层功能的应用。

因此，决定将TCP一分为二：保留第四层功能，将TCP更名为传输控制协议（而不是程序）。第三层的功能成为互联网协议。这一拆分在TCP的第4个版本中最终完成，因此，为了保持一致性，第一个IP也被赋予了 "第4个版本"。1981年9月出版的RFC 793《传输控制协议》对TCP的第四版进行了定义，它仍然是该标准的当前版本。

尽管它已经有20多年的历史，而且是大多数人使用过的第一个版本，但版本4是几年工作的结果，而且许多早期的TCP版本在早期互联网上进行了测试。因此，就其年龄而言，它是一个非常成熟的协议。你可以说是一个早熟的协议。(公平地说，许多额外的功能和对TCP工作方式的修改已经在其他标准中描述过了，而不是升级主文件）。

<u>**TCP的特点和操作概述**</u>

TCP是一个全功能的传输层协议，它提供了一个典型的应用程序所需要的所有功能，以便在一个任意的互联网上可靠地传输数据。它以TCP端口的形式为应用程序提供传输层寻址，并允许这些端口用于在机器之间建立连接。一旦建立了连接，数据就可以在两个设备之间双向传递。应用程序可以将数据作为一个简单的字节流发送给TCP，而TCP负责将数据打包并作为片段发送，这些片段被打包成IP数据报。接收设备的TCP实现反转这一过程，将最初发送的数据流传递给应用程序。

TCP包括一套广泛的机制，以确保数据能够可靠、一致和及时地从源头到达目的地。在这方面，其操作的关键是滑动窗口确认系统，它允许每个设备跟踪哪些字节的数据已被发送，并确认收到来自连接中其他设备的数据。未确认的数据最终会自动重传，该系统的参数可以根据设备和连接的需要进行调整。这个系统还在设备之间提供缓冲和流量控制功能，以处理不均匀的数据传输率和其他问题。

在TCP中包含了如此多的功能，使得几乎所有需要面向连接的可靠数据传输的应用都能通过该协议得到最大的满足。这是TCP的一个主要目标，因为它意味着高层应用不需要单独提供这些通用功能。TCP是最广泛使用的TCP/IP传输协议，被大多数传统的消息传递应用所采用。

**关键概念。**TCP/IP套件中的主要传输层协议是传输控制协议（TCP）。TCP是一个面向连接的、公认的、可靠的、功能齐全的协议，旨在为应用程序提供一种可靠的方式，使用不可靠的互联网协议发送数据。它允许应用程序以字节流的形式发送数据，并自动将其打包成适当大小的片段进行传输。它使用一个特殊的滑动窗口确认系统，以确保所有数据被其接收者收到，处理必要的重传，并提供流量控制，以便连接中的每个设备能够管理其被发送数据的速度。

<u>**TCP标准**</u>

RFC 793是TCP的定义标准，但它并不包括现代TCP操作的所有细节。其他几个标准包括关于协议如何工作的额外信息，并描述了多年来对基本TCP机制的增强。其中一些是相当 "深奥 "的，并不广为人知，但它们对于获得对TCP更全面的理解是非常有用的。我在表149中列出了其中一些

​                                                                                  **表149：补充的TCP标准**

| **RFC Number** | **Name**                                                                      | **Description**                                  |
| -------------- | ----------------------------------------------------------------------------- | ------------------------------------------------ |
| **813**        | *Window and Acknowledgment Strategy in TCP**TCP中的窗口和确认策略*                     | 讨论 TCP 滑动窗口确认系统，描述它可能出现的某些问题以及纠正这些问题的方法。         |
| **879**        | *The TCP Maximum Segment Size and Related Topics**TCP 最大段大小和相关主题*             | 讨论拥塞问题以及如何使用 TCP 来处理它们。注意正常协议套件名称的有趣反转：“IP/TCP”。 |
| **896**        | *Congestion Control in IP/TCP Internetworks**IP/TCP 网络中的拥塞控制*                 | 讨论拥塞问题以及如何使用 TCP 来处理它们。注意正常协议套件名称的有趣反转：“IP/TCP”。 |
| **1122**       | *Requirements for Internet Hosts — Communication Layers*Internet 主机的要求——通信层** | 描述如何在主机上实现 TCP 的重要细节。指定让 TCP 设备使用另一种校验和生成方法的机制。  |
| **1146**       | *TCP Alternate Checksum Options**TCP 备用校验和选项*                                 | 指定让 TCP 设备使用另一种校验和生成方法的机制。                       |
| **1323**       | *TCP Extensions for High Performance**高性能 TCP 扩展*                             | 为高速链路定义 TCP 扩展，以及新的 TCP 选项。                      |
| **2018**       | *TCP Selective Acknowledgment Options**TCP 选择性确认选项*                           | 对基本 TCP 功能的增强，允许 TCP 设备有选择地指定特定段进行重传。            |
| **2581**       | *TCP Congestion Control*TCP 拥塞控制**                                            | 描述 TCP 网络中用于拥塞控制的四种算法：慢启动、拥塞避免、快速重传和快速恢复。        |
| **2988**       | *Computing TCP's   *计算 TCP*        Retransmission Timer**重传定时器*               | 讨论与设置 TCP 重传计时器相关的问题，该计时器控制设备在重传数据之前等待确认发送数据的时间。 |

当然，有成百上千的高层应用协议使用TCP，因此它们的定义标准至少也会瞥见它。

TCP当然是为了使用互联网协议而设计的，因为它们是一起开发的，正如我们所看到的，甚至曾经是同一规范的一部分。同时，为了尊重架构分层的原则，它们被分割开来。出于这个原因，TCP试图对它所运行的底层协议做出尽可能少的假设。它并不像人们想象的那样与IP的使用严格挂钩，甚至可以在其他网络层协议上使用。然而，对于我们的目的来说，这应该被认为主要是一个 "有趣的旁观者"。在我们的讨论中，我们将假设TCP在IP上工作，因为它几乎总是这样被使用。

###### 4.1.4.1.2 TCP的功能。TCP的作用 (部分: 1 2 )

我们现在已经看到了TCP的来源和描述它的标准。正如我在本节介绍中所说，TCP是一个复杂的协议，所以需要一些时间来解释它是如何工作的。在食用这头特殊的 "大象 "时，最合理的第一口是看看TCP到底是做什么的。从那里，我们可以描述它的特点，然后进入其操作的细节。

<u>**TCP执行的功能**</u>
尽管TCP很复杂，但通过描述其主要功能，可以合理地简化其基本操作。以下是我认为TCP所执行的六项主要任务。

- 寻址/多路复用。TCP被许多不同的应用程序用作其传输协议。因此，像其更简单的兄弟姐妹UDP一样，TCP的一项重要工作是多路复用从这些不同进程中收到的数据，以便它们能够使用底层网络层协议发送出去。同时，这些高层的应用进程是用TCP端口来识别的。关于TCP/IP传输层寻址的部分包含了大量关于这种寻址方式的细节。

- 连接的建立、管理和终止。TCP提供了一套程序，设备遵循这套程序来协商和建立TCP连接，数据可以通过该连接传输。一旦打开，TCP包括管理连接和处理可能产生的问题的逻辑。当一个设备完成TCP连接后，会有一个特殊的过程来终止它。

- 数据处理和包装。TCP定义了一种机制，通过这种机制，应用程序能够从高层向其发送数据。然后，这些数据被打包成消息，发送到目的地的TCP软件。目的地软件将数据解包，并将其交给目的地机器上的应用程序。

- 数据传输。从概念上讲，发送设备上的TCP实现负责将打包的数据传输给另一设备上的TCP进程。遵循分层原则，这是由发送机器上的TCP软件将数据包传递给底层网络层协议，这通常也意味着IP。

- 提供可靠性和传输质量服务。TCP包括一组服务和功能，允许应用程序认为使用该协议发送的数据是 "可靠的"。这意味着，通常情况下，TCP应用程序不必担心数据被发送但从未出现，或以错误的顺序到达。这也意味着，如果直接使用IP，可能会出现的其他常见问题也可以避免。

- 提供流量控制和拥塞避免功能。TCP允许两个设备之间的数据流被控制和管理。它还包括处理设备间通信过程中可能出现的拥堵问题的功能。

显然，TCP负责相当数量的关键功能。这个清单可能看起来不是那么令人印象深刻。原因是这只是对协议的高层次审视，这些功能在上面的列表中得到了总结；当我们详细审视它们时，我们会发现每一项功能实际上都涉及到TCP要做的相当大的工作量。

<u>**不由TCP执行的功能**</u>

TCP做了很多事情，以至于有时它被描述为做了一个应用程序使用互联网所需的 "一切"。我自己可能也犯过这样的错误。然而，该协议并不是什么都做。它有局限性，也有其设计者特别没有涉及的某些领域。其中值得注意的是，TCP没有执行的功能包括。

- 指定应用程序的使用：TCP定义了传输协议。它并没有具体描述应用程序如何使用TCP。

- 提供安全性。TCP没有提供任何机制来确保它所传输数据的真实性或隐私。如果需要，它们必须通过其他方式来完成，例如IPSec。

- 保持消息的边界。TCP以连续流的形式发送数据，而不是以离散的消息形式发送。由应用程序来指定一个消息的结束和下一个消息的开始。

- 保证通信。等一下......TCP的全部意义不就是保证数据能够到达目的地吗？嗯，是的，也不是。J TCP将检测未被认可的传输，并在需要时重新发送。然而，如果出现某种问题，妨碍了可靠的通信，TCP所能做的就是 "继续尝试"。它不能做出任何保证，因为有太多的事情是它无法控制的。同样，它可以尝试管理数据流，但不能解决所有问题。

最后一点可能看起来有点迂腐，但必须牢记，特别是因为人们倾向于认为TCP在某种程度上是 "防弹的"。通信的整体成功完全取决于底层的互联网和构成它的网络。一个链条的强度取决于其最薄弱的环节，如果下层出现问题，那么TCP所能做的一切都不能保证数据的成功传输。

**关键概念。**TCP只通过检测失败的传输并重新发送来提供可靠的通信。它不能保证任何特定的传输，因为它依赖于IP，而IP是不可靠的。它所能做的就是在最初的传输尝试失败时继续尝试。

###### 4.1.4.1.3 TCP的特点。TCP如何做它所做的事情（部分：1 2）

在上一主题中，我们开始了对TCP的高层次研究，研究了该协议执行的最重要的功能，以及一些它没有执行的功能。在许多方面，研究TCP如何完成其工作比研究工作本身的功能更有意思。通过研究TCP及其运行的最重要属性，我们可以更好地掌握TCP的工作方式。我们还可以看到它与它更简单的传输层兄弟姐妹UDP的许多对比方式。

<u>**TCP的特点**</u>
以下是我对传输控制协议的最佳描述方式，以及它如何执行前述主题中描述的功能。

- 以连接为导向。TCP要求设备在发送数据之前首先与对方建立一个连接。这种连接在各设备之间建立了相当于电路的作用，类似于电话通话。建立连接需要一个协商过程，以确保两个设备就如何交换数据达成一致。

- 双向的。一旦建立了连接，TCP设备就会双向发送数据。连接上的两个设备都可以发送和接收，无论哪个设备发起连接。

- 多重连接和端点识别。TCP连接是由连接中的两个设备使用的一对套接字来识别的。这使得每个设备都可以打开多个连接，可以是同一个IP设备，也可以是不同的IP设备，并且可以独立处理每个连接而不发生冲突。

- 可靠的。使用TCP的通信据说是可靠的，因为TCP会跟踪已经发送和接收的数据，以确保它们都到达目的地。正如我们在上一主题中看到的，TCP不能真正 "保证 "数据总是被收到。然而，它可以保证所有发送的数据将被检查是否收到，并检查数据的完整性，然后在需要时重新传输。因此，虽然IP使用 "尽最大努力 "传输，但你可以说TCP更努力，就像古老的租车广告所说的那样。

- 认可。提供可靠性的一个关键是TCP的所有传输都被确认（在TCP层，TCP不能保证所有这些传输都被远程应用程序收到）。收件人必须告诉发件人 "是的，我收到了 "的每一条传输的数据。这与典型的信息传递协议形成了鲜明的对比，在后者中，发送方永远不知道它的传输发生了什么。正如我们将看到的那样，这对整个TCP的运行是至关重要的。

- 以流为导向。大多数下层协议被设计成这样，为了使用它们，上层协议必须以块的形式向它们发送数据。IP是这方面最好的例子；你给它发送一个需要格式化的消息，它就把这个消息放到一个数据报中。UDP也是如此。相比之下，TCP允许应用程序向它发送一个连续的数据流进行传输。应用程序不需要担心将其做成块状进行传输；TCP会这样做。

- 数据非结构化。TCP的数据流方向的一个重要结果是，在应用程序的数据流中，数据元素之间没有自然的划分。当多个消息通过TCP发送时，应用程序必须提供一种方法来区分一个消息（数据元素、记录等）和另一个消息。

- 数据流管理。TCP所做的不仅仅是将数据打包并尽可能快地发送。TCP连接被管理，以确保数据均匀和顺利地流动，并包括处理沿途出现的问题的方法。

**关键概念。**总结TCP的主要特点，我们可以说它是面向连接的、双向的、多重连接的、可靠的、确认的、面向流的和流动管理的。

<u>**稳健性原则**</u>

关于TCP还有一件事，与其说是其操作的特殊性，不如说是其创建背后的一般格言。TCP标准说，TCP遵循稳健性原则，它是这样描述的。"在你做的事情上要保守；在你接受别人的事情上要自由"。这意味着每个TCP实现都试图避免做任何会给另一个设备的TCP层带来问题的事情，同时也试图预测另一个TCP可能带来的问题并优雅地处理它们。

这一原则代表了一种 "腰带和吊带 "的方法，有助于为TCP操作中的异常情况提供额外保护。事实上，这个一般原则适用于TCP/IP套件中的许多其他协议，这也是多年来证明其能力的部分原因。它允许TCP和其他协议经常处理可能出现在像互联网这样的大型网络的困难环境中的意外问题。

<u>**审视TCP的性能**</u>
另外，当我们在讨论TCP的特性时，我想加强我在概述TCP和UDP时所说的另一件事。TCP有许多特性，但其中之一不是 "慢"。诚然，当应用程序不想处理TCP在连接和可靠性方面的开销时，UDP通常是出于性能的考虑而使用的。然而，这不应该导致人们得出结论说TCP是冰冷的，无论如何。事实上，它是相当高效的--如果不是这样，它就不可能获得如此广泛的使用。

##### 4.1.4.2 TCP基础知识和一般操作

许多人很难真正理解传输控制协议的工作原理。(在花了几十个小时写了近100页的协议后，我很有同感）。我认为难以理解TCP的一个主要原因是，太多关于该协议的描述从简单的介绍中迅速跳到TCP操作的令人费解的细节中。问题是，TCP有一种非常特别的方式来做某些事情。它的操作是围绕着一些非常重要的基本原理进行的，在了解TCP操作的细节之前，必须先了解这些原理。

在这一节中，我将描述TCP的一些关键操作基本原理。我首先讨论了TCP如何处理数据，并介绍了流、段和序列的概念。然后我描述了非常重要的TCP滑动窗口系统，用于确认、可靠性和数据流控制。我讨论了TCP如何使用端口，以及如何识别连接。我还描述了使用TCP的最重要的应用程序，以及它们对服务器应用程序使用的端口。

###### 4.1.4.2.1 TCP数据处理和加工: 流、段和序列号（部分：1 2 3 )

我们在OSI参考模型的上层发现的大多数协议的运作的一个 "先决条件 "是，它们是围绕着使用消息而展开的。这些消息类似于装在信封里的书面信件，包含了一个特定的信息。它们从上层传到下层，在那里被封装在下层的标头中（就像把它们放在另一个信封中），然后进一步向下传递，直到它们在物理层被实际发送出去。

看一下用户数据报协议，即TCP的传输层对等物，就可以看到一个很好的例子。为了使用UDP，一个应用程序向它传递一个通常相当短的数据块。该数据块被打包成一个UDP消息，然后被发送到IP。IP将消息打包成一个IP数据报，并最终将其传递给第二层协议，如以太网。在那里，它被放入一个帧，并被发送到第一层进行传输。

<u>**增加应用数据处理的灵活性。TCP的流导向**</u>
使用离散的消息传递是非常简单的，而且它显然工作得很好，因为大多数协议都在使用它。然而，它具有内在的局限性，因为它迫使应用程序创建离散的数据块以进行通信。有许多应用程序需要不断地发送信息，而这种方式并不适合创建 "块 "状的数据。还有一些应用程序需要分块发送数据，而这些数据大到无论如何也无法在低层作为单一消息发送。

为了使用像UDP这样的协议，许多应用将被迫人为地把他们的数据分成大小不一的消息，而这些消息对他们来说没有任何内在的意义。这将立即引入新的问题，要求应用程序做更多的工作。它将不得不跟踪什么数据在什么消息中，并替换任何丢失的数据。它需要确保信息能够以正确的顺序重新组合，因为IP可能会将它们错乱地传递。

当然，人们可以通过编程来完成这些工作，但这些功能已经是TCP负责的功能了，所以这没有什么意义。相反，TCP的设计者采取了非常聪明的方法，将TCP通用化，使其能够接受任何大小和结构的应用数据，而不要求它是离散的碎片。更具体地说，据说TCP将来自应用程序的数据视为一个流；因此，TCP被描述为面向流。每个应用程序将其希望传输的数据作为一个稳定的八进制（字节）流来发送。它不需要把它们分割成块，也不需要担心冗长的数据流会在互联网上传播。它只是向TCP "输送字节"。

<u>**TCP数据包装：分段**</u>

当然，TCP必须使用网络层协议（指互联网协议）来处理这些字节并发送它们。IP是一个面向消息的协议，而不是面向流。因此，我们只是把责任 "推给 "了TCP，它必须从应用程序中获取数据流，并将其划分为离散的消息供IP使用。这些消息被称为TCP段。

**注意：**作为一个旁观者，这是网络世界中最令人困惑的数据结构名称之一。从字典定义的角度看，把一个流的片段称为段是合理的，但大多数从事网络工作的人不认为一个消息是一个 "段"。在业界，这个词还指一段电缆或一个局域网的一部分，等等，所以要注意这个问题。

IP对TCP段的处理与所有其他离散消息的传输一样。它们被放置在IP数据报中，并传送到目的地设备。接收者将这些段解包并传给TCP，后者将其转换为字节流并发送给应用程序。这个过程如图202所示。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\tcpstreamsegment.png)

​                                                                        **图202: TCP数据流处理和分段打包**

TCP与大多数协议不同，因为它不要求使用它的应用程序在消息中向它发送数据。一旦建立了TCP连接，应用协议就可以向TCP发送稳定的字节流，不需要符合任何特定的结构。TCP将这些字节打包成段，这些段的大小是基于一些不同的参数。这些段被传递给IP，在那里它们被封装成IP数据报并被传输。接收设备对这一过程进行了反转：从IP数据报中删除段，然后从段中提取字节，作为字节流传递给适当的接收应用协议。

设备上的TCP层积累它从应用进程流中收到的数据。在定期的间隔中，它形成段，使用IP进行传输。段落的大小由两个主要因素控制。第一个问题是，段的大小有一个总体限制，选择它是为了防止在IP层出现不必要的碎片。这是由一个叫做最大网段大小（MSS）的参数控制的，该参数在连接建立期间确定。第二，TCP的设计是这样的：一旦建立了连接，每个设备都会告诉对方它在任何时候准备接受多少数据。如果这个值低于MSS值，就必须发送一个较小的段。这是下一个主题中描述的滑动窗口系统的一部分。

**关键概念。**TCP的设计是让应用程序以字节流的形式发送数据，而不是要求使用固定大小的消息。这为各种用途提供了最大的灵活性，因为应用程序不需要担心数据包装，可以发送任何大小的文件或消息。TCP负责将这些字节打包成称为段的信息。

<u>**TCP数据识别:序列号**</u>

TCP将来自应用程序的数据视为一个八位字节流，这对协议的运行有几个非常重要的影响。首先是与数据识别有关。由于TCP是可靠的，它需要跟踪它从一个应用中收到的所有数据，以确保它被目的地全部收到。此外，它必须确保数据是按照发送的顺序收到的，并且必须重新传输任何丢失的数据。

如果数据是以块状消息的形式传递给TCP的，那么通过给每个消息添加一个标识符来跟踪数据就相当简单了。然而，由于TCP是面向流的，因此必须对每个字节的数据进行识别。这似乎令人惊讶，但这实际上是TCP通过使用序列号所做的。每个字节的数据都被分配了一个序列号，用于在传输、接收和确认的过程中对其进行跟踪（尽管在实践中，许多字节的数据块是使用数据块开始和结束时的字节序列号来管理的）。这些序列号被用来确保以分段形式发送的数据被重新组合成由发送应用程序传输的原始数据流。它们是实现滑动窗口系统的必要条件，使TCP能够提供可靠性和数据流控制。

**关键概念。**由于TCP的工作对象是单个字节的数据，而不是离散的信息，因此它必须使用一种在字节层面上工作的识别方案来实现其数据传输和跟踪系统。这是通过给TCP处理的每个字节分配一个序列号来实现的。

<u>**应用数据定界的需要**</u>
TCP将传入的数据视为流的另一个影响是，使用TCP的应用程序收到的数据是无结构的。在传输时，一个数据流进入一个设备上的TCP，而在接收时，一个数据流回到接收设备上的应用程序。即使数据流被TCP分解成段进行传输，但这些段是TCP级别的细节，对应用程序是隐藏的。因此，当一个设备想发送多个数据段时，TCP没有提供任何机制来指示这些数据段之间的 "分界线"，因为TCP根本没有检查数据的含义。应用程序必须提供一种方法来做到这一点。

例如，考虑一个正在发送数据库记录的应用程序。它需要发送雇员数据库表中的579号记录，然后是581号记录和611号记录。它将这些记录发送到TCP，TCP将它们统统作为字节流处理。TCP会将这些字节打包成段，但其方式是应用程序无法预测的。有可能每个字节都会在不同的段中结束，但更有可能的是它们都在一个段中，或者每个段的一部分会在不同的段中结束，这取决于它们的长度。记录本身必须有某种明确的标记，以便接收设备可以知道一条记录在哪里结束，下一条记录在哪里开始。

**关键概念。**由于应用程序以字节流的形式向TCP发送数据，而不是预先包装好的消息，因此每个应用程序必须使用自己的方案来确定一个应用程序的数据元素在哪里结束，下一个开始。也就是上层应用再接收到数据时需要解码根据报文中定义的字段等待接收响应的报文大小然后进行应用处理

###### 4.1.4.2.2 用于数据传输、可靠性和流量控制的TCP滑动窗口确认系统（部分：1 2 3 4 5 6 7 8 9）

传输控制协议与UDP等简单传输协议的区别在于它在设备间发送数据的方式的质量。TCP不是把数据塞进信息中然后说 "你走吧"，而是仔细地跟踪它所发送的数据和它的情况。这种对数据的管理是为了促进该协议的两个关键要求。

- 可靠性。确保发送的数据真正到达目的地，如果没有，则检测并重新发送数据。

- 数据流控制。管理数据的发送速度，使其不至于使接收数据的设备不堪重负。

为了完成这些任务，该协议的整个操作是围绕着一个叫做滑动窗口确认系统的东西进行的。毫不夸张地说，理解滑动窗口的工作原理对于理解TCP中的其他内容至关重要。不幸的是，如果你想一下子掌握它，也是有点困难的，这意味着许多人在试图理解它时眼睛都花了。

由于不了解滑动窗口就无法真正理解TCP，所以我想确保彻底解释这一机制--而不像大多数参考资料那样，假定你已经了解了很多东西。出于这个原因，我将从滑动窗口背后的概念开始，并最终解释该技术如何在一般情况下工作，以及为什么它如此强大。要正确地做到这一点，需要相当多的解释（我可以补充说，花了很长时间才得到正确的解释！）所以请系好安全带。😄

<u>**不可靠的协议的问题。缺少反馈**</u>

像IP这样简单的 "发送和忘记 "协议是不可靠的，并且不包括流量控制，主要原因是：它是一个开放的循环系统，发送方没有收到接收方的反馈。(在此讨论中，我忽略了使用ICMP等的错误报告。) 一个数据报被发送，它可能到达，也可能没有到达，但发送方永远没有办法知道，因为没有反馈机制存在。这在图203中作了概念性的说明。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\tcpswunack.png)

​                                                                                   <u>**图203：不可靠的协议的操作**</u>

在诸如IP所使用的系统中，如果它到达了那里，那就太好了；否则，没有人会有任何线索。J 需要一些外部机制来处理丢失的信息，除非该协议并不真正关心它的信息流中是否缺少一些比特和碎片。

<u>**使用带重传的积极确认（PAR）提供基本可靠性**</u>

在像IP这样不可靠的协议上运行的协议的基本可靠性可以通过关闭循环来实现，这样收件人就会向发件人提供反馈。这一点最容易通过一个简单的确认系统来实现。设备A向设备B发送一段数据。设备B在收到数据后，发回一个确认函，说："设备A，我收到了你的信息"。然后，设备A知道它的传输是成功的。

当然，由于IP是不可靠的，该信息事实上可能永远不会到达它要去的地方。设备A将坐在那里等待确认，但永远不会收到它。相反，也有可能设备B从设备A那里得到了消息，但确认本身却以某种方式消失了。在这两种情况下，我们都不希望设备A永远坐在那里等待一个永远不会到达的确认。

为了防止这种情况的发生，设备A在第一次向设备B发送消息时启动了一个定时器，这使得消息有足够的时间到达B，确认也有足够的时间返回，再加上一些合理的时间来考虑可能出现的延迟。如果计时器在收到确认之前就过期了，A就会认为有问题，并重新发送其原始信息。由于这种方法涉及积极的确认（"是的，我收到了你的信息"）和需要时的重传设施，它通常被称为（ta-da！）带重传的积极确认（PAR），如图204所示。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\tcpswpar.png)

​                                                        **图204: 基本可靠性。带有重发的积极确认（PAR）。**

这张图显示了确保可靠性的最常见的简单技术之一。每次设备A发送消息时，它都会启动一个计时器。设备B在收到信息时向设备A发送确认信息，以便设备A知道信息被成功传送。如果消息丢失，定时器就会关闭，A就会重新传输数据。请注意，**在任何时候都只能有一条消息未被发送**，这使得这个系统相当缓慢。

<u>**关键概念。**</u>确保通信可靠性的一个基本技术是使用一个规则，要求设备在每次成功接收一个传输时都要发回一个确认信息。如果一个传输在一段时间后没有被确认，它将被其发送者重新传输。这个系统被称为正向确认与重传（PAR）。这个基本方案的一个缺点是，在第一个信息被确认之前，发送方不能发送第二个信息。

<u>**通过消息识别和发送限制提高PAR的效用**</u>

PAR是一种在网络和通信中广泛使用的技术，用于交换相对较小的数据量或不经常交换数据的协议。这种基本方法是可行的，但由于两个原因，它不太适合像TCP这样的协议。第一个原因是它的效率低下。设备A发送一个消息，然后等待确认。设备A不能向设备B发送另一个消息，直到它听到它的原始消息被收到，这是非常浪费的，会使协议变得非常慢。

我们可以对这个系统进行的第一个改进是为发送的消息和确认提供一些识别手段。例如，我们可以在消息头中加入一个消息ID字段。发送消息的设备将唯一地识别它，而收件人将在确认中使用这个标识符。例如，设备A可能在消息中发送一个数据，消息ID为#1。设备B将收到该消息，然后将自己的消息发回给设备A："设备A，我收到你的消息#1"。这个系统的优点是，设备A可以同时发送多个消息。它必须跟踪每一条发送的信息，以及它是否被确认。每一条也需要一个单独的定时器，但这并不是一个大问题。

当然，我们也需要从设备B的角度考虑这种交换。以前，它每次只需要处理来自设备A的一个信息，现在它可能会有几个信息同时出现。如果它已经忙于处理来自另一个设备（或十个）的传输怎么办？我们需要一些机制，让设备B说 "我只愿意一次处理来自你的以下数量的消息"。我们可以通过让确认信息包含一个字段来做到这一点，例如发送限制，它规定了A允许在同一时间内传输给B的未确认信息的最大数量。

设备A将使用这个发送限制字段来限制它向设备B发送消息的速度。设备B可以根据其当前的负载和其他因素来调整这个字段，以便在与设备A的讨论中实现性能最大化。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\tcpswparid.png)

​                                                                    **图205: 增强的带重传的正向确认（PAR)**

这张图显示了对图204的基本PAR方案的两项增强。首先，每个信息现在都有一个识别号；每个信息都可以被单独确认，所以在给定时间内可以有多个信息在传输中。第二，设备B定期向A传达一个发送限制参数，该参数限制了A可以同时拥有的信息数量。B可以调整这个参数以控制来自A的数据流。

**关键概念。**基本的PAR可靠性方案可以通过识别每条要发送的信息而得到加强，因此多条信息可以同时在传输中。使用发送限制允许该机制也提供流量控制能力，允许每个设备控制它被发送数据的速度。

<u>**TCP的面向流的滑动窗口确认系统**</u>

那么，TCP是否使用这种PAR的变体？当然不是! 那就太简单了。实际上，TCP的滑动窗口系统在概念上与这种方法非常相似，这就是为什么我们要了解它的重要性。然而，它需要一些调整。主要原因与TCP处理数据的方式有关：与上一主题中讨论的消息导向相比，流导向的问题。我们所概述的技术涉及明确的确认和（如果需要）消息的重传。因此，对于在相当不频繁的基础上交换相当大的消息的协议来说，它可以很好地工作。

另一方面，TCP将单个字节的数据作为一个流来处理。一次传输一个字节，一次确认一个字节，这显然是很荒谬的。它需要太多的工作，而且即使是重叠传输（在发送下一个数据之前不等待确认），结果也会慢得可怕。

当然，这就是为什么TCP不单独发送字节，而是将它们分成若干段。一个网段中的所有字节一起发送，一起接收，因此一起确认。TCP使用我们上面描述的方法的一个变种，即使用我们在上一主题中讨论的序列号来识别发送和确认的数据。我们不使用类似消息ID字段的确认，而是使用段中最后一个数据字节的序列号来确认数据。因此，我们在每种情况下都要处理一个字节的范围，这个范围代表段中所有字节的序列号。

**TCP传输流的概念性划分**
想象一下设备A和设备B之间新建立的TCP连接，设备A有一个很长的字节流要传输，但设备B不能一次全部接受。所以它限制设备A一次发送特定数量的字节，直到已经发送的字节被确认。然后，设备A被允许发送更多的字节。每个设备都会跟踪哪些字节已经发送，哪些没有发送，哪些已经被确认。

在任何时间点上，我们都可以对这个过程进行 "快照"。如果我们这样做，我们可以从概念上将发送TCP在其缓冲区内的字节分为四类，作为一个时间轴来看（图206）。

1. 发送和确认的字节。流中最早的字节将被发送和确认。从发送数据的设备的角度来看，这些字节基本上是 "完成 "了。例如，让我们假设31个字节的数据已经被发送和确认。这些将属于1号类别。

2. 已发送但尚未确认的字节。这些是设备已经发送但尚未收到确认的字节。发件人在收到确认之前，不能认为这些字节已经 "完成"。比方说，这里有14个字节，属于第2类。

3. 尚未发送的字节，收件人已准备好。这些是尚未发送的字节，但根据收件人最近向发件人发出的关于它愿意一次处理多少字节的信息，收件人有空间接收这些字节。发送方将尝试立即发送这些字节（受制于我们将在后面探讨的某些算法限制）。假设第3类中有6个字节。

4. 尚未发送的字节，收件人还没有准备好。这些是更远的 "下游 "的字节，由于接收方还没有准备好，所以发送方还不允许发送。第4类中有44个字节。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\tcpswcategories.png)

​                                                                        **图206: TCP传输流的概念性分类**

**注意：**我在这里使用非常小的数字，以保持例子的简单性（并使图表更容易构建！）TCP通常不会因为效率的原因而发送小数量的字节。

接收设备使用类似的系统来区分收到并确认的数据、尚未收到但准备接收的数据以及尚未收到和尚未准备接收的数据。事实上，这两个设备都维护着一组单独的变量，以跟踪字节在它们所发送的数据流和它们所接收的数据流中的类别。这将在描述详细的滑动窗口数据传输程序的主题中进行探讨（是的，这个主题甚至还有更多！）。

**关键概念。**TCP滑动窗口系统是增强型PAR系统的一个变种，为支持TCP的流导向而做了改变。每个设备都跟踪它需要传输的字节流的状态，将它们分为四个概念类别：已发送并确认的字节、已发送但尚未确认的字节、尚未发送但可立即发送的字节，以及尚未发送的字节，在接收方发出信号说它已准备好之前不能发送。

<u>**序列号的分配和同步化**</u>

发送方和接收方必须就分配给流中字节的序列号达成一致。这被称为同步，在建立TCP连接时完成。为简单起见，让我们假设第一个字节是以序列号1发送的（通常不是这样）。因此，在我们的例子中，四个类别的字节范围是。

1. 已发送和确认的字节。字节1至31。

2. 已发送但尚未确认的字节。字节32至45。

3. 尚未发送的字节，收件人已准备好。字节46至51。

4. 尚未发送的字节，收件人尚未准备好。字节52至95。

<u>**发送窗口和可用窗口**</u>
整个过程操作的关键是收件人允许发送者在同一时间拥有未确认的字节数。这被称为发送窗口，或者通常只是窗口。窗口是决定允许发送方传输多少字节的因素，它等于第2类和第3类的字节数之和。因此，后两类（收件人准备好的未发送的字节和未准备好的字节）之间的分界线是由窗口与流中第一个未确认的字节的字节数相加决定的。在我们上面的例子中，第一个未确认的字节是#32。总的窗口大小为20。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\tcpswwindows.png)

​                                                                      图207: TCP传输流类别和发送窗口术语

该图显示了与图206相同的类别，同时还标明了发送窗口。黑框是整个发送窗口（类别#2和#3合并）；灰色代表已经发送的字节（类别#2），红框是可用窗口（类别#3）。

可用窗口一词被定义为考虑到未发送的数据量，发射器仍被允许发送的数据量。因此，它正好等于第3类的大小。你可能还经常听到有人提到窗口的边缘。左边的边缘标志着窗口的第一个字节（上面的第32字节）。右边的边缘标志着窗口中的最后一个字节（第51字节）。请参阅图207，了解这些概念的图解。

**关键概念。**发送窗口是整个TCP滑动窗口系统的关键：它代表了一个设备被允许同时拥有的未确认字节的最大数量。可用窗口是指发送方在任何时候仍被允许发送的发送窗口的数量；它等于发送窗口的大小减去已经发送的未确认字节的数量。

<u>**在可用窗口中发送字节后TCP类别和窗口大小的变化**</u>

现在，让我们假设在上面的例子中，没有任何东西可以阻止发送方立即发送3号类别（可用窗口）中的6个字节。当它这样做时，这6个字节将从3号类别转移到2号类别。现在的字节范围将如下（图208）。

1. 发送和确认的字节。字节1至31。

2. 已发送但尚未确认的字节。字节32至51。

3. 收件人准备好的尚未发送的字节。无。

4. 尚未发送的字节，收件人尚未准备好。字节52至95。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\tcpswaftersendnow.png)

​                                                            **图208: 发送可用窗口字节后的TCP流类别和窗口**

该图显示了设备发送其可用窗口中允许传输的所有字节的结果。它与图207相同，只是类别3中的所有字节被移到类别2中。可用窗口现在是零，并将保持这一状态，直到收到对类别2的字节的确认。

<u>**处理确认和滑动发送窗口**</u>

一段时间后，目标设备会向发送方发回一条消息，提供确认信息。它不会特别列出已经确认的字节，因为正如我们之前所说，这样做效率很低。相反，它将确认一个字节的范围，该范围代表自它之前确认的字节以来收到的最长的连续字节序列。

例如，让我们假设在本例开始时已经发送但尚未确认的字节（32至45）是在四个不同的段中传输的。这些段分别传输了字节32至34、35至36、37至41和42至45。第一、第二和第四段到达，但第三段没有。接收方将只对字节32至36（32-34和35-36）发回一个确认函。它将保留字节42至45，但不确认它们，因为这将意味着收到字节37至41，这些字节还没有出现。这是必要的，因为TCP是一个累积确认系统，它只能使用一个单一的数字来确认数据，即成功收到的流中最后一个连续字节的数字。我们还假设目的地保持窗口大小不变，为20字节。

注意：一个叫做选择性确认的可选功能确实允许非连续的数据块被确认。这将在后面的一个单独的主题中解释；我们现在将忽略这个复杂的问题。

当发送设备收到这个确认时，它将能够把一些字节从第2类转移到第1类，因为它们现在已经被确认。当它这样做时，有趣的事情就会发生。由于五个字节已经被确认，而且窗口大小没有改变，发送者被允许再发送五个字节。实际上，窗口在时间轴上向右移动，或滑动。在五个字节从2号类别移到1号类别的同时，五个字节从4号类别移到3号类别，为后续传输创造了一个新的可用窗口。因此，在收到确认后，这些组将看起来像这样（图209）。

1. 已发送和确认的字节。字节1至36。

2. 已发送但尚未确认的字节。字节37至51。

3. 收件人准备好的尚未发送的字节。字节52至56。

4. 尚未发送的字节，收件人尚未准备好。字节57至95。

这个过程将在每次收到确认时发生，导致窗口滑过整个要传输的流。因此，女士们、先生们，我们有了TCP的滑动窗口确认系统。这是一种非常强大的技术，它允许TCP使用一个确认号码轻松地确认任意数量的字节，从而为面向字节的协议提供可靠性，而不需要在过多的确认上花费时间。为简单起见，上面的例子让窗口大小保持不变，但实际上它可以被调整，以允许收件人控制数据发送的速度，实现流量控制和拥塞处理。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\tcpswslide.png)

​                                                                                         <u>**图209: 滑动TCP发送窗口**</u>

在收到第32至36字节的确认后，它们从第2类移到第1类。图208的发送窗口向右滑动5个字节；将5个字节从4号类别移到3号类别，打开一个新的可用窗口。

**关键概念。**当设备得到一个字节范围的确认时，它知道它们已经被目的地成功接收。它把它们从 "已发送但未确认 "移到 "已发送并确认 "类别。这导致发送窗口向右滑动，允许设备发送更多数据。

<u>**处理缺失的确认信息**</u>

但是，等等......我们的例子中的第42至45字节怎么办？好吧，在第3段（包含字节37至41）出现之前，接收设备不会为这些字节发送确认，也不会为其后出现的任何其他字节发送确认。发送方将能够发送添加到第3类的新字节：第52至56字节。然后它将停止，窗口 "卡 "在字节37至41上。

当然，像任何PAR系统一样，TCP包括一个定时传输和重传的系统。最终，TCP设备将重新发送丢失的数据段，希望这一次它能再次到达。不幸的是，TCP的一个缺点是，由于它不单独确认分段，这可能意味着重发收件人实际收到的其他分段（如带有字节42至45的分段）。这就开始变得非常复杂了，在关于TCP重传的专题中讨论过。

**关键概念。**TCP确认是累积性的，它告诉发送方，直到确认中显示的序列号的所有字节都被成功接收。因此，如果字节的接收顺序不对，在收到所有前面的字节之前，它们不能被确认。TCP包括一种对传输进行计时的方法，并在必要时对丢失的片段进行重传。

<u>**关于TCP滑动窗口的更多信息**</u>
我应该明确指出，尽管这个话题很长，但前面的内容只是对滑动窗口整体操作的一个总结性描述，并不包括现代TCP中使用的所有修改! 正如你所看到的，滑动窗口机制是整个TCP操作的核心。

在描述网段和讨论数据传输的部分，我们将更详细地看到TCP发送器如何决定如何以及何时创建网段进行传输。描述TCP的可靠性和数据流控制功能的部分将提供更多关于滑动窗口如何使设备管理TCP连接上的数据流的信息。它还讨论了如果不仔细管理窗口大小可能出现的特殊问题，以及在TCP实现中如何通过对本主题中描述的基本滑动窗口机制的关键变化来避免拥堵等问题。

###### 4.1.4.2.3 TCP端口、连接和连接识别（部分：1 2）

两种TCP/IP传输层协议，即TCP和UDP，在协议套件中发挥着相同的架构作用，但却以非常不同的方式进行。事实上，这两个协议为数不多的共同功能之一是提供一种传输层寻址和复用的方法。通过使用端口，这两个协议允许来自许多不同的应用进程的数据被聚集起来，并通过IP层发送，然后沿着堆栈返回到目标设备上的适当的应用进程。这在描述端口和套接字的章节中都有详细解释。

尽管有这个共同点，TCP和UDP甚至在处理进程的方式上也有一些分歧。UDP是一个无连接协议，这当然意味着设备在发送数据之前不会建立一个正式的连接。UDP不需要使用滑动窗口，也不需要跟踪发送后有多长时间了等等。当设备上的UDP层收到数据时，它只是将其发送给目的端口所指示的进程，就这样。它可以无缝地处理任何数量的进程向它发送消息，因为它们的处理方式是相同的。

<u>**连接处理的责任**</u>
由于TCP是面向连接的，它有更多的责任。每个TCP软件层都需要能够同时支持与其他几个TCP的连接。每个连接的操作与其他连接是分开的，TCP软件必须独立管理每个连接。它不仅要确保数据被路由到正确的进程，还要确保在每个连接上传输的数据被管理，没有任何重叠或混淆。

<u>**连接识别**</u>
这方面的第一个结果是，每个连接必须被唯一地识别。这是通过使用对应于连接的两个端点的一对套接字标识来实现的，其中套接字是每个进程的IP地址和端口号的简单组合。这意味着一个套接字对包含四个信息：源地址、源端口、目标地址。因此，TCP连接有时被说成是由这个寻址四要素描述的。

我在关于TCP/IP套接字的一般主题中介绍了这一点，我举了一个例子，即从177.41.72.6的客户端向41.199.222.3的网站发送一个HTTP请求。该网站的服务器将使用众所周知的80号端口，因此其套接字是41.199.222.3:80。如果客户端已经为Web浏览器分配了临时端口号3,022，那么客户端的套接字就是177.41.72.6:3022。这些设备之间的整体连接可以用这个套接字对来描述。

(41.199.222.3:80, 177.41.72.6:3022)

<u>**多重连接管理**</u>

这种使用客户和服务器套接字的连接识别，正是提供了我们在互联网上认为理所当然的、允许设备间多连接的灵活性。例如，繁忙的应用服务器进程（如Web服务器）必须能够处理来自一个以上的客户端的连接，否则万维网将几乎无法使用。由于连接是用客户的套接字和服务器的套接字来识别的，所以这没有问题。在Web服务器维护上面提到的连接的同时，它可以很容易地有另一个连接，比如说IP地址为219.31.0.44的2199端口。这是由连接标识符表示的。

​              (41.199.222.3:80, 219.31.0.44:2199).
事实上，我们可以有多个连接从同一个客户端到同一个服务器。每个客户端进程将被分配一个不同的短暂端口号，所以即使它们都试图访问同一个服务器进程（例如位于41.199.222.3:80的Web服务器进程），它们都会有一个不同的客户端套接字，并代表独特的连接。这就是让你从你的计算机向同一个网站同时发出几个请求的原因。

同样，TCP独立地跟踪每一个连接，所以每一个连接都不知道其他连接的情况。TCP可以处理数以百计甚至数以千计的同时连接。唯一的限制是运行TCP的计算机的容量，以及与之相连的物理连接的带宽--同时运行的连接越多，每个连接就越需要分享有限的资源。

**关键概念。**每个设备都可以处理与一个或多个设备上的许多不同进程同时进行的TCP连接。每个连接由连接中的设备的套接字号码来识别，称为连接的端点。每个端点由设备的IP地址和端口号组成，因此每个连接由客户端IP地址和端口号，以及服务器IP地址和端口号的四重性来识别。

###### 4.1.4.2.4 TCP常见应用和服务器端口分配

我们在TCP的概述中看到，该协议最初包括现代TCP和互联网协议的功能。TCP被拆分为TCP和IP，以使那些不需要TCP的复杂性的应用程序能够绕过它，而使用简单得多的UDP作为传输层协议。这是TCP/IP协议套件发展过程中的重要一步，因为有几个重要的协议是UDP的理想选择，甚至有些协议是TCP的麻烦多于好处。

然而，最常见的是，UDP只在特殊情况下使用。UDP应用主题描述了两类可能比TCP更适合使用UDP的协议：一类是速度比可靠性更重要的协议，另一类是不经常发送短消息的协议。大多数TCP/IP应用不属于这些类别。因此，尽管TCP和IP的分层意味着大多数协议不需要使用TCP，但它们中的大多数还是使用的。大多数使用它的协议都采用了它所提供的全部或至少大部分功能。对于许多交互式协议，如Telnet，以及那些发送命令和状态回复的协议，如HTTP，建立一个持久的连接是必要的。可靠性和流量控制对于发送大文件的协议是必不可少的，如FTP或电子邮件协议。

表150显示了一些在TCP上运行的更重要的应用协议。我为每个协议显示了为该协议的服务器进程保留的知名或注册的端口号（客户端使用的是临时端口，而不是表中的端口号）。我还显示了每个端口分配的特殊 "关键字 "快捷方式，并提供了关于该协议为什么与TCP良好匹配的简短评论。

​                                                               **表150: 常见的TCP应用和服务器端口分配**

| **Port #**      | **Keyword**    | **Protocol**                                        | **Comments**                                                                                                                                                     |
| --------------- | -------------- | --------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **20 and 21**   | ftp-data / ftp | File Transfer Protocol (FTP, data and control)      | Used to send large files, so ideally suited for TCP.                                                                                                             |
| **23**          | telnet         | Telnet Protocol                                     | Interactive session-based protocol. Requires the connection-based nature of TCP.                                                                                 |
| **25**          | smtp           | Simple Mail Transfer Protocol (SMTP)                | Uses an exchange of commands, and sends possibly large files between devices.                                                                                    |
| **53**          | domain         | Domain Name Server (DNS)                            | An example of a protocol that uses both UDP and TCP. For simple requests and replies, DNS uses UDP. For larger messages, especially zone transfers, TCP is used. |
| **70**          | gopher         | Gopher Protocol                                     | A messaging protocol that has been largely replaced by the WWW.                                                                                                  |
| **80**          | http           | Hypertext Transfer Protocol (HTTP / World Wide Web) | The classic example of a TCP-based messaging protocol.                                                                                                           |
| **110**         | pop3           | Post Office Protocol (POP version 3)                | E-mail message retrieval protocols; use TCP to exchange commands and data.                                                                                       |
| **119**         | nntp           | Network News Transfer Protocol (NNTP)               | Used for transferring NetNews (USEnet) messages, which can be lengthy .         用于传输可能很长的 NetNews (USEnet) 消息。                                                   |
| **139**         | netbios-ssn    | NetBIOS Session Service                             | A session protocol, clearly better suited to TCP than UDP.                                                                                                       |
| **143**         | imap           | Internet Message Access Protocol (IMAP)             | Another e-mail message retrieval protocol.                                                                                                                       |
| **179**         | bgp            | Border Gateway Protocol (BGP)                       | RIP 和 OSPF 等内部路由协议直接使用 UDP 或 IP，而 BGP 则通过 TCP 运行。这允许 BGP 假定可靠的通信，即使它在可能的长距离上发送数据。                                                                                |
| **194**         | irc            | Internet Relay Chat (IRC)                           | IRC 与 Telnet 类似，因为它是一个交互式协议，它强烈基于客户端和服务器之间的持久连接的概念。                                                                                                              |
| **2049**        | nfs            | Network File System (NFS)                           | 出于性能原因，NFS 最初是使用 UDP 实现的。鉴于它负责大量文件传输并且 UDP 不可靠，这可能不是最好的主意，因此创建了 TCP 版本。最新版本的 NFS 专门使用 TCP。                                                                       |
| **6000 - 6063** | TCP            | x11                                                 | 用于 X Window 图形系统。多个端口专用于允许许多会话。                                                                                                                                  |

上表中的几个协议同时使用TCP和UDP，以获得 "两全其美 "的效果。短的、简单的信息可以用UDP发送，而较大的文件则用TCP移动。许多同时使用TCP和UDP的协议实际上是实用/诊断协议（如Echo、Discard和时间协议）。这些是一个特例，因为它们被设计为同时使用UDP和TCP，特别是允许它们在两个协议上用于诊断。

我没有在上面列出TCP应用的详尽清单；请看关于常见的TCP/IP应用和端口号的主题，其中还包含一个指向TCP知名和注册服务器端口的完整（大量）清单的指针。

##### 4.1.4.3 TCP的基本操作。连接的建立、管理和终止

虽然我把传输控制协议描述为面向连接，但这个术语并不是TCP的 "任何旧特性"。整个协议的整体运作可以用TCP软件如何准备、协商、建立、管理和终止连接来描述。TCP实现当然不仅仅是处理连接，但它们执行的其他主要任务，如数据处理、提供可靠性和流量控制，只能在稳定的连接上发生。这使得连接成为探索TCP如何工作的细节的逻辑起点。

在本节中，我将从头到尾描述TCP连接。我首先概述了TCP的操作，提供了一个正式定义连接阶段的有限状态机的摘要。当你在标准中读到状态机时，可能会感到有点匪夷所思，但简化版的状态机为连接的 "生命 "提供了一个很好的高层视图，所以它是一个很好的开始。

从那里，我继续提供关于TCP处理连接的细节。我描述了如何准备连接和设置传输控制块（TCB），以及被动和主动套接字打开之间的区别。我解释了用于创建连接的三方握手，以及交换参数和同步序列号的方法。我讲述了如何管理一个已建立的连接，包括TCP处理问题条件和在必要时重置连接的方法。最后，我描述了当一个连接不再需要时如何终止它。

背景信息。本节的详细主题假定你熟悉前面基本原理部分的概念，特别是序列号的概念。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\TCPStateTransitionDiagram.gif)

###### 4.1.4.3.1 TCP操作概述和TCP有限状态机（FSM）（部分：1 2 3 )

所有实施任何网络协议的设备都必须以一致的方式进行。否则，一个设备可能会以另一个设备意想不到的方式行事。自然，这就是为什么有标准来描述每个协议的操作。像TCP这样的协议的问题是，它执行的任务太多，很难简明扼要地说明协议所有方面的确切操作。

<u>**使用有限状态机来解释复杂的协议**</u>
计算机科学家解释复杂协议工作方式的一种方法是通过一种叫做有限状态机（FSM）的理论工具。FSM试图描述一个协议或算法，把它看作是一个虚拟的 "机器"，通过一系列的操作阶段来应对各种情况的发生。你需要了解四个基本概念来理解有限状态机的工作原理。

- 状态。特定的 "情况 "或 "状态"，描述了机器在特定时间的协议软件。

- 过渡。从一个状态转移到另一个状态的行为。

- 事件。导致状态之间发生转换的东西。

- 行动。设备在过渡到另一个状态之前对一个事件的反应。

FSM通过解释协议可能处于的所有不同状态、每个状态下可能发生的事件、响应事件的行动以及结果发生的转换来描述协议。然后，它遵循一连串的步骤，使其进入一个正常的运行状态，并根据特定类型的输入或其他情况移动到其他状态。状态机被称为有限的，因为只有有限数量的状态。

**关键概念。**许多计算机科学家用来描述协议或算法操作的工具是有限状态机。它通过定义有限数量的运行状态、可导致状态间转换的事件以及对事件的响应行动，来描述一个软件在一段时间内采取的不同行动。

<u>**简化的TCP有限状态机**</u>

在TCP的情况下，有限状态机可以被认为是描述连接的 "生命阶段"。一个TCP设备和另一个设备之间的每个连接都是从没有连接的空状态开始的，然后经过一系列的状态，直到建立一个连接。它一直处于这种状态，直到有事情发生导致连接再次被关闭，这时它将经过另一连串的过渡状态并返回到关闭状态。

对TCP连接中的状态、事件和转换的完整描述是冗长而复杂的--这并不奇怪，因为这将涵盖整个TCP标准的大部分内容。对于我们的目的来说，这种程度的细节是治疗失眠的良药，但没有其他的作用。然而，对TCP FSM的简化考察将有助于我们对TCP如何建立连接以及连接建立后的功能有一个很好的整体感觉。

表151简要描述了TCP连接中的每一个TCP状态，还描述了每个状态下发生的主要事件，以及因此而发生的动作和转换。为简洁起见，对控制状态间转换的三种类型的消息使用了三个缩写，它们与TCP头的标志相对应，这些标志被设置为指示消息正在发挥该功能。这些是

- SYN：一个同步消息，用于启动和建立连接。之所以这样命名，是因为其功能之一是在设备之间同步序列号。

- FIN：一个结束消息，它是一个设置了FIN位的TCP段，表示一个设备想终止连接。

- ACK：一个确认，表示收到一个消息，如SYN或FIN。

同样，我没有显示每一种可能的转换，只是显示了在连接过程中通常遵循的转换。错误条件也会导致转换，但包括这些将使我们远远超出 "简化 "状态机。图210中也展示了FSM，你可能会发现它更容易看到状态转换是如何发生的。

​                                                       **表151: TCP有限状态机（FSM）状态、事件和转换**

| **State**           | **State Description**                                                                                               | **Event and Transition**                                                                                                                                                                                                                                                                                          |
| ------------------- | ------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ***CLOSED\***       | 这是每个连接在建立过程开始之前开始的默认状态。该状态在标准中被称为“虚构”。原因是这种状态代表了设备之间没有连接的情况——它要么尚未创建，要么刚刚被销毁。如果这是有道理的。                              | **Passive Open:** 被动打开：服务器通过在 TCP 端口上进行被动打开来开始连接设置过程。同时，它建立了管理连接所需的数据结构（传输控制块或TCB）。然后它转换到 LISTEN 状态。                                                                                               **Active Open, Send \*SYN\*:**主动打开，发送 SYN：客户端通过发送 SYN 消息开始连接建立，并为此连接建立 TCB。然后它转换到 SYN-SENT 状态。                 |
|                     |                                                                                                                     |                                                                                                                                                                                                                                                                                                                   |
| ***LISTEN\***       | 设备（通常是服务器）正在等待接收来自客户端的同步 (SYN) 消息。它还没有发送自己的 SYN 消息。                                                                 | **Receive Client \*SYN\*, Send \*SYN+ACK\*:** 接收客户端 SYN，发送 SYN+ACK：服务器设备接收来自客户端的 SYN。它发回一条包含自己的 SYN 的消息，并确认它收到的消息。服务器进入 SYN-RECEIVED 状态。                                                                                                                                                                          |
| ***SYN-SENT\***     | 设备（通常是客户端）已发送同步 (SYN) 消息，并正在等待来自其他设备（通常是服务器）的匹配 SYN。                                                                | **Receive \*SYN\*, Send \*ACK\*:** 接收 SYN，发送 ACK：如果发送了 SYN 消息的设备从其他设备收到 SYN，但没有收到自己 SYN 的 ACK，它会确认收到的 SYN，然后转换到 SYN-RECEIVED 以等待确认它的SYN。                                      **Receive \*SYN+ACK\*, Send \*ACK\*:** 接收 SYN+ACK，发送 ACK：如果发送 SYN 的设备同时收到对其 SYN 的确认以及来自其他设备的 SYN，它会确认收到的 SYN，然后直接进入 ESTABLISHED 状态。 |
|                     |                                                                                                                     |                                                                                                                                                                                                                                                                                                                   |
| ***SYN-RECEIVED\*** | 设备既收到了来自其伙伴的 SYN（连接请求），又发送了自己的 SYN。它现在正在等待对其 SYN 的 ACK 以完成连接设置。                                                     | **Receive \*ACK\*:** 接收 ACK：当设备接收到它发送的 SYN 的 ACK 时，它会转换到 ESTABLISHED 状态。                                                                                                                                                                                                                                          |
| ***ESTABLISHED\***  | 打开的 TCP 连接的“稳定状态”。一旦连接中的两个设备都进入此状态，就可以自由交换数据。这将一直持续到连接因某种原因关闭。                                                      | **Close, Send \*FIN\*:** 关闭，发送 FIN：设备可以通过发送带有 FIN（完成）位的消息来关闭连接，并转换到 FIN-WAIT-1 状态。                                                               **Receive \*FIN\*:** 接收 FIN：设备可能会收到来自其连接伙伴的 FIN 消息，要求关闭连接。它将确认此消息并转换到 CLOSE-WAIT 状态。                                                                             |
|                     |                                                                                                                     |                                                                                                                                                                                                                                                                                                                   |
| ***CLOSE-WAIT\***   | 设备已收到来自其他设备的关闭请求 (FIN)。它现在必须等待本地设备上的应用程序确认此请求并生成匹配请求。                                                               | **Close, Send \*FIN\*:** 关闭，发送 FIN：使用 TCP 的应用程序在被告知其他进程想要关闭后，向正在运行它的机器上的 TCP 层发送关闭请求。然后 TCP 向已经要求终止连接的远程设备发送一个 FIN。该设备现在转换到 LAST-ACK。                                                                                                                                                                             |
| ***LAST-ACK\***     | 已经收到关闭请求并确认它的设备已经发送了自己的 FIN 并正在等待对该请求的 ACK。                                                                         | **Receive \*ACK\* for \*FIN\*:** 为 FIN 接收 ACK：设备收到其关闭请求的确认。我们现在已经发送了我们的 FIN 并得到了确认，并收到了另一个设备的 FIN 并确认了它，所以我们直接进入 CLOSED 状态。                                                                                                                                                                                       |
| ***FIN-WAIT-1\***   | 处于此状态的设备正在等待其发送的 FIN 的 ACK，或者正在等待来自其他设备的连接终止请求。                                                                     | **Receive \*ACK\* for \*FIN\*:** 为 FIN 接收 ACK：设备收到其关闭请求的确认。它转换到 FIN-WAIT-2 状态。           **Receive \*FIN\*, Send \*ACK\*:** 接收 FIN，发送 ACK：设备不接收自己 FIN 的 ACK，而是接收来自其他设备的 FIN。它承认它，并移动到 CLOSING 状态。                                                                                                                 |
|                     |                                                                                                                     |                                                                                                                                                                                                                                                                                                                   |
| ***FIN-WAIT-2\***   | 处于此状态的设备已收到终止连接请求的 ACK，现在正在等待来自其他设备的匹配 FIN。                                                                         | **Receive \*FIN\*, Send \*ACK\*:** 接收 FIN，发送 ACK：设备从其他设备接收 FIN。它确认它并进入 TIME-WAIT 状态。                                                                                                                                                                                                                              |
| ***CLOSING\***      | 该设备已收到来自其他设备的 FIN 并为其发送了 ACK，但尚未收到自己的 FIN 消息的 ACK。                                                                  | **Receive \*ACK\* for \*FIN\*:** 为 FIN 接收 ACK：设备收到其关闭请求的确认。它转换到 TIME-WAIT 状态。                                                                                                                                                                                                                                     |
| ***TIME-WAIT\***    | 该设备现在已经从另一个设备接收到一个 FIN 并对其进行确认，并发送了自己的 FIN 并收到了一个 ACK。我们完成了，除了等待确保收到 ACK 并防止与新连接的潜在重叠。 （有关此状态的更多详细信息，请参阅描述连接终止的主题。） | **Timer Expiration:** Timer Expiration：在指定的等待期后，设备转换到 CLOSED 状态。                                                                                                                                                                                                                                                  |

​                                                    

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\tcpfsm.png)

​                                                                   **图210: TCP有限状态机（FSM）**

这张图说明了简化的TCP FSM。颜色编码不是FSM定义的正式部分；我添加它们是为了更清楚地显示两个设备打开和关闭链接的顺序。对于建立和终止，有一个常规的序列，发起和响应的设备经过不同的状态，还有一个同时的序列，每个设备使用相同的序列。

敲敲打打......还醒着吗？好吧，我想即使进行了认真的简化，那个FSM也不是那么简单的。一开始它可能看起来有点吓人，但如果你花几分钟时间来处理它，你就能很好地掌握TCP的工作原理。FSM对于理解本节后面的连接建立和终止过程有很大的帮助，反过来说，阅读这些部分将有助于你理解FSM。所以，如果你的眼睛已经完全睁不开了，那就继续吧，以后再来看看这个话题。

<u>**有限状态机的步骤代表了一个连接的各个阶段**</u>

重要的是要记住，这个状态机对每个连接都要遵循。这意味着在任何时候，TCP可能在与套接字X的连接中处于一种状态，而在与套接字Y的连接中则处于另一种状态。另外，在一个特定的连接中，两个进程的典型的状态变化并不对称，因为设备的角色并不对称：一个设备发起连接，另一个设备作出响应；一个设备开始终止，另一个则作出响应。如果两个设备同时启动（这是不寻常的，但可能发生），也有一个建立和终止连接的备用路径。这由图210中的颜色编码显示。

因此，例如，在连接建立的开始阶段，两个设备将采取不同的路径到达ESTABLISHED：一个设备（通常是服务器）将通过LISTEN状态，而另一个（客户端）将通过SYN-SENT。同样地，一个设备将启动连接终止，并通过FIN-WAIT-1的路径回到CLOSED；另一个设备将通过CLOSE-WAIT和LAST-ACK。然而，如果两个设备都试图同时打开，它们各自通过SYN-SENT和SYN-RECEIVED进行，如果两个设备都试图同时关闭，它们大致同时通过FIN-WAIT-1、CLOSING和TIME-WAIT。

**关键概念。**TCP有限状态机描述了TCP会话中两个设备在建立、管理和关闭连接时所采取的步骤序列。每个设备都可能采取不同的状态路径，因为在正常情况下，协议的操作是不对称的，一个设备发起连接的建立或终止，另一个设备做出响应。

###### 4.1.4.3.2 TCP连接准备。传输控制块（TCB）和被动与主动套接字的打开（部分：1 2 )

在描述端口和连接的TCP基础知识专题中，我提出了关于TCP操作的一个重要观点：它必须能够同时处理许多连接。正是由于这个原因，我们使用连接上的两个设备的套接字标识（IP地址和端口号）的四重性来唯一地识别每个连接。设置、管理和终止连接的过程对每个连接都是独立进行的。

<u>**存储连接数据：传输控制块**</u>
由于每个连接都是不同的，我们必须分别维护每个连接的数据。TCP为此使用一个特殊的数据结构，称为传输控制块（TCB）。TCB包含关于连接的所有重要信息，如识别它的两个套接字号码和存放传入和传出数据的缓冲区的指针。TCB也被用来实现滑动窗口机制。它持有一些变量，用于跟踪收到和确认的字节数、收到但尚未确认的字节数、当前窗口大小等等。当然，每个设备都为连接维护自己的TCB。

在建立TCP连接的过程开始之前，两端的设备必须进行一些 "准备工作"。为连接做准备的任务之一是建立TCB，用来保存连接的信息。这是在连接建立过程的一开始就完成的，当时每个设备刚刚从关闭状态转换出来。

<u>**主动和被动开放**</u>

TCP/IP是基于客户/服务器操作模式的，而TCP连接的建立也是基于这些角色的存在。客户端和服务器各自通过执行OPEN操作为连接做准备。然而，有两种不同的OPEN。

- 主动开放。使用TCP的客户进程扮演 "主动角色"，通过实际发送TCP消息来启动连接（SYN消息）。

- 被动开放。然而，被设计为使用TCP的服务器进程采取了一种更 "悠闲 "的方式。它通过联系TCP并说 "我在这里，我在等待可能希望与我交谈的客户在以下端口号上向我发送消息 "来执行被动开放。这种开放被称为被动的，因为除了表明进程正在监听之外，服务器进程什么也不做。

事实上，一个被动的OPEN可以指定服务器正在等待来自特定客户的主动OPEN，尽管不是所有的TCP/IP API都支持这种能力。更常见的是，服务器进程愿意接受所有来者的连接。这种被动的OPEN被认为是未指定的。

<u>**关键概念。**</u>客户端进程通过执行主动开放，向服务器发送SYN消息来启动一个TCP连接。一个使用TCP的服务器进程通过执行被动开放来准备一个传入的连接请求。两种设备都为每个TCP会话创建一个数据结构，用于保存与连接有关的重要数据，称为传输控制块（TCB）。

<u>**连接的准备**</u>
客户端和服务器在执行开放时都为连接创建了TCB。客户端已经知道了它试图到达的客户端进程和服务器进程的IP地址和端口号，所以它可以用这些来唯一地识别连接和与之相关的TCB。

对于服务器来说，在游戏的这个阶段，TCB的概念要复杂一些。如果服务器实际上在等待一个特定的客户，它可以使用自己的套接字和它正在等待的客户的套接字来识别连接。然而，通常情况下，服务器并不知道什么客户端在试图联系它。事实上，它可能几乎同时被一个以上的客户联系到。

在这种情况下，服务器用一个未指定的（零）客户端套接字号码创建一个TCB，并等待一个活动的OPEN被收到。然后，作为连接过程的一部分，它将客户端的套接字号码绑定到被动开放的TCB上。为了使它能够处理多个传入的连接，服务器进程实际上可以同时执行几个未指定的被动开放。

一个连接的传输控制块在整个连接过程中被维护，并在连接完全终止和设备返回到CLOSED状态时被销毁。TCP确实包括一个程序来处理两个设备同时执行主动开放的情况。这将在下一个关于连接建立过程的主题中详细讨论。

###### 4.1.4.3.3 TCP连接的建立过程:三次握手"(Parts: 1 2 3 4 )

我们在本节前面的主题中已经讨论了TCP的连接方向和它的操作。在TCP可以用于任何实际有用的目的之前，即发送数据，必须在希望通信的两个设备之间建立连接。这个过程，通常称为连接建立，涉及到信息的交换，将两个设备从最初的连接状态（CLOSED）过渡到正常的操作状态（ESTABLISHED）。

<u>**连接建立的功能**</u>
连接建立过程实际上完成了几件事，因为它创建了一个适合于数据交换的连接。

- 联系和通信。客户端和服务器相互接触，并通过相互发送消息建立通信。服务器通常在这之前甚至不知道它将与哪个客户交谈，所以它在连接建立过程中发现了这一点。

- 序列号同步。每个设备让对方知道它想在第一次传输中使用什么初始序列号。

- 参数交换。控制TCP连接操作的某些参数由两个设备交换。

<u>**用于建立连接的控制信息: SYN 和 ACK**</u>

TCP使用控制消息来管理联系和通信的过程。然而，并没有任何特殊的TCP控制信息类型；所有的TCP信息都使用相同的段格式。TCP报头中的一组控制标志表明一个网段是用于控制目的还是仅仅用于传输数据。正如我在讨论TCP有限状态机时介绍的那样，在连接设置中使用两种控制消息类型，通过设置以下两个标志来指定。

- SYN：该位表示该段被用于初始化连接。SYN代表同步，指的是我上面提到的序列号同步。

- ACK：该位表示发送网段的设备正在为其收到的信息（如SYN）传达确认。

还有其他控制位（FIN、RST、PSH和URG），这些位对连接的建立并不重要，所以我们暂时将它们放在一边。我们将在其他主题中讨论它们。在常见的TCP术语中，一个设置了控制位的消息通常以该位命名。例如，如果SYN控制位被设置，该段通常被称为 "SYN消息"。同样，设置了ACK位的报文被称为 "ACK报文"，甚至只是 "ACK"。

<u>**正常连接的建立: 三向握手**</u>"

为了建立连接，每个设备都必须发送一个SYN，并从另一个设备接收一个ACK。因此，从概念上讲，我们需要有四个控制信息在设备之间传递。然而，在可以同时通信SYN和ACK的情况下，在不同的消息中发送SYN和ACK的效率很低。因此，在连接建立的正常事件序列中，其中一个SYN和一个ACK是通过设置两个相关位一起发送的（这个消息有时称为SYN+ACK）。这使得总共有三个消息，因此连接程序被称为三方握手。

**关键概念。**在TCP客户端和服务器之间建立连接的正常过程包括三个步骤：客户端发送一个SYN消息；服务器发送一个消息，该消息结合了客户端SYN的ACK并包含服务器的SYN；然后客户端发送服务器SYN的ACK。这就是所谓的TCP三方握手。

表152详细描述了三方握手的工作原理（包括上一主题中讨论的准备工作的总结）。它改编自描述TCP有限状态机的表格，但显示了服务器和客户端在一段时间内发生的情况。每一行都显示了设备开始时的状态，它在该状态下采取的行动以及它过渡到的状态。握手过程的三个步骤中每个步骤的发送和接收部分都显示在表中，也显示在图211中。

​                                                                       **表152: TCP "三向握手 "连接建立程序**

|                    | **Client**                                                                                                                             |                    |                     | **Server**                                                                                                               |                     |
| ------------------ |:--------------------------------------------------------------------------------------------------------------------------------------:| ------------------ | ------------------- | ------------------------------------------------------------------------------------------------------------------------ | ------------------- |
| **Start State**    | **Action**                                                                                                                             | **Move To State**  | **Start State**     | **Action**                                                                                                               | **Move To State**   |
| ***CLOSED\***      | 在服务器执行被动 OPEN 并准备好接受连接之前，客户端无法执行任何操作。 （好吧，它可以尝试，但在服务器准备好之前什么都不会完成。）                                                                    | ***—\***           | ***CLOSED\***       | 服务器执行被动 OPEN，为连接创建传输控制块 (TCB)，并为接收来自客户端的连接请求 (SYN) 做好准备。                                                                 | ***LISTEN\***       |
| ***CLOSED\***      | **Step #1 Transmit:** 第 1 步传输：客户端执行主动 OPEN，为连接创建传输控制块 (TCB) 并向服务器发送 SYN 消息。                                                            | ***SYN-SENT\***    | ***LISTEN\***       | 服务器等待来自客户端的联系。                                                                                                           | ***—\***            |
| ***SYN-SENT\***    | 客户端等待接收它发送的 SYN 的 ACK，以及服务器的 SYN。                                                                                                      | ***—\***           | ***LISTEN\***       | **Step #1 Receive, Step #2 Transmit:** 步骤#1 接收，步骤#2 发送：服务器从客户端接收SYN。它将单个 SYN+ACK 消息发送回客户端，其中包含客户端 SYN 的 ACK 和服务器自己的 SYN。 | ***SYN-RECEIVED\*** |
| ***SYN-SENT\***    | **Step #2 Receive, Step #3 Transmit:** 步骤#2 接收，步骤#3 发送：客户端从服务器接收包含对客户端SYN 的ACK 的SYN+ACK，以及来自服务器的SYN。它向服务器发送服务器 SYN 的 ACK。客户端现在已完成连接建立。 | ***ESTABLISHED\*** | ***SYN-RECEIVED\*** | 服务器等待它之前发送的 SYN 的 ACK。                                                                                                   | ***—\***            |
| ***ESTABLISHED\*** | 客户端正在等待服务器完成连接建立，以便它们可以正常运行。                                                                                                           |                    | ***SYN-RECEIVED\*** | **Step #3 Receive:**步骤#3 接收：服务器接收到它的 SYN 的 ACK，现在完成连接建立。                                                                 | ***ESTABLISHED\***  |
| ***ESTABLISHED\*** | 客户端已准备好进行正常的数据传输操作。                                                                                                                    |                    | ***ESTABLISHED\***  | 服务器已准备好进行正常的数据传输操作。                                                                                                      |                     |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\tcpopen3way.png)

​                                                                       **图211: TCP "三向握手 "连接建立程序**

该图说明了客户端和服务器之间的传统连接是如何建立的，显示了该过程中发送的三个消息，以及每个设备如何从关闭状态通过中间状态过渡，直到会话被建立起来。

**同时打开连接建立**

TCP也被设置成可以处理这样的情况：两个设备都执行主动开放，而不是一个设备执行被动开放。这可能发生在两个客户试图相互联系，而不是一个客户和一个服务器。然而，这并不常见，只有在特定情况下才会发生。同时建立连接的情况也只有在一个知名的端口被用作其中一个设备的源端口时才会发生。

在这种情况下，两个设备的步骤是不同的。每个客户端将执行一个主动开放，然后通过SYN-SENT和SYN-RECEIVED状态进行，直到他们的SYN被确认。这意味着不再有表152中所示的 "三方握手 "了。相反，它就像两个同时进行的 "双向握手"。每个客户发送一个SYN，接收对方的SYN并进行ACK，然后等待自己的ACK。表153和图212描述了简化后的事务。

​                                                                     **表153: TCP同时开放连接的建立程序**

| **Client A**        |                                                                                                                               |                     | **Client B**        |                                                                                                                               |                     |
| ------------------- | ----------------------------------------------------------------------------------------------------------------------------- | ------------------- | ------------------- | ----------------------------------------------------------------------------------------------------------------------------- | ------------------- |
| **Start State**     | **Action**                                                                                                                    | **Move To State**   | **Start State**     | **Action**                                                                                                                    | **Move To State**   |
| ***CLOSED\***       | **Client A Step #1 Transmit:** 客户端 A 第 1 步传输：客户端 A 执行主动 OPEN，创建 TCB 并向服务器发送 SYN 消息。                                           | ***SYN-SENT\***     | ***CLOSED\***       | **Client B Step #1 Transmit:** Client *B* performs an active *OPEN*, creating a TCB and sending a *SYN* to the server.        | ***SYN-SENT\***     |
| ***SYN-SENT\***     | **Client B Step #1 Receive and Step #2 Transmit:** 客户端 B 步骤 #1 接收和步骤 #2 发送：客户端 A 接收客户端 B 的 SYN 并向其发送 ACK。它仍在等待对自己的 SYN 的 ACK。 | ***SYN-RECEIVED\*** | ***SYN-SENT\***     | **Client A Step #1 Receive and Step #2 Transmit:** 客户端 A 步骤 #1 接收和步骤 #2 传输：客户端 B 接收客户端 A 的 SYN 并向其发送 ACK。它仍在等待对自己的 SYN 的 ACK。 | ***SYN-RECEIVED\*** |
| ***SYN-RECEIVED\*** | **Client A Step #2 Receive:** 客户端 A 步骤 #2 接收：客户端 A 从客户端 B 接收到其 SYN 的 ACK，并完成连接建立。                                             | ***ESTABLISHED\***  | ***SYN-RECEIVED\*** | **Client B Step #2 Receive:** 客户端 B 步骤 #2 接收：客户端 B 接收来自客户端 A 的 SYN ACK 并完成连接建立。                                               | ***ESTABLISHED\***  |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\tcpopensimul.png)

​                                                                      **图212: TCP同时打开连接的建立程序**

该图显示了当两个设备试图同时向对方打开一个连接时发生的情况。在这种情况下，不是三方握手，而是各自发送一个SYN并接收一个ACK。它们各自遵循相同的状态序列，这与正常三方握手中的两个序列不同。

为了减少表格的大小，我显示了两个设备同时进行的活动（在同一行）。在 "现实生活 "中，这些动作不需要完全在同一时间发生，也可能不会。如图212所示，同时进行的程序所必须发生的是，每个设备在收到自己的SYN的ACK之前收到一个SYN。

**关键概念。**如果一个建立TCP连接的设备发送一个SYN，然后在其SYN被确认之前收到另一个设备的SYN，那么这两个设备就会执行同步开放，这包括交换两个独立的SYN和ACK消息集。最终结果与传统的三方握手相同，但进入ESTABLISHED状态的过程是不同的。

###### 4.1.4.3.4 TCP连接建立序列号同步和参数交换（部分：1 2 3）

TCP三方握手描述了消息交换的机制，使一对TCP设备从封闭状态转为随时可用的已建立的连接。连接的建立不仅仅是在设备之间传递消息以建立通信。设备上的TCP层还必须交换关于每个设备希望用于其第一次数据传输的序列号的信息，以及控制连接如何运行的参数。这两个数据交换功能中的前者通常被称为序列号同步，它是连接建立的一个重要部分，每个设备为启动连接而发送的消息被称为SYN（同步）消息。

你可能还记得，在TCP基础部分，TCP单独提到了每个数据字节，并使用序列号来跟踪哪些字节已经被发送和接收。由于每个字节都有一个序列号，我们可以确认每个字节，或者更有效地使用一个数字来确认收到的一系列字节。

<u>**使用相同的序列号开始每个连接的问题**</u>
在我给出的描述滑动窗口系统的例子中，为了 "简单"（哈哈，有那么简单吗），我假设每个设备将通过给发送的第一个数据字节提供序列号1来启动连接。一个有效的问题是，为什么我们不总是通过发送序列号为1的第一个字节的数据来启动每个TCP连接？毕竟，序列号是任意的，而且这是最简单的方法。

在一个理想的世界里，这可能是可行的，但我们并不生活在一个理想的世界里。J 每个连接开始时的序列号都是1，问题是它引入了不同连接的段被混在一起的可能性。假设我们建立了一个TCP连接并发送了一个包含字节1到30的段。然而，互联网出现了问题，导致该段被延迟，最终，TCP连接本身被终止。然后，我们启动了一个新的连接，并再次使用了1的起始序列号。然而，一旦这个新的连接被启动，带有1至30字节的旧段就会出现。其他设备会错误地认为这些字节是新连接的一部分。

这只是可能发生的几个类似问题中的一个。为了避免这些问题，每个TCP设备在启动连接时，为连接选择一个32位的初始序列号（ISN）。每个设备都有自己的ISN，它们通常是不一样的。

**选择初始序列号**
传统上，每个设备通过利用一个定时计数器来选择ISN，就像一个时钟一样，每4微秒递增一次。这个计数器在TCP启动时被初始化，然后它的值每4微秒增加1，直到它达到可能的最大32位值（4,294,967,295），这时它 "环绕 "到0并继续增加。任何时候建立一个新的连接，ISN都是取自这个定时器的当前值。由于从0数到4,294,967,295需要4个多小时，每次递增4微秒，这实际上保证了每个连接不会与以前的连接冲突。

这种方法的一个问题是，它使ISN变得可预测。恶意的人可以编写代码来分析ISN，然后根据先前连接中使用的ISN来预测后续TCP连接的ISN。这代表了一种安全风险，过去曾被利用过（如著名的Mitnick攻击案）。为了解决这个问题，现在的实施方案在其ISN选择过程中使用一个随机数。

<u>**TCP序列号同步**</u>

一旦每个设备选择了它的ISN，它就在其初始SYN消息的序列号字段中向另一个设备发送这个值。收到SYN的设备用ACK消息回应，确认SYN（也可能包含它自己的SYN，如三方握手的第2步）。在ACK消息中，确认号码字段被设置为从其他设备收到的ISN的值加1。这代表了设备期望从其同伴那里收到的下一个序列号；因此ISN实际上代表了收到的最后一个字节的序列号（在这种情况下是虚构的，因为连接是新的，还没有收到任何东西）。我们将在后面看到，这与这两个字段用于正常数据交换的方式是一致的。

**关键概念。**作为连接建立过程的一部分，TCP连接中的两个设备中的每一个都通过在其SYN报文的序列号字段中放入前一个序列号来通知对方它计划在其第一次数据传输中使用的序列号。另一个设备通过增加该值并将其放入其ACK的确认号码字段来确认，告诉另一个设备这是它对第一个数据传输所期望的序列号。这个过程被称为序列号同步。

下面是一个简化的三向握手步骤的例子，显示了这是如何完成的（也见图213）。为了便于阅读，我选择了小的ISN，但请记住，它们可以是任何32位数字。

1. 客户端的连接请求。客户端为其传输选择了一个4,567的ISN。它发送一个SYN，序列号字段设置为4,567。

2. 服务器的确认和连接请求。服务器为其传输选择了一个12,998的ISN。它收到客户端的SYN。它发送一个SYN+ACK，确认号字段值为4,568（比客户的ISN多一个）。这个消息的序列号字段值为12,998。

3. 客户端的确认。客户端发送一个ACK，其确认号字段设置为12,999。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\tcp3waysynch.png)

​                                                                                        **图213: TCP序列号同步**

这张图展示了图211中介绍的同样的三方握手连接建立过程，只是这次我展示了每个消息中的序列号和确认号字段，这样你就可以看到它们是如何被两个设备各自用来建立数据交换的初始序列号。

随着连接的建立，客户端将发送数据，其第一个字节将被赋予序列号4,568。服务器的第一个字节的数据将被编号为12,999

<u>**TCP参数交换**</u>

除了初始序列号外，SYN消息还被设计用来传达关于连接如何运行的重要参数。TCP包括一个携带这些参数的灵活方案，其形式为TCP段格式中的可变长度选项字段，可以扩展为携带多个参数。在TCP 793中只定义了一个参数，在连接建立期间进行交换。最大网段尺寸（MSS）。这个参数的意义将在TCP数据传输部分解释。

如果每个设备希望使用非默认值，则向对方发送它希望用于连接的MSS。当接收到SYN时，服务器会记录客户发送的MSS值，并且永远不会向客户发送大于该值的网段。客户端对服务器也是这样做的。客户端和服务器的MSS值是独立的，因此可以建立一个连接，其中客户端可以接收比服务器更大的网段，反之亦然。

后来的RFC定义了连接建立过程中可能交换的其他参数。其中一些包括

- ***Window Scale Factor\***窗口比例系数。允许一对设备指定更大的窗口大小，而不是通常可能的TCP窗口字段的16位大小。
- **Selective Acknowledgment Permitted**允许选择性确认：允许一对设备使用可选的选择性确认功能，只允许重新传输某些丢失的片段。
- **Alternate Checksum Method**替代校验方法。让设备指定一种比标准TCP机制更适合执行校验的替代方法。

###### 4.1.4.3.5 TCP连接管理和问题处理，连接复位功能，以及TCP "保持"（部分：1 2 3）

一旦TCP连接中的两个设备都完成了连接设置并进入ESTABLISHED状态，TCP软件就处于正常的工作模式。数据字节将被打包成段，使用消息格式化和数据传输一节中描述的机制进行传输。滑动窗口方案将被用来控制段的大小，并根据需要提供流量控制、拥塞处理和重传。

一旦进入这种模式，两个设备都可以无限期地保持这种状态。一些TCP连接确实可以非常长寿--事实上，一些用户保持某些连接，如Telnet会话，每次都是几个小时甚至几天。有两种情况会导致连接脱离ESTABLISHED状态。

- 连接终止。任何一个设备决定终止连接。这涉及到一个特定的程序，将在本节的下一个主题中介绍。

- 连接中断。发生了某种问题，导致连接中断。

<u>**TCP复位功能**</u>
为了使TCP不辜负其作为一个可靠和稳健的协议的工作，它包括智能，使其能够检测和应对在建立连接过程中可能发生的各种问题。最常见的问题之一是半开放连接。这种情况发生时，由于某种问题，一个设备关闭或中止连接，而另一个设备不知道这一点。这意味着一个设备处于ESTABLISHED状态，而另一个设备可能处于CLOSED状态（无连接）或其他一些瞬时状态。这可能发生在，例如，一个设备的软件崩溃，在连接过程中被重新启动，或者某种故障导致两个设备的状态不同步。

为了处理半开放连接和其他问题情况，TCP包括一个特殊的复位功能。复位是一个TCP段，在其头部的RST标志被设置为1。一般来说，只要发生了TCP软件 "意想不到 "的事情，就会产生复位。一些最常见的产生复位的具体情形包括。

- 收到来自任何设备的任何TCP段，而接收该段的设备目前没有连接（除了请求新连接的SYN之外）。

- 收到一个序列号或确认号字段无效或不正确的消息，表明该消息可能属于以前的连接或在其他方面是虚假的。

- 在一个没有进程监听连接的端口上收到SYN消息。

<u>**处理复位段**</u>

当设备收到一个发送了RST位的段时，它告诉设备重置连接，以便重新建立连接。像所有的段一样，复位本身必须被检查以确保它是有效的（通过查看其序列号字段的值）。这可以防止一个虚假的复位关闭一个连接。假设复位是有效的，对消息的处理取决于收到消息的设备的状态。

- 如果设备处于LISTEN状态，复位被忽略，并保持在该状态。

- 如果设备处于SYN-RECEIVED状态，但之前处于LISTEN状态（这是服务器建立新连接的正常情况），它将返回到LISTEN状态。

- 在任何其他情况下，复位会导致连接中止，设备会返回到该连接的关闭状态。设备将通知使用TCP的上层进程，该连接已被关闭。

**关键概念。**TCP包括一个特殊的连接重置功能，允许设备处理问题情况，如半开的连接或收到意外的消息类型。要使用该功能，检测到问题的设备发送一个TCP段，RST（复位）标志设置为1，接收设备要么返回到LISTEN状态，如果它正在建立连接，要么关闭连接并返回到CLOSED状态，等待新的会话协商。

**空闲连接管理和“保持活动keepalive”消息**

TCP的最后一个连接管理问题是如何处理空闲连接；也就是说，一个TCP会话是活动的，但在很长一段时间内，任何设备都没有传输数据。TCP标准规定，在这种情况下采取的适当行动是......什么都不做。原因是，严格来说，在TCP中不需要做任何事情来维持一个空闲的连接。该协议完全可以允许两个设备在很长一段时间内停止传输，然后在任何一个设备有数据需要发送时简单地恢复数据和确认段的传输。

然而，就像许多人在打电话时长时间没有听到任何声音而变得 "焦躁不安 "一样，一些TCP实现者担心TCP连接空闲时间过长可能意味着连接已经中断。

因此，TCP软件通常包括一个 "非官方 "的功能，允许有TCP连接的设备定期向其连接上的对等体发送一个不含数据的空段。如果连接仍然有效，另一个设备就会用一个包含确认的段来回应；如果不有效，另一个设备就会用上述的连接重置段来回应。这些网段有时被称为TCP "keepalive "消息，或只是 "keepalives"。它们类似于BGP Keepalive消息。

这些消息的使用是有争议的，因此，并不普遍。那些反对的人认为，它们并不是真正必要的，发送它们代表了对网络带宽的浪费，并可能对计费链路（那些对发送的每个数据报收费的链路）产生额外的费用。 他们的关键观点是，如果连接目前没有被使用，它是否仍然有效并不重要；一旦连接被再次使用，如果它在这段时间内中断了，TCP可以使用上述的复位功能来处理。

更糟糕的是，发送 "keepalive "在理论上会导致一个良好的TCP会话被不必要地破坏。如果在客户端和服务器之间出现间歇性故障时发送 "keepalive"，这种情况可能会发生，否则在必须发送下一段 "真实 "数据时，这种故障可能已经得到纠正。此外，一些TCP实现可能无法正确处理这些片段的接收。

赞成使用 "保持 "的人指出，每个TCP连接都会消耗一定量的资源，这对繁忙的服务器来说可能是个问题。如果许多客户连接到这样的服务器，并且没有正确地终止TCP连接，服务器可能会在空闲的连接中坐很长时间，使用系统内存和其他资源，而这些资源可以应用在其他地方。

由于对这一功能的使用没有广泛的认可，实施这一功能的设备包括一种在必要时禁用它的方法。设备也被编程为不会仅仅因为没有收到对单个 "keepalive "的响应而终止一个连接。如果它们在一段时间内发送了几条这样的信息而没有收到回复，它们就会这样做。

###### 4.1.4.3.6 TCP连接终止 (部分: 1 2 3 4 )

俗话说，"好事多磨"......TCP连接也是如此。假设一个问题没有迫使连接中止，一对设备之间的链接可以保持相当长一段时间的开放。然而，最终，连接中的一个或两个进程将耗尽要发送的数据，并将关闭TCP会话，或由用户指示这样做。

<u>**连接终止的要求和问题**</u>
正如TCP遵循有序的操作顺序来建立连接一样，它也包括终止连接的特定程序。与建立连接一样，每个设备从一个状态移动到下一个状态以终止连接。这个过程比人们想象的要复杂得多。事实上，对TCP有限状态机的研究表明，关闭一个连接所涉及的不同状态比建立一个连接所涉及的更多。

连接终止之所以复杂，是因为在正常运行期间，两个设备都在同时发送和接收数据。通常，连接终止开始时，只有一个设备上的进程向TCP表示它想关闭连接。另一个设备上的匹配进程可能根本不知道它的同伴想要结束连接。需要几个步骤来确保连接被两个设备优雅地关闭，并且在此过程中没有数据丢失。

最终，关闭一个TCP连接需要连接两端的应用进程认识到连接的 "结束"，并停止发送数据。出于这个原因，连接终止的实现使每个设备单独终止其连接的一端。一个设备关闭连接的行为意味着该设备将不再发送数据，但可以继续接收数据，直到其他设备决定停止发送。这使得通信双方所有有待发送的数据在连接结束前被刷新。

<u>**正常连接的终止**</u>

在正常情况下，每一方通过发送一个设置了FIN（结束）位的特殊消息来终止其连接的末端。这个消息，有时被称为FIN，作为对另一设备的连接终止请求，同时也可能像普通网段一样携带数据。收到FIN的设备会对FIN进行确认，以表示收到了它。在双方通过发送FIN和接收ACK完成关闭程序之前，整个连接不被认为是终止的。

因此，终止并不像建立那样是一次三方握手：它是一对双向握手。在正常的连接关闭过程中，连接中的两个设备所经历的状态是不同的，因为发起关闭的设备的行为必须与接收终止请求的设备不同。特别是，收到初始终止请求的设备上的TCP必须通知其应用进程，并等待该进程准备继续的信号。发起的设备不需要这样做，因为应用程序是首先开始的。

**关键概念。**一个TCP连接通常使用一个特殊的程序来终止，每一方都独立地关闭其链接的一端。它通常是由其中一个应用程序向其TCP层发出信号，表示不再需要这个会话了。该设备发送一个FIN消息，告诉其他设备它想结束连接，该消息被确认。当响应设备准备好时，它也发送一个FIN消息，并被确认；在等待一段时间收到ACK后，会话被关闭。

表154详细描述了连接终止过程是如何进行的；图214中也可以看到状态和消息交换的进展情况。该表改编自描述TCP有限状态机的表151，但显示了在连接关闭期间服务器和客户端发生的情况。任何一个设备都可以发起连接终止；在这个例子中，我假设是客户端发起的。每一行都显示了每个设备开始时的状态，它在该状态下采取的行动以及它过渡到的状态。我还显示了客户端和服务器的每个关闭操作的两个步骤的发送和接收阶段。

​                                                                **表154: TCP连接的终止程序**

| **Client**         |                                                                                                         |                          | **Server**         |                                                                                                                                                             |                          |
| ------------------ | ------------------------------------------------------------------------------------------------------- | ------------------------ | ------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------ |
| **Start State**    | **Action**                                                                                              | **Transitions To State** | **Start State**    | **Action**                                                                                                                                                  | **Transitions To State** |
| ***ESTABLISHED\*** | **Client Close Step #1 Transmit:** 客户端关闭第 1 步传输：使用 TCP 的应用程序发出不再需要连接的信号。客户端 TCP 发送一个设置了 FIN 位的段以请求关闭连接。 | ***FIN-WAIT-1\***        | ***ESTABLISHED\*** | 在这个阶段，服务器仍处于正常运行模式。                                                                                                                                         | ***—\***                 |
| ***FIN-WAIT-1\***  | 发送了 FIN 的客户端正在等待它被确认并等待服务端发送它自己的 FIN。在这种状态下，客户端仍然可以从服务器接收数据，但将不再接受来自其本地应用程序的数据发送到服务器。                   | ***—\***                 | ***ESTABLISHED\*** | **Client Close Step #1 Receive and Step #2 Transmit:** 客户端关闭步骤#1 接收和步骤#2 发送：服务器接收客户端的 FIN。它发送一个 ACK 来确认 FIN。服务器必须等待使用它的应用程序被告知另一端正在关闭，所以这里的应用程序可以完成它正在做的事情。 | ***CLOSE-WAIT\***        |
| ***FIN-WAIT-1\***  | **Client Close Step #2 Receive:** 客户端关闭步骤 #2 接收：客户端接收其 FIN 的 ACK。它现在必须等待服务器关闭。                          | ***FIN-WAIT-2\***        | ***CLOSE-WAIT\***  | 服务器端等待应用程序进程发出信号，表明它已准备好关闭。                                                                                                                                 | ***—\***                 |
| ***FIN-WAIT-2\***  | 客户端正在等待服务器的 FIN。                                                                                        | ***—\***                 | ***CLOSE-WAIT\***  | **Server Close Step #1 Transmit:** 服务器关闭 步骤#1 传输：服务器的 TCP 从本地应用程序接收到它已完成的通知。服务器将其 FIN 发送给客户端。                                                               | ***LAST-ACK\***          |
| ***FIN-WAIT-2\***  | **Server Close Step #1 Receive and Step #2 Transmit:** 服务器关闭步骤#1 接收和步骤#2 发送：客户端接收服务器的 FIN 并发送回一个 ACK。   | ***TIME-WAIT\***         | ***LAST-ACK\***    | 服务器正在等待它发送的 FIN 的 ACK。                                                                                                                                      | ***—\***                 |
| ***TIME-WAIT\***   | 客户端等待一段等于最大分段寿命 (MSL) 时间的两倍的时间，以确保接收到它发送的 ACK。                                                          | ***—\***                 | ***LAST-ACK\***    | **Server Close Step #2 Receive:** 服务器关闭步骤 #2 接收：服务器接收到其 FIN 的 ACK 并关闭连接。                                                                                    | ***CLOSED\***            |
| ***TIME-WAIT\***   | 计时器在 MSL 时间的两倍后到期。                                                                                      | ***CLOSED\***            | ***CLOSED\***      | 连接在服务器端关闭。                                                                                                                                                  |                          |
| ***CLOSED\***      | 连接已关闭。                                                                                                  |                          | ***CLOSED\***      | 连接已关闭。                                                                                                                                                      |                          |

​                                                                     **图214：TCP连接的终止程序**

该图显示了TCP会话的传统终止程序，由一个设备发起终止，另一个设备做出响应。在这种情况下，客户端发起；它发送一个FIN，并得到服务器的确认。服务器等待服务器进程准备好关闭，然后发送它的FIN，并得到客户端的确认。客户端等待一段时间以确保其ACK被收到，然后再进入CLOSED状态。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\tcpclose.png)

​                                                                             **图 214：TCP 连接终止程序**

此图显示了 TCP 会话的传统终止过程，其中一个设备启动终止，另一个设备响应。在这种情况下，客户端发起；它发送一个由服务器确认的 FIN。服务器等待服务器进程准备好关闭，然后发送它的 FIN，由客户端确认。客户端等待一段时间以确保收到其 ACK，然后进入 CLOSED 状态。

<u>**TIME-WAIT状态**</u>

收到初始FIN的设备可能需要在CLOSE-WAIT状态下等待相当长的时间（以网络术语来说），等待它所服务的应用程序表明它已经准备好关闭。TCP不能对这一过程需要多长时间做出任何假设。在这段时间内，我们上面的例子中的服务器可以继续发送数据，而客户端将收到这些数据。然而，客户端将不会向服务器发送数据。

最终，第二个设备（我们例子中的服务器）将发送一个FIN来关闭其连接的一端。最初发起关闭的设备（上面的客户端）将为这个FIN发送一个ACK。然而，客户端不能在发送该ACK后立即进入CLOSED状态。原因是它必须留出时间让ACK传到服务器上。通常情况下，这将是快速的，但延迟可能会导致它被放慢一些。

需要TIME-WAIT状态有两个主要原因。第一个原因是提供足够的时间来确保另一个设备收到ACK，并在ACK丢失时进行重传。第二是在这个连接的结束和任何后续连接之间提供一个 "缓冲期"。如果没有这个时期，来自不同连接的数据包就有可能混在一起，造成混乱。

该标准规定，在完成连接的关闭之前，客户端应等待双倍的特定时间长度，称为最大段寿命（MSL）。TCP标准将MSL定义为一个120秒（2分钟）的值。在现代网络中，这是一个永恒的数字，所以TCP允许实施者选择一个较低的值，如果它被认为会导致更好的操作。

<u>**同时终止连接**</u>

正如如果两个设备决定主动向对方开放连接，正常的连接建立过程有可能被改变，两个设备也有可能试图同时终止连接。这个术语 "同时 "并不意味着它们都决定在完全相同的时间关闭--网络延迟的变化意味着无论如何在一个互联网上没有什么是可以同时进行的。它只是意味着，在上面的例子中，客户决定关闭并发送一个FIN，但服务器在客户的FIN出现在服务器之前就发送了自己的FIN。在这种情况下，要遵循一个不同的程序，如表155和图215所述。

正如你所看到的，在这种情况下，过程更加对称，两个设备通过相同的状态过渡。无论哪种情况，最终结果都是一样的，连接处于关闭状态，即没有连接。每个TCP将确保所有未完成的数据被发送到应用程序，有时被称为隐含的 "推送"（见 "推送 "功能的描述，对这个术语的解释）。当连接关闭时，两个设备中为连接建立的传输控制块（TCB）会被销毁。

​                                                                **表155: TCP同步连接的终止程序**

| **Client**         |                                                                                                                                               |                          | **Server**         |                                                                                                                                               |                          |
| ------------------ | --------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------ | ------------------ | --------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------ |
| **Start State**    | **Action**                                                                                                                                    | **Transitions To State** | **Start State**    | **Action**                                                                                                                                    | **Transitions To State** |
| ***ESTABLISHED\*** | **Client Close Step #1 Transmit:** 客户端关闭第 1 步传输：使用 TCP 的应用程序发出不再需要连接的信号。客户端上的 TCP 发送设置了 FIN 位的下一个段，指示关闭连接的请求。                                 | ***FIN-WAIT-1\***        | ***ESTABLISHED\*** | **Server Close Step #1 Transmit:** 服务器关闭步骤#1 发送：在服务器可以接收到客户端发送的 FIN 之前，服务器上的应用程序也发出关闭信号。服务器也发送一个 FIN。                                         | ***FIN-WAIT-1\***        |
| ***FIN-WAIT-1\***  | **Server Close Step #1 Receive and Step #2 Transmit:** 服务器关闭步骤#1 接收和步骤#2 发送：客户端已发送 FIN 并等待确认。相反，它接收服务器发送的 FIN。它使用 ACK 确认服务器的关闭请求并继续等待自己的 ACK。 | ***CLOSING\***           | ***FIN-WAIT-1\***  | **Client Close Step #1 Receive and Step #2 Transmit:** 客户端关闭步骤#1 接收和步骤#2 发送：服务器已发送 FIN 并等待确认。相反，它接收客户端发送的 FIN。它使用 ACK 确认客户端的关闭请求并继续等待自己的 ACK。 | ***CLOSING\***           |
| ***CLOSING\***     | **Client Close Step #2 Receive:** 客户端关闭步骤 #2 接收：客户端接收其 FIN 的 ACK。                                                                             | ***TIME-WAIT\***         | ***CLOSING\***     | **Server Close Step #2 Receive:** 服务器关闭步骤 #2 接收：服务器接收其 FIN 的 ACK。                                                                             | ***TIME-WAIT\***         |
| ***TIME-WAIT\***   | 客户端等待的时间段等于最大段寿命 (MSL) 时间的两倍。这提供了足够的时间来确保接收到它发送到服务器的 ACK。                                                                                     | ***—\***                 | ***TIME-WAIT\***   | 服务器等待的时间段等于最大段寿命 (MSL) 时间的两倍。这提供了足够的时间来确保接收到它发送给客户端的 ACK。                                                                                     | ***—\***                 |
| ***TIME-WAIT\***   | 计时器在 MSL 时间的两倍后到期。                                                                                                                            | ***CLOSED\***            | ***TIME-WAIT\***   | 计时器在 MSL 时间的两倍后到期。                                                                                                                            | ***CLOSED\***            |
| ***CLOSED\***      | 连接已关闭。                                                                                                                                        | ***—\***                 | ***CLOSED\***      | 连接已关闭。                                                                                                                                        | ***—\***                 |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\tcpclosesimul.png)

​                                                                                **图215: TCP同步连接终止程序**

在某些情况下，两个设备可能决定同时或几乎同时终止一个连接。在这种情况下，每台设备都发送一个FIN，在收到ACK之前，收到另一台设备的FIN。各自确认对方的 FIN，并在关闭连接前等待一段时间。注意通过CLOSING状态的转换，它只作为同时终止的一部分使用。

**关键概念。**正如两个设备可以同时打开一个TCP会话一样，它们也可以同时终止它。在这种情况下，要遵循不同的状态序列，每个设备用一个ACK响应对方的FIN，等待收到自己的ACK，并停顿一段时间，以确保在结束连接之前对方设备收到自己的ACK。

##### 4.1.4.4 TCP消息格式化和数据传输

上一节描述了使用传输控制协议的两个设备如何建立一个TCP连接，以及如何管理和最终终止该连接。虽然连接是TCP工作方式的一个关键部分，但它们实际上是实现协议最终目的的一种手段：发送数据。通过采用TCP滑动窗口机制、特殊的段格式和一些特性，TCP设备能够通过连接打包和发送数据，使应用程序能够进行通信。

在本节中，我将描述TCP消息的格式化和数据在设备间传输的实际机制。我首先看一下重要的TCP段格式，它描述了每个TCP消息中的字段以及它们的使用方法。我描述了用于计算TCP（以及UDP）报文中的校验和的方法，以及使用特殊 "伪报头 "的原因。我讨论了最大网段大小（MSS）参数及其意义。然后，我准确地谈论了滑动窗口机制是如何用于传输和确认数据的。最后，我描述了两个特殊的数据传输功能：用于即时数据传输的 "push "功能，以及用于优先数据传输的 "urgent "功能。

**背景信息。**本节假定你已经熟悉了TCP的概念，如序列号、分段和TCP滑动窗口机制的基本知识。如果你不熟悉，我强烈建议你在进行本节内容之前先阅读TCP基础知识部分。

###### 4.1.4.4.1 TCP消息（段）格式（部分：1 2 3 4 ）。

在TCP基础部分，我描述了TCP最有趣的工作之一：它允许应用程序将数据作为非结构化的字节序列发送，按照TCP使用的底层协议（当然，通常是互联网协议）的要求，将数据透明地打包成不同的消息。TCP消息被称为段，这个名字指的是每个段是在设备之间传递的整个数据流的一部分。

<u>**TCP段所扮演的角色**</u>
TCP段在很大程度上是 "万能的 "消息--它们很灵活，有多种用途。所有网段都使用单一的字段格式，有一些头字段实现TCP负责的许多功能和特性。TCP网段最显著的特点之一是，它们被设计为同时携带控制信息和数据。这就减少了发送段的数量，因为它们可以执行一个以上的功能。

例如，不需要在 TCP 中发送单独的确认，因为每个 TCP 消息都包含一个用于确认字节号的字段。类似地，可以请求关闭连接，同时在同一消息中发送数据。每个 TCP 段的性质通过使用几个特殊的控制位来表示。可以发送多个位以允许一个段执行多种功能，例如当一个位用于指定初始序列号并同时确认另一个此类段的接收时。

<u>**TCP头字段功能**</u>

我们为这种灵活性付出的代价是，TCP头很大：普通段为20字节，携带选项的段则更多。这就是为什么一些协议在不需要TCP的功能时宁愿使用UDP的原因之一。TCP头字段用于以下一般用途。

- 进程寻址。源设备和目的设备上的进程使用端口号进行识别。

- 滑动窗口系统的实现。序列号、确认号和窗口大小字段实现了TCP的滑动窗口系统。

- 控制位和字段。实现各种控制功能的特殊位，以及携带指针和其他所需数据的字段。

- 携带数据。数据字段携带设备间发送的实际数据字节。

- 杂项功能。用于数据保护的校验和以及连接设置的选项。

<u>**TCP段的格式**</u>

表156和图216对TCP消息（段）的格式进行了全面描述。

​                                                                          **表156: TCP段的格式**

| **Field Name**               | **Size (bytes)** | **Description**                                                                                                                            |
| ---------------------------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------ |
| ***Source Port\***           | 2                | ***Source Port:\***源端口：在源设备上发起 TCP 段的进程的 16 位端口号。这通常是客户端向服务器发送请求的临时（客户端）端口号，或者是从服务器到客户端的回复的知名/注册（服务器）端口号。                                  |
| ***Destination Port\***      | 2                | ***Destination Port:\*** 目标端口：作为目标设备上消息的最终预期接收者的进程的 16 位端口号。这通常是客户端请求的知名/注册（服务器）端口号，或服务器回复的临时（客户端）端口号。                                     |
| ***Sequence Number\***       | 4                | ***Sequence Number:\*** 序号：对于正常传输，该段中数据的第一个字节的序号。在连接请求 (SYN) 消息中，它携带源 TCP 的初始序列号 (ISN)。数据的第一个字节将被赋予该字段内容之后的下一个序列号，如序列号同步主题中所述。             |
| ***Acknowledgment Number\*** | 4                | ***Acknowledgment Number:\*** 确认号：当设置 ACK 位时，该段用作确认（除了其他可能的职责），并且该字段包含源接下来期望目的地发送的序列号。有关详细信息，请参阅描述 TCP 数据传输的主题。                            |
| ***Data Offset\***           | 1/2 (4 bits)     | ***Data Offset:\*** 数据偏移量：指定 TCP 标头中 32 位数据字的数量。换句话说，这个值乘以四等于标头中的字节数，它必须始终是四的倍数。它被称为“数据偏移量”，因为它表示数据的开头与 TCP 段的开头偏移了多少个 32 位字。              |
| ***Reserved\***              | 3/4 (6 bits)     | ***Reserved:\*** 保留：保留 6 位以供将来使用；发送为零。                                                                                                     |
| ***Control Bits\***          | 3/4 (6 bits)     | ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\aa200ab4.png)                                                       |
| ***Window\***                | 2                | ***Window:\*** Window：表示该段的发送方一次愿意从接收方接受的八位字节数据的数量。这通常对应于分配用于接受此连接数据的缓冲区的当前大小。换句话说，该字段是发送该段的设备的当前接收窗口大小，这也是该段的接收者的发送窗口。有关详细信息，请参阅数据传输机制主题。 |
| ***Checksum\***              | 2                | ***Checksum:\*** 校验和：用于数据完整性保护的 16 位校验和，在整个 TCP 数据报加上一个特殊的“伪标头”字段计算。它不仅用于保护整个 TCP 段免受传输错误的影响，而且还用于保护传输错误。还支持可选的替代校验和方法。                    |
| ***Urgent Pointer\***        | 2                | ***Urgent Pointer:\*** 紧急指针：与 URG 控制位一起使用，用于优先数据传输。该字段包含紧急数据最后一个字节的序列号。有关详细信息，请参阅优先级数据传输主题。                                                |
| ***Options\***               | Variable         | ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\aa200b6a.png)                                                       |
| ***Padding\***               | Variable         | ***Padding:\*** 填充：如果选项字段的长度不是 32 位的倍数，则添加足够的零来填充标头，使其成为 32 位的倍数。                                                                          |
| ***Data\***                  | Variable         | ***Data:\*** 数据：在段中发送的数据字节数。                                                                                                               |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\tcpsegmentformat.png)

​                                                                  **Figure 216: TCP Segment Format**

<u>**TCP段的格式**</u>

表156和图216对TCP消息（段）的格式进行了全面描述。

​                                                                           **表156: TCP段的格式**

| ***Option-Kind\*** | ***Option-Length\*** | ***Option-Data\***                          | **Description**                                                                                                                                                                                                             |
| ------------------ | -------------------- | ------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **0**              | **—**                | **—**                                       | ***End Of Option List:\*** End Of Option List：一个单字节选项，用于标记此段中包含的所有选项的结束。只有当选项的结尾与TCP标头的结尾不一致时，才需要包含此选项                                                                                                                      |
| **1**              | **—**                | **—**                                       | ***No-Operation:\*** 无操作：如果需要，可以在选项之间包含一个“分隔符”，以便在 32 位边界上对齐后续选项。                                                                                                                                                           |
| **2**              | **4**                | **Maximum Segment Size Value**              | ***Maximum Segment Size:\*** 最大段大小：传达段的发送者希望接收的最大段的大小。仅用于连接请求 (SYN) 消息。                                                                                                                                                     |
| **3**              | **3**                | **Window Size Shift Bits**                  | ***Window Scale:\***窗口缩放：实现可选的窗口缩放功能，允许设备指定比普通窗口字段更大的窗口大小。 Option-Data 中的值指定 Window 字段应乘以 2 的幂，以获得选项发送者正在使用的真实窗口大小。例如，如果 Option-Data 的值为 3，这意味着 Window 字段中的值应乘以 8，假设两个设备都同意使用此功能。这允许在高性能链接上需要时宣传非常大的窗口。有关更多信息，请参阅有关数据传输的主题。 |
| **4**              | **2**                | **—**                                       | ***Selective Acknowledgment Permitted:\*** 允许选择性确认：指定此设备支持选择性确认 (SACK) 功能。这是作为没有 Option-Data 字段的两字节选项实现的，而不是像 End Of Option List 或 No-Operation 这样的单字节选项。这是必要的，因为它是在原始 TCP 规范之后定义的，因此必须指定明确的选项长度以实现向后兼容性。                   |
| **5**              | **Variable**         | **Blocks Of Data Selectively Acknowledged** | ***Selective Acknowledgment:\*** 允许选择性确认：指定此设备支持选择性确认 (SACK) 功能。这是作为没有 Option-Data 字段的两字节选项实现的，而不是像 End Of Option List 或 No-Operation 这样的单字节选项。这是必要的，因为它是在原始 TCP 规范之后定义的，因此必须指定明确的选项长度以实现向后兼容性。                             |
| **14**             | **3**                | **Alternate Checksum Algorithm**            | ***Alternate Checksum Request:\*** 选择性确认：允许支持可选选择性确认功能的设备指定已接收的非连续数据块，以便在中间段未显示且需要重新传输时不会重新传输它们。                                                                                                                            |
| **15**             | **Variable**         | **Alternate Checksum**                      | ***Alternate Checksum:\*** 备用校验和：如果实现备用校验和所需的校验和值太大而无法放入标准的 16 位校验和字段，则将其放置在此选项中。                                                                                                                                           |

我没有在表157中显示每一个TCP选项，只是显示了RFC 793中定义的基本选项和其他一些有趣的选项，它们与指南中其他地方描述的功能相对应。注意，大多数选项只在连接请求（SYN）段中发送。这包括上面的最大网段大小、窗口比例、允许选择性确认和备用校验请求等选项。相反，*Selective Acknowledgment* and *Alternate Checksum* 选择确认和备用校验选项在使用时，会出现在常规数据段中。

###### 4.1.4.4.2 TCP校验和计算和TCP "伪头"（部分：1 2 3 )

传输控制协议是为了在IP网络上的一对设备之间提供可靠的数据传输。为确保数据段的可靠传递，所需的大部分努力必然集中在确保数据在传输过程中不丢失的问题上。但是，对于数据的安全传输还有一个重要的关键障碍：在TCP网段穿越网络的过程中被引入错误的风险。

<u>**使用校验和检测传输错误**</u>
如果数据到达了它需要去的地方，但却被破坏了，而我们却没有发现这种破坏，这在某些方面比它根本没有出现更糟糕。为了提供对传输错误的基本保护，TCP在其头中包括一个16位的校验字段。校验和的概念非常简单：取一串数据字节并将它们加在一起。然后将这个总和与数据流一起发送，让接收方检查这个总和。在TCP中，发送数据段的设备使用一种特殊的算法来计算这个校验和；然后接收方使用同样的算法来检查它所收到的数据，确保没有错误。

TCP 使用的校验和计算与常规校验和算法有点不同。对校验和旨在保护的所有字节执行常规校验和，并且可以检测任何这些字段中的大多数位错误。 TCP 的设计者想要这种位错误保护，但也想要防止其他类型的问题。

<u>**增加检测错误的范围：TCP 伪报头**</u>

为此，对TCP校验和的计算方式进行了修改。这种特殊的TCP校验算法最终也被用户数据报协议（UDP）所采用。

在计算校验和之前，不是只对TCP段的实际数据字段进行计算，而是创建一个12字节的TCP伪头。这个头包含的重要信息来自TCP头和IP数据报中的字段，TCP段将被封装在其中。TCP伪报头的格式如表158和图217所示。

​                                                                      **表158: 用于校验和计算的TCP "伪报头"**

| **Field Name**             | **Size (bytes)** | **Description**                                                                                 |
| -------------------------- | ---------------- | ----------------------------------------------------------------------------------------------- |
| ***Source Address\***      | 4                | ***Source Address:\*** 源地址：数据报始发者的 32 位 IP 地址，取自 IP 报头。                                         |
| ***Destination Address\*** | 4                | ***Destination Address:\*** 目标地址：数据报的预期接收者的 32 位 IP 地址，也来自 IP 报头。                               |
| ***Reserved\***            | 1                | ***Reserved:\*** 保留：8 位零。                                                                       |
| ***Protocol\***            | 1                | ***Protocol:\*** 协议：IP 标头中的协议字段。这表明在 IP 数据报中承载的是什么高层协议。当然，我们已经知道这个协议是什么了，它就是 TCP！因此，该字段的值通常为 6。 |
| ***TCP Length\***          | 2                | ***TCP Length:\*** TCP Length：TCP 段的长度，包括标头和数据。请注意，这不是 TCP 标头中的特定字段；它是计算出来的。                    |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\tcppseudoheader.png)

​                                                              **图217: 用于计算校验和的TCP "伪报头"**

一旦这个96位的头形成，它就被放置在一个缓冲区中，然后再放置TCP段本身。然后，在整个数据集（伪头加TCP段）上计算校验和。校验和的值被放入TCP头的校验和字段中，而伪头被丢弃--它不是TCP段的实际部分，不会被传输。这个过程如图218所示。

**注意：**校验和字段本身就是TCP头的一部分，因此也是计算校验和的字段之一，这就造成了一种 "鸡和蛋 "的情况。在计算校验和的过程中，该字段被假定为全部为零。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\tcppseudocalc.png)

​                                                                         **图218: TCP报头校验和的计算**

为了计算TCP段头的校验和字段，首先构建TCP伪头，并在逻辑上置于TCP段之前。然后在伪头和TCP段上计算校验和。然后，伪头被丢弃。

当TCP段到达其目的地时，接收的TCP软件进行同样的计算。它形成伪头，将其预加到实际的TCP段中，然后执行校验（像以前一样将校验字段设置为零进行计算）。如果它的计算结果与源设备放在Checksum字段中的值不匹配，这表明发生了某种错误，该段通常被丢弃。

<u>**伪标头法的优点**</u>

那么，为什么要用这种 "伪头 "呢？源设备和目的设备都使用这个伪头中的字段来计算校验和。这意味着，如果出于任何原因，两个设备不使用相同的伪头值，校验将失败。现在，当我们考虑头中的内容时，我们发现这意味着校验和现在不仅能防止TCP段字段中的错误，还能防止。

- 段落交付不正确。如果目的地地址与源指定的地址不匹配，那么校验将失败。如果源地址不匹配，也会发生同样的情况。

- 不正确的协议。如果一个数据报被路由到TCP，但实际上由于某种原因属于不同的协议，这可以立即被发现。

- 段落长度不正确。如果TCP段的一部分被意外地省略了，源端和目的端使用的长度将不匹配，校验将失败。

伪头的聪明之处在于，通过使用它来计算校验和，我们可以提供这种保护，而实际上不需要发送伪头本身的字段。这就避免了在TCP头中重复使用伪头中的IP字段，这将是多余的，而且浪费带宽。伪头方法的缺点是，它使校验计算需要更多的时间和精力（尽管这在今天不是什么问题。）

在今天的现代、高速、高度可靠的网络背景下，伪头的使用有时显得 "过时 "了。一个数据报被送到错误地址的可能性有多大？不大可能。然而，在创建TCP的时候，人们非常担心在IP层面上可能没有对数据报的交付进行适当的 "端到端 "检查。在TCP检查和中包括IP信息被认为是一种有用的额外保护。

当然，TCP伪头有一个有趣的含义：它违反了TCP设计者在分割TCP和IP时试图尊重的架构分层原则。对于校验和，TCP必须知道IP信息，而技术上它 "不应该 "知道。例如，TCP校验和的计算需要将IP头中的协议号提供给接收设备上的TCP层，该协议号来自于承载该段的IP数据报。TCP伪头是一个很好的例子，在这种情况下，为了实用而放弃了严格的分层。

最后，TCP还支持一种可选的方法，即让两个设备商定一种替代的校验算法。这必须在连接建立期间进行协商。

**关键概念。**TCP校验和不仅通过TCP段计算，还通过TCP伪头计算，该伪头包含TCP段的长度以及IP源地址、目标地址和协议字段。由于这些字段是校验和的一部分，如果该段被错误的设备接收，或有不正确的协议字段或段长，它将被拒绝。这项技术很聪明，因为即使伪头本身没有实际传输，校验和也能提供这种保护。

###### 4.1.4.4.3 TCP最大段大小（MSS）和与IP数据报大小的关系（部分：1 2 3）

TCP段是TCP设备之间传输数据的信息。数据字段是传输实际数据的地方，由于TCP中数据字段的长度是可变的，这就提出了一个有趣的问题：我们应该在每个段中放多少数据？对于那些从高层接受数据块的协议来说，问题并不大，但TCP从使用它的应用程序中接受数据是一个恒定的流。这意味着它必须决定在它发送的每个消息中放入多少字节。

决定在一个网段中发送多少数据的一个主要因素是接收方的滑动窗口机制的当前状态。当设备A收到来自设备B的TCP段时，它检查窗口字段的值，以了解设备B允许设备A在其下一个段中发送多少数据的限制。在选择和调整窗口大小方面也有一些重要的问题，这些问题影响到整个TCP系统的运行，将在可靠性部分讨论。

除了当前窗口大小的要求外，每个TCP设备还与TCP大小的上限有关，即无论当前窗口有多大，都不会超过一个段的大小。这被称为最大网段大小（MSS）。当决定在一个网段中放入多少数据时，TCP连接中的每个设备将根据当前的窗口大小，结合可靠性部分描述的各种算法来选择数据量，但它永远不会大到数据量超过它所发送的设备的MSS。

注意：我需要指出的是，"最大网段大小 "这个名称实际上是误导性的。该值实际上是指一个网段所能容纳的最大数据量--它不包括TCP头。因此，如果MSS是100，实际的最大网段大小可能是120（对于普通的TCP头）或者更大（如果网段包括TCP选项）。

<u>**最大段大小选择**</u>

MSS的选择是基于在TCP/IP网络上传输数据时需要平衡各种相互竞争的性能和实施问题。主要的TCP标准RFC 793对MSS的讨论不多，这为如何使用该参数带来了潜在的混乱。RFC 879是在TCP标准发布几年后发布的，以澄清这个参数和围绕它的问题。与MSS有关的一些问题是相当平凡的；例如，某些设备用于容纳TCP段的缓冲区空间有限，因此可能希望将段大小限制在一个相对较小的值。但是，一般来说，必须通过平衡两个相互竞争的性能问题来选择MSS。

- 开销管理。TCP头占用了20个字节的数据（如果使用了选项则更多）；IP头也占用了20个或更多的字节。这意味着它们之间至少需要40个字节的头，所有这些都是非数据 "开销"。如果我们把MSS设置得太低，这将导致带宽的使用效率非常低。例如，假设我们把它设置为40；如果我们这样做，每个网段中最多只能有50%的数据；其余的都是头信息。许多网段的数据报在效率上会更差。

- IP分片。TCP段将被打包成IP数据报。正如我们在IP部分所看到的，数据包有自己的大小限制问题：底层网络的最大传输单元（MTU）的问题。如果一个TCP网段太大，它将导致一个IP数据报太大，无法在没有分片的情况下发送。分片会降低效率，并增加TCP段部分丢失的机会，导致整个段需要重传。

<u>**TCP默认最大网段大小**</u>
解决这两个相互竞争的问题的办法是为TCP建立一个默认的MSS，这个MSS尽可能大，同时避免大多数传输段的碎片。这是以IP网络的最小MTU 576开始计算的。所有的网络都被要求能够处理这个大小的IP数据报而不产生分片。从这个数字中，我们减去20字节的TCP头和20字节的IP头，剩下536字节。这就是TCP的标准MSS。

选择这个值是一种折中的办法。当使用这个数字时，它意味着大多数TCP段将在IP网络中被不分块地发送。然而，如果使用任何TCP或IP选项，这将导致超过576的最小MTU并发生分片。尽管如此，允许一些网段被分割，而不是使用一个小得多的MSS来确保没有任何网段被分割，这更有意义。如果我们选择，比如说，MSS为400，我们可能永远不会有碎片，但我们会把所有网段的数据/标题比例从536:40（93%的数据）降低到400:40（91%的数据）。

**关键概念。**TCP的设计是将其发送的网段大小限制在一定的最大限度内，以减少网段在IP层面上需要进行分片传输的可能性。TCP最大段大小（MSS）规定了TCP段数据字段的最大字节数，而不考虑影响段大小的任何其他因素。TCP的默认MSS是536，这是由最小的IP MTU 576和减去IP和TCP头的20字节得出的。

<u>**指定一个非默认的MSS值**</u>

当然，可能会出现默认MSS不理想的情况，因此TCP提供了一种方法，使设备可以指定它要使用的MSS比默认值536小一些或大一些。一个设备可以在连接建立过程中通知对方它想使用的MSS。选择这样做的设备在其SYN消息中包括TCP选项，适当地称为最大网段大小。另一个设备收到这个选项并记录连接的MSS。每个设备都可以为它收到的段独立指定它想要的MSS。

注意：设置过程中的MSS值的交换有时被称为MSS协商。这实际上是一个误导性的术语，因为它意味着两个设备必须同意一个共同的MSS值，但事实并非如此。每个设备使用的MSS值可能是不同的，事实上根本不存在协商。

如果设备知道网段将经过的网络的MTU大于IP最小值576，它们可能希望使用更大的MSS。当大量数据在本地网络上发送时，这是最常见的情况；路径MTU发现过程被用来确定适当的MSS。如果知道有一个特定的可选功能会持续增加IP头的大小，那么较小的MSS可能是可取的。采用IPSec的安全性就是一个很好的例子。

**关键概念。**设备可以通过在它们用来建立连接的SYN消息中包括一个©最大段大小的选项来表明它们希望使用不同于默认的MSS值。连接中的每个设备可以使用不同的MSS值。

![image-20221113102819207](C:\Users\zy\AppData\Roaming\Typora\typora-user-images\image-20221113102819207.png)

###### 4.1.4.4.4 TCP滑动窗口数据传输和确认机制（部分：1 2 3 4 5 6）

TCP连接建立过程是由一对设备在它们之间建立一个TCP连接。一旦所有的设置完成，传输控制块（TCB）被建立，参数被交换等等，设备就可以开始工作了：传输数据。

连接上的TCP设备之间的数据发送是通过我们在基础部分探讨的滑动窗口系统完成的。现在是时候更详细地了解一下滑动窗口是如何实现的，以允许数据被发送和接收。为了便于解释，我们将假设我们的连接是在一个客户和一个服务器之间--这比整个 "设备A/设备B "的事情要简单。

<u>**滑动窗口发送类别**</u>
连接上的两个设备中的每一个都必须跟踪它所发送的数据，以及它从另一个设备接收的数据。这是通过在概念上将字节划分为我们在滑动窗口概述中看到的类别来实现的。对于正在传输的数据，有四个传输类别。

- 传输类别#1：已发送和确认的字节

- 传输类别#2：已发送但尚未确认的字节

- 传送类别#3: 收件人已准备好的尚未发送的字节

- 传送类别#4：尚未发送的字节，收件人尚未准备好

<u>**滑动窗口接收类别**</u>
对于正在接收的数据，没有必要像发送器将其前两类分为 "已发送并确认 "和 "已发送但尚未确认 "那样，将其分为 "已接收并确认 "和 "已发送但尚未确认"。当然，原因是发送方必须等待每一次传输的确认，而接收方则不需要 "确认 "它收到了什么。

因此，一个接收类别对应于发送类别#1和#2，而另外两个则分别对应于发送类别#3和发送类别#4，总共有三个接收类别。为了帮助更清楚地了解这些类别的关系，我对它们进行了如下编号。

- 接收类别#1+2：收到并确认的字节。这是接收器对发送类别#1和#2的补充。

- 接收类别#3。尚未收到的字节，接收方已准备好。这是接收方对发送类别#3的补充。

- 接收类别#4：尚未收到的字节，接收方尚未准备好。这是接收方对发送类别#4的补充。

<u>**端（SND）的指针**</u>

连接中的客户端和服务器都必须跟踪它正在传输的数据流和它从其他设备接收的数据流。这是通过一组被称为指针的特殊变量来完成的，这些变量将字节流分为上述类别。四个传输类别是用三个指针划分的。其中两个指针是绝对的（指的是特定的序列号），而另一个是加入到绝对指针之一的偏移量，如下所示（参考图219）。

- Send Unacknowledged（SND.UNA）。已经发送但尚未确认的第一个数据字节的序列号。这标志着发送类别#2的第一个字节；之前的所有序列号都是指发送类别#1的字节。

- 发送下一个（SND.NXT）。发送给其他设备（本例中为服务器）的下一个数据字节的序列号。这标志着传输类别#3的第一个字节。

- 发送窗口（SND.WND）。发送窗口的大小。回顾一下，窗口规定了任何设备在任何时候都可能有 "未决"（未确认）的字节总数。因此，将第一个未确认字节的序列号（SND.UNA）和发送窗口（SND.WND）相加，标志着发送类别#4的第一个字节。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\tcpswpointers.png)

​                                                                **图219: TCP传输类别、发送窗口和指针**

此图与图207相同，但显示了TCP发送指针。SND.UNA指向传输类别#2的开始，SND.NXT指向传输类别#3的开始，SND.WND是发送窗口的大小。可用窗口的大小可以通过这三个指针计算出来。

观察这些指针的另一种方式是它们如何指示发送设备在任何时间点可以发送的字节数；也就是发送类别#3的字节数。传输类别#3的开始是由SND.NXT标记的。发送类别#4的第一个字节标志着结束，由SND.UNA+SND.WND给出。因此，传输类别#3的字节数由以下公式给出。

​                  **SND.UNA + SND.WND - SND.NEXT**
这被称为可用窗口，因为它表明发射器在任何时间点上可以使用多少个字节。当数据被确认时，通过增加SND.UNA的值，这将导致字节从发送类别2号移到类别1号。假设发送窗口大小不改变，这将导致窗口向右滑动，允许发送更多数据。

**关键概念。**TCP滑动窗口方案使用三个指针来跟踪四个发送类别中的每个字节。SND.UNA指向第一个未确认的字节，表示第二类传输的开始；SND.NXT指向下一个要发送的数据字节，标记第三类传输的开始。SND.WND包含发送窗口的大小；它被添加到SND.NXT中，标志着发送类别#4的开始。将SND.WND加到SND.UNA，然后减去SND.NXT，就得到了当前可用的发送窗口的大小。

<u>**接收（RCV）指针**</u>

三个接收类别使用两个指针来划分。

- 接收下一个（RCV.NXT）。预计来自其他设备的下一个数据字节的序列号。这标志着接收类别#3中的第一个字节。所有之前的序列号都是指已经收到并确认的字节，在接收类别#1+2中。

- 接收窗口（RCV.WND）。向其他设备 "公布 "的接收窗口的大小。这指的是设备愿意一次接受来自其对等设备的字节数，这通常是为这个连接分配的接收数据的缓冲区的大小。当添加到RCV.NXT指针时，标志着接收类别#4的第一个字节。

​                                                                **图220中说明了接收类别和指针。**

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\tcpswpointersreceive.png)

​                                                                              **图220: TCP接收类别和指针**

这张图是对图219的补充，显示了接收设备的类别是如何设置的。1号和2号类别已被合并，因为在 "收到和未确认 "和 "收到和确认 "之间没有区别。这个例子显示了接收设备在收到图219中已经发送的14个字节之前的状态。

**关键概念。**每个设备都会维护一组接收指针，它们是发送指针的补充。一个设备的发送指针跟踪其发出的数据，而其接收指针则跟踪进入的数据。两个接收指针是RCV.NXT和RCV.WND，前者表示预计来自另一设备的下一字节数据的编号，后者是该设备的接收窗口的大小。一个设备的RCV.WND等于连接上其他设备的SND.WND。

<u>**发送和接收指针之间的关系**</u>

当然，SND和RCV指针是互补的，就像类别一样，每个设备既要管理其数据的发送，又要管理从其对等物接收数据。假设我们有一个客户端和一个服务器，那么。

- 客户端。SND指针跟踪客户机的外发数据流；RCV指针指的是从服务器进来的数据。客户端的SND类别对应于服务器的RCV类别。

- 服务器。SND指针跟踪服务器的出站数据流；RCV指针指的是从客户端接收的数据。服务器的SND类别对应于客户端的RCV类别。

<u>**用于交换指针信息的TCP段字段**</u>
由于SND和RCV值是互补的，一个设备的发送窗口就是另一个设备的接收窗口，反之亦然。然而，请注意，两个设备之间的指针值并不总是完全一致的，因为在任何时候，一些字节可能在两个设备之间传输。例如，图220显示了接收方在接收字节32至45之前的接收指针，这些字节在图219中显示为过境。

SND和RCV指针都在每个设备持有的连接的传输控制块（TCB）中保持。随着数据的交换，指针被更新，关于发送和接收流的状态的通信使用TCP段格式中的控制字段进行交换。其中最重要的三个字是

- 序列号：确定正在传输的段中第一个字节的数据的序列号。这通常等于数据发送时SND.UNA指针的值。

- 确认号。通过指定段的发送方在段的接收方的下一次传输中所期望的序列号来确认数据的接收情况。这个字段通常等于发送设备的RCV.NXT指针。

- 窗口。发送段的设备的接收窗口的大小（因此，接收段的设备的发送窗口也是如此）。

Acknowledgment Number字段很关键，因为这是设备用来告诉它的同伴它收到了哪些段。该系统是累积性的：确认号码字段说 "我已经收到了序列号小于这个值的所有数据字节"。这意味着，如果客户端从服务器快速连续收到许多数据段，只要它们是连续的，它就可以用一个数字确认所有这些数据段。如果它们不是连续的，那么事情就会变得更加复杂。

**关键概念。**TCP段格式中的三个基本字段被用来实现滑动窗口系统。顺序号字段表示正在传输的数据的第一个字节的编号。确认号用于确认发送此段的设备所收到的数据。窗口字段告诉段的接收者它应该设置其发送窗口的大小。

<u>**TCP滑动窗口机制的实例说明**</u>

为了了解这一切是如何运作的，让我们考虑一个客户和服务器使用神话般的文件检索协议的例子。该协议规定，客户端发送一个请求，并从服务器收到一个即时响应。然后，服务器在准备好后发送所请求的文件。

当然，这两个设备将首先建立一个连接并同步序列号。为了简单起见，我们假设客户端使用的初始序列号（ISN）为0，而服务器的ISN为240。服务器将向客户端发送一个确认号为1的ACK，表示这是它期望接下来收到的序列号。假设服务器的接收窗口大小被设置为350，那么这就是客户端的发送窗口大小。客户端将发送其ACK，确认号码为241。假设它的接收窗口大小是200（而服务器的客户端窗口大小因此是200）。让我们假设两个设备在整个交易过程中保持相同的窗口大小。这通常不会发生，尤其是在设备繁忙的情况下，但这个例子足够复杂。我们还假设两个方向的最大段大小都是536字节。这意味着在这个例子中，MSS不会影响实际段的大小（因为MSS比两个设备的发送窗口大小都大）。

有了这个例子的背景，我们现在可以按照一个样本事务来详细说明在客户端和服务器之间交换信息时，发送和接收指针是如何创建和改变的。表159详细描述了这个过程，显示了每个步骤中两个设备的发送和接收指针的情况。它相当大，所以要小心。J 该交易还用两幅图来说明。图221和图222。两幅图都说明了同样的信息交换，使用的是表159的步骤号，但都是从其中一个设备的角度来说明的。图221显示了服务器的发送指针和客户端的接收指针；图222显示了客户端的发送指针和服务器的接收指针。(我本想把它们都放在一张图里，但它不适合！）。

​                                                                **表159: 带有发送和接收指针的TCP事务实例**

![image-20221113114732000](C:\Users\zy\AppData\Roaming\Typora\typora-user-images\image-20221113114732000.png)

![image-20221113114754257](C:\Users\zy\AppData\Roaming\Typora\typora-user-images\image-20221113114754257.png)

​                                                                       ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\tcpswexampleserver.png) 

​                                    **图221: 显示服务器发送指针的TCP事务实例**

从服务器的角度看表159的事务。客户端的指针见图222。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\tcpswexampleclient.png)

​                                                              **图222：显示客户端发送指针的TCP事务实例**

从客户端的角度看表159的事务。见图221，显示服务器的指针。

<u>**滑动窗口机制的现实世界中的复杂情况**</u>

我相信这看起来相当复杂，但事实上，这个例子是高度简化的，是为了向你展示基本的数据传输机制是如何工作的，而没有太多的事情发生。很吓人，不是吗？J 一个真实世界的连接会包括几个复杂的问题。

- 重叠的传输。我故意只展示了客户端的一个请求和服务器的一个响应。在现实中，客户机和服务器可能会快速连续地向对方发出许多请求和响应；客户机会用本身包含新请求的段来确认从服务器收到的段，如此类推。

- 对多个段的确认。我也没有展示一个设备收到两个段并以一个确认来确认的情况，尽管这肯定会发生。假设在上面的例子中，280字节文件的两个部分是同时发送的，并且同时被客户端接收。客户端将通过发送一个确认号为601的单一段来确认这两部分。请记住，这个字段是对所有包含数据的段的累积确认，直到它前面的数字，所以这将确认到600字节的所有数据。

- 流控制的窗口大小的波动。上面的例子中，窗口大小保持不变，但在实际连接中，情况并非总是如此。一个非常繁忙的服务器可能无法像确认数据那样快速处理和删除缓冲区中的数据。它可能需要减少其接收窗口，以减少客户端发送给它的数据量，然后在有更多空间时增加窗口。这就是TCP实现流量控制的方式。

- 丢失的传输。在一个真实的连接中，一些传输段会丢失，需要重新传输。这是由TCP的重传方案处理的。

- 避免小窗口问题。我在上表中暗示，我们不一定总是想以最快的速度发送数据，如果这意味着我们必须发送一个非常小的段。原因是这可能导致性能下降，包括一种叫做傻子窗口综合症的现象。这一点也将在接下来的章节中进行探讨，我们将看到处理它需要我们改变我们在这之前所看到的简单的滑动窗口方案。

- 拥堵处理和避免。多年来，基本的滑动窗口机制已经被改变，以避免TCP连接造成网络拥堵，并在检测到拥堵时让他们处理。拥塞问题将在下一节讨论，你猜对了。

###### 4.1.4.4.5 TCP即时数据传输。"Push "功能（部分：1 2）

TCP以非结构化的字节流形式接收来自进程的数据，这一事实使它在满足大多数应用的需要方面具有很大的灵活性。应用程序不需要创建块或消息；它只是在数据准备好传输时将其发送给TCP。就其本身而言，TCP对这个数据流中的字节的意义没有任何了解或兴趣。它们只是 "字节"，TCP只是发送它们，而不关心它们的结构或目的。

这对应用程序的工作方式有几个有趣的影响。其一是TCP不提供数据片断之间的分界点的任何自然指示，如数据库记录或文件。应用程序必须照顾到这一点。TCP的字节取向的另一个结果是，TCP不能根据数据的内容来决定何时形成一个段并在设备之间发送字节。TCP通常会将应用进程发送给它的数据累积在一个缓冲区中。它完全根据上一主题中讨论的滑动窗口系统，结合有助于确保协议有效运行的逻辑，来选择何时和如何发送数据。

这意味着，虽然一个应用程序可以控制它向TCP发送数据的速率和时间，但它不能从本质上控制TCP本身在互联网上发送数据的时间。现在，如果我们正在发送一个大文件，例如，这并不是一个大问题。只要我们继续发送数据，TCP就会继续在网络上转发数据。在这种情况下，让TCP用数据填满它的内部发送缓冲区，并在TCP认为合适的时候形成一个段来发送，一般是没有问题的。

<u>**积累数据进行传输的问题**</u>
然而，在有些情况下，让TCP在传输前积累数据会导致严重的应用问题。这方面的典型例子是一个交互式应用程序，如Telnet协议。当你使用这样的程序时，你希望每个按键都能立即发送到另一个程序；你不希望TCP积累数百个按键，然后一次全部发送。后者可能更 "有效"，但它使应用程序无法使用，这真是本末倒置。

即使是比较平凡的传输文件的协议，在很多情况下，我们也需要说 "现在就发送数据"。例如，许多协议开始时，客户端向服务器发送一个请求，就像前面的例子中假设的那样，或者由网络浏览器发送一个网页的请求。在这种情况下，我们希望客户端的请求立即发送；我们不想等到TCP积累了足够多的请求来填充一个 "最佳大小 "的段。

<u>**强制立即传输数据**</u>

自然，TCP的设计者意识到需要一种方法来处理这些情况。当一个应用程序有需要立即在互联网上发送的数据时，它会将数据发送到TCP，然后使用TCP推送功能。这告诉发送的TCP在它能够做到的情况下立即 "推送 "它所拥有的所有数据到接收者的TCP上，而不必等待更多的数据。

当这个功能被调用时，TCP将创建一个（或多个）网段，其中包含它所拥有的所有数据，并在传输时将PSH控制位设置为1。 目的地设备的TCP软件看到这个位的发送，就会知道它不应该只是把它所收到的网段中的数据拿去缓冲，而是直接推送给应用程序。

重要的是要认识到，推送功能只是强迫立即交付数据。它并没有改变TCP在数据元素之间不提供边界的事实。看起来，一个应用程序可以发送一条数据记录，然后 "推 "给收件人；然后发送第二条记录，"推 "给收件人，如此循环。然而，应用程序不能因为它给TCP的每条数据都设置了PSH位，就认为每条数据都会在一个段中。第一条 "推送 "可能包含之前给TCP的尚未传输的数据，而且也有可能以这种方式 "推送 "的两条记录最终会出现在同一个段中。

**关键概念。**TCP包括一个特殊的 "推 "功能，以处理给TCP的数据需要立即发送的情况。一个应用程序可以向其TCP软件发送数据，并指出它应该被推送。该段将被立即发送，而不是被缓冲。被推送的段的PSH控制位将被设置为1，以告诉接收的TCP应该立即将数据传递给接收的应用程序。

###### 4.1.4.4.6 TCP优先数据传输。"Urgent "功能 (Parts: 1 2 )

TCP把要传输的数据看作只是一个非结构化的字节流，这对它的使用方式有一些重要的影响。这一特点的一个方面是，由于TCP不了解它所发送的数据的内容，它通常将一个流中的所有数据字节视为等同的。数据以特定的顺序被发送到TCP，并以同样的顺序进行传输。这使得TCP在这方面就像那些恼人的语音邮件系统，告诉你不要挂断电话，因为他们会按照收到的顺序接听电话。

**注：**小毛病：我讨厌被告知 "您的电话将按照收到的顺序接听"。我只打了一个电话，所以我的电话并没有按照任何 "顺序 "被接听！"。这句话应该是复数："电话将按照收到的顺序回答"。J

<u>**TCP的正常数据处理。先入先出**</u>
当然，虽然等待是令人恼火的，但这种先入先出的行为通常是我们希望TCP的操作方式。如果我们要传输一个消息或文件，我们希望能够给TCP提供组成要发送的文件的字节，并让TCP按照我们给它的顺序传输数据。然而，正如我们在上一主题中看到的特殊情况需要 "推 "的功能一样，在有些情况下，我们可能不希望总是按照给TCP的确切顺序发送所有数据。

最常见的例子是当需要中断一个应用程序的数据传输时。假设我们有一个应用程序，在两个设备之间双向发送大文件。该应用程序的用户意识到正在传输的是错误的文件。当他或她告诉应用程序停止正在发送的文件时，我们希望这一点能立即被传达给TCP连接的另一端。我们不希望 "中止 "命令只是被放在我们试图发送的文件之后的行尾

<u>**确定数据传输的优先次序**</u>

TCP以其 "紧急 "功能的形式，为进程提供了一种优先发送数据的方法。要使用它，需要发送紧急数据的进程要启用该功能，并将紧急数据发送至其TCP层。TCP然后创建一个特殊的TCP网段，将URG控制位设置为1，并将紧急指针字段设置为一个偏移值，指向网段中紧急数据的最后一个字节。因此，例如，如果该段包含400字节的紧急数据和200字节的常规数据，URG位将被设置，紧急指针字段的值将为400。

在收到URG标志设置为1的段时，接收设备会查看紧急指针，并根据其值确定段中的哪些数据是紧急的。然后，它将紧急数据转发给进程，并指出该数据被发送者标记为紧急。该段中的其他数据则被正常处理。

由于我们通常想发送紧急数据，嗯，是紧急的，所以当这种数据被提供给TCP时，通常也会调用 "推 "函数。这确保了紧急数据被发送的TCP尽快发送，同时也被接收的TCP立即转发到协议栈中。同样，我们需要记住，这并不能保证紧急段的内容。使用 "推送 "功能可能意味着该段只包含紧急数据，而没有非紧急数据，但同样，应用程序不能假设这将永远是这种情况。

**关键概念。**为了处理数据流的某一部分需要以比其他部分更高的优先级发送的情况，TCP包含了一个 "紧急 "功能。当需要发送关键数据时，应用程序向其TCP层发出信号，该层在TCP段中设置URG位进行传输，绕过任何可能已经排队传输的低优先级数据。

##### 4.1.4.5 TCP的可靠性和流量控制功能及协议的修改

传输控制协议的主要任务很简单：打包和发送数据。当然，几乎每个协议都会打包和发送数据。TCP与这些协议的不同之处在于控制设备间数据流的滑动窗口机制。这个系统不仅管理基本的数据传输过程，还用于确保数据的可靠发送，同时也管理设备间的数据流，以确保数据的有效传输，而不会出现任何一个设备发送数据的速度超过另一个设备的接收速度。

为了使TCP能够提供应用所需的数据传输功能和质量，该协议必须在我们在前面几节中看到的简化数据传输机制之外进行增强。额外的 "智能 "需要被赋予协议以处理潜在的问题，并对设备发送数据的基本方式进行了改变，以避免可能导致的低效率。

在本节中，我描述了TCP如何确保TCP连接上的设备以可靠和有效的方式进行通信。我首先解释了TCP检测丢失段并重传的基本方法。我讨论了与TCP的确认方案有关的一些问题以及提高其效率的可选功能。然后，我描述了TCP调整其在决定一个网段丢失之前将等待多长时间的系统。我讨论了如何调整窗口大小以实现流量控制，以及窗口大小管理中涉及的一些问题。这包括对臭名昭著的 "傻子窗口综合症 "问题的研究，以及用于解决与修改基本滑动窗口方案的小窗口大小有关的问题的特殊启发式方法。最后，我讨论了TCP处理和避免拥塞的机制。

**背景信息。**本节假定你已经熟悉了TCP序列号和分段，以及TCP滑动窗口机制的基本知识。它还假定你已经阅读了关于TCP消息格式和数据传输的章节。如果没有，你可能想至少回顾一下描述TCP数据传输机制的主题；本节中的几个主题扩展了对TCP数据传输的简化讨论，以显示在非理想条件下发生的情况。

###### 4.1.4.5.1 TCP分段重传定时器和重传队列（部分：1 2 3）

TCP的基本数据传输和确认机制使用一组由每个设备维护的变量来实现滑动窗口确认系统。这些指针记录了每个设备发送和接收的数据字节，以及区分已确认和未确认的传输。在上一节中，我描述了这种机制，并给出了一个简化的例子，显示了客户端和服务器如何使用它们进行基本的数据传输。

这个例子被简化的原因之一是，服务器传输的每个片段都被客户端接收，反之亦然。如果我们总是能指望这种情况发生就好了，但正如我们所知，在互联网环境中这是不现实的。由于任何情况，如硬件故障、IP数据报的损坏或路由器拥堵，一个TCP段可能被发送但从未被收到。为了成为一个可靠的传输协议，TCP必须能够检测到丢失的网段并重新传输。

<u>**使用重传队列管理重传**</u>
检测丢失的网段和重传的方法在概念上很简单。每次我们发送一个网段时，我们启动一个重传定时器。这个定时器从一个预定的值开始，随着时间的推移而倒数。如果定时器在收到段的确认之前过期，我们就重发该段。

TCP使用这种基本技术，但以一种略微不同的方式实现。这样做的原因是需要有效地处理许多可能同时未被确认的网段，以确保它们在需要时在适当的时间被重新传送。TCP系统按照以下特定顺序工作。

- 放置在重传队列中，定时器开始。一旦一个包含数据的网段被传输，该网段的副本就会被放在一个叫做重传队列的数据结构中。当段被放在队列中时，一个重传定时器就开始了。因此，每个网段都会在某一时刻被放在这个队列中。该队列按照重传定时器的剩余时间进行排序，因此TCP软件可以跟踪哪些定时器在过期前剩余时间最少。

- 确认处理。如果在计时器过期前收到一个网段的确认，该网段将从重传队列中删除。

- 重传超时。如果在一个网段的定时器过期前没有收到确认，就会发生重传超时，该网段会自动重传。

当然，我们不能保证重传的网段会被收到，就像我们对原始网段一样。由于这个原因，在重传一个网段后，它仍然留在重传队列中。重传定时器被重置，倒计时再次开始。希望能收到重传的确认，但如果没有，该段将被再次重传，并重复这一过程。

某些情况下，甚至可能导致一个网段的重复重传失败。我们不希望TCP永远不停地重传，所以TCP在断定有问题并终止连接之前，只会重传一个丢失的网段一定的次数。

**关键概念。**为了给发送的数据提供基本的可靠性，每个设备的TCP实现都使用一个重传队列。每个发送的数据段都被放在队列中，并为其启动一个重传计时器。当收到对该段数据的确认时，它将从重传队列中删除。如果定时器在收到确认之前关闭，该段将被重新发送，并重新启动定时器。

<u>**识别一个片段何时被完全确认**</u>

我们尚未讨论的一个问题是我们如何知道一个网段何时被完全确认。重传是按段处理的，但正如我们所看到的，TCP的确认是在累积的基础上使用序列号进行的。每次设备A向设备B发送一个网段时，B会查看网段中的确认号码字段的值。所有序列号低于该字段值的字节都已被A收到。

**因此，当段中发送的所有字节的序列号低于 B 发送给 A 的最新确认号时，B 发送给 A 的段被视为已确认。这是通过计算该段中的最后一个序列号来确定的。段使用它的第一个字节号（在序列号字段中）和段的数据字段的长度。**

**关键概念：**TCP 使用累积确认系统。设备接收到的段中的确认号字段表示序列号小于该值的所有数据字节已被其他设备成功接收。当一个段的所有字节都已被确认时，该段被视为已确认；换句话说，当接收到一个包含大于其最后一个字节的序列号的值的确认号时。

<u>**带重传的TCP事务实例**</u>

让我们用一个例子来说明确认和重传在TCP中是如何工作的（如图223所示，你可以在阅读过程中参考该图）。假设一个连接中的服务器发送了四个连续的段（为了清楚起见，从1开始编号）。

- 段落#1：序列号字段为1，段长为80。所以段#1中的最后一个序列号是80。

- 段落#2：序列号字段为81，段长为120。在段#2中的最后一个序列号是200。

- 3号段：序列号字段为201，段长为160。3号段中的最后一个序列号是360。

- 4号段：序列号字段为361，段长为140。4号段中的最后一个序列号是500。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\tcpswretrans.png)

​                                                                            图223: 带有重传的TCP事务实例

该图说明了一个简单的事务，显示了服务器的发送指针和客户端的接收指针。服务器向客户端快速连续发送了三个片段，为每个片段设置了一个重传计时器。客户端收到了第1和第2部分，并为它们发送了一个确认信息；在收到这个确认信息后，第1和第2部分被从重传队列中移除。然而，第3部分在传输中丢失。当收到第4部分时，客户端不能确认它；这将意味着收到了丢失的第3部分。最终，第3部分的重传计时器过期，它被重传，这时第3和第4部分都被确认。

同样，这些信息可以一个接一个地发送，而不必等待前面的每个传输被确认；这是TCP的滑动窗口机制的一个主要好处。

现在我们假设客户端收到前两次传输。它将发回一个确认字段值为201的确认信息。这告诉服务器，客户机已经成功地收到了前两个片段；它们将从重传队列中移除（而且服务器的发送窗口将向右滑动200字节）。3号段将保持在重传队列中，直到收到一个确认号字段值为361或更高的段；4号段需要一个确认值为501或更高。

现在，让我们进一步假设在这个例子中，3号段在传输中丢失，但4号段被收到。客户端将在其接收缓冲区中存储4号段，但不能确认它，因为TCP的累积确认系统--确认4号段意味着也收到了3号段，但它从未出现过。所以客户端将不得不简单地等待#3。最终，服务器为3号段启动的重传定时器将过期。然后，服务器将重新传输3号段。客户端将收到它，然后它将能够向服务器确认#3和#4。

然而，这里还有一个重要的问题：服务器到底应该如何处理第4段。当客户端在等待丢失的3号段时，服务器没有收到任何反馈；它不知道3号段丢失了，它也不知道4号段发生了什么（或任何后续的传输）。然后，也许4号段也丢失了。有些实现可能选择只重新发送第3段，而有些可能选择同时重新发送第3段和第4段。这是一个重要的问题，将在下一个话题中详细讨论。

最后一个问题是，当我们把一个段放在重传队列中时，我们应该使用什么值作为重传计时器。如果设置得太低，就会发生过多的重传；如果设置得太高，由于重新发送丢失的网段时出现了不相干的延迟，性能就会下降。事实上，TCP不能使用一个单一的数字作为这个值；它必须使用一个称为自适应重传的过程来动态地确定它。

###### 4.1.4.5.2 TCP非连续应答处理和选择性应答（SACK）（部分：1 2 3 4）

计算机科学界人士有时会用 "优雅 "一词来描述对一个问题或需求的简单而有效的解决方案。我认为这个词相当适用于作为TCP滑动窗口系统一部分的累积确认方法。通过在TCP网段的确认号码字段中返回一个数字，发送网段的设备不仅可以确认它从其连接对等体收到的一个网段，还可以确认其中的几个。我们在关于滑动窗口的基本原理的专题中看到了这一点，并在之前关于重传的专题中再次看到了这一点。

<u>**TCP滑动窗口系统的主要弱点。处理非连续的确认信息**</u>
然而，即使是最优雅的技术也有某些弱点。就TCP确认系统而言，它无法有效地处理收到非连续的TCP段。确认号码指定所有低于其值的序列号已经被发送该号码的设备收到。如果我们收到的字节的序列号在两个不连续的范围内，就没有办法用一个数字来指定。

这可能会导致潜在的严重的性能问题，特别是在高速运行的互联网上或在固有的不可靠的物理网络上。为了了解问题所在，让我们回到上一主题中的例子。在那里，服务器发送了四个段，并收到了一个确认号码为201的回执。因此，段#1和段#2被认为是被确认的。它们将被从重传队列中移除，这也将允许服务器的发送窗口向右滑动80+120字节，允许再发送200字节的数据。

然而，让我们再次设想，从序列号201开始的3号段 "消失 "了。由于客户端从来没有收到过这个段，所以它永远无法发回一个确认号高于201的确认信息。这导致滑动窗口系统被 "卡住"。服务器可以继续发送额外的段，直到它填满客户端的接收窗口，但直到客户端发送另一个确认，服务器的发送窗口将不会滑动。

我们看到的另一个问题是，如果3号段丢失了，客户端没有办法告诉服务器它实际上已经收到了任何后续段。客户端完全有可能收到服务器的4号段，此外，还有后来发送的段，直到窗口满了。但是客户端不能发送一个值为501的确认，以表明收到了第4段，因为这意味着也收到了第3段。

**注意**：注意：在某些情况下，客户端可能仍会在收到段#4 时发送确认，但仅包含对直到段#2 末尾的字节的重复确认。有关说明，请参阅拥塞避免主题。

在这里，我们看到了 TCP 单个编号、累积确认系统的缺点。我们可以想象一个“最坏的情况”，服务器被告知它有一个 10,000 字节的窗口，并发送 20 个 500 字节的段。第一段丢失，其他 19 段被接收。但是因为是第一个段没有出现，所以其他19个段都不能确认！

**关键概念。**TCP的确认系统是累加的。这意味着，如果一个段在传输过程中丢失，在丢失的段被重传并成功接收之前，没有任何后续段可以被确认。

<u>**当存在未确认的网段时处理重传的策略**</u>

这就引出了一个重要的问题：当丢失的网段之外还有后续的网段未处理时，我们如何处理重传？在我们上面的例子中，当服务器在3号段上遇到重传超时时，它必须决定如何处理4号段，因为它根本不知道客户是否收到它。在我们的 "最坏情况 "下，我们有19个段，在第一个段丢失后，可能出现在客户端，也可能没有出现。

我们有两种不同的可能方式来处理这种情况。

<u>**只重发超时的片段**</u>
这是更 "保守 "的方法，或者如果你愿意，"乐观 "的方法。我们只重传超时的段，希望其他的段都能成功接收。

如果超时段之后的片段真的出现了，这种方法是最好的。如果它们没有出现，那就不太行了。在后一种情况下，每个片段都必须单独超时并被重新传输。想象一下，在我们的 "最坏情况 "下，所有20个500字节的段都丢失了。我们将不得不等待1号段超时并被重新传输。这个重传将被确认（希望如此），但随后我们将陷入等待2号段超时并被重新发送。我们将不得不多次这样做。

<u>**重发所有未发送的段**</u>
这是更 "激进 "或 "悲观 "的方法。每当一个网段超时，我们不仅要重新发送它，还要重新发送所有其他仍未被确认的网段。

这种方法确保在任何时候出现确认中断时，我们都会 "刷新 "所有未确认的段，以便给其他设备一个额外的机会来接收它们，以防它们也丢失。在所有20个片段都丢失的情况下，这比 "乐观 "的方法节省了大量的时间。这里的问题是，这些重传可能没有必要。如果20段中的第一段丢失了，而其他19段实际收到了，我们就会无缘无故地重新发送9500字节的数据（加上头信息）。

<u>**没有理想的答案**</u>

由于TCP不知道这些其他段是否出现，它不能知道哪种方法更好。它必须简单地做出一个 "执行决定"，使用一种方法或另一种方法，并希望得到最好的结果。在上一主题的例子中，如图223所示，我展示了 "保守 "的方法--只重传了文件中丢失的那一段。相比之下，图224显示的是 "激进 "的重传方法。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\tcpswretransaggr.png)

​                                                               **图224: TCP "激进 "重传实例**

这个例子与图223相同，只是这里服务器采取了一种 "积极 "的方法来重传丢失的网段。当3号段超时时，3号和4号段都被重传，并且重启了它们的重传计时器。(在这种情况下，#4已经到达，所以这个额外的传输是没有用的）。

**关键概念。**有两种方法来处理TCP的重传。在更 "保守 "的方法中，只有计时器过期的网段被重传；这可以节省带宽，但如果连续丢失许多网段，可能会导致性能下降。另一种方法是，当一个网段的重传计时器过期时，它和所有后续的未确认网段都被重传。如果许多网段丢失，这将提供更好的性能，但可能会在不必要的重传中浪费带宽。

<u>**一个更好的解决方案。选择性确认(SACK)**</u>

事实上，正是这种对非连续段的不了解才是非连续段问题的核心。解决方案是在基本的TCP滑动窗口算法中增加一个可选功能，允许设备单独确认非连续段。这个功能在RFC 1072中引入，并在RFC 2018中完善，被称为TCP选择性确认，缩写为SACK。

要使用SACK，连接上的两个设备必须都支持该功能，并且必须通过协商他们用来建立连接的SYN段中的选择性确认许可（SACK-Permitted）选项来启用它。假设这样做了，那么任何一个设备都被允许在常规的TCP段中包含一个选择性确认（SACK）选项。这个选项包含一个序列号范围的数据段列表，这些数据段已经被收到，但由于它们是不连续的，所以没有被确认。

每个设备修改它的重传队列，使每个网段包括一个标志，如果该网段已被选择性地确认，则该标志被设置为1--SACK位。然后，设备使用上述 "激进 "方法的修改版本，在重发一个段时，所有后来的段也被重发，除非它们的SACK位被设置为1。

例如，在我们的四节段案例中，如果客户端收到了第4节段，但没有收到第3节段，当它发回一个确认号字段值为201的节段时（对于#1和#2），它可以包含一个SACK选项，指定 "我已经收到了361到500字节，但它们还没有被确认"。如果4号段在1号和2号段之后到达，这也可以在第二个确认段中完成。服务器认识到这是第4段的字节范围，并打开第4段的SACK位。当3号段被重传时，服务器看到4号段的SACK位被打开，就不重传了。这在图225中有所说明。

在3号段被重传后，4号段的SACK位被清除。这样做是为了稳健，以处理客户由于某种原因对收到4号段 "改变主意 "的情况。客户端应该发送一个确认号码为501或更高的确认，表明 "正式 "收到第3和第4段。如果没有发生这种情况，服务器必须收到另一个关于第4段的选择性确认，以使其SACK位重新打开。否则，当它的定时器过期时，或当3号段被重传时，它将被自动重新发送。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\tcpswretranssack.png)

​                                                             **图225: 带有选择性确认（SACK）的TCP重传**

这是图223和图224中的例子，改变后使用了可选的选择性确认功能。在收到文件的第1、2和4部分后，客户端为第1和2部分发送一个确认，其中包括第4部分的SACK。这告诉服务器在第3部分的定时器过期时不要再发送第4部分。

**关键概念。**可选的TCP选择性确认功能提供了一种更优雅的方式来处理重传定时器过期时的后续段。当设备收到一个非连续段时，它在其常规确认中包括一个特殊的选择性确认（SACK）选项，该选项可以识别已经收到的非连续段，即使它们还未被确认。这使原发件人不必重新传输它们。

###### 4.1.4.5.3 TCP自适应重传和重传定时器的计算（部分：1 2 3）

每当传输一个TCP网段时，它的一个副本也会被放在重传队列中。当网段被放在队列中时，该网段的重传定时器就会启动，该定时器从一个特定的值开始，倒数到零。正是这个定时器控制了在发件人放弃之前，一个网段可以保持多长时间不被确认，断定它已经丢失并再次发送。

因此，我们用于重传计时器的时间长度是非常重要的。如果它被设置得太低，我们可能会开始重发一个实际已经收到的片段，因为我们没有等待足够长的时间来确认该片段的到来。相反，如果我们把定时器设置得太长，我们就会浪费时间等待一个永远不会到达的确认，从而降低整体性能。

<u>**选择重传定时器的持续时间的困难**</u>
理想情况下，我们希望将重传定时器设置为一个略大于两个TCP设备之间的往返时间（RTT）的值，也就是说，从客户端向服务器发送一个网段，然后由服务器向客户端发送确认的典型时间（当然，也可以反过来）。问题是，不存在这样的 "典型 "往返时间。这有两个主要原因。

- 连接距离的差异。假设你在美国工作，在午餐时间，你在你的工作站和本地服务器之间使用100Mbps的快速以太网连接传输一个大文件，同时你从你姐姐的个人网站上下载你侄子的照片，该网站使用模拟调制解调器连接到秘鲁利马附近小镇的ISP。你想让这两个TCP连接使用相同的重传计时器值吗？我当然不希望

- 瞬时延迟和可变性。在任何两个设备之间发送数据所需的时间都会因互联网上发生的各种情况而变化：流量的波动、路由器的负载等等。要自己看一个例子，试着在连接互联网的个人电脑的命令行中输入 "ping www.tcpipguide.com"，你会看到报告的时间是如何变化的。

<u>**基于往返时间计算的自适应重传**</u>

正是由于这些原因，TCP并不试图为其重传计时器使用一个静态的、单一的数字。相反，TCP使用动态或自适应重传方案。TCP试图确定设备之间的近似往返时间，并随着时间的推移对其进行调整，以补偿平均延迟的增加或减少。如何做到这一点的实际问题很重要，但在主要的TCP标准中没有详细介绍。RFC 2988，计算TCP的重传计时器，广泛地讨论了这个问题。

正如我们所看到的，往返时间可以 "反弹"，所以我们希望为连接争取一个平均RTT值。这个平均值应该对RTT的持续上下波动做出反应，而不是对少数非常慢或非常快的确认做出过度反应。为了允许这种情况发生，RTT计算使用了一个平滑公式。

New RTT = (α* Old RTT) + ( (1-α) * Newest RTT Measurement)
其中 （α）是一个介于0和1之间的平滑系数。α的值越高（越接近1），就越能提供更好的平滑效果，避免因一个非常快或非常慢的RTT测量而产生的突然变化。相反，这也减慢了TCP对往返时间的持续变化的反应速度。较低的α值（更接近于0）使RTT在对测量的RTT的变化作出反应时变化得更快，但在RTT剧烈波动时可能导致 "过度反应"。

<u>**确认的模糊性**</u>
测量两个设备之间的往返时间在概念上很简单：注意一个段的发送时间，注意收到确认的时间，然后将两者相减。然而，在实际执行中，这种测量是比较棘手的。一个主要的潜在的 "麻烦 "发生在一个段被认为丢失并被重新传送的时候。重传的段没有任何区别于原始段的地方。当收到该段的确认时，不清楚它是对应于重发段还是原始段。(尽管我们决定该段丢失并重新传输，但有可能该段最终到达了那里，花了很长时间；或者该段很快到达了那里，但确认却花了很长时间！)

这就是所谓的确认模糊性，要解决这个问题并不容易。我们不能只是决定假设一个确认总是与发送的段的最古老的副本一起发送，因为这使得往返时间显得太高。我们也不希望只是假设一个确认总是与最近发送的段一起发送，因为这可能会人为地降低平均往返时间。

<u>**对RTT计算和卡恩算法的改进**</u>

TCP对往返时间计算的解决方案是基于使用一种叫做卡恩算法的技术，这是以其发明者菲尔-卡恩的名字命名的。该算法的主要变化是将平均往返时间的计算与用于重传段的定时器的计算分开。

卡恩算法的第一个变化是，在计算连接的总体平均往返时间时，不使用任何被重传的段的测量往返时间。这就完全消除了确认不明确的问题。

然而，这本身并不允许由于重传而增加的延迟影响平均往返时间。为此，我们需要第二个变化：为重传段加入一个定时器退避方案。我们首先根据当前的平均往返时间，为每个新传输的网段设置重传计时器。当一个网段被重传时，定时器不会被重置为初始传输时的相同值。它使用一个乘数（通常为2）被 "退后"（增加），以使重传有更多时间被接收。计时器继续增加，直到重传成功，达到一定的最大值。这可以防止重传发送过快，进一步增加网络拥堵。

一旦重传成功，往返定时器将保持在较长的（退后）值，直到可以测量到一个有效的往返时间，该段已发送并确认没有重传。这允许设备用较长的定时器来应对偶尔的情况，这些情况会导致连接上的延迟持续一段时间，而当正常情况恢复时，最终使往返时间恢复到长期平均值。

**关键概念。**TCP使用自适应重传方案，根据设备间发送段的平均时间，自动调整重传计时器设置的时间量。这有助于避免过快或过慢地重传可能丢失的段。

###### 4.1.4.5.4 TCP窗口大小调整和流量控制（部分：1 2 3 4）

我们已经看到窗口大小的概念对TCP的滑动窗口机制的重要性。在客户端和服务器之间的连接中，客户端告诉服务器它愿意一次从服务器接收多少个字节；这就是客户端的接收窗口，它成为服务器的发送窗口。同样地，服务器告诉客户端它愿意一次从客户端接收多少字节的数据；这就是服务器的接收窗口和客户端的发送窗口。

这些窗口的使用在讨论TCP的基本数据传输和确认机制的专题中进行了演示。然而，正如该主题中的例子被简化了，因为我没有展示丢失段会发生什么，还有一种情况是它没有反映实际互联网的真实情况：在通信过程中，发送和接收窗口大小从未改变。

<u>**缓冲区管理对TCP窗口大小的影响**</u>
要理解为什么窗口大小可能会波动，我们需要了解它代表什么。考虑窗口大小的最简单方法是，它表示设备对特定连接的接收缓冲区的大小。也就是说，窗口大小表示设备在传递给应用进程之前，一次可以处理多少来自其对等物的数据。让我们考虑前述的例子。我说，服务器的窗口大小是360。这意味着服务器愿意从客户端一次接受不超过360字节的数据。

当服务器收到来自客户端的数据时，它将其放入这个缓冲区。然后，服务器必须对这些数据做两件不同的事情。

- 确认。服务器必须向客户端发送一个确认信息，以表明数据已经收到。

- 传输。服务器必须处理数据，将其转移到目标应用进程。

区分这两项活动是至关重要的。不幸的是，TCP标准在这方面没有做得很好，这使得它们非常难以理解。关键的一点是，在基本的滑动窗口系统中，数据在收到时被确认，但不一定立即从缓冲区中传输出来。这意味着缓冲区有可能被接收的数据填满，比接收TCP清空的速度更快。当这种情况发生时，接收设备可能需要调整窗口大小以防止缓冲区过载。

由于窗口大小可以用这种方式来管理连接两端设备之间的数据流速，它是TCP实现流量控制的方法，是传输层的 "经典 "工作之一。流量控制对TCP极为重要，因为它是设备之间相互交流状态的方法。通过减少或增加窗口大小，服务器和客户端各自确保其他设备发送数据的速度与接收方处理数据的速度相同。

<u>**减少发送窗口大小以降低数据的发送速度**</u>

让我们回到先前的例子，希望我能更好地解释我的意思，但让我们做一些改变。首先，为了简单起见，我们只看从客户端到服务器的传输，而不看服务器的回复（除了确认）--这在图222中有所说明。如前所述，客户端向服务器发送了140个字节。发送完这140个字节后，客户端的可用窗口中还剩下220个字节--发送窗口中的60个字节减去它刚刚发送的140个字节。

稍后，服务器收到这140个字节并将其放入缓冲区。现在，在一个 "理想的世界 "里，这140个字节进入缓冲区，被确认并立即从缓冲区移除。另一种思考方式是，缓冲区是 "无限大 "的，客户能发送多少就能容纳多少。缓冲区的自由空间仍然是360字节大小，所以同样的窗口大小可以回馈给客户端。这就是前面例子中的 "简化"。

只要服务器能够像处理进来的数据一样快，它就会把窗口大小保持在360字节。客户端在收到140字节的确认和之前相同的窗口大小后，将360字节的完整窗口向右 "滑动 "了140字节。由于现在有0个未确认的字节，客户端现在可以再次发送360字节的数据。这相当于以前在可用窗口中的220个字节，加上刚刚被确认的140个新字节。

然而，在 "现实世界 "中，该服务器可能要处理几十个、几百个甚至几千个TCP连接。TCP可能无法立即处理这些数据。另外，也有可能是应用程序本身由于某种原因还没有准备好接受这140个字节。在任何一种情况下，服务器的TCP可能无法立即从缓冲区中删除所有140字节。如果是这样，在向客户端发送确认时，将希望改变它向客户端公布的窗口大小，以反映缓冲区被部分填充的事实。

假设我们如上所述收到了140个字节，但只能向应用程序发送40个字节，缓冲区内还剩下100个字节。当我们为这140个字节发回确认时，服务器可以将其发送窗口减少100个，变成260个。当客户端收到服务器的这段话时，它将看到发送140字节的确认，并将其窗口向右滑动140字节。然而，当它滑动这个窗口时，它将其大小减少到只有260字节。我们可以认为这就像在窗口的左边缘滑动140字节，但右边缘只滑动40字节。新的、更小的窗口确保服务器从客户端接收到最多260个字节，这将适合其接收缓冲区中剩余的260个字节。这在图226顶部的第一次消息交换（步骤#1到#3）中得到了说明。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\tcpswflow.png)

​                                                                       **图226: TCP窗口大小调整和流量控制**

该图显示了三个消息周期，每个周期都会导致服务端减少其接收窗口。在第一个周期中，服务器将其从360减少到260，因此客户机的可用窗口在得到服务器的确认时只能增加40。在第二和第三种情况下，服务器根据它收到的数据量减少窗口大小，这就暂时冻结了客户端的发送窗口大小，使其停止发送新数据。

<u>**减少发送窗口大小以停止发送新数据**</u>

如果服务器忙得不可开交，无法处理收到的任何字节，怎么办？假设客户端的下一个传输是180个字节，但服务器非常忙，无法删除任何一个字节。它可以对这180个字节进行缓冲，并在它为这些字节发送的确认中，将窗口大小减少相同的数量：从260个减少到80个。当客户端收到180字节的确认时，它将看到窗口大小也减少了180字节。它将 "滑动 "其窗口，与窗口大小减少的数量相同。这实际上就像服务器说："我承认收到了180个字节，但我不允许你发送任何新的字节来替代它们"。

另一种看法是，窗口的左边缘滑动了180个字节，而右边缘保持固定。而只要窗口的右边缘不移动，客户端就不能比收到确认之前发送更多的数据。这就是图226中的中间交换（步骤#4至#6）。

<u>**关闭发送窗口**</u>

窗口调整的过程可以继续进行，当然，两个设备都可以做--我们在这里只是考虑客户机向服务器发送的一方。如果服务器继续从客户端接收数据的速度快于它向应用程序输送数据的速度，它将继续减少其接收窗口的大小。继续我们上面的例子，假设在发送窗口减少到80后，客户端发送了第三个请求，这个请求的长度是80字节，但服务器仍然很忙。然后，服务器将其窗口一直减少到0，这被称为关闭窗口。这告诉客户端，服务器已经非常超负荷了，它应该完全停止常规的数据发送，如图226底部三分之一所示。稍后，当服务器的负载减少时，它可以再次增加这个连接的窗口大小，允许更多的数据被传输。

虽然概念上很简单，但使用窗口大小调整的流量控制可能非常棘手。如果我们不注意如何改变窗口大小，我们就会在TCP的运行中引入严重的问题。还有一些特殊情况可能发生，特别是在窗口大小因设备变得繁忙而变小的情况下。接下来的两个主题将探讨窗口管理问题，以及为解决这些问题需要对基本的滑动窗口系统做出的改变。

**关键概念。**TCP的滑动窗口系统不仅用于通过确认和重传来确保可靠性--它也是TCP的流量控制机制的基础。通过增加或减少其接收窗口的大小，一个设备可以提高或降低其连接伙伴向其发送数据的速度。在设备变得非常繁忙的情况下，它甚至可以将接收窗口减少到零，关闭它；这将停止任何进一步的数据传输，直到窗口被重新打开。

###### 4.1.4.5.5 TCP窗口管理问题 (Parts: 1 2 3 )

TCP连接上的两个设备中的每一个都可以调整它向对方公布的窗口大小，以控制连接上的数据流。缩小窗口的大小迫使另一个设备发送更少的数据；增加窗口大小可以让更多的数据流动。理论上，我们应该能够让每个设备上的TCP软件根据需要改变窗口的大小，以匹配数据进入缓冲区和从缓冲区中取出并发送给接收应用程序的速度。

<u>**与 "缩减 "TCP窗口有关的问题**</u>
不幸的是，窗口大小的某些变化会导致不理想的后果。当窗口的大小减少或增加时，都会出现这些问题。为此，我们需要考虑一些与窗口大小管理有关的问题。和以前的主题一样，我们将使用在解释基本TCP数据传输过程的主题中首次展示的同一个客户/服务器例子的修改来说明。

一个窗口大小的管理问题与设备在繁忙时减少其接收窗口大小的速度有关。假设服务器开始时有一个360字节的接收窗口，就像前面提到的例子，收到140字节的数据，它确认了，但不能立即从缓冲区中删除。服务器可以通过减少它回馈给客户端的窗口的大小来做出回应。我们甚至在上一主题中讨论了根本无法从缓冲区中移除任何字节的情况，因此窗口大小减少了与添加到缓冲区的140个字节相同。这就 "冻结 "了客户端发送窗口的右边缘，所以当它得到确认时就不能发送任何额外的数据。

如果服务器过载到我们实际上需要减少缓冲区本身的大小呢？假设内存不足，操作系统说 "我知道你有360字节分配给这个连接的接收缓冲区，但我需要释放内存，所以现在你只有240字节"。服务器仍然不能立即处理它所收到的140个字节，所以它需要把发回给客户端的窗口大小从360个字节一直降到100个（总缓冲区中的240个字节减去已经收到的140个字节）。

实际上，这样做实际上是把客户端的发送窗口的右边缘移到了左边。它说 "当你收到这个确认时，你不仅不能发送更多的数据，而且你现在可以发送更少的数据"。在TCP术语中，这被称为收缩窗口。

然而，这样做有一个非常严重的问题：当原来的140个字节从客户端传输到服务器时，客户端仍然认为它有360个字节的总窗口，其中220个字节是可用的（360减140）。在收到服务器缩小窗口的通知之前，客户端很可能已经向服务器发送了这220字节的部分数据。如果是这样，服务器将其缓冲区减少到240字节，并使用了140字节，当这220字节出现在服务器上时，只有100字节可以容纳，任何额外的字节都需要被丢弃。这将迫使客户端不得不重新传输这些数据，这是很低效的。图227形象地说明了这种情况是如何发生的。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\tcpswshrinkprob.png)

​                                                                     <u>**图227："缩减 "TCP窗口的问题**</u>

在图226例子的修改中，客户端开始时的可用窗口大小为360。它发送了一个140字节的段，然后在很短的时间内发送了一个180字节的段。然而，服务器很忙，当它收到第一个传输时，决定将其缓冲区减少到240字节。它保留了刚刚收到的140字节，并将其接收窗口一直减少到100。当客户的180字节段到达时，服务器的缓冲区里只有180字节的100个空间。当客户端收到新的窗口大小为100的通告时，它将有一个问题，因为它已经有180个字节被发送但没有被确认。

<u>**在不 "缩减 "窗口的情况下减少缓冲区大小**</u>

为了防止这种情况的发生，TCP在基本的滑动窗口机制中增加了一条简单的规则：设备不允许缩小窗口。请注意，这里有一个潜在的术语歧义。在口语化的讨论中，"缩小 "和 "减少 "这两个词有时被当作同义词使用。正如我们所看到的，缩小窗口的大小并没有什么问题。缩小窗口 "的问题只是指这样一种情况，即我们把窗口大小缩小到与之前的窗口广告相矛盾，收回了发送一定数量字节的许可。

另一种看法是，只要服务器发回的窗口大小广告小于客户端当时认为的可用窗口大小，就会发生缩减。在这种情况下，服务器缩小了窗口，因为在它确认140字节的时候，它发回的窗口大小是100，小于客户端当时的220字节可用窗口。

当然，很可能有这样的情况，我们确实需要缩小缓冲区，那么应该如何处理呢？与其缩减窗口，服务器必须更有耐心。在上面的例子中，缓冲区需要减少到240，服务器必须发回一个220的窗口大小，冻结客户端发送窗口的右边缘。客户端仍然可以填满360字节的缓冲区，但不能发送超过这个数字。只要从服务器的接收缓冲区中删除120字节，缓冲区的大小就可以减少到240字节，而且没有数据损失。然后，服务器可以恢复正常操作，随着从接收缓冲区中取出的字节增加窗口大小。

**关键概念。**当一个设备减少其接收窗口，以至于其伙伴设备的可用发送窗口缩小时（意味着其发送窗口的右边缘向左移动），就会出现一种叫做缩小窗口的现象。由于这可能导致已经在传输中的数据不得不被丢弃，因此设备必须更逐步地减少其接收窗口的大小。

<u>**处理关闭的窗口和发送探针段**</u>

另一个特殊的窗口管理问题是如何处理设备必须将发送窗口的大小一直减少到零的情况。这被称为关闭接收窗口。由于服务器的接收窗口是客户端的发送窗口，将其大小减少到零意味着客户端不能再发送任何数据，正如我们在上一主题的例子结尾所看到的那样。这种情况一直持续到客户端从服务器收到一个新的确认，其中有一个非零的Window字段，这就重新打开了窗口。然后客户端就能再次发送。

这种情况的问题是，客户端依赖于从服务器收到的 "窗口打开 "段。像所有的TCP段一样，这个段是通过IP传输的，这是不可靠的。记住，TCP是可靠的，因为它确认发送的数据，并在必要时重传丢失的数据，但它永远不能保证任何特定的分段到达目的地。这意味着，当服务器试图用一个包含更大Window字段的确认分段重新打开窗口时，客户端有可能永远得不到消息。客户端可能会得出结论，认为发生了问题并终止连接。

为了防止这种情况发生，客户端可以定期向服务器发送特殊的探测段。这些探测的目的是促使服务器发送一个包含当前窗口大小的段。探测段可以包含零或一个字节的数据，即使在窗口关闭时也是如此。探针将继续定期发送，直到窗口重新打开，具体实现方式决定了探针产生的速度。

当服务器决定重新打开已关闭的窗口时，还有一个潜在的隐患：将窗口打开到太小的数值。一般来说，当接收窗口太小时，会导致产生许多小段，大大降低TCP的整体效率。下一个话题将探讨这个众所周知的问题以及如何通过改变基本的滑动窗口机制来解决这个问题。

<u>**关键概念。**</u>一个设备将其接收窗口减少到零，就被称为关闭窗口。其他设备的发送窗口因此被关闭；它不能发送常规数据段。然而，它可以发送探测段来检查窗口的状态，从而确保它不会错过窗口重新打开时的通知。

###### 4.1.4.5.6 TCP "傻子窗口综合症 "和为避免小窗口问题而对滑动窗口系统的改变（部分：1 2 3 4）

在描述TCP的最大网段大小（MSS）参数的专题中，我解释了在确定TCP网段的最佳大小方面的权衡。如果网段太大，我们就有可能使它们在IP层面上被分割成碎片。如果太小，我们的性能就会大大降低，因为我们在一个段中发送少量的数据，而段头的开销至少有40字节。我们还占用了宝贵的处理时间，因为需要处理这些小段。

MSS参数确保我们不会发送过大的网段--TCP不允许创建一个大于MSS的网段。不幸的是，基本的滑动窗口机制并没有提供任何可以传输的最小段大小。事实上，不仅设备有可能发送非常小的、低效的网段，使用不受限制的窗口大小调整的最简单的流量控制实现确保在重载条件下，窗口大小将变得很小，导致性能明显下降

<u>**愚蠢的窗口综合症是如何发生的**</u>
为了了解这种情况是如何发生的，让我们考虑一个例子，这个例子是我们在本节到目前为止所使用的例子的一个变种。我们假设MSS是360，一个客户/服务器对，同样，服务器的初始接收窗口被设置为这个相同的值，即360。这意味着客户端可以向服务器发送一个 "全尺寸 "段。只要服务器能够以客户端发送数据的速度从缓冲区中移除数据，我们就应该没有问题。(在现实中，缓冲区的大小通常会比MSS大）。

现在，想象一下，相反，服务器由于某种原因陷入困境，而客户需要向其发送大量的数据。为了简单起见，我们假设服务器每收到3个数据，只能从缓冲区中删除1个字节的数据。比方说，在下一个客户端的数据段到达的时间内，它还从缓冲区中删除了40个额外的字节。以下是将发生的情况。

1. 客户端的发送窗口是360，而且它有很多数据要发送。它立即向服务器发送了一个360字节的段。这就耗尽了它的整个发送窗口。

2. 当服务器收到这个段时，它确认了它。然而，它只能删除120字节，所以服务器将窗口大小从360减少到120。它在确认的窗口字段中发送了这一信息。

3. 客户端收到一个360字节的确认，并看到窗口大小已经减少到120。它想尽快发送它的数据，所以它发送了一个120字节的段。

4. 当120字节的片段到达时，服务器已经从缓冲区中又删除了40字节。这样，缓冲区就包含了200个字节（240个来自第一段，减去移除的40个）。服务器能够立即处理这120个字节的三分之一，即40个字节。这意味着80个字节被添加到已经留在缓冲区的200个字节中，所以280个字节被用掉了。服务器必须将窗口大小减少到80字节。

5. 客户端将看到这个减少的窗口大小，并发送一个80字节的段。

6. 服务器开始时有280个字节，去掉40个，剩下240个字节。它从客户那里收到80个字节，去掉三分之一，因此53个字节被添加到缓冲区，变成293个字节。它将窗口大小减少到67字节（360-293）。

这个过程，如图228所示，将持续很多轮，窗口大小越来越小，特别是如果服务器变得更加超载。它清除缓冲区的速度可能会进一步下降，而窗口可能会完全关闭。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\tcpswshrinkprob.png)

​                                                                          **图228: TCP "愚蠢窗口综合症"**

这张图显示了被称为TCP傻子窗口综合症的现象是如何产生的一个例子。客户端试图以最快的速度向服务器发送数据，而服务器非常繁忙，无法及时清除其缓冲区。客户端每次发送数据时，服务器都会减少其接收窗口。客户端发送的消息的大小就会缩小，直到它只发送非常小的、低效率的片段。

(请注意，在这张图中，我把服务器的缓冲区固定在某个位置，而不是像本节中的其他图那样向右滑动。这样你可以更容易地看到接收窗口的大小在减少。

 让我们假设这发生了。现在，最终，服务器将从这个缓冲区中删除一些数据。假设它在来自客户端的第一个关闭窗口“探测”到达时删除了 40 个字节。然后服务器将窗口重新打开到 40 字节的大小。客户端仍然迫切希望尽可能快地发送数据，因此它生成了一个 40 字节的段。就这样，可能所有剩余的数据都以小段从客户端传递到服务器，直到客户端用完数据，或者服务器更快地清除缓冲区。

现在想象最坏的情况。这一次，是服务器上的应用程序进程过载。它一次一个字节地从缓冲区中提取数据。每次它从服务器的缓冲区中删除一个字节时，服务器的 TCP 都会打开窗口大小正好为 1 的窗口，并将其放入 Window 字段中以向客户端确认。然后客户端发送一个正好有一个字节的段，重新填充缓冲区，直到应用程序提取下一个字节。

<u>**愚蠢的窗户综合症的原因：窗户尺寸的低效缩减**</u>

我们在上面看到的情况都不代表滑动窗口机制本身的失败。它正在正常工作，以保持服务器的接收缓冲区被填满并管理数据流。问题是，滑动窗口机制只关注缓冲区的管理--它没有考虑到以这种方式对窗口大小进行微观管理时产生的小段的低效率。

从本质上讲，通过发送小窗口大小的广告，我们是 "赢了战斗，输了战争"。早期发现这种现象的TCP/IP研究人员称其为愚蠢的窗口综合症（SWS），这是对 "滑动窗口系统 "一词的戏称，表达了他们对进入这种状态时的行为方式的看法。

上面的例子显示了SWS是如何由接收设备的小窗口尺寸广告引起的。如果发送设备不注意生成传输段的方式，不管接收方缓冲区的状态如何，也有可能发生SWS。

例如，假设在上面的例子中，客户端TCP从发送应用程序接收数据，每次是10字节的块。然而，发送的TCP非常急切地想把数据送到客户端，它把每个10字节的数据块立即打包成一个段，尽管下一个10字节的数据块很快就会到来。这将导致不必要的10字节数据段的蜂拥而至，效率低下。

关键概念。基本的TCP滑动窗口系统没有对传输段设置最小尺寸。在某些情况下，这可能会导致发送许多小的、低效的分段，而不是数量较少的大分段。这种现象被亲切地称为傻子窗口综合症（SWS），它的发生可能是由于接收方公布的窗口大小太小，或者发送方过于积极地立即发送非常小的数据量。

<u>**傻子窗口综合症的规避算法**</u>

由于SWS是由基本的滑动窗口系统不注意创造小段的决策结果造成的，处理SWS在概念上很简单：改变系统，使我们避免小窗口大小的广告，同时，也避免发送小段。由于数据的发送方和接收方都对SWS有影响，所以要对两者的行为进行改变以避免SWS。这些变化被统称为SWS避免算法。

<u>**接收者SWS避免**</u>
让我们从接收方的SWS避免开始。正如我们在上面的初始例子中所看到的，接收器由于忙于工作，将其接收窗口的大小减少到越来越小的值，从而导致了SWS。这导致发送方的发送窗口的右边缘以越来越小的增量移动，导致越来越小的片段。为了避免SWS，我们简单地规定，接收方不得以这样的方式更新其宣传的接收窗口，从而使发送方留下太少的可用窗口空间。换句话说，我们限制接收方将窗口的右边缘移动得太小。通常可以移动的最小边缘是MSS参数的值，或者是缓冲区大小的二分之一，以较小者为准。

让我们看看我们如何在上面的例子中使用这个方法。当服务器从客户端收到最初的360字节的段，只能处理120字节时，它不会将窗口大小减少到120。它把它一直减少到0，关闭窗口。它将此发回给客户端，然后客户端就会停止，不再发送一个小段。一旦服务器从缓冲区中又删除了60个字节，它现在将有180个字节空闲，是缓冲区的一半大小。它现在将窗口打开到180字节大小，并将新的窗口大小发送给客户端。

它将继续只公布0字节，或180或更多，而不是中间更小的值。这似乎会减慢TCP的运行速度，但实际上并没有。因为服务器是超载的，连接的整体性能的限制因素是服务器可以清除缓冲区的速度。我们只是用许多小段来交换几个大段。

<u>**发送方SWS规避和Nagle的算法**</u>

发送方避免SWS通常是通过对发送TCP的部分施加 "约束 "来完成的。我们不是试图尽快发送数据，而是等待发送，直到我们有一个合理大小的段。这样做的具体方法被称为Nagle算法，以其发明者John Smith命名。(开玩笑，是约翰-纳格尔。 J）简化后，该算法的工作原理如下。

- 只要连接上没有未确认的数据，只要应用程序想要，就可以立即发送数据。例如，在像Telnet这样的交互式应用程序的情况下，一个单一的击键可以在一个段中 "推 "出来。

- 当有未确认的数据时，所有后续要发送的数据都被保留在发送缓冲区中，直到所有未确认的数据被确认，或者我们已经积累了足够的数据来发送一个完整大小（MSS大小）的段，才会发送。即使用户要求 "推"，这也适用。

这可能看起来很奇怪，特别是关于尽管有推送请求，但仍要缓冲数据的部分！你可能会认为这将导致一些应用程序，如 "MSS"，被认为是 "MSS"。你可能认为这将导致像Telnet这样的应用 "中断"。事实上，Nagle的算法是一个非常聪明的方法，适合像Telnet这样的低数据率交互式应用和高带宽文件传输应用的需要。

如果你使用的是像Telnet这样数据到达速度非常慢的应用（与计算机相比，人类的速度非常慢），初始数据（第一次击键）可以立即推送。下一个按键必须等待确认，但相对于按下一个键所需的时间，这可能会很快到来。相比之下，产生大量数据的更传统的应用程序会自动将数据累积成更大的片段，以提高效率。

Nagle的算法实际上比这个描述要复杂得多，但这个话题已经变得太长了。RFC 896对其进行了（更多）详细的讨论。

**关键概念。**现代TCP的实现包含了一套SWS避免算法。当接收时，设备被编程为不公布非常小的窗口，而是等待，直到缓冲区有足够的空间来容纳一个合理大小的窗口。发送器使用Nagle算法来确保在有未确认字节的情况下不产生小段。

###### 4.1.4.5.7 TCP拥塞处理和拥塞避免算法 (Parts: 1 2 3 )

通过改变设备在TCP连接上向对等体宣传的窗口大小，设备可以增加或减少其对等体向其发送数据的速率。这就是TCP滑动窗口系统在两个连接设备之间实现流量控制的方式。在过去的几个主题中，我们已经看到了这是如何工作的，包括对 "基本 "机制所需的改变，以确保通过减少发送小段的数量来保持高的性能。

<u>**为什么TCP必须监控和处理网络拥塞问题**</u>
流量控制是调节设备间数据传输的一个非常重要的部分，但它在以下方面受到限制：它只考虑连接上每个设备内发生的情况，而不考虑它们之间的设备内发生的情况。事实上，这种 "以自我为中心 "是架构分层的症状。由于我们正在处理第四层的典型服务器和客户端之间的TCP工作，我们不担心数据如何在它们之间传递；那是第三层的互联网协议的工作。

在实践中，第三层发生的事情可能相当重要。从一个抽象的角度考虑，我们的服务器和客户可能使用TCP "直接 "连接，但我们传输的所有数据段都是通过网络和路由器在它们之间传输的。这些网络和路由器也在传输来自许多其他连接和高层协议的数据。如果网络变得非常繁忙，我们的连接端点之间传输段的速度就会降低，甚至可能被丢弃。这就是所谓的拥堵。

同样，在TCP层面，没有办法直接理解是什么导致了拥堵或为什么。它被认为是在将数据从一个设备转移到另一个设备的过程中效率低下，因为需要重传一些片段。然而，尽管TCP对互联网上发生的事情大多一无所知，但它必须足够聪明，以了解如何处理拥塞问题，而不是加剧它。

回顾一下，每个被传输的网段都被放在重传队列中，有一个重传定时器。现在，假设互联网上的拥堵情况急剧增加，而且没有任何机制来处理拥堵。分段将被延迟或丢弃，这将导致它们超时并被重传。这将增加我们的客户和服务器之间的网络流量。此外，可能有成千上万的其他TCP连接有类似的行为。每个人都会不断重传越来越多的片段，进一步增加拥堵，导致恶性循环。整个互联网的性能将急剧下降，导致一种叫做拥堵崩溃的情况。

这个信息很清楚：TCP不能忽视其连接端点之间的互联网上发生的事情。为此，TCP包括几个特定的算法，旨在应对拥堵，或首先避免拥堵。在某种程度上，许多这些技术可以被认为是使TCP连接不那么 "自私 "的方法，也就是说，它试图考虑到它所运行的国际网络中其他用户的存在。虽然没有任何一个连接本身可以解决整个互联网的拥堵问题，但是让所有的设备共同实施这些措施可以减少TCP造成的拥堵。

第一个问题是，我们需要知道什么时候发生了拥塞。根据定义，拥堵意味着中间设备--路由器--过载。路由器对过载的反应是丢弃数据报。当这些数据报包含TCP段时，这些段没有到达目的地，因此它们没有被确认，最终会过期并被重新传输。这意味着，当一个设备发送TCP段而没有收到确认时，可以认为在大多数情况下，这些段由于拥堵而被中间设备放弃。通过检测段的发送和未被确认的速度，TCP设备可以推断出它和它的TCP连接对等体之间网络的拥堵程度。

<u>**TCP拥塞处理机制**</u>

然后我们必须决定如何处理这些信息。主要的TCP标准，RFC 793，包括很少关于TCP拥塞处理问题的信息。这是因为仅基于该标准的早期TCP版本并不包括拥塞处理措施--正是这些早期实现的问题导致人们发现拥塞是一个重要问题。现代设备中使用的措施是经过多年发展的，并最终在RFC 2001、TCP慢速启动、拥塞避免、快速重传和快速恢复算法中得到记录。

下面是对构成这一标准名称的四项技术的简化描述。

<u>**慢速启动**</u>
在TCP的最初实现中，一旦两个设备之间建立了连接，它们就可以各自 "大干一场"，只要对方的接收窗口有空间，就可以以自己喜欢的速度发送数据段。在一个繁忙的网络中，突然出现的大量新流量可能会加剧任何现有的拥堵。

为了缓解这一问题，现代TCP设备在最初发送段的速度上受到限制。每个发件人最初被限制只能发送相当于一个 "全尺寸 "网段的数据量，也就是相当于连接的MSS值。每次收到确认时，设备可以发送的数据量就会增加一个全尺寸段的大小。因此，设备在可以发送的数据量方面 "开始很慢"，它发送的数据量不断增加，直到达到全窗口大小或在链路上检测到拥堵。在后一种情况下，将使用下面描述的拥堵避免功能。

<u>**拥塞避免**</u>
当检测到TCP链路上有潜在的拥堵时，设备会通过节制其发送段的速率来做出反应。使用一种特殊的算法，允许设备在发生拥堵时迅速降低段的发送速率。然后，设备使用上面的慢速启动算法，逐渐将传输速率重新提高，试图在不发生拥塞的情况下最大限度地提高吞吐量。

<u>**快速重传**</u>**Fast Retransmit**

我们在研究TCP段重传时已经看到，当一个设备不按顺序接收段时（意思是不连续），接收方将只确认连续接收的段。确认号将指定它期望收到的下一个字节的序列号。因此，在该主题给出的例子中，1号和2号段被确认，而4号段没有，因为3号段没有收到。

事实上，当TCP设备收到一个无序的段时，有可能以确认的方式进行响应，只是 "重申 "它在等待一个特定的字节数。因此，当该例子中的客户端收到第4段而不是第3段时，它可以发回一个确认信息说 "我正在等待第3段的第一个字节"。

现在，假设这种情况不断地发生。服务器没有意识到第3段丢失了，就发送第5段、第6段，以此类推。每次收到一个，客户都会发回一个确认函，指明第3段的第一个字节数。最终，服务器可以合理地得出结论，3号段已经丢失，即使它的重传定时器还没有过期。

快速重传功能规定，如果收到三个或更多这样的确认，都说 "我想要以#N字节开始的网段"，那么以#N字节开始的网段很可能已经丢失，通常是因为拥堵而被丢弃。在这种情况下，设备将立即重发丢失的段，而不经过正常的重发队列过程。这通过消除将暂停链路上有效数据流的延迟而提高了性能。

<u>**快速恢复**</u>**Fast Recovery**
当快速重传被用来重发一个丢失的网段时，使用它的设备会执行拥塞避免，但不使用慢速启动来增加传输速率。这样做的理由是，由于发送方收到的多个ACK都表明收到了失序段，这表明有几个段已经从两个设备之间的段流中删除。那么，出于效率的考虑，传输速率可以比其他方式发生拥塞时更快地提高。与使用快速重传后的常规拥塞避免算法相比，这提高了性能。

<u>**拥塞处理机制的关系**</u>***Relationship of Congestion Handling Mechanisms\***
在实践中，这些功能都是相互关联的。慢速启动和拥塞避免是不同的算法，但使用一个单一的机制来实现，涉及到定义一个拥塞窗口，限制传输的大小，其大小根据拥塞程度增加或减少。快速重传和快速恢复是作为对实现慢速启动和拥塞避免的机制的改变而实现的。

我意识到这有些隐晦；拥塞处理是一个相当复杂的过程。如果你想了解更多，RFC 2001包含了技术细节，显示了每一种算法是如何在每个设备中实现的。我在这个话题中特别省略了这些细节，因为我觉得我的总结描述已经够复杂了，我的目标只是帮助你感受一下TCP中的拥塞处理的一般方法。

**关键概念**。TCP流量控制是调节TCP设备间流量的一个重要部分，但只考虑到两个TCP端点的繁忙程度。同样重要的是要考虑到建立任何TCP会话的网络发生拥堵的可能性，这可能会通过丢弃的片段导致效率低下。为了处理拥堵问题并避免不必要地造成拥堵，现代的TCP实现包括一套避免拥堵的算法，这些算法改变了滑动窗口系统的正常运行，以确保更有效的整体运行。

#### 4.1.5 TCP/IP传输层协议（UDP和TCP）的概要比较

用户数据报协议（UDP）和传输控制协议（TCP）是TCP/IP协议套件中传输层的 "兄弟姐妹"。它们发挥着同样的作用，在应用程序和互联网协议（IP）的数据移动能力之间提供一个接口，但它们以非常不同的方式进行。因此，这两个协议为高层协议提供了选择，允许每个协议根据其需要选择合适的协议。

我已经在各自的章节中详细描述了UDP和TCP。然而，这些部分需要花费一些时间来阅读；UDP部分有好几页，而TCP部分则有更多的篇幅 为方便起见，我在此附上表160，它有助于说明这两种协议最重要的基本属性以及它们之间的对比。

​                                                                 **表160: UDP和TCP的简要比较**

| **Characteristic / Description**                | **UDP**                                      | **TCP**                                                  |
| ----------------------------------------------- | -------------------------------------------- | -------------------------------------------------------- |
| **General Description**                         | 简单、高速、低功能的“包装器”，将应用程序连接到网络层，几乎不做其他事情。        | 允许应用程序可靠地发送数据而无需担心网络层问题的全功能协议。                           |
| **Protocol Connection Setup**                   | 无连接；无需设置即可发送数据。                              | 面向连接；必须在传输之前建立连接。                                        |
| **Data Interface To Application**               | 基于消息的；数据由应用程序以离散包的形式发送。                      | 基于流；数据由应用程序发送，没有特定的结构。                                   |
| **Reliability and Acknowledgments**             | 在没有确认的情况下不可靠、尽力而为的交付。                        | 可靠的消息传递；所有数据均已确认。                                        |
| **Retransmissions**                             | 不执行。应用程序必须检测丢失的数据并在需要时重新传输。                  | 管理所有数据的交付，并自动重新传输丢失的数据。                                  |
| **Features Provided to Manage Flow of Data**    | None                                         | 使用滑动窗口进行流量控制；窗口大小调整启发式；拥塞避免算法。                           |
| **Overhead**                                    | Very low                                     | 低，但高于 UDP                                                |
| **Transmission Speed**                          | Very high很高                                  | 高，但不如 UDP                                                |
| **Data Quantity Suitability**                   | 小到中等数量的数据（最多几百字节）                            | 小到非常大的数据量（高达千兆字节）                                        |
| **Types of Applications That Use The Protocol** | 数据传输速度比完整性更重要的应用程序，即发送少量数据的应用程序；或使用多播/广播的地方。 | 大多数协议和应用程序发送必须可靠接收的数据，包括大多数文件和消息传输协议。                    |
| **Well-Known Applications and Protocols**       | 多媒体应用、DNS、BOOTP、DHCP、TFTP、SNMP、RIP、NFS（早期版本） | FTP、Telnet、SMTP、DNS、HTTP、POP、NNTP、IMAP、BGP、IRC、NFS（更高版本） |

# 
