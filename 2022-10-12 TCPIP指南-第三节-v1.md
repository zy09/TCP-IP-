TCP/IP   指南

[TOC]

------



## 

​	

​																											

## 第三节、 TCP/IP应用层协议、服务和应用（OSI第5、6和7层）

OSI参考模型被用来描述网络协议和技术的结构，并显示它们之间的关系。在描述OSI模型的章节中，我提到它的七个层可以被组织成两个层组：低层（1到4）和高层（5到7）。虽然肯定还有其他方法来划分OSI层，但我觉得这种划分最能反映各层在网络中的不同作用。

下层主要关注在网络上格式化、编码和发送数据的机制；它们涉及软件元素，但通常与网络硬件设备密切相关。相比之下，上层主要涉及用户互动和软件应用程序、协议和服务的实现，让我们实际利用网络。这些元素通常不需要担心细节问题，而是依靠下层来确保数据能够可靠地到达它需要去的地方。

在这一章中，我描述了现代网络和互联网中运行在上层的许多协议和应用程序的细节。本章的组织结构与前一章完全不同。我觉得单独解释每个下层的技术是有好处的。这是可能的，因为除了少数例外，低层之间的分界线是相当完善的，这有助于显示各层的不同。

上层则更难区分，因为有许多技术和应用实现了第5至第7层中的一个以上。此外，在网络堆栈的顶部附近，即使区分这些层也变得不那么重要。事实上，TCP/IP协议套件使用的是一种架构，它把所有的高层放在一起。

由于这些原因，本章是按功能而不是按层划分的。它包含四个不同的部分，涵盖了不同的高层协议和应用领域。第一部分讨论了命名系统，特别是TCP/IP域名系统。第二部分概述了文件和资源共享协议，重点是网络文件系统。第三部分涉及网络配置和管理协议，其中包括主机配置协议BOOTP和DHCP。最后一个也是最大的部分涵盖了最终用户应用和应用协议，包括一般文件传输、电子邮件、Usenet、万维网、交互式协议（如Telnet）和管理实用程序。



### 第一章、名称系统和TCP/IP名称注册和名称解析

人类和计算机在几十年前就开始打交道了。人类（和女人！）和机器之间的关系总体上是相当好的，这反映在这样一个事实上，即虽然计算机曾经只是科技人员的专利，但它们现在是主流。然而，在有些领域，人类和计算机根本就不对眼。其中之一就是我们处理信息的方式。

计算机最擅长处理数字，而大多数人喜欢......不喜欢处理数字。这种基本的脱节给网络技术的设计者带来了问题。从技术角度来看，为网络和互联网设计寻址方案，使用简单的数字标识符是有意义的，因为这样做既简单又高效。不幸的是，使用数字地址来识别计算机对人们来说是很麻烦的，而且随着网络上设备数量的增加而变得更加麻烦。

为了解决这个问题，技术人员开始工作，并想出了网络的名称系统。这些机制允许计算机继续使用简单、有效的数字地址，同时让人类指定更容易记忆的名称来识别它们。这样一来，大家都很高兴。好吧，我想几乎是所有人。这些系统意味着我们这些研究网络的人又多了一件事要学习。J

在本节中，我解释了网络名称系统背后的理论和实践。我首先介绍了名称系统的动机以及它们如何工作的重要概念和技术。然后，我有一大部分内容专门介绍用于TCP/IP的名称系统。这包括非常重要的域名系统（DNS），以及在它之前的老式主机表方法。



#### 1.1 名称系统问题、概念和技术

名称系统在某些方面可以被认为是网络协议栈的 "外交官"。就像政治外交官擅长说多种语言，并确保那些可能以不同方式看待世界的人之间的良好沟通一样，名称系统在计算机喜欢使用的数字地址和人类喜欢的更简单的名称之间架起了桥梁。

在研究具体的名称系统之前，我认为一般性地讨论它们是有意义的。这将有助于我们理解这些系统之所以重要的原因，也有助于理解所有名称系统的基础概念，而不论具体的实现方式如何。在这一节中，我首先对名称系统进行了概述，并讨论了它们被创建的原因。然后，我讨论了名称系统的不同主要功能：名称空间、名称注册和名称解析。然后，我对这个功能概述进行了扩展，说明了名称空间和架构是如何工作的，名称注册和管理背后的问题，最后是名称解析技术和解析过程中的实际问题。

由于这是一个介绍性的部分，我试图坚持一般性的描述，不在这里的主题中过多地提及具体的名称系统。但是，我喜欢用例子来解释概念，为此，我有时会提到TCP/IP域名系统（DNS）。但是，你不需要熟悉DNS就可以了解本节内容。



##### 1.1.1 名称系统概述和动因（部分：1 2 3 ）

在本节关于名称系统的介绍中，我提到了人类和计算机之间的几个重要区别之一：我们喜欢如何处理信息。计算机与数字打交道，而我们人类中很少有人喜欢这样做。当我们研究如何将标识符或地址分配给网络设备时，这一区别变得尤为重要。

**寻址的符号名称**
对计算机来说，为网络上的每个设备分配一个数字并使用这些数字来移动信息是没有问题的。如果你给它和网络上的所有其他机器分配一个像341,481,178,295这样的数字，然后发出诸如 "将此文件发送到机器56,712,489,901 "的命令，你的计算机会非常高兴。然而，大多数人类并不希望以这种方式使用网络。这些长长的加密数字对他们来说没有任何意义。他们想告诉他们的机器 "把这个文件发送到乔的电脑上"；"在销售部的彩色激光器上打印这个"，或者 "检查CNN的网站，看看最新的头条新闻是什么"。

正是这种脱节导致了名称系统的发展。这些技术使网络上的计算机既能得到一个传统的数字地址，也能得到一个更 "用户友好 "的人类可读名称。这种名称由字母、数字和其他特殊符号组成，有时被称为符号名称；它可以作为设备的另一种寻址形式。名称系统负责管理这个系统的必要功能，包括确保名称是唯一的，从名称翻译成数字，以及管理名称和数字的列表。

<u>**一个悖论：名称系统既是必要的又是不必要的？**</u>

关于名称系统的有趣之处在于，它们对网络极为重要......但同时，它们往往不是网络运行的严格必要条件。这个看似矛盾的现象又是由于人类和计算机之间的差异造成的。计算机只需要数字寻址方案，而不是分配给它们的 "人名"。因此，计算机和网络仍然可以工作--但对我们人类来说，使用它们将更加困难

这方面的一个例子最容易看到，当一个问题使用于在互联网上提供命名服务的域名系统（DNS）的一部分无法运行。从技术上讲，使用互联网不需要DNS，因为所有通信都使用IP地址。这意味着，即使你通常可能在 "www.cnn.com "访问CNN的网站，但如果DNS不工作，你反而可以直接使用IP地址64.236.16.20。

问题是，在阅读这篇文章之前，你可能不知道CNN网站的IP地址是什么，几乎所有其他使用他们网站的人也是如此。此外，你可能想检查的不仅仅是CNN的网站，可能还有其他一、二或二十个新闻网站。要记住互联网上成千上万个不同网站中哪怕是一小部分的号码都很困难，所以每次你想访问一个资源时，都必须手动查找其地址，如图229所示。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\nameovernoname.png)


​                                                                **图229：没有名称系统的Internet网络访问**

在没有名称系统的情况下，用户必须知道他或她希望在互联网上访问的任何设备的地址。由于我们大多数人对数字的记忆有限，这意味着每次访问前都必须进行低效、乏味的手动地址查询。



<u>**决定名称系统的必要性的因素**</u>

记忆资源的名称要容易得多；当实施名称系统时，你只需输入设备的名称，名称系统就会将其转换为地址，如图230所示。这就是为什么名称系统如此重要，即使网络技术本身不需要它们。(事实上，对DNS等名称系统的依赖是如此重要，以至于许多人甚至没有意识到他们可以在网络浏览器中输入IP地址！）。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\nameoverwithname.png)


​                                                                           图230: 使用名称系统的网络访问

当一个网络配备了名称系统后，用户不再需要知道设备的地址来访问它。他或她输入名称，名称系统会自动将其转换为地址，就像我在这里展示的计算机化的 "通讯录"。然后，名称系统将地址传递给客户端软件，客户端软件使用该地址来访问所请求的资源，就像用户直接输入地址一样。


更一般地说，名称系统的重要性在很大程度上取决于使用它的网络的特点。在确定对名称系统的需求方面，有三个主要问题。

- 网络规模。如果你有一个真正的小网络，只有几台计算机，让人类用户记住这些机器的数字地址，即使不理想，也至少是可行的。例如，一个有两三台机器的小型家庭网络在理论上并不真正需要一个名称系统。但是，如果你有几千或几百万台设备，名称系统就变得至关重要。

- 地址大小和复杂度。数字寻址方案越复杂，或者使用的数字越大，人类就越难记住这些数字。

- 用户群规模和技能：在网络的早期，只有少数技能高超、训练有素的工程师使用网络，这些人有时只是记住了他们每天工作的机器的号码。在拥有数千或数百万 "非专业 "用户的现代网络中，期望普通人记住设备编号是不合理的。

纵观这些问题，我们可以看到，当今网络的趋势都是朝着增加名称系统的重要性的方向发展。我们的网络，不管是私人的还是公共的，都在不断扩大，我们有更多的人在使用它们，包括更多没有技术背景的人。我们也越来越多地从小地址向大地址转移。这方面最好的例子是即将到来的互联网协议的变化。虽然DNS对于IP版本4中使用的32位地址很重要，但对于处理IP版本6中巨大的128位地址来说，它甚至更加重要。

**关键概念。**网络名称系统是很重要的，因为它们允许设备被分配有效的数字地址，同时仍然使人类能够使用更容易记忆的名称来访问它们。当你增加网络、地址或用户群的规模时，名称系统变得更加重要。当用户群的技能或经验有限时，它们也更加重要。



##### 1.1.2 名称系统的功能。名称空间、名称注册和名称解析（部分：1 2）

虽然数字地址和符号名称之间的区别对网络设备的用户来说非常重要，但重要的是要记住，数字和名称实际上都是为了同一个基本目的：设备识别。即使我们使用名称系统来使设备更容易访问，计算机本身通常仍需要使用基本的数字标识符。那么，从本质上讲，每个设备最终都会有（至少）两个标识符：一个数字和一个名称。

事实上，设备最终会有多个标识符，这使得人们和他们的机器都可以使用他们喜欢的识别方法。然而，这意味着必须有办法管理对设备的名称分配，并在它们之间进行转换。因此，一个名称系统涉及的不仅仅是在计算机上贴上名称。事实上，它必须是一个完整的系统，允许人类使用名称，而设备继续使用数字。

<u>**名称系统的基本功能概述**</u>
在最高层次上，我认为名称系统的工作包括这三个基本功能。

- 名称空间。名称系统为它所运行的网络系统定义了一个名称空间。名称空间，有时也称为名称架构，描述了名称的结构和使用规则。它还定义了一个设备的名称与系统中其他设备的名称的关系，以及如何确保没有无效的名称被赋予而导致整个系统的问题。

- 名称注册。为了实现名称系统，必须为网络上的每个设备分配一个名称。像任何寻址系统一样，除非系统上的每个名称都是唯一的，否则名称系统无法正常工作；我们需要某种方式来管理名称的分配方式，以便结果是合理的。将特定的名称与特定的设备联系起来的过程，通常称为名称注册。

- 名称解析。正如我在上面提到的，尽管人类喜欢符号化的名字，但计算机通常对它们没有什么用处。有必要定义一种机制，使设备的符号名称能够转化为其数字地址。这个过程通常被称为名称解析。

<u>**名称系统功能之间的关系**</u>

名称空间更多的是一种 "描述性 "功能；它是对名称在系统中如何工作的一种定义。名称注册和解析是更加 "活跃 "的功能，每个名称系统都包括一个或多个关于如何执行这些工作的具体程序。名称注册和解析在某些方面是相互补充的，因此某些注册技术最常与特定的解析方法相关。反过来，可能的注册和解析方法的类型取决于名称空间，特别是其架构。这些关系以简化形式显示在图231中。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\namefunctions.png)


​                                                                                **图231: 名称系统功能**

该图显示了名称系统的三个主要功能之间的关系。名称空间定义了名称系统的结构和创建名称的规则。名称空间被用作名称注册方法的基础，该方法定义了名称和地址之间的映射。当用户想通过名称访问设备时，名称解析方法被用来查询名称空间，确定与名称相关的地址，然后将名称转换成地址。


注册和解析的过程可以很简单，也可以相当复杂，这取决于使用的名称系统的类型。简单的名称系统在很大程度上是手工操作的，易于理解，最好用于较小的网络。更大、更复杂的网络和互联网需要更复杂的注册和解析方法，这些方法不需要管理员的干预，而且随着网络中新机器的增加，可以更好地扩展。

我还应该指出，虽然我认为名称注册和名称解析是最高级别的 "功能"，但它们可能被认为是一组功能更好。名称注册必然与名称系统管理等问题联系在一起，而理解解析需要我们关注效率和可靠性方面的一些重要实施问题。接下来的几个主题将通过更详细地考虑这三种功能中的每一种来扩展这一概述。

**关键概念。一个名称系统包括三个理论上的高级功能：名称空间，它描述了如何创建和组织名称；名称注册技术，它用于建立名称和地址之间的关系；以及名称解析方法，它负责将名称转换为地址。**



##### 1.1.3 名称空间和名称结构（扁平和分层）（部分：1 2 3）

名称系统的主要思想是提供一种使用符号名称来识别设备的方法。像任何识别机制一样，在我们使用该系统之前，我们必须定义识别的方式。数字寻址方案（如IP地址）有关于如何创建地址的规则，并从其地址空间为每个设备分配地址。以类似的方式，名称系统中的设备从系统的名称空间被赋予名称。

<u>**名称空间的功能**</u>
在名称系统的三个主要功能组件中，名称空间是最抽象的。它也是系统中最基本的部分，因为它实际上描述了名称是如何创建的。名称空间在名称系统中定义的内容有几个方面。

- 名称大小和名称的最大数量。名称空间规定了构成名称的字符（符号）的数量。这样一来，它也定义了系统中可出现的最大数量的名称。

- 名称规则和语法。名称空间规定了名称中允许有哪些字符或符号。这用于允许为所有设备选择合法的名称，同时避免非法名称。

- 名称架构和语义。每个名称空间都使用特定的架构或结构，它描述了名称的构建和解释方式。

<u>**名称架构**</u>
名称大小和名称语法的概念是相对直接的。最后一项，名称架构，可能是名称系统最重要的区别特征。由于这个原因，名字空间有时甚至被称为名字架构。名称空间的架构决定了名称是作为简单的非结构化符号集被分配和使用，还是具有更复杂的内部结构。在后一种情况下，名称空间还必须定义特定名称的元素如何相互关联。

理论上，许多不同的名字架构是可能的。在实践中，大多数属于两类中的一类：**扁平式和分层式的架构**。

<u>**扁平的名称架构（扁平的名称空间）**</u>
名称被分配为一连串的符号，这些符号被解释为一个单一的、完整的标签，没有任何内部结构。任何名字和其他名字之间都没有明确的关系。

这种架构的一个例子是一个名称系统，其中计算机被赋予非结构化的名称，如 "工程工作站1 "或 "Joanne的PC"，如图232中的例子所示。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\namespaceflat.png)


​																		图232: 扁平名称架构（扁平名称空间）

这张图显示了扁平名称架构的一个例子。没有组织名称的结构，也没有规定它们必须如何构建。从逻辑上讲，每个设备都是其他设备的一个对等物。

<u>**层次化名称架构（层次化或结构化名称空间）**</u>

在这种架构中，虽然名称由一连串的符号组成，但这些符号是使用特定的、明确的结构分配的。名称由离散的元素组成，这些元素通常使用分层的 "父/子 "语义相互关联。在各种情况下，有许多命名架构使用这种类型的层次结构；例如，考虑一个大公司如何设置组织结构图，并命名组织中的高管和官员。图233展示了一个假设的分层名称架构的例子。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\namespacehier.png)


​                                                                  **图233：分层名称架构（结构化名称空间）**

该图包含与图232相同的设备，但它们被安排使用分层的、结构化的名称架构。在这种情况下，该组织选择了首先按设施位置，然后按部门来构建设备名称。每个名称都以 "美国-服务 "或 "欧盟-制造 "这样的字眼开头。这提供了直接的好处，因为它提供了对设备命名的本地控制，没有冲突的风险。如果一个叫约翰的人被雇用到美国的销售队伍，他的机器可以被命名为 "US-Sales-John"，而不会与欧洲销售队伍的约翰拥有的机器（"EU-Sales-John"）发生冲突。

分层名称空间最著名的现实例子是TCP/IP域名系统的名称空间，它使用由句号（"点"）分隔的文本标签来形成一个内部结构。系统中的所有名称都被组织成一个结构，一个特定设备在结构中的位置可以通过查看其名称来确定。例如，"www.tcpipguide.com "指的是《TCP/IP指南》的万维网服务器，它被命名在 "COM商业 "公司的旗下。反过来讲它是.com 组织下的tcpipguide 组织里的www 服务。

<u>**名称架构的比较**</u>

正如我们在接下来的两个主题中所看到的，名称空间的架构与名称的注册和管理方式密切相关，最终也与名称的解析方式密切相关。扁平化的名字空间需要某种中央机构来为系统中的所有设备分配名字，以确保唯一性。分层名称架构非常适合于更多的分布式注册方案，允许许多机构分享注册和管理过程。

所有这些意味着这些架构中的每一个的优点和缺点都不是一个很大的谜团。如图232所示，扁平名称空间的优点是简单，能够创建简短和容易记住的名称。然而，由于难以确保每个名字都是独一无二的，它们对于包含成百上千台机器的名字系统来说，规模并不大。例如，如果有四个叫John的人都想把他们的电脑命名为 "John's PC"，会发生什么？另一个问题是集中管理这些名字所需的开销。

相比之下，层次化的名字空间更加复杂和灵活，因为它们允许使用逻辑结构来分配名字。例如，我们可以使用反映我们组织结构的层次结构来命名我们的机器，并授权组织的不同部分来管理名称空间的一部分。只要每个部门的名称是唯一的，并且这个唯一的部门名称是每个机器名称的一部分，我们就不需要担心每个分配的名称在整个组织内是唯一的，只是在部门内。因此，我们可以用部门名称和 "约翰 "命名四台不同的机器，如图233所示。这种灵活性的代价是需要更长的名字，以及名字注册和解析的复杂性。

**关键概念。**两种最常见的名称架构是平面名称空间和分层名称空间。扁平名称空间中的名称都是对等的，没有任何关系；在层次结构中，采用多级结构，以特定方式组织名称。扁平系统比较简单，对小型网络来说是令人满意的，而分层名称空间更加灵活和强大，更适合于大型网络和国际网络。



##### 1.1.4 名称注册方法、管理和授权 (部分: 1 2 )

似乎很明显的是，为了实现我们的名称系统，我们需要一些方法来为每个将使用该系统的设备分配名称。正如名称系统有一个与寻址系统的地址空间相当的名称空间一样，它也必须实现一套分配名称的规则和程序，就像寻址系统分配地址一样。这就是所谓的名称注册。

<u>**名称注册的功能**</u>
一般来说，名称注册包括以下概念和任务。

- 名称分配和保证唯一性。名称注册过程的核心任务当然是为设备分配名称。像所有的识别方案一样，名称注册的一个关键要求是确保每个名称是唯一的。重复的名称会引起歧义，使一致的名称解析成为不可能。

- 中央注册机构的指定。确保名称的唯一性需要有人 "负责 "名称分配过程。这个中央注册机构可以是一个维护包含名称的文件的个人，或者是一个负责整个名称注册过程的组织。该机构还负责解决注册中可能出现的问题和冲突。

- 注册机构的授权。在较小的名称系统中，中央注册机构可能负责所有设备的实际注册过程。在较大的分层名称系统中，将这一过程集中起来是不现实的。相反，中央注册机构将划分名称空间，并将其不同部分的名称注册权委托给下级组织。这需要制定和实施授权政策。

- 定义分层结构。当使用分层名称空间时，中央机构负责定义结构的样子。这反过来又决定了如何在层次结构的不同部分注册名称，当然也会影响到授权的方式。

<u>**名称空间结构对名称注册的影响**</u>
名称注册过程的复杂性在很大程度上取决于整个名称系统的规模和复杂性，特别是名称空间的结构。在使用平面名称空间的简单名称系统中，注册通常是通过一个单一的机构完成的。当然，没有结构，通常也没有授权，所以注册的内容也不多。

对于分层的名称系统，名称注册与用于名称的分层结构紧密相连。中央机构定义了层次结构，并决定如何将层次结构划分为子集，由其他机构独立管理。这些机构可以反过来委托他们的名字空间的子集，创造一个灵活和可扩展的系统。

这种授权名称注册的能力是分层名称空间的最强大的好处之一。例如，在TCP/IP域名系统中，一个中央机构负责整体的名称注册；它负责决定哪些顶级域名，如".com"、".edu"、".info "和".uk "被允许存在。然后，管理全球层次结构中的每个子集的权力被委托给其他组织。这些组织继续按照他们认为合适的方式划分层次结构的过程。最终，每个组织都能独立决定如何命名自己的内部系统；例如，IBM可以在 "ibm.com "名称中以任何它认为合适的方式注册名称。

<u>**名称注册方法**</u>

有几种常见的方法来进行实际的注册过程。每种方法都有其长处和短处，同样，有些方法更适合于平面名称空间，有些则适合于分层名称空间。

<u>**表名注册**</u>
在这种技术中，名称分配由管理员维护在一个表中。当需要添加、删除或改变名称时，要对表进行编辑。

这种技术通常与小型扁平名称空间名称系统有关，与一般的扁平架构有相同的好处和缺点：它很简单，容易实现，但不能很好地扩展到大型系统。对于十几台机器来说，让人编辑名称注册表是实用的；而对于成千上万的机器来说，就不实用了。它也不利于有多个当局的分层系统，因为表需要保存在一个地方。

在更大的互联网中，表格可以作为以下更复杂的技术的辅助手段来使用。

<u>**广播名称注册**</u>
这是一种 "试错 "技术；想要使用一个特定名称的设备向网络上的所有其他设备发送一个消息，询问是否有其他人已经在使用该名称。如果有，它就选择一个不同的名字。如果没有，这个名字就被认为是注册过的，然后就可以使用了。

这种技术比使用表格更复杂，但仍然限于在相对较小的系统中使用。试图向成千上万的系统广播是不现实的，而且这种方法不能在互联网上使用，因为没有办法向互联网上的每个设备广播。

<u>**数据库注册**</u>
一个名称分配的数据库得到了维护。要注册一个名称，必须提出请求，将名称分配添加到数据库中。如果名称系统的授权是完全集中的，那么数据库将是集中的，由该机构维护。如果部分等级制度的权力被下放，那么分布式数据库被用于注册，每个机构维护数据库中描述其等级制度的部分。

这是最复杂的技术，也是通常与DNS等分层名称系统相关的技术。它有几个好处，包括灵活性、可靠性和维护工作的分配；其主要缺点是复杂。

**关键概念。**名称注册是将名称与名称系统中的地址联系起来的过程。它包括中央注册机构的指定和授权以及名称空间结构管理等活动。最常见的名称注册方法，按照能力和复杂性的增加顺序，是表格维护、广播注册和数据库注册。


我们刚刚看到，名称空间和结构的选择立即对如何进行名称注册产生了重要影响。下一个话题将说明名称解析与名称注册和架构也密切相关。

##### 1.1.5 名称解析技术和名称解析系统的功能要素（部分：1 2）

正如我们在本节前面所讨论的，使用名称系统为计算机创造了两个 "平行 "的识别系统：机器使用的数字和人使用的名字。名称系统的工作是整合这两种方案。名称注册允许人类指定哪些机器使用哪些名称。然而，这只是过程的一半；我们还需要一种方法，使机器能够接受人类给它们的名字，并将其转化为它可以实际用于通信的 "真实 "地址。这就是所谓的名称解析。

名称解析，有时也被称为名称转换、映射或绑定，是名称系统中最著名的方面，因为它是名称系统中大多数 "繁重工作 "的发生地。名称空间一般只设置一次，而且名称注册不常发生：只有在必须创建或更改名称时才会发生。相比之下，名称系统的每个用户都会指示他或她使用的机器执行名称解析，每天数百次甚至数千次。

<u>**名称解析方法**</u>
有几种不同的技术可用于名称解析。如何实现这一功能在很大程度上取决于其他两个名称系统功能，即名称空间和名称注册。正如你所想象的，具有简单名称注册方法的简单名称系统通常也会使用简单的解析方法。带有分布式数据库的复杂的分层系统需要更复杂的名称解析方法。

有三种常见的名称解析方法。

<u>**表格名称解析**</u>
当需要进行解析时，设备会查阅用于基于表的名称注册的表。该表告诉设备如何将它需要联系的机器的名称转化为地址。

这种技术显然与表名注册相对应；它是三种方法中最简单、能力最弱的一种。表名解析只适合在非常小的名称系统中独立使用，但也可以作为其他方法的补充。类似hosts 文件

<u>**广播式名称解析**</u>
当设备需要解析一个名称时，它广播一个查询，大意是："我需要向名为'X'的设备发送，那是谁？" 名称为'X'的设备回话说："我是'X'，我的数字地址是'N'"。类似arp 查询

当然，这是广播名称注册的补充。它也只能用于每个设备都能听到广播的简单系统中。广播的使用也使它浪费了网络带宽。

<u>**客户端/服务器名称解析**</u>
服务器是用软件编程的，允许它们响应客户发送的名称解析请求。这些服务器接收请求中的名称，在数据库中查找相关的数字标识符，并在响应中发送回来。类似 dns

当然，这种技术通常与数据库名称注册一起使用。它是最复杂的名称解析方法，但也是最有效的，而且是唯一能在大型、分布式分级名称系统上真正正常工作的方法。

<u>**客户端/服务器解析功能要素**</u>

这三种方法中的最后一种是用于大多数大型现代名称系统的方法。客户端/服务器的请求/回复解析方法与许多其他协议的功能相似。然而，关于名称解析的一个独特之处在于，名称解析并不经常由客户直接调用。例如，人类用户很少会说 "请解析以下名字"。我们当然也不希望用户在每次联系设备时都必须手动将名字解析为地址，因为这将是很麻烦的。

相反，该系统通过让软件接受用户输入的机器名称而实现自动化。该软件通过将名称传递给一个名称解析器软件组件来解析该名称。该解析器在名称解析过程中充当客户端。它与名称服务器联系，后者对请求作出回应。名称解析器和名称服务器构成了名称解析的两个主要功能元素。

在分级名称系统的分布式数据库中，可能需要多个请求，因为名称服务器将只包含某些机器的信息，而不包含其他机器的信息。解析器遵循一个特殊的程序来 "穿越 "层次结构，直到找到拥有他们想要的信息的服务器。同样，TCP/IP的域名系统（DNS）名称解析是这种方法的最好例子。

**关键概念。**名称解析可以说是名称系统主要功能要素中最重要的一个，因为它是系统中实际将名称转换为地址的部分。名称解析的两个主要组成部分是名称解析器（在解析过程中作为客户）和名称服务器。三种主要的名称解析方法--基于表、广播和客户/服务器--与名称注册的表、广播和数据库方法密切对应。

##### 1.1.6 效率、可靠性和其他名称解析问题和特征（部分：1 2）

在前面的主题中，我描述了名称解析的主要功能：允许人类使用名称来识别设备，然后将这些名称转换为数字，以便计算机能够使用这些数字。这项基本任务在概念上是非常简单的，但在实施中会变得相当复杂。其原因是使名称解析与名称系统执行的其他任务如此不同的关键特征：它的执行频率。

名称注册很少进行，但名称解析却经常进行。如果你考虑一个有成千上万的用户运行各种应用程序的大型互联网，每天必须解决数百万个名字。现在，考虑一下像互联网这样的东西，它每天必须处理数十亿的客户/服务器请求和回复 确保这样的系统工作需要我们做的不仅仅是实施一个解析过程；我们必须增加设施以确保尽可能有效地进行解析。

<u>**效率方面的考虑**</u>
名称解析的第一个主要问题是效率。名称解析会消耗系统资源，尤其是需要发送请求和回复的解析技术。这意味着，如果可能的话，我们希望尽量减少执行解析的次数。现在，考虑到许多人将频繁地重复访问同一台机器。例如，如果你第一次访问一个叫 "www.thisisasite.com "的网站，你的系统将需要解析这个名字。在该网站的主页加载后，如果你点击一个链接到该网站的另一个页面，该页面也将被发现在同一个名称："www.thisisasite.com"。如果再去解析这个名字，那就太浪费了。

为了避免这种情况，名称系统几乎总是包括某种**缓存功能**，它允许设备记住最近的名称解析，并在一段时间内保留从名称到地址的映射。每当需要解决一个名字时，在通过正式的解决过程之前，首先会检查缓存。缓存的使用消除了绝大部分实际的名称解析请求，否则就需要这些请求。

缓存的缺点是它本身需要一些系统资源，而且会增加系统的复杂性。一个问题是决定在缓存中保留数据的时间；如果我们保留的时间太短，就会产生额外的不必要的解析请求；保留的时间太长，如果机器的名称分配发生变化，我们就有可能使映射变得 "陈旧"。这些都是一个复杂的名称系统必须处理的问题。一个典型的解决方案是允许每个名称注册指定关于该名称到地址链接的信息可以被缓存多长时间。

<u>**可靠性的考虑**</u>

在效率之后，名称解析的主要问题是可靠性。正如我在本节前面所说，拥有一个名称系统对计算机来说并不是严格意义上的必要条件，但对用户来说却非常重要，尤其是在像互联网这样的大型网络中。虽然有一个维护名称系统所有信息的中央场所可能使管理更简单，但它创造了一个危险的 "单一故障点"。如果存储信息的设备发生任何问题，整个名称系统都会失效。

现代名称系统采用冗余，以防止整个系统依赖任何特定的设备进行解析。在客户/服务器系统中，一个典型的方法是在不同的地点（或连接到不同的网络）有多个服务器，可以响应名称解析请求。

**关键概念。**由于名称解析是名称系统中使用最频繁的部分，因此在这里我们必须仔细关注实施问题。两个最重要的问题是效率和可靠性。由于大型系统每天都要进行成千上万次的解析，所以效率是至关重要的；可靠性是一个考虑因素，因为名称系统的用户很快就会依赖它，我们必须确保它是强大的。

<u>**其他考虑因素**</u>
一些名称解析系统的可选功能是负载平衡。当正确实施时，负载平衡允许一个名称映射到一个以上的基础地址。这允许发送到一个特定的 "虚拟 "设备的请求实际上被引导到一些不同的实际物理设备，将负载分散到多个机器上。这一功能的一个常见用途是用于非常流行的、大量使用的网站。

最后，虽然名称解析显然是为了让名称映射到地址，但在有些情况下，我们可能希望向另一个方向发展：给定一个数字地址，找到与之对应的名称。这个过程被称为反向解析，类似于拥有一个电话号码并试图找到它所属的人或公司的名字。就像我们不能用传统的电话簿轻易地找到与电话号码相匹配的名字一样（我们必须扫描每一页来寻找号码），反向解析需要名称系统的特殊支持。如果名称系统的数据分布在许多服务器上，这一点尤其正确。

#### 1.2 TCP/IP名称系统:主机表和域名系统(DNS)

TCP/IP协议套件是当今网络中最广泛使用的协议。TCP/IP已经变得非常流行，许多人--甚至是非专家！--在使用其数字标识符（IP地址）时相当自如。即便如此，使用名字比使用数字要容易得多，而且当然也更容易记住它们。我们还可以考虑到，在大型网络上使用名称系统比小型网络更重要，而且TCP/IP被用来实现世界上最大的国际网络--互联网。拥有一个好的名字系统对互联网的运行至关重要，因此，它已经成为整个TCP/IP的一个重要元素。

在本节中，我描述了TCP/IP中使用的名称系统。我首先概述了TCP/IP中的设备命名，包括讨论了设备命名的历史。然后我描述了TCP/IP中使用的两种不同的名称系统：简单的主机表名称系统和现代的域名系统（DNS）。后者比前者包括更多的细节，因为DNS比主机表复杂得多，而且在今天的网络中使用得更广泛。

**背景信息。**本节假定你已经熟悉了上一节中解释的名称系统的一般概念和问题。在适当的地方参考了对名称系统组件和方法的描述。




##### 1.2.1 TCP/IP主机名和名称系统的概述和历史（部分：1 2）

在介绍名称系统和描述其背后的概念的部分，我描述了一个有趣的悖论。尽管名字系统对于网络系统的运行来说并不是严格意义上的必要条件，但它们却使人们在使用网络时更加容易，以至于它们被认为是大多数网络的一个重要组成部分。我认为没有比TCP/IP中名称系统的发展历史更能证明这一点了。

<u>**早期在ARPA网络上使用主机名**</u>
事实上，TCP/IP协议套件中名称系统的历史实际上可以追溯到TCP和IP本身创建之前。在20世纪60年代末和70年代初，当互联网的前身（ARPAnet）正在开发时，它使用了旧的网络协议，其功能与今天的TCP和IP相同。按照今天的标准，ARPAnet非常小，起初只包含几台机器，就像今天的TCP/IP机器一样被称为主机。寻址方案也非常简单：每个主机只有一个IMP（计算机）号和一个端口号的组合。

由于只有少数几台机器的名字，所以很容易记住地址，但当ARPA网络发展到几十台机器时，这就无法维持了。早在1971年，设计ARPAnet的工程师们就发现，对每个人来说，符号化的名字比数字地址更容易操作。他们开始为网络上的每个设备分配简单的主机名。每个站点都管理着自己的主机表，列出了名称与地址的映射关系。

<u>**第一个ARPA网络名称系统。主机名列表**</u>
当然，ARPAnet的工程师们立即意识到让每个站点维护一个可能不一致的主机名列表的危险性。由于此时的互联网只是一个小的 "俱乐部"，他们利用RFC过程本身来记录标准的主机名和地址的映射关系。RFC226，主机记忆法的标准化，是我能找到的第一个显示主机名如何分配的RFC。它发表于1971年9月20日。

这个最初的名称系统是一个可以手动操作的系统。随着网络的增加和变化，主机名称列表在新的RFC中被更新，导致一系列的RFC在20世纪70年代被发表。每个主机管理员仍然维护着他或她自己的主机表，当新的RFC发表时就会更新。在这一时期，主机名称的结构仍在讨论之中，随着新想法的探索和完善，名称系统的几乎每一个方面都有变化。

在ARPA网络非常小的时候，这种方式运作良好，但也有许多问题。其中一个问题是，它对网络修改的反应极其缓慢；只有在新的列表公布后，添加或修改才会被输入设备表。即使有了集中的清单，也仍然存在潜在的一致性问题，如果一个站点管理员忘记更新文件或出现印刷错误。这些都是基于主机表的名称系统的常见限制。

<u>**在主机表文件中存储主机名称**</u>

第一项改进是将主机名称分配列表变成一个标准的 "主 "文本文件，该文件将被集中管理，并可使用FTP等网络协议下载。该文件由斯坦福大学的网络信息中心（NIC）维护。定义和使用该文件的过程在RFCs 606和608中作了描述，这两个文件的标题都是Host Names On-line，分别于1973年12月和1974年1月发布。这些文件还正式规定了TCP/IP主机表名称系统的语法。

集中管理的主机表的使用一直持续到1970年代。当TCP/IP开发时，该系统得到了维护，并在主机名和32位IP地址之间进行了映射。RFC 810，国防部互联网主机表规范，显示了主机表是如何被定义为用于IP地址的。它发表于1982年。

<u>**主机表名称系统的发展和向DNS的过渡**</u>
正是在这个时候，ARPAnet/互联网的持续增长使得简单的主机表名称系统最终变得难以管理。起初有几十个，后来很快就有成百上千的新主机连接到互联网上，由于各种原因，在一个中心位置维护一个单一的文本文件是无法胜任的。

1981年，在RFC799《互联网名称域》中首次提出了转向基于域概念的分层名称系统的想法。在20世纪80年代初，对这一概念进行了大量的讨论和发展，到1983年，一个从平面主机表名称系统迁移到新的域名系统（DNS）的计划已经到位。这个名称系统的详细发展历史将在关于DNS的概述部分继续介绍。



##### 1.2.2 TCP/IP主机表名称系统（部分：1 2 3 4）

现代互联网的先驱们在创建包含早期ARPA网络中机器名称和地址的简单文件时，为这套系统制作了第一个名称系统。这个系统是如此简单，以至于它最初甚至没有被正式指定为一个 "名称系统 "本身。由于这些文件包含了网络主机的名称，将名称和地址联系起来的过程被简单地称为 "主机名称 "机制。后来，这些文件被称为主机表，因此我把这项技术称为TCP/IP主机表名称系统。

作为一个系统，它是极其简单的，因为它只是由网络上每台机器上维护的一个文本文件组成。这个文件在UNIX系统中通常称为"/etc/hosts"，在Windows系统中称为HOSTS（通常位于Windows主目录中）。该文件通常以一些注释行开始，然后列出一对IP地址和主机名称。一个非常简化的例子（使用现代的表结构，与原来的主机表格式略有不同），见表161。

​                                                                             **表161: TCP/IP主机表示例**

```shell
# Host Database
# This file should contain the addresses and aliases
# for local hosts that share this file.
#
# Each line should take the form:
# <address> <host name>
#
127.0.0.1 localhost
209.68.14.80 www.pcguide.com
216.92.177.143 www.desktopscenes.com
198.175.98.64 ftp.intel.com
```

<u>**主机表名称空间**</u>
这个系统的名字空间和架构理论上是扁平的，每个名字可以采取任何形式，没有任何真正的结构。尽管如此，为了保持一致性，最终还是制定了一些关于如何创建名称的规则。正如我们将在本主题的后面看到的，也可以使用主机表来支持分层名称空间的实现，这显然意味着名称必须使用该名称空间的结构规则来创建。

<u>**主机表名称解析**</u>

本系统中的名称解析非常简单。每个设备在启动时都会将主机表读入内存。系统的用户在调用各种应用程序时可以参考该主机表中的名称，使用名称而不是数字IP地址。当软件检测到一个名字以这种方式被使用时，它将该名字指向设备中的内部解析程序，该程序在内存的主机表中查找该名字并返回其地址。没有必要进行任何传输或联系服务器；解析完全是本地的。

<u>**主机表名称注册**</u>
现在，我想说的是，主机表名称系统中的名称注册也很简单，对吗？嗯，是的，也不是。从纯粹的技术角度来看，它当然是简单的：当一个名字和相应的IP地址被输入到设备的主机表中时，这个名字就被 "注册 "到一个特定的设备上，仅此而已。

然而，从管理的角度来看，名称注册要复杂得多，这实际上是我们发现使用主机表的主要弱点所在。每个网络设备都维护自己的主机表，独立于其他设备，通常以文件形式存储在本地硬盘上。这与数据库注册系统形成鲜明对比，后者的数据是集中存储和管理的。这导致了两个非常重要的问题。

- 一致性。由于每个设备都有自己的主机表，我们如何确保不同设备上的所有表之间的信息是一致的？

- 修改。我们如何确保关于新设备映射的信息，或对现有设备映射的改变，被传播到所有设备上？

最初的机制是简单的手工编辑，由管理员查阅最新公布的设备名称列表。这是一个非常低效的方法，很容易出错，而且对网络的变化确认缓慢。修订后的系统使用一个集中管理的 "主 "文件，由所有站点定期下载。用这种方法进行名称登记，需要将名称/地址映射提交给管理中央文件的机构，即网络信息中心（NIC）。

<u>**主机表名称系统的弱点**</u>

使用集中的主文件进行名称注册当然比使用相当于 "办公室间备忘录 "的方式发布主机名称列表要好，但它本身只是在TCP/IP的早期阶段才实用。随着互联网络的扩大，主机表系统的弱点也在增加。

- 中央管理过载。对中央文件的修改变得更加频繁，增加了管理 "主 "文件的个人的管理负担，以至于每天都要进行多次修改。随着互联网的不断发展，一个人最终不可能以提交变化的速度来输入这些变化。

- 主文件大小的增长：每个主机在主文件中都需要一个行。当互联网发展到有数千乃至数百万台设备时，文件大小就会变得过大。

- 过多的带宽使用：由于文件经常变化，这也意味着网络上的所有设备必须不断地下载这个主文件以保持最新。同时，正如刚才提到的，该文件的大小也在增长。一个大文件的多次下载意味着大量的网络带宽被消耗在本质上是一种开销的活动上。

- 扁平命名空间问题。由于缺乏一个分层的名称空间，当用户为他们的设备选择相同的名称时就会产生冲突，这进一步增加了中央管理员的工作量。这些问题在一定程度上通过使用命名规则得到了改善，比如在每台机器名称前使用带有位置的前缀，但这并不是一个理想的解决方案。

所有这些都是互联网的设计者最终放弃对整个互联网使用主机表的原因，转而使用能力更强的域名系统（DNS）。

**关键概念。**主机表名称系统是早期互联网上用于实现名称的原始机制。它由一组包含名称和地址之间的映射的表格组成，这些地址保存在互联网的每台机器上。当一个名字需要被解决时，就会查阅该表以确定适当的地址。这个系统非常简单，但能力不强，而且不适合大型全球互联网，这就是为什么它最终被放弃而采用DNS。

<u>**现代网络中主机表名系统的使用**</u>

也就是说，主机表名称系统并没有完全消失。有两种情况下，这种技术仍有价值。

- 小型 "岛 "式网络。如果你正在建立一个使用TCP/IP的小型局域网，而且你不需要你的设备的名称被网络外的人访问，那么你猜怎么着？你拥有相当于早期互联网的东西，而且主机表系统对你的适用性就像它对70年代的互联网一样。你可以简单地在每个设备上设置主机表，并手动管理它们。只要局域网足够小，定期编辑这些文件并不麻烦，这实际上是一个快速有效的名称系统，因为不需要交换信息来解决。你甚至可以在一台机器上维护一个主文件，并在需要更改时使用脚本将其复制到其他机器上，以节省时间。

- 提供本地名称映射以补充DNS。尽管现代系统使用DNS进行大多数名称解析，但它们通常仍支持使用主机表文件。你可以在这个文件中手动输入常见的名称映射，即使是在全球互联网上的设备。然后，你的系统可以被设置为在使用其分配的DNS服务器之前查阅这个列表。

将HOSTS文件与DNS结合使用，允许你手动指定常用网站的映射，这可能会提供一个轻微的性能改进，因为不需要访问服务器。由于HOSTS文件并不强制执行任何特定的名称结构，自然很有可能将DNS风格的分层名称放入文件中，正如我在表161中显示的那样。该文件被加载到内存中，用于覆盖其中列出的名称的正常DNS过程。

当然，你会使自己受到手动编辑文件的所有潜在维护问题的困扰：当主机名称或地址在DNS系统中发生变化时，你必须更新这些文件。由于这个原因，HOSTS文件对由DNS提供服务的互联网站点的第二种使用，比对本地机器的文件使用要少。

**关键概念**。即使主机表名称系统不是用于TCP/IP命名的主要机制，它仍然在两种情况下使用。第一种情况是在小型本地TCP/IP网络中实现基本的名称系统。第二种情况是作为DNS的辅助工具，它允许创建手动映射，在需要时覆盖DNS过程。



##### 1.2.3 TCP/IP域名系统(DNS)

创建主机表，将计算机名称映射到地址，极大地提高了早期互联网和实现它的TCP/IP协议套件的可用性。不幸的是，虽然主机表名称系统在互联网规模较小时运行良好，但随着互联网规模和复杂性的增加，它的扩展性并不特别好。名称系统必须保留，但主机表的使用必须被免除，以支持一个更新、更有能力的系统。

在几年的时间里，许多工程师努力创建一个系统，不仅能满足当时的TCP/IP网络的需要，而且能满足未来的需要。新的名称系统是基于网络的分层划分，分为组和子组，名称反映了这一结构。它被设计为以分布式方式存储数据，以促进分散控制和高效运行，并包括灵活和可扩展的名称注册和解析机制。这个用于TCP/IP的新名称系统被称为域名系统（DNS）。

在这一节中，我描述了TCP的域名系统背后的概念，以及它的运行。本节分为四个小节。第一个部分提供了DNS的概述，包括对其特点和组成部分的描述。接下来的三个小节描述了DNS如何实现三个主要的名称系统功能：DNS名称空间和架构；DNS名称注册过程，包括分级授权和管理；以及DNS名称解析过程，重点是名称服务器和解析器如何工作。最后，我有一个主题，简要强调了为支持新的互联网协议版本6及其更长的地址而对DNS做出的改变。

**背景信息。**在本节中，我假定你已经熟悉了名称系统的基本知识，并根据需要参考名称系统概述中的适当主题。你还应该熟悉TCP/IP主机表的工作原理，如本节前面的主题所述。

**注意：**现在，要做一个快速的术语说明。首先，尽管缩写 "DNS "通常代表 "域名系统"，但你有时也会看到 "S "代表其他词，特别是 "服务 "或 "服务器"。第二，有些文件将这个名称系统称为 "DNS"。大多数人只是说 "DNS"，不加定语，这也是我在这里遵循的惯例。




###### 1.2.3.1 DNS概述、功能和特点

我们大多数人都知道，做一个批评者比做一个创造者要容易得多。很容易看出，在刚刚起步的TCP/IP互联网上使用的主机表名称系统是无法为它的未来服务的，但找到解决这个问题的办法就困难得多。主机表系统不足的主要原因是它太简单了，这意味着它的替代品--域名系统（DNS）--必须相当复杂。自然，这使得DNS的设计更加困难，同时也意味着我们必须投入更多的精力来理解它的工作原理。

正如我在本指南中对大多数复杂的系统和协议所做的解释一样，我在本节中首先介绍了背景信息和对TCP/IP DNS的介绍。我首先概述了DNS的发展、历史和标准，延续了在全面考察TCP/IP名称系统时开始的历史。我讨论了DNS创建者的设计目标和目的，以帮助你更好地理解它的设计者想要做什么。然后，我谈到了DNS的主要组成部分和它所执行的功能，并将这些功能与名称系统概述部分中解释的基本功能联系起来。



###### 1.3.2.1-1 DNS概述、历史和标准（部分：1 2 3 )

大多数人对试图记住数字标识符的厌恶，导致在我们现在所说的互联网的前身上，很快就采用了设备名称系统。在20世纪60年代和70年代初，人们给机器起了名字，并将这些名字保存在主机表中。TCP/IP主机表名称系统在若干年内运行良好，设备管理员使用一个集中维护的主列表，以确保网络的一致视图。

不幸的是，这样的系统只有在设备数量较少的情况下才运行良好。随着萌芽中的互联网的发展，主机表方法的许多弱点变得很明显，我在描述该系统的章节中详细介绍了这一点。此外，该系统的问题并不是可以通过小的改动就能轻易 "修补 "的；这些问题是结构性的，是整个主机表基本理念的一部分。对于如何在互联网上使用名称，需要一种全新的方法。

<u>**早期DNS的发展和向分层域的转移**</u>
TCP/IP工程师所做的最重要的 "范式转变 "是决定将名称系统从使用单一的、集中的名称列表改为更分散的系统。这个想法是要创建一个结构化的拓扑，将名称组织到域中。这个想法在1981年9月的RFC799中首次提出，标题是互联网名称域。

RFC 799实际上更多的是描述了在域之间传递电子邮件信息的机制，而不是域本身。有趣的是，该标准在其讨论中假设了一个扁平的域名结构，同时提到了建立一个分层结构的可能性。事实上，正是由于决定采用这种分层的域名空间，才导致了我们今天所知的域名系统（DNS）的建立。

在20世纪80年代初，许多不同的RFC文件被发表，描述了DNS不同方面的发展。DNS历史上第一个真正的里程碑可能是1983年11月发表的讨论DNS概念的 "三合一 "初始文件，见表162。


​                                               表162: 讨论TCP/IP域名系统（DNS）概念的文件

| **RFC Number** | **Name**                                                     | **Description**                                              |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **881**        | *Domain Names Plan and Schedule**域名计划和时间表*           | 讨论了实施新的 DNS 名称系统以及如何从旧的主机表系统迁移所涉及的问题。 |
| **882**        | *Domain Names: Concepts and Facilities**域名：概念和设施*    | 相当详尽地描述了 DNS 的概念和功能元素。包括对名称空间、资源记录以及名称服务器和解析器如何工作的讨论。 |
| **883**        | *Domain names: Implementation Specification**域名：实施规范* | 提供有关 DNS 消息传递和操作的“细节”详细信息。                |

<u>**DNS的标准化和最初的定义标准**</u>

在随后的几个月里，上述文件被频繁讨论，基本的DNS机制也被多次修订。随后发表了几份RFC，更新了DNS的切换计划和时间表。最后，在1987年11月，就系统的运行达成了协议，并发表了一个 "四重奏 "的新RFC，首次正式确定了DNS系统。这些标准是RFCs 1032至1035，见表163。


​                                                表163: 定义TCP/IP域名系统（DNS）的初始标准

| **RFC Number** | **Name**                                                     | **Description**                                              |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **1032**       | *Domain Administrators Guide*                                | 为运行域的人员指定管理程序和策略。                           |
| **1033**       | *Domain Administrators Operations Guide*                     | 提供有关如何操作 DNS 服务器的技术细节，包括如何维护部分 DNS 分布式名称数据库。 |
| **1034**       | *Domain Names - Concepts and Facilities**域名 - 概念和设施*  | 替换 RFC 882，提供 DNS 的介绍和概念描述。                    |
| **1035**       | *Domain Names - Implementation and Specification**域名 - 实施和规范* | 对 RFC 883 的更新，详细说明了 DNS 的工作方式，包括资源记录定义、消息类型、主文件格式以及解析器和名称服务器实现细节。 |



这最后两份文件，RFCs 1034和1035，被认为是域名系统运行的最终原始规范。虽然它们现在已经有很多年的历史了，但它们仍然提供了关于DNS如何工作的基本描述。

DNS已经迅速成为互联网和TCP/IP工作方式的一个非常重要的部分。随着互联网的发展，包括成千上万的网站，然后是数以百万计的网站，DNS的重要性也在增加。今天，大多数人几乎每次使用TCP/IP访问互联网时都会使用DNS。它已经从应用的替代寻址形式变成了大多数用户的首选。它是为TCP/IP开发的更完整的 "应用层寻址 "方案的一个重要组成部分：统一资源标识符（URI）。

DNS名称空间的层次性是唯一允许互联网发展的东西，同时使名称的分配和映射可以管理。权限结构也是分层的，使本地管理员能够控制他们所管理的设备的名称，同时确保整个层次结构的名称一致性。使用许多名称服务器和遵循标准消息协议的标准化解析技术进行的数据分配提供了效率和可靠性。当我们在后面的主题中更全面地探讨DNS时，这些概念将变得更加清晰。

<u>**DNS的演变和重要的附加标准**</u>

当然，自1987年以来，TCP/IP和互联网都发生了很大的变化，而DNS也不得不随之改变。自20世纪80年代末发表基本文件以来，已经编写了许多RFC，其中大多数进一步澄清了DNS的操作，扩大了其能力，或为其定义了新的功能。你可以通过在RFCs列表中搜索 "域名 "或 "DNS "来找到所有这些。有几十个这样的RFC，我认为在这里简单地列出它们没有意义，但我在表164中强调了几个更有趣的。

​                                                                                     表164: 其他DNS标准

| **RFC Number** | **Name**                                                     | **Description**                                              |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **1183**       | *New DNS RR Definitions**新的 DNS RR 定义*                   | 定义了几个新的“实验性”资源记录类型。其他后续 RFC 也定义了新的 RR。 |
| **1794**       | *DNS Support For Load Balancing**负载平衡的 DNS 支持*        | 讨论负载平衡以提高 DNS 服务器的性能。                        |
| **1995**       | *Incremental Zone Transfer in DNS**DNS 中的增量区域传输*     | 指定一项新功能，该功能仅允许将区域的一部分传输到辅助名称服务器以提高效率。 |
| **1996**       | *A Mechanism for Prompt Notification of Zone Changes (DNS NOTIFY)**区域更改提示通知机制 (DNS NOTIFY)* | 向 DNS 添加新的消息类型，以允许主（权威）DNS 服务器告诉辅助服务器主数据库中的信息已更改。 |
| **2136**       | *Dynamic Updates in the Domain Name System (DNS UPDATE)**域名系统中的动态更新 (DNS UPDATE)* | 描述一种在 DNS 数据库（也称为动态 DNS）中动态更改资源记录的技术。 |
| **2181**       | *Clarifications to the DNS Specification**对 DNS 规范的澄清* | 讨论 RFC 1034 和 1035 中定义的主要 DNS 标准的几个问题以及如何解决这些问题。 |
| **2308**       | *Negative Caching of DNS Queries (DNS NCACHE)**DNS 查询的负缓存 (DNS NCACHE)* | 指定负缓存的操作，该功能允许服务器更有效地维护有关不存在的名称的信息。 |

<u>**为IPv6调整DNS**</u>
IP版本6是在20世纪90年代中期开始开发的，并带来了对DNS操作的改变和加强的需要。(尽管DNS在更高的层次上运行，但它与地址密切相关，而地址在IPv6中已经改变了）。为支持IPv6而对DNS进行的修改首先在RFC 1886 "IPv6 DNS扩展 "中定义，这是一组RFC的一部分，规定了IPv6的基本原理。从那时起，已经发布了几个后续标准；这些标准将在IPv6 DNS主题中讨论。

本节接下来的三个主题通过讨论DNS创建者的设计目标和协议的主要特征，对DNS及其发展进行了更全面的概述。



###### 1.3.2.1-2 DNS设计目标、目的和假设（部分：1 2 )

正如我们在前面的话题中所看到的，从第一个讨论TCP/IP域名的RFC到描述DNS操作的官方标准的发布，经过了六年多的时间。对于一个系统的发展来说，这是一个非常长的时间，但这并不令我感到惊讶。在创建DNS的过程中，必须进行大量的思考，以确保它能满足所有将被置于它之上的许多要求。

第一个问题是，DNS的创建者不得不担心如何定义新系统和如何从旧系统迁移。他们花了大量的时间来计算如何将所有现有的主机转移到新的DNS名称空间，以及如何在这些主机上实施交换DNS信息的新协议。

DNS的创建者们知道他们之所以制作新的系统，是因为旧的系统不能很好地扩展；他们还知道，如果迁移在当时存在的少量主机中是一个困难的问题，那么如果他们在未来不得不去使用另一个新的系统，那就会更加困难。这使得DNS的关键挑战是创建一个能够满足互联网需求的系统，不仅仅是在它被引入的那一天，或者第二年，甚至是十年或更久以后。

<u>**DNS的设计目标和目的**</u>
早在20世纪80年代，没有人知道互联网将如何像过去十年那样发展。DNS至今仍然运作良好，证明了其设计者的技能。这种成功在很大程度上是由于早期对系统设计所做的基础工作。DNS的工程师们记录了一些他们认为是创建该系统的主要设计目标，这不仅可以帮助我们理解DNS的作用，而且可以帮助我们理解为什么。

- 创建一个全球的、可扩展的、一致的名称空间。名称空间必须能够跨越一个包含数百万台机器的大型全球互联网。它有必要为设备和资源的命名提供一个一致的、可预测的方法，以便它们能够被轻易找到。显然，还必须避免名称的重复，即使在不同大洲的设备之间有潜在的冲突也是如此。

- 对本地资源的本地控制。整个互联网上的网络和小型互联网的管理员需要能够控制他们自己设备的命名。要通过一个中央机构来命名每一个对象是不可接受的，每个管理员需要知道其他人的网络和机器的名称也是不可接受的。

- 分布式设计，避免瓶颈。DNS的设计者知道，他们必须放弃集中式数据库的想法，而采用分布式的方法来存储数据，以避免在许多设备上使用DNS时产生的瓶颈问题。

- 应用的普遍性。该系统必须具有足够的通用性，以支持各种各样的应用。例如，它需要支持主机识别、邮件发送和其他功能。

- 多种基础协议支持。DNS需要在本质上能够支持不同的基础协议。(许多人没有意识到，例如，DNS不仅可以支持IP地址，还可以支持其他类型的地址，这仅仅是因为IP在今天的网络中是如此的占优势）。

- 硬件通用性。大型和小型计算机都需要能够使用该系统。

在你进一步了解DNS时，请记住这些目标，它将帮助你更好地理解为什么选择某些设计属性。例如，如果我们考虑上面列出的前两个目标，它们似乎几乎是矛盾的：如果个别管理员能够分配本地名称，我们怎么能有一个具有独特名称的全球名称空间？答案是，正如我们将看到的，这正是DNS分层名称空间的力量所在。

<u>**DNS的设计假设**</u>

上面的目标告诉我们，DNS的创建者希望确保新系统能够解决什么问题。此外，从事协议实施细节工作的工程师们必须根据对协议使用方式的某些假设来做出决定。其中一些比较重要的假设。

- 快速增长的数据库规模。到20世纪80年代中期，很明显，DNS的名称数据库开始时相当小，但会迅速增长。该系统需要有能力处理这种快速增长。

- 可变的数据修改率。名称数据库中的大多数数据将不经常变化，但有些数据会比这更频繁地变化。这意味着在如何处理数据变化，以及如何沟通这些变化的信息方面，需要有灵活性。

- 可授权的组织责任。名称数据库的部分责任将主要根据组织的边界来委托。许多组织也将运行他们自己的硬件和软件来实现整个系统的部分功能。

- 名称信息访问的相对重要性。人们认为，DNS最重要的是提供可靠的名称解析，因此该系统的创建使用户总是有可能访问一个名称并确定其地址。创建该系统的一个关键决定是，即使信息稍微过时，也比没有信息好。如果名称服务器不能提供最新的数据来满足一个请求，它将返回它所拥有的最好的信息。

- 对缺失信息的请求的处理。由于名称数据将被分发，一个特定的名称服务器可能没有用户要求的信息。在这种情况下，名称服务器不应该只是说 "我不知道"。它应该提供一个更有可能的信息来源的转介，或者通过发出自己的请求来寻找数据。这导致了几种DNS名称解析技术的产生：本地、迭代和递归。

- 使用缓存的性能。从一开始，人们就认为DNS将广泛使用缓存，以避免对包含分布式名称数据库部分的服务器进行不必要的查询。

可以说，在创建这个系统时，像每个系统一样，还做了很多假设。例如，DNS不得不对数据的具体存储方式、发送消息的传输机制、管理员的角色等做出假设。当我们看完这个系统时，我们会更多地了解这些。

###### 1.3.2.1-3 DNS组件和一般功能 (部分: 1 2 )

为了满足其设计者为它设定的许多目标，DNS需要大量的功能。它是一个真正的名称系统，重点是系统，因此比TCP/IP中早期使用的主机表名称系统要复杂得多。在描述一般名称系统的章节中，我把一个功能齐全的名称系统的许多任务分为三类。DNS包括所有这些类别的功能，因此，使用这些类别是一个很好的方法，可以高瞻远瞩地了解DNS的工作方式。

下面是三个基本的名称系统功能，以及DNS如何实现它们（见图234）。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\dnsfunctions.png)


​                                                                        图234: DNS功能



<u>**名称空间**</u>
DNS使用一个分层的名称空间，包括一个单一的、复杂的、多层次的结构，系统中的所有名称都适合这个结构。名称空间从一个根开始组织，"容器"（称为域）被放入其中。每个容器可以包含单个设备名称或更具体的 "子容器"。整体结构有点类似于计算机上的目录系统如何从一般到具体地组织文件，使用一个任意的结构，可以根据各种需要进行优化。

一个特定的语法被用来定义有效的名称，特殊的术语被用来描述结构的一部分和识别域名，从根到设备级别。

<u>**名称注册（包括管理和授权）**</u>
DNS名称注册是用来将单个名称输入到DNS分布式数据库中。DNS使用分层的管理机构安排，对分层的名称空间进行补充。一个集中的机构决定了名称空间的整体形状和结构，并在最高级别处理名称的注册。然后将权力下放给不同的组织，以管理名称空间的各个部分。一套通用政策控制注册过程，并处理问题和冲突。

<u>**名称解析**</u>

DNS使用一个强大的、分布式的、客户/服务器名称解析机制。这可能是在设计DNS时最需要注意的地方，以确保它可以扩展到每天处理数百万乃至数十亿的名称解析请求。

名称解析过程是通过两个基本的软件元素来实现的，它们扮演着客户和服务器的角色：名称服务器和名称解析器。

<u>**名称服务器**</u>
DNS名称服务器是运行在硬件服务器上的特殊程序，是DNS的核心。服务器由对DNS名称空间的一部分拥有管理控制权的组织维护，并包含描述名称空间的那些部分的名称、地址和其他特征的资源记录。因此，服务器本身被安排在一个类似于名称空间的层次结构中，尽管在结构上不尽相同。

名称服务器的主要工作是接收名称解析的请求，并以从数据库中请求的数据进行响应，或者以另一个名称服务器的名称来引导请求的信息。名称服务器还负责数据缓存和其他管理任务，以确保整个系统的有效运行。

<u>**名称解析器**</u>
名称解析器是名称解析过程中的通常客户。当用户在网络应用中引用一个名称时，该名称被传递给解析器，解析器向名称服务器发出请求。根据配置的不同，可能需要一个以上的请求，并且可能结合几个不同的解析过程来寻找所需的信息。解析器也可能采用缓存或实现其他功能。

**注意：**解析器和服务器之间的划分是基于角色的。正如我们在研究名称解析时看到的那样，名称服务器在某些数据交换中也可以作为客户。关于这个明显的悖论的解释，请参见DNS消息传递的主题。


如果这看起来很像我在名称系统概念部分对名称系统的 "经典 "描述，那并不是巧合；DNS被认为是大多数其他名称系统的对比对象。如果你理解这些高层次的描述，那么你已经知道了DNS工作的基本原理。接下来的三节将更详细地探讨这三个功能区的每一个，并将帮助你真正了解DNS是如何工作的。

**关键概念。**作为一个完整的名称系统，DNS提供了众多的功能，实现了三个基本名称系统功能中的每一个。DNS的名称空间是分层次的，是使用多层次结构的组织，有特定的命名规则。DNS名称注册系统是基于域的层次结构和负责这些域的注册机构的想法。DNS名称解析同样是分层的，并围绕着名称解析器和名称服务器软件组件之间的互动而设计，这些软件组件查询DNS资源记录数据库，并使用特殊的信息传输协议进行通信，以回答客户查询。





###### 1.2.3.2 DNS名称空间、架构和术语

名称空间是任何名称系统的最基本部分，因为它定义了名称本身的创建方式。名称空间告诉我们名称可以采取什么形式，并提供如何创建的规则。最重要的是，它规定了名字的架构--名字本身的内部结构。这反过来又对名称注册和解析的工作方式产生了重要影响，使得对名称空间和架构问题的研究成为学习DNS细节的明显起点。

在本节中，我描述了DNS名称空间及其结构背后的概念。我首先概述了DNS名称空间，并描述了它使用的分层结构。然后，我提供了关于名称结构的更多细节，还解释了经常用来指称名称空间的部分的术语。我对DNS标签和创建域名的官方和非官方规则进行了正式描述。最后，我对域名规范进行了描述，并解释了 "资格 "的概念，以及完全资格和部分资格的名称有何不同。资格这里理解**完全限定域名** 和非**完全限定域名** 



###### 1.2.3.2-1 DNS域名和DNS分层名称结构（部分：1 2 3 )

名称系统的名称空间中最重要的元素是其名称架构，它描述了名称的构建和解释方式。不出所料，域名系统的架构是基于一个叫做域的抽象概念的。这显然是解释DNS如何工作的一个好起点。不幸的是，这并不是一个最容易从头开始解释的概念，所以像往常一样，我会尽力而为，请大家耐心等待。J

<u>**DNS名称空间中的基本概念。域名**</u>
字典中对 "域 "的定义通常传达的是一个影响范围，或控制或统治的区域的概念。一个基本概念是，在许多不同的情况下，可以在许多不同的层次上施加控制或权力。一个势力范围可能包含更小的势力范围，而这些势力范围又可能包含更小的势力范围。这意味着这些领域自然而然地被安排在一个等级体系中。

一个明显的例子是地缘政治领域。我们在地球上没有集中的 "世界政府"，但我们有联合国，它处理全世界的问题。在下一个层次，我们有各个国家。其中一些国家有州和省这样的部门。更低的层次有县、市、街区和个人住宅或企业。这些 "域 "在组织上具有内在的层次性。

域名系统使用域名的方式与此非常相似，并采用了与地缘政治例子基本相同的等级结构。在DNS中，域被定义为一个单一的对象或一组基于某种类型的共性而被收集在一起的对象。通常在DNS中，这种共性是它们都是由同一个组织或当局管理的，这使得名称层次与DNS的等级权威结构的概念紧密相连。

**注：**"域 "一词也用于网络世界的其他语境中。最明显的例子是在微软网络中的使用，在那里它也被用来代表共同授权下的对象集合的概念。然而，这两种类型的域是完全不同的，没有超出这个概念层面的关系。

<u>**DNS名称的层次树状结构**</u>

人们可以构建一个树状图，上面是联合国，其线条指向地球上的每个国家。然后，在美国境内，例如，我们可以画线指向每个州；在每个州内，画线指向每个县，依此类推。其结果将是看起来像一棵倒置的树，正如我们在图235中看到的那样。这就是所谓的树状结构。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\dnshier.png)


​                                                                            **图235: 全球分层域结构的例子**

这张图显示了一个层次结构的例子，是基于政治划分的。联合国是一个伞式组织，（在某种程度上）代表了世界上所有的国家。它是这棵树的根；在它下面，我们可以看到各个国家。然后每个国家以其选择的方式进一步细分；例如，加拿大有省和地区，而美国有个别州。这些又可以以任何方式进一步细分。


树被用于整个计算和网络；例如，树是局域网拓扑结构的一种类型。对于我们解释DNS的目的来说，树状结构的最好例子是用于在计算机硬盘或其他存储设备上存储文件的目录树。根目录位于结构的顶部，可能包含命名的文件和/或命名的目录。每个目录本身可以包含单独的文件或子目录，子目录又可以包含自己的子目录，以此类推。

DNS的域名结构在概念上是以完全相同的方式安排的，只是DNS不是处理文件，而是处理命名的对象，通常是像IP主机这样的设备。最高层仍然是树的根。它包含一些域，每个域都可以包含单个对象（名称）和/或较低级别的域。低级域又可以有更低级的域，使树作为一个整体可以采取任意的结构。

<u>**DNS分层名称架构的好处**</u>

像目录结构一样，DNS分层名称架构允许名称从最一般到最具体地组织起来。它还具有完全的灵活性，允许我们以任何我们想要的方式安排结构。例如，我们可以制作一个名称系统，其结构与我前面描述的地缘政治组织图完全相同。我们可以让名称结构的根代表 "联合国"，并为每个国家创建一个域。然后，对于那些有国家的国家，如美国，我们可以在这些国家内创建 "国家域"。不需要这些域的较小国家可以在国家域下直接建立 "城市域"。这个层次结构是灵活的，因为在每一级都可以给它一个合适的子结构。

**关键概念。**DNS名称空间被安排成一个域的层次结构，形状像一棵倒置的树。它在结构上类似于文件系统的目录结构，有一个包含域的根，每个域都可以包含子域，以此类推。


重要的是要记住，每个独立的国际网络都可以有自己的名称空间和独特的层次结构。很多时候，人们将 "***a\*** DNS name space "的概念与 "*the DNS name space "混为一谈。后者指的是用于全球互联网的DNS层次结构，很明显，这值得高度重视。但它只是无限多的可能结构中的一种可能安排，即使是重要的安排。

在本节剩下的主题中，我继续对DNS名称空间和架构进行通用描述，包括在下一个主题中对DNS名称和术语进行考察。关于名称注册和授权的部分提供了关于互联网的DNS层次结构的更多具体信息。正如我们在那里看到的，地缘政治结构实际上是以类似于我上面描述的方式来为互联网的一些计算机分配名称的，但层次结构的其他部分则不同。



###### 1.2.3.2-2 DNS结构元素和术语。域、子域和节点；根、叶和分支；父母、子女和兄弟姐妹（部分：1 2 3）

现在我们了解了域名系统名称空间的基本原理，让我们更详细地看看DNS的结构。同时，我们可以更好地掌握用于指称DNS域名层次结构部分的许多不同术语。

<u>**与DNS树相关的术语**</u>
我们在上一主题中看到，DNS域名结构的形状有点像一棵树；结构化元素和树之间的比较是网络中常见的一种。这里技术和生物的主要区别是，DNS树是自上而下生长的，而不是伸向天空。对树的类比自然导致在描述DNS名称结构时使用几个与树有关的术语，其中一些在图236中说明。

**Root**根: 这是DNS名称结构的概念性顶部。DNS中的根域包含整个结构。根据定义，它没有名字；它是空的。

**Branch*分支:一个分支是DNS层次结构的任何连续部分。它由一个域和其中所有的域和对象组成。所有的分支都连接到根部，就像真正的树一样。 是的，如果根部被称为树干会更好，但计算机科学专业的学生显然不把植物学作为选修课。J)

**Leaf**叶子:这是结构中的一个 "终端对象"，也就是说，一个没有任何东西在它下面的域。同样，把叶子比喻为处于一连串树枝的末端是很恰当的。
没有特定的术语来指代不是叶子的域。这些节点有时被称为内部节点，意思是它们处于结构的中间位置。节点是拓扑结构中一个对象的通用计算术语；它在本指南中一直被使用。因此，在DNS中，每个节点都是一个域，可以是一个包含其他域和/或对象的内部节点，也可以是一个特定命名设备的叶子。**因此，域这个术语有些含糊，因为它既可以指代表树的一个分支的对象集合，也可以指具体的叶子。**

<u>**与DNS域相关的术语**</u>

还有几个 "类似于域 "的术语，经常被用来指称层次结构中不同级别的域。这些术语，如图236所示，包括。

- 根域。这是树的根，如前所述。

- **Top-Level Domains** 顶级域名（TLD）。这些是直接位于树根之下的最高级别的域。它们有时也被称为第一级域名。
- 二级域名。令人震惊的是，这些域位于顶级域的正下方。

- 子域。在某些情况下，这个术语仅指位于二级域正下方的域（但见下文）。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\dnstree.png)

​                                                                      **图236：DNS名称空间树和与域相关的术语**

DNS名称空间的顶端是树的根，没有名称。在根部下有任何数量的顶级域（TLD）；在每个顶级域中可以放置二级域，然后在这些子域中，以此类推。

这里还显示了DNS中使用的一些 "树状 "术语。紫色背景的树的部分是一个分支；蓝色区域强调了该分支中较小的 "子分支"。该蓝色区域内的绿色节点是该树的较小分支的叶子。

 

**关键概念。**DNS名称空间的顶部是根；在根下有顶级域，在这些域中有二级域，然后是子域。从理论上讲，可以创建任何数量的子域级别。一个分支是DNS树的任何连续部分；一个叶子是一个结构中下面没有任何东西的域，通常代表一个单一的设备。


术语 "子域 "也可以笼统地使用，就像 "域 "本身一样。在这种情况下，它只是指两个域之间的关系，一个子域在结构中处于另一个域之下。这意味着，例如，顶级域可以说是根的子域；每个二级域都是顶级域的子域，等等。但同样，有时 "子域 "具体是指三级或更低的域。

<u>**与DNS家族相关的术语**</u>

你会遇到的另一组术语，不是把DNS树结构比作一棵活树，而是事实上，比作另一个比喻：家庭树。这些术语最常被用来描述所讨论的特定域与它周围的其他域或子域的关系，所以它们是相对术语。通常看到的是（见图237）。

- 父域。在层次结构中位于此域之上的域。例如，根域是所有顶级域的父域。

- 子域**Child**。在层次结构中处于这个域的下一级的域。因此，顶级域是根域的子域。

- 兄弟姐妹**Sibling**。在层次结构中与此域处于同一级别的同级域，具有相同的父母。因此，所有顶级域都是以根为父的兄弟姐妹；某一顶级域内的所有二级域都是兄弟姐妹，依此类推。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\dnstreefamily.png)

​                                                                         **图237: DNS名称空间 "家庭树"**

该图与图236相似，但我对节点进行了不同的标注，以显示DNS中有时使用的 "面向家庭 "的术语。在这种情况下，名称是相对于青色显示的内部节点而言的。紧挨着它的域名是它的父节点；同级别的其他节点是兄弟姐妹，而其中的子域是该节点的子节点。

**关键概念。**在DNS名称空间中，给定域上方的域被称为其父域；同一父域内同一级别的域是兄弟姐妹；子域被称为该域的子女。

<u>**对DNS树结构的限制**</u>
请注意，像真正的树一样，DNS名称结构在结构上必须是一棵真正的树。每个域只能有一个父域（根除外），就像树的每个分支只能连接到一个枝干（根/干除外）一样。此外，结构中不能出现 "循环"；例如，你不能有一个域的子代也是它的父代。

**关键概念。**一个DNS名称空间必须被安排为真正的拓扑树。这意味着每个域只能有一个父域，而且结构中不允许有 "循环"。

我还想指出的是，即使名称层次代表了命名设备的安排，它也只是一个逻辑结构。与设备的物理位置没有必然的对应关系。一个有10个子域的域可能代表11个不同国家的11台设备。当我们研究DNS权威结构时，我们会更多地探讨这个问题。



###### 1.2.3.2-3 DNS标签、名称和语法规则 (部分: 1 2 3 )

我们已经看到了DNS名称空间的层次结构是如何让我们把域安排成一个虚拟的树，反映出设备本身的组织方式的特点。虽然使用分层名称空间本身比平面名称空间更复杂，但它产生了一个强大的结果：能够指定可在本地管理的名称，同时保持全球唯一。同时，树的复杂性产生了使用域标识符的相对简单的名称构建的好处。

<u>**DNS标签和标签语法规则**</u>
在DNS中命名，首先是给DNS名称空间中的每个域或节点一个文本标签。标签确定结构中的域，并且必须遵循这些语法规则。

- 长度。每个标签理论上可以是0到63个字符的长度。在实践中，1到20个字符的长度是最常见的，但分配给树根的标签是一个特殊的例外（见下文）。

- 符号。允许使用字母、数字，以及破折号（"-"）。不允许使用其他标点符号，包括下划线（"_"）。

- 大小写。标签是不分大小写的。这意味着 "Jabberwocky "和 "jabberwocky "都是允许的域名标签，但它们是等同的。

<u>**DNS标签的唯一性要求**</u>
每个标签在其父域内必须是唯一的。因此，例如，如果我们有一个名为 "rocks "的顶级域名（TLD），我们只能在 "rocks "中拥有一个名为 "crystal"的子域。由于标签的大小写不敏感，我们不能在 "rocks "中同时出现 "crystal "和 "CRYSTAL"，因为它们被认为是相同的。

正是这种在父域内的 "局部唯一性 "的概念，确保了名称整体的唯一性，同时允许对命名进行局部控制。负责 "rocks  "域的人可以随心所欲地为单个对象或子域分配名称，只要它们在该域内是唯一的。其他人，比如说，"glass "域的维护者，也可以在 "glass "中创建一个名为 "rocks "的子域；由于 "glass"和 "rocks  "域是分开的，所以没有冲突。当然，由于所有顶级域名都有相同的父域名（根域名），所有顶级域名必须是唯一的。

**关键概念。**DNS名称空间中的每个节点都由一个标签来识别。每个标签在父域内必须是唯一的，但在各域之间不需要是唯一的。这使得每个域都能对子域的名称进行本地控制，而不会导致在全球范围内创建的全域名称出现任何冲突。

<u>**从域名标签构建域名**</u>

域名结构中的每一个单独的域都可以使用从树的根部开始并向下延伸到该域的标签序列进行唯一的识别。层次结构中每一级的标签按顺序列出，从最高一级开始，从右到左，用点隔开。其结果就是域名的正式定义。

默认情况下，名称空间的根被赋予一个零长度的 "null "名称。也就是说，根的标签是存在的，它只是空的。之所以这么做，是因为根在技术上是每个域名的一部分。这意味着它必须包含在每个域名中。如果它是像 "root "这样长的东西，我们将不得不在每个域名的末尾包括它。这只是让每个名字变得更长，同时并没有真正增加任何有用的信息--我们已经知道每个域名都在根的下面。

让我们再来看看上面的例子，一个叫做 "rocks "的顶级域名，其中有一个二级域名 "crystal"。rocks "的域名是 "rocks."，"rocks "和""（null root）之间用点隔开。在实践中，尾部的点经常被省略，所以顶级域名 "rocks "的域名可以被认为只是 "rocks"。在 "rocks "中的子域 "crystal "的域名是 "crystal.rocks"。如果我们在 "crystal.rocks "域名内有一个名为 "salt "的设备，它将被称为 "salt.crystal.rocks"。这是很直接的，你可以在非常简单的图238中看到。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\dnslabels.png)


​                                                                                  **图238: DNS标签和域名结构**

DNS名称空间中的每个节点都有一个标签（根除外，其标签为空）。一个节点的域名的构建方法很简单，就是将标签的顺序从树的顶端一直到各个域名，从右到左，每个标签之间用一个点（句号）隔开。


我们可以使用这些名称来轻松识别一个特定领域的子域。例如，如果我们从 "salt.crystal.rocks "开始，很明显，"crystal.rocks "是其父域。同样明显的是，"crystal.rocks "和 "salt.crystal.rocks "都是 "rocks "的子域；一个是 "rocks "的单层，另一个是双层。

<u>**DNS名称的长度限制**</u>

出于执行的目的，一个完整的域名的最大限制是255个字符。在实践中，大多数域名都比这个限制短得多，因为如果我们让它们变得如此之长，以至于没有人能够记住它们，这就违反了域名的整个目的。

<u>**资源规范**</u>
在许多协议中，可以通过在名字后面提供一个目录结构来指定域名中的特定资源。这是用标准的TCP/IP统一资源定位器（URL）语法来完成的，其中一个路径是用斜线来分隔子目录。例如，"salt.crystal.rocks "的一个特定文件可能位于 "salt.crystal.rocks/chem/composition"。

虽然DNS名称是不区分大小写的，但URL路径中的标签要区分。所以这个例子与 "salt.crystal.rocks/chem/Composition"是不同的。更多细节请参见URL语法专题。

**关键概念。**域名是一串文本，用于唯一地识别名称空间中的特定节点。一个节点的域名是由DNS树的分支中从树顶开始到特定节点的所有标签按从右到左的顺序连接而成的，每个标签之间用一个点" . " （句号。）



###### 1.2.3.2-4 **完全限定域名** 和相对完全限定域名规格

上一个主题展示了我们如何指定DNS名称层次结构中任何节点的域名。我们只需从根节点开始，按照子域的顺序一直到有关的节点，列出每一级的标签，用一个点分开。当我们这样做的时候，我们就得到了唯一能识别一个特定设备的单一名称。

<u>**完全合格的域名(FQDNs)**</u>
从技术上讲，如果一个顶级域名 "A "包含一个子域 "B"，而这个子域又包含子域 "C"，那么 "C "的全域名就是 "C.B.A."。这被称为节点的完全限定域名（FQDN）。这里，"限定 "一词与 "指定 "同义。域名 "C.B.A. "是完全限定的，因为它给出了在整个DNS名称空间中带有其名称的特定域的完整位置。

完全限定的域名有时也被称为绝对域名。这个术语反映了这样一个事实：人们可以从名称空间的任何其他部分使用其FQDN毫不含糊地参考任何设备的名称。使用FQDN总是指示解释该名称的人或软件从根部开始，然后按照域名标签的顺序从右到左，在树中从上到下。

<u>**部分合格的域名（PQDNs）**</u>
还有一些情况下，我们可能会使用不完整的名称规范来指代一个设备。这被称为部分合格的域名（PQDN），这意味着该名称只是部分地指定了设备的位置。根据定义，PQDN是模糊的，因为它没有给出域名的完整路径。因此，人们只能在一个特定的父域范围内使用PQDN，这个父域的绝对域名是已知的。然后，我们可以通过将部分名称附加到父域的绝对名称上，找到部分指定的域名的 FQDN。例如，如果我们在FQDN "Y.X. "的范围内有PQDN "Z"，我们知道 "Z "的FQDN是 "Z.Y.X"。

为什么要这样做呢？答案是方便。一个域的管理员可以使用相对名称作为简称来指代设备或子域，而不必重复整个全名。例如，假设你是Widgetopia大学计算机科学系的负责人。整个部门的域名是 "cs.widgetopia.edu."，而你管理的各个主机是以水果命名的。

在你维护的DNS文件中，你可以每次都用FQDN来指代每个设备；例如，"apple.cs.widgetopia.edu."，"banana.cs.widgetopia.edu."，等等。但是，告诉软件 "如果你看到一个没有完全限定的名字，假定它在'cs.widgetopia.edu'域中 "会更容易。然后你就可以把机器称为 "苹果"、"香蕉 "等。每当DNS软件看到一个PQDN，如 "kiwi"，它就会把它当作 "kiwi.cs.widgetopia.edu"。

关键概念。完全限定域名（FQDN）是一个完整的域名，它通过给出从树根到该节点的完整标签路径，唯一地标识了DNS名称空间中的一个节点。它定义了一个域名的绝对位置。相比之下，部分合格的域名（PQDN）只指定了域名的一部分。它是一个相对名称，只有在特定的环境中才有意义；必须在该环境中解释部分名称，以完全识别节点。

区分DNS中的FQDN和PQDN
我在前面的主题中提到，空根域名的尾部点通常被省略。这在通常情况下是正确的，当用户在应用程序中指定一个域名时；例如，你在你的Web浏览器中不使用尾部的点。然而，在DNS本身，点是用来明确区分FQDN和PQDN的DNS主文件。这使得我们可以同时使用FQDN和PQDN。在上面的例子中，"apple "指的是 "apple.cs.widgetopia.edu."，但 "apple.com. "指的是苹果电脑公司的全限定域名。你必须注意这里的点，因为 "apple.com"（没有尾部句号）将是一个PQDN，将指 "apple.com.cs.widgetopia.edu."，而不是苹果公司的域名。





###### 1.2.3.3 DNS名称注册、公共管理、区域和权威性

DNS名称空间由域和子域的层次结构组成。从根部开始，我们有一些顶级域，然后是二级域，再往下是低级域。那么明显的问题是：我们如何确定名称空间的形状和结构，以及谁来管理它？更具体地说，谁将控制树的根部并决定顶级域的名称？然后，我们将如何划分对名称空间其他部分的控制？我们如何确保在选择一个域内的同级子域的名称时没有冲突？

DNS可以用在由单一组织控制的私有网络上，如果是这样，我上面的问题的答案显然是 "那个组织"。我们将讨论私人命名，但在现实中，它只是没有那么有趣。绝大多数的DNS使用都发生在公共互联网上。在这里，我们有一个更大的挑战，因为我们必须构建一个跨越全球的名称空间，涵盖由不同组织管理的数百万台机器。为此，我们需要一个非常有能力的名称注册过程和管理方法来支持它。

在这一节中，我描述了名称注册的过程以及在域名系统中如何管理权限，重点是公共互联网。我首先描述了DNS的分级授权结构以及它与分级名称空间的关系，并讨论了DNS分布式名称数据库背后的概念。我描述了互联网的组织和地缘政治的顶级域，以及它们是如何被各种机构管理的。然后，我讨论了如何将权力下放给二级和低级域名，以及域名的公共注册是如何进行的，包括如何解决公共注册的问题和难题。我解释了DNS名称空间是如何被划分为权力管理区的，并在最后简要讨论了私人DNS名称注册。

**相关信息:** 大多数TCP/IP实现都包括一个名为whois的特殊工具，可以用来询问DNS分布式名称数据库，以获得有关域的注册信息。这个应用程序对于故障排除非常有用；详情请参见TCP/IP管理工具一节中讨论whois的主题。




###### 1.2.3.3-1 DNS分层权限结构和分布式名称数据库（部分：1 2）

我在描述DNS名称空间时，首先论述了DNS中命名的核心概念：域的概念。每个域都可以被视为类似于一个影响或控制的范围。一个域对它所包含的所有对象和子域 "张开翅膀"。由于这种影响的概念，当我们考虑任何DNS名称空间时，我们看到它是分层次的，因为它反映了控制域和域内节点的组织的层次结构。这意味着事实上存在着一个分层的权威结构，它补充了DNS中的分层名称结构。

<u>**DNS根域的中央机构**</u>
名称空间层次结构导致权威层次结构的主要原因是要求同级子域在一个域内是唯一的。一旦我们有了对唯一性的需求，这就意味着我们必须有某种权威或程序来确保每个子域或对象在该域中选择不同的名称。这实际上就是名称注册的意义所在。

这种分层权威结构的概念有点抽象，但如果我们检查一个DNS名称空间的样本，并讨论在其中分配名称所涉及的问题，就会更容易理解。当然，我们要从名称层次结构的顶端开始，即根域 "null"。为了启动名称空间，我们必须在根域内创建顶级域名（TLD）。现在，每一个都必须是唯一的，所以一个权威机构必须管理所有顶级域名的创建。这又意味着，控制根域的机构控制着整个名称空间。

那么，在 Internet 的情况下，这个中央机构最终对 DNS 中的每个名称负责。控制 TLD 创建的 Internet 中央 DNS 机构最初称为网络信息中心。后来是 Internet 编号分配机构 (IANA)，它还负责协议编号、IP 地址等。这些职能现在由 IANA 和互联网名称与数字地址分配机构 (ICANN) 共享。我们将在接下来的几个主题中讨论 Internet 的特定 TLD； IANA/ICANN 和相关组织在互联网注册机构主题中进行了讨论。

<u>**顶级域名主管部门**</u>
在权威机构的下一级，我们在每个顶级域名中创建二级域名。每个顶级域名本身必须使用一个协调机构进行管理，但是，这不一定是管理根（IANA）的组织。IANA将一些顶级域名的权力下放给其他组织。他们可能将每个顶级域名的控制权委托给这个层次的不同机构。事实上，一个顶级域名和另一个顶级域名在管理二级域名的创建方面可能有完全不同的规则。

我们将在本节后面看到更多关于它是如何工作的。我们还会发现，在某些 TLD 中，实际上有多个机构在名称注册方面协同工作。

<u>**较低级别的权力下放**</u>

当我们继续往下看名称空间的层次结构时，授权的过程仍在继续。在每一级名称空间变得更加具体；如果我们使用组织层次结构，如".COM "顶级域，我们通常将每个二级域的权力下放给它所代表的组织。所以 "IBM.COM "是由IBM管理的，以此类推。由于IBM很庞大，它本身可能会进一步细分权力结构，但较小的组织可能不会。

我想明确指出，授权层次是对名称层次的补充；它们并不完全相同。不一定每一级都要有不同的机构。在许多情况下，一个机构可能会管理名称空间的一个部分，而这个部分跨越了结构的一个以上的层次。例如，IANA管理互联网根域（"null"）和".INT "顶级域名，但其他顶级域名则由其他组织管理。名称层次结构被划分为权力区，反映了管理名称空间部分的权力机构的层次结构。

还值得记住的是，对一个域名的授权并不一定意味着实际控制。一个域可以包含由不同大洲的组织管理的子域，而一个子域也可以包含位于不同大洲的命名设备。

<u>**DNS分布式名称数据库**</u>
当然，有权力就有责任，权力机构对一个域的主要责任是在该域内注册名称。当一个名字被注册时，就会为它创建一组数据，然后网络设备可以使用这些数据将名字解析为地址，或执行其他功能。描述所有DNS域的所有数据集构成了DNS名称数据库。正如注册机构是分布式和分层的一样，这个数据库也是分布式和分层的。

换句话说，没有一个地方存储所有的DNS名称信息。相反，DNS服务器携带的资源记录描述了他们拥有权限的域。正如我们将看到的，这个数据库是分布式的，这对如何进行名称解析有重大影响。

**关键概念:** 公共互联网的名称空间是由权威机构的层次结构管理的，该结构与分层的DNS名称空间相似，但不完全相同。层次结构的顶端由IANA/ICANN集中管理，它将权力下放给其他组织，以便在层次结构的各个其他部分注册名称。有关名称注册的信息被保存在存储在不同地点的资源记录中，这些记录构成了互联网上的一个分布式名称数据库。



###### 1.2.3.3-2 DNS组织（通用）顶级域和授权（部分：1 2 3 4 )

DNS名称层次的顶端由一个中央机构管理，它通过决定允许存在哪些顶级域名（TLD）来控制整个名称空间。显然，在如何选择顶级域名方面，必须要有大量的思考；在这个最高层次上的不良设计会使整个层次结构不能很好地反映使用名称空间的组织的实际结构。

DNS的创建者可以选择任何一种方式来构建互联网的名称层次。一个明显的可能性是根据地缘政治边界来构建互联网：国家、州等，正如我们在上一节的一个主题中看到的那样。另一个合理的想法是根据组织的类型来构建名称空间。我们也可以想象其他可能的方式来划分世界上的计算机名称。

分层名称空间的好处是，我们不必在不同的结构名称空间的方法之间进行选择。我们可以同时使用一种以上的技术，而这正是DNS最初实施时的做法。我上面描述的两种方法，基于组织类型和地理，都被用于顶级域名。这就为大多数团体和个人的名称注册提供了多种选择。我在这里首先讨论的是组织性顶级域名；地缘性顶级域名是下面这个话题的主题。

<u>**最初的通用顶级域名**</u>

最初部署的DNS有一组七个顶级域名，在标准中被称为通用顶级域名。当时的想法是，每个公司或组织都可以在这些顶级域名中选择一个名称；它们足够 "通用"，每个组织都可以找到适合自己的地方。我更愿意称它们为组织型，因为它们按组织类型划分了名称空间的通用部分。最初的顶级域名及其最初的组织类型是：。

- .ARPA。多年前用于过渡到DNS的一个临时域名。它的名字指的是ARPA网络，现代互联网的前身（反过来又以美国国防部高级研究计划局命名，ARPA）。今天，这个域名被用于反向名称解析。

- .COM：公司和企业。

- .EDU：大学和其他教育组织。

- .GOV。政府机构。

- .MIL。军事组织。

- .NET。实施、处理或管理网络技术和/或互联网的组织。


- .ORG：不适合上述任何分类的其他组织。

乍一看，这似乎是涵盖世界上各种组织的合理方式。然而，由于.ARPA域名是 "临时 "的，这就为所有其他组织只留下了六个类别。此外，这些顶级域名并没有像最初预计的那样全部使用；例如，.GOV和.MIL域名并没有用于所有类型的政府和军事组织，而是主要用于美国联邦政府和军队。.EDU最终只用于大学，也是在美国。

这就只剩下三个普通的顶级域名--.COM、.NET和.ORG--几乎所有其他想使用组织层次的团体和公司。由于只有三个这样的顶级域名，它们很快变得非常 "拥挤"，特别是.COM域名。在原有的七个顶级域名之外，很快又增加了第四个域名，即针对国际组织的.INT，但它也只针对少数组织，如国际标准机构。尽管组织型顶级域名为数不多，但毫无疑问，它们比地缘政治型顶级域名要受欢迎得多。我在下一个话题中解释了其中的一些原因。

<u>**新的通用顶级域名**</u>

当然，没有任何固有的理由必须将通用域名限制在最初创建的几个域名上。多年来，人们对新的通用顶级域名提出了许多建议，这些建议将扩大可能的二级域名的数量，并为不同的组织类型提供更好的分类，也就是说，使通用顶级域名 "不那么通用"。起初，采用这些新名称有一些阻力，特别是因为对应该创建什么新的顶级域名有许多不同的想法。正如我之前所说，创建顶级域名必须谨慎行事，以确保名称的层次结构是合理的。

IANA听取了很多人的意见，并遵循一个复杂的程序--我宁愿不在这里J，来决定应该制作哪些新的顶级域名。在2001年和2002年，批准了几个新的顶级域名的创建，并就管理这些域名的机构作出了决定。

在过去几年中批准的新顶级域名中，据我所知，获得广泛欢迎的数量为零。人类是惯性的动物，大多数人仍然习惯于以.COM、.NET或.ORG结尾的名称。随着时间的推移，这可能会改变，但可能需要几年时间。

顺便提一下，有一些人实际上认为增加新的通用顶级域名是一个坏主意，因为它使组织可能更难找到（由于一个名字可能以各种不同的顶级域名结尾）。然而，这一点值得商榷，特别是由于现有顶级域名的地址空间已经耗尽，意味着许多公司无论如何都不得不选择不直观的域名。

<u>**组织（通用）顶级域名的摘要**</u>

表165显示了目前所有的通用顶级域名，并描述了它们的使用方式，还列出了目前管理每个顶级域名的中央机构。原有的顶级域名用斜体字标出（我将.INT列为原有的顶级域名，因为它是在本世纪初 "新 "的顶级域名之前很久才创建的）。图239以图形的形式显示了15个通用顶级域名的情况。


​                                                           <u>**表165: 互联网DNS组织（通用）顶级域名**</u>

| **Generic TLD** | **Abbreviation For**                               | **Authority**                                                | **Current Use / Description**                                |
| --------------- | -------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **.AERO**       | Aerospace航天                                      | 国际电信航空公司 (SITA)                                      | Members of the aerospace industry, such as airlines and airports. (Yes, that ***is\*** French!)航空航天业的成员，例如航空公司和机场。 （是的，那是法语！） |
| ***.ARPA\***    | Address and Routing Parameter Area地址和路由参数区 | 互联网号码分配机构 (IANA) / 互联网名称与数字地址分配机构 (ICANN) | 最初定义为从旧主机表系统迁移的临时域，“ARPA”当然最初代表高级研究计划署，互联网前身的创建者。今天，.ARPA 域用于内部互联网管理；我相信左边的缩写是“制造”以适应字母“ARPA”。 J 此域最著名的用途是反向 DNS 查找。 |
| **.BIZ**        | Business商业                                       | NeuLevel, Inc.                                               | 企业。旨在作为 .COM 的竞争对手。                             |
| ***.COM\***     | Commercial Organizations商业组织                   | VeriSign Global Registry Services威瑞信全球注册服务          | .COM 最初旨在为公司和其他商业利益服务，但也广泛用于其他用途，包括小型企业甚至喜欢 .COM 域名受欢迎程度的个人。 |
| **.COOP**       | Cooperative Associations合作协会                   | Dot Cooperation LLC                                          | Cooperative associations.合作协会。                          |
| ***.EDU\***     | Education教育                                      | Educause教育事业                                             | 最初适用于所有类型的教育机构，现在仅用于美国认可的授予学位的高等教育机构。公立学校等其他教育机构通常使用国家/地区代码 TLD。 |
| ***.GOV\***     | Government政府                                     | US General Services Administration美国总务署                 | Reserved for the United States federal government.           |
| **.INFO**       | Information                                        | Afilias Limited   Afilias 有限公司                           | 一个非常通用的 TLD，专为各种信息资源而设计。它不受限制，因为任何人都可以在 .INFO 中注册任何类型的组织。也定位为 .COM 的替代品。 |
| ***.INT\***     | International                                      | IANA .int 域名注册                                           | 仅用于国际条约建立的大型组织。                               |
| ***.MIL\***     | Military军队                                       | 美国国防部网络信息中心                                       | 军队                                                         |
| **.MUSEUM**     | Museum博物馆                                       | Museum Domain Management Association博物馆领域管理协会       | 猜一下。J                                                    |
| **.NAME**       | Names                                              | Global Name Registry全球名称注册                             | 在最初的通用层次结构中，没有留出供个人为自己注册姓名的地方，因此人们会改为创建像“jonesfamily.org”这样的域。这并不理想，因此.NAME 被创建为个人和家庭为其姓名注册域名的地方。 .NAME 还与国家代码 TLD 竞争。 |
| ***.NET\***     | Network                                            | VeriSign Global Registry Services威瑞信全球注册服务          | 该 TLD 应该仅用于 Internet 服务提供商和其他与 Internet 或网络密切合作的组织。然而，由于 .COM 和 .ORG 中的名称空间已用尽，许多 .NET 域已注册到其他组织。 |
| ***.ORG\***     | Organizations                                      | Public Interest Registry公共利益登记处                       | .ORG 最初是为不适合其他通用 TLD 的组织而设计的，但很快就与专业和非营利组织建立了联系。但是，可以让营利性公司使用 .ORG 名称。 |
| **.PRO**        | Professional                                       | RegistryPro                                                  | 保留给有资质的专业人士，如律师和医生。                       |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\dnsgentld.png)



​                                                             **图239: 互联网DNS组织（通用）顶级域名（TLDs）**

目前为互联网定义的通用顶级域名有15个。它们在这里按字母顺序排列，原来的顶级域名显示为蓝色，2001/2002年增加的新域名为绿色。

**关键概念。**互联网DNS名称空间的两种划分方式之一是使用一套通用顶级域名。这些顶级域名旨在为所有公司和组织提供一个根据其组织类型命名的地方。最初有六个这样的域名，但现在已经扩大到了十五个。



###### 1.2.3.3-3 DNS地缘政治（国家代码）顶级域名和权威机构（部分：1 2 3 4 )

从理论上讲，通用顶级域（TLD）足以满足世界上所有个人、公司和团体的需求。这一点尤其正确，因为根据定义，.ORG是一个 "全能"，可以包括任何人或任何东西。然而，早在DNS成立之初，其创建者就认识到，通用顶级域名可能无法满足世界各地所有人的需求。这有几个原因，其中最主要的是。

- 通用域名的美国中心主义。我没有批评的意思（我是美国公民，爱我的国家！）但是，美国的组织和公司在通用顶级域名中占主导地位是不争的事实。这并不奇怪，因为互联网最早是在美国发展起来的，但这对某些团体来说仍然是一个问题。例如，如果美国军方控制了.MIL域名，那么，英国军方在名称空间中的地位又如何呢？

- 语言。大多数通用域名都是由主要以英语开展业务的组织填充的。然而，世界上有数百种语言，如果这些语言的使用者能够更容易地找到他们能够理解的资源，就会更容易。

- 地方控制。世界各地的国家很少在很多方面达成一致，他们在本国的组织应该如何安排他们的互联网存在方面当然有分歧。许多人都希望允许各国有能力建立供自己使用的名称空间子集。

<u>**地缘政治（国家代码）顶级域名**</u>

由于这些原因和其他原因，互联网的名称空间设置了一组与通用名称平行的国家代码顶级域名，有时也被称为ccTLDs。我称这些为地缘政治顶级域名，因为它们是以世界的地缘政治划分为基础的（类似于我在概述DNS名称空间时使用的例子）。在这种层次结构中，世界上每个国家都被分配了一个特定的双字母代码作为顶级域名，并由一个特定的机构负责管理该域名。例如，英国的国家顶级域名是".UK"，加拿大的是".CA"，日本的是".JP"。顺便说一下，这些代码在当地语言中往往比英语更有意义；德国的代码是".DE"，瑞士的是".CH"。

<u>**指定国家和国家代码的字母**</u>
当我说国家很少在任何事情上达成一致时，我并不是在开玩笑--事实上，他们甚至不能就什么是国家达成一致！真正的枪战已经打响。真正的枪战是为了争夺某块领土是独立的还是另一个国家的一部分，更不用说口水战了，而DNS的创建者不想参与这种争论。正如IANA网站所说。

"IANA不负责决定什么是和什么不是一个国家，也不负责决定什么编码字母适合某个国家。"
为了保持中立，IANA的国家代码直接取自国际标准化组织（ISO）在ISO标准3166-1中维护的标准国家缩写。当一个国家被国际标准化组织承认，并在这个名单上分配了一个代码，IANA就将其创建为一个顶级域名。目前，有超过200个不同的地缘政治顶级域名。不，我不会把它们放在这里的表格中，我必须在这里的某个地方划出界线! J

**在互联网上**: 你可以在以下网站上找到IANA国家代码顶级域名的当前列表：http://www.iana.org/cctld/cctld-whois.htm

<u>**国家代码顶级域名的权力**</u>

每个国家都有权以其选择的任何内部子结构建立其顶级域名；同样，这也是等级结构的权力。一些国家在较低的层次上执行进一步的地理子结构。例如，美国的.US域名最初是这样设置的：所有二级域名都是两个字母的州的缩写（这一点后来被改变了）。其他国家实际上可以在其国家代码内使用组织子域；例如，英国有.CO.UK，用于本国的公司（像.COM，但只用于英国；他们省去了 "M"），而.COM.AU则用于澳大利亚的公司。其他国家可能根本没有任何特定的子结构，特别是如果它们是小国。

**关键概念。**由于通用顶级域名的限制，创建了一套国家代码顶级域名。这种地缘政治等级制度允许地球上的每个国家根据自己的要求建立自己的名称系统，并以自己认为合适的方式进行管理。IANA根据ISO的官方决定来确定什么是国家。

<u>**国家代码域名的租赁/销售**</u>
有趣的是，一些拥有可识别代码的非常小的国家，特别是对讲英语的人来说，已经将他们的代码用于非常有创意的目的，包括将名称空间出售或出租给有进取心的公司。一个很好的例子是.TV域名，它在技术上属于岛国图瓦卢。当然，对大多数人来说，"TV "的含义完全不同。一些人认为，以 "TV "结尾的域名可能在英语世界很受欢迎，因此他们成立了一家名为".TV公司 "的公司，并与图瓦卢政府就使用.TV域名进行了谈判。今天，这个顶级域名的主管部门实际上是这家公司，总部设在加利福尼亚州 在.CC、.NU、.TO和其他顶级域名中也可以找到类似的安排。

这很好地提醒我们，名称空间是逻辑的，而不是物理的。显然，许多拥有".TV "名称的计算机实际上并不位于南太平洋的一个偏远岛屿上。同样，如果一个网站以".CA "结尾，例如，它可能代表一个加拿大组织，但这并不一定意味着该网站本身实际上是在加拿大托管的。

<u>**地缘政治顶级域名的弊端**</u>

地缘政治域名在某些用途上非常受欢迎；首先，国家政府和其他 "官方 "机构喜欢使用它们，原因显而易见。输入 "www.gov.XX "或 "www.government.XX"，其中 "XX "是一个国家代码，可能会把你带到大多数国家的国家政府网站。一些公司和组织使用国家代码顶级域名，因为它们允许他们选择一个已经在通用层次结构中被占用的名称，或者仅仅是为了表达国家的自豪感。

然而，对许多其他公司和组织来说，通用顶级域名比国家代码更受欢迎。我相信这有几个原因，但我认为最重要的原因是，使用通用域名更容易找到组织。

这里有一个很好的例子说明我的意思。在我居住的小镇附近，一家名为阿尔迪的新杂货店最近开业。我喜欢这家店，想更多地了解他们，所以我启动了我的网络浏览器，寻找他们的网站。是的，我可以把它输入搜索引擎，但像大多数人一样，我很懒。在我的浏览器中输入 "www.aldi.com "要容易得多，看，跳出来的是阿尔迪国际公司的网站。

现在，阿尔迪公司的总部实际上在德国，他们也有一个网站，网址是 "www.aldi.de"。但我不知道他们最初来自哪里。我通过访问 "www.aldi.com "很容易找到他们，因为我不需要知道他们的实际位置，而且我知道大多数大公司都有一个".COM "域名。当然，"可以找到 "是非常重要的，特别是对于试图做生意的商业组织。

另一个很好的例子是美国，如上所述，美国除了在通用顶级域名中占主导地位外，还有自己的国家代码.US。负责这个域名的当局选择使其遵循严格的地理等级制度，因此每个域名都必须是 "organization.city.statecode.US "的形式。因此，要使用这部分名称空间，波士顿的一家公司必须在".boston.ma.us "域内。

这是非常整洁和合乎逻辑的，但它使名字比通用的等价物更长、更难猜。假设你想获得有关金属巨头美国铝业公司的信息。如果你是业内人士，你可能知道他们位于匹兹堡，但如果不是，哪个更容易找到，"www.alcoa.pittsburgh.pa.us"，还是 "www.alcoa.com"？这里有人知道如何拼写阿尔布开克吗？J

正是由于这个原因，.US域名在社会的某些部分取得了成功，但在其他部分却没有，特别是商业实体（公司）。然而，严格的等级制度确实有一些真正的优势，如避免名称空间冲突。由于不被接受，.US当局最终放弃了严格的地理等级制度。

严格的等级制度带来的好处和坏处，好处是清晰的结构划分，坏处就是没人愿意用

###### 1.2.3.3-4 DNS二级和低级域名，注册授权和公共注册 (部分: 1 2 )

IANA负责决定互联网名称空间中存在哪些顶级域名（TLD），因此，他们最终对互联网中的所有名称负责。然而，权威等级制度的全部意义在于，IANA不对整个名称空间负责。因此，虽然IANA保持着对某些顶级域名的控制，如.INT和.ARPA，但管理其他域名的控制权被委托给每个顶级域名的二级机构。

正如IANA可以选择如何将权力下放给 "根 "域名的子域一样，负责每个顶级域名的组织也可以就如何在该顶级域名下创建二级域名做出同样的决定。在许多顶级域名中，尤其是通用域名，二级域名直接分配给个人或组织。

例如，一家名为XYZ工业的公司可能想获得域名 "xyzindustries.com"。在其他顶级域名中，二级域名是按照特定的结构设置的，比如.US域名中使用的州代码。在那里，你需要往下走更多的级别，但最终你会再次到达公司和人们注册自己的域名的地步；在.US域名中，XYZ工业可能想注册 "xyz.phoenix.az.us"，例如，如果他们的总部在凤凰城。

<u>**集中的公共注册**</u>
在授权负责部分名称空间的机构与希望在其中获得名称的 "普通 "人和团体之间的这个过渡点很重要。必须建立一个公共注册程序，以使这种名称分配以一致和可管理的方式发生。在最初创建通用顶级域名和国家代码顶级域名时，这并不难做到。当时的互联网规模很小，由负责每个顶级域名的机构在该顶级域名内进行注册是有意义的。这就确保了在一个顶级域名内没有重复的名称，而且麻烦也最少。

对于非常重要的通用顶级域名，如.COM、.NET和.ORG，负责注册的机构是互联网网络信息中心（InterNIC）。InterNIC是作为美国政府管理的一项服务而设立的，美国政府后来将管理该中心的合同授予网络解决方案公司（NSI）。NSI最终被威瑞信公司收购，后来又将其分拆为一个独立的企业。(在网络世界里，事情变化很快！）。

多年来，NSI一手包办了.COM、.NET和.ORG顶级域名的所有注册工作。然而，最初的通用顶级域名的普及导致了20世纪90年代这些领域对名称注册的需求激增。由一家公司负责注册，导致这成为互联网域名系统的另一个瓶颈。也有许多人不喜欢由单一的 "垄断 "公司负责注册所带来的缺乏责任和竞争；InterNIC可以自己定价，最初每个域名每年收费35美元，后来是每年50美元。

<u>**放松对公共注册的管制**</u>

20世纪90年代末，名称注册的责任被赋予了互联网名称与数字地址分配机构（ICANN）。注册过程被 "放松管制"，借用一个术语，指的是取消发电等行业的垄断。截至1999年12月，仍有一个机构全面负责每个顶级域名，包括.COM、.NET和.ORG。今天，Network Solutions仍然是管理.COM和.NET的机构。然而，他们并不是在这些顶级域名中注册名称的唯一机构。他们还将注册权下放给其他许多公司，称为经认可的注册商。任何注册商都可以在他们被认可的顶级域名中注册名称。

自然，当你有多家公司在一个顶级域名中注册名称时，与只有一家公司相比，协调就变得更加令人担忧。我们遵循一套特殊的技术和行政程序，以确保不会出现两个注册商同时抢注一个名称的问题。该系统运行良好，那些希望使用存在竞争的顶级域名的人现在可以从各种注册公司中选择。这方面最明显的结果也是最可预见的结果：在放松管制的通用顶级域名中注册域名的费用通常比InterNIC原来收取的费用低得多。

一旦一个公司、个人或组织拥有一个注册的低级域名，他/她/它就成为该域名的权威。然后，该域名的使用就变成了私人的，但根据该域名的使用方式，可能需要进一步的公共名称注册。更多信息请参见私人注册专题。



###### 1.2.3.3-5 DNS公共注册争端（冲突、抢注、"欺骗性命名 "等）和争端解决（部分：1 2 3 4）

互联网一开始是研究网络的媒介，后来演变为科学家之间相互联系的系统，最后成为几乎所有人都在使用的全球通信工具。作为这一演变的一部分，互联网也成为世界上如何开展业务的一个非常重要的部分。20世纪90年代初，金钱开始真正进入互联网领域，短短几年后，它对互联网的影响是如此之大，以至于20世纪90年代末股票市场增长到令人眩晕的高度，现在通常被称为 "互联网泡沫"。

<u>**公共注册纠纷**</u>
不幸的是，互联网对商业利益日益增长的重要性一头撞上了互联网技术的非商业性原始设计，这一点在域名系统中表现得最为明显。由于只有几个通用的顶级域名，由于顶级域名中的每一个名字都必须是独一无二的，由于人类通常是对抗性的动物，在谁应该能够使用什么名字以及为什么要使用的问题上，没过多久就发生了争论。当然，从那里开始，没过多久就爆发了诉讼和其他不愉快的事情。

与域名的公开注册相关的重大问题多得令人吃惊。

<u>**企业名称冲突**</u>
.COM域名是为公司服务的，但许多公司都有相同的名字。ACME家具公司、ACME餐馆供应公司和ACME鞋业公司，可能都想拥有 "acme.com "域名。但在.COM中只能有一个这样的域名。(这些都是虚构的例子；"acme.com "实际上是由一个叫做Acme Labs的组织拥有的）。

<u>**企业/个人/小型企业名称冲突**</u>
有许多公司的名字与个人的名字相似，甚至相同，这导致了潜在的冲突。例如，假设你的名字是Wendy，你拥有一家名为 "Wendy's Fabrics "的小型布料店。但你很懂互联网，在1993年一听说互联网，就决定要注册 "wendys.com"。然后这个大的汉堡包连锁店出现了，并对此有意见......J

据我所知，温迪公司没有出现这样的问题，但实际上有一个广为流传的案例，表明最近大多数公司在域名命名方面是多么的 "不知所云"。1994年，《连线》杂志的一位作者惊奇地发现，"mcdonalds.com "域名没有被注册！这说明，在域名命名方面，大多数公司都是 "不务正业"。为了说明注册过程是多么的不规范，他自己注册了这个域名，结果引起了一阵骚动。金拱门公司最终以友好的方式从他那里获得了这个域名，他放弃了这个名字，而他们则向慈善机构进行了捐赠。

<u>**"公司战争"**</u>

有时会看到一种特别丑陋的冲突，即公司故意通过注册与自己公司无关的名称来抢夺对方的业务。一个例子是，如果汉堡王试图注册 "mcdonalds.com "并使用它来宣传汉堡王的产品。(我想补充的是，他们并没有这样做，所以请不要起诉我！J)

另一个例子是当公司试图使用备用顶级域名时，例如注册 "burgerking.org "来迷惑试图找到 "burgerking.com "的人。事实上，许多公司已经采取了在许多不同的顶级域名中注册其名称的措施，以防止这类事情的发生。

**"抢注"（Cybersquatting**
一些雄心勃勃的人（选择一个好词），很早就认识到某些名字的潜在价值，注册了大量的名字，希望能将它们转卖。许多人谴责这是一种剥削行为，并创造了抢注一词来指代这种类型的活动。不幸的是，这种方式赚了很多钱，有许多域名至今不能使用，因为它们被那些永远不会使用它们的人或个人无限期地 "保留 "了。

<u>**欺骗性的命名做法**</u>
另一种有点新陈代谢的创造力是由那些试图利用我们中的一些人不善于拼写的人所表现的。例如，如果你是一家名为Superb Transceivers Inc.的大公司的竞争对手，该公司注册了 "superbtransceivers.com"，你可能会注册 "superbtranscievers.com"，并将那里的流量重定向到你自己的域名。另一个例子是利用了 "O"（字母）和 "0"（数字）之间的常见混淆。例如，一家软件公司曾经注册了 "micros0ft.com"，这让华盛顿州雷德蒙市的软件巨头感到非常恼火。

<u>**争端解决方法**</u>

那么，我们该如何解决这些情况呢？俗话说，要么用简单的方法，要么用困难的方法......

<u>**域名共享**</u>
有时，对立的双方会就一个富有成效的解决方案达成一致。一个特别有建设性的想法是同意共享域名。例如，我在上面的例子中提到的三家ACME公司可以各自创建自己的更具体的域名，如 "acmefurniture.com"、"acmerestaurantsupply.com "和 "acmefootwear.com"。然后，他们可能会同意将 "www.acme.com "注册给任何人，由一家公司注册，不用于任何用途。

更妙的是，他们可以设置一个简单的网页，说这个域名是共享的，并有一个指向上述三个网站的链接。我以前见过这种情况，但很少。不幸的是，似乎小学生比大多数企业高管更了解共享的概念。

<u>**域名购买**</u>
另一个选择是购买。如果一个大公司想要一个已经被个人或小企业注册的域名，他们往往会直接购买，因为这是最容易做到的。在互联网狂热的高峰期，有的域名卖到了几百万美元--仅仅是为了使用这个名字的权利！在这种情况下，很多抢注者都会选择购买。同样，许多抢注者和其他投机者通过这种方式发了财。

<u>**诉讼**</u>
通常情况下，战斗人员不善言辞，通常会发生：威胁、恐吓、法律诉讼，等等。有时，一封律师信就足以解决问题，特别是当一些拥有网站的可怜人被一家大公司威胁要采取法律行动时--这种情况已经发生过很多次。

然而，持不同意见的一方往往坚持己见，尤其是当两家公司互相争吵而他们的律师拒绝让步时。通常，这件事最终会在法庭上结束，并最终以一种或另一种方式解决。这涉及到我完全没有资格谈论的法律问题。通常，公司会使用商标侵权索赔来质疑先前的域名注册。

<u>**统一域名争议解决政策**</u>

诉讼既昂贵又耗时，因此人们希望也有一些其他机制来解决这些冲突。由于每个顶级域名的管理机构控制着其内部发生的事情，它也有权制定自己的政策来处理这类问题。对于通用顶级域名，最初的注册机构InterNIC有一项争议解决政策，允许有投诉的人对域名注册提出质疑，如果他们对该名称有商标权益的话。该政策因多种原因而引起争议，其中最重要的原因是它导致一些域名被成功质疑，即使没有商标侵权的证据。

目前负责通用顶级域名的机构IANA/ICANN在1999年制定了一项新的统一域名争议解决政策（UDRP），以更好地处理域名冲突。该政策规定了一个程序，拥有有效商标的公司可以对一个域名提出质疑，如果该域名侵犯了该商标，与该商标混淆性地相似，或者该名称是由其他人恶意注册的。同时，它还列出了原注册人可以证明注册有效并应予以保留的方法。这个新系统消除了上述许多实际问题，如欺骗性命名、"公司战争 "和抢注，同时又不自动允许第二人关闭合法域名。

<u>**争议作为新通用顶级域名的动机**</u>
顺便说一句，正是所有这些无稽之谈在一定程度上导致了对新通用顶级域名的喧嚣。为了公平起见，我还想提一下，即使像过去严格分层的.US这样更复杂的顶级域名不是很受欢迎，但它们比通用域名有巨大优势。由于那里的所有注册都是地理上的，所以冲突要少得多，因为争端要求两个组织有相同的名字，而且还在同一个州和镇。

例如，你仍然可以让芝加哥的三家 "Joe's Pizza Parlor "争吵，但你不可能看到大公司在.US的垫子上。例如，ACME家具公司可能使用 "acme.seattle.wa.us"，ACME餐馆供应公司可能使用 "acme.mendocino.ca.us"，ACME鞋业公司可能使用 "acme.anchorage.ak.us"。



###### 1.2.3.3-6 **DNS 名称空间管理层次结构分区：DNS 权限区域** (部分: 1 2 3 )

我在本主题的前面解释过，DNS名称空间是按层次排列的，也有一个与该层次名称结构相关的授权层次。然而，这两个层次结构并不完全相同。原因是，如果它们是一样的，这将意味着我们需要在树的每一级为每个域名建立一个单独的权威机构，而这是我们非常不可能希望在结构中到处都有的。

在DNS树的最顶层，我们可能想在结构的每一层指定一个单独的权威机构，这似乎是合理的。考虑一下地缘政治名称的层次结构；IANA/ICANN管理 "根 "域名，但每个国家代码顶级域名都由不同的国家机构管理

<u>**权力层级划分的必要性**</u>
然而，当你进入结构的较低层次时，让每个层次对应于一个单独的机构往往是不方便的，甚至是完全不可能的。举个例子，假设你负责Googleplex大学的IT部门，它为 "googleplex.edu "域名运行自己的DNS服务器。假设这所大学只有两所学校，教授美术和计算机科学。又假设计算机的名称空间被划分为三个子域。"finearts.googleplex.edu"，"compsci.googleplex.edu"，和 "admin.googleplex.edu"（用于中央管理职能，包括IT部门本身）。

最有可能的是，你不希望或不需要美术系运行自己的DNS服务器，他们可能也不希望这样。管理机器也可能是这样。然而，计算机科学系有可能想运行自己的DNS服务器，因为他们可能比其他部门有更多的计算机，而且他们可能把运行DNS服务器作为他们课程的一部分。在这种情况下，你可能希望你自己，即 "googleplex.edu "的管理员，保持对 "finearts.googleplex.edu "和 "admin.googleplex.edu "子域以及其中所有内容的权限，而将 "compsci.googleplex.edu "的权限下放给计算机科学系中被指定负责该任务的人。

<u>**DNS的权力区**</u>

DNS是专门设计来允许在名称层次和授权结构之间创建这些划分。完整的DNS名称结构是通过在相邻的节点之间进行切割（标准称之为切割）来创建结构中的连续节点组来划分的。每个组被称为一个授权区，或更常见的，只是一个区。每个区通常由区中最高级别节点的域名来识别，也就是最接近根的那个节点。根据定义，DNS中的区是不重叠的--每个域或子域都正好在一个区内。

<u>**将名称空间划分为区的方法**</u>
可以用任意的方式将名称空间划分为区。在一个极端，我们可以在每个节点之间放置一个切口，从而将整个名称空间划分为每个域（和子域等）是一个独立的区。如果我们这样做，名称层次和授权层次对整个DNS树来说确实是一样的。在规模的另一端，我们可以不使用任何切割，定义一个包含整个DNS结构的单一区域。这将意味着根是整个树的权威。

当然，在实践中，这两种方法都不是特别有用，因为这两种方法都没有真正反映现实世界中DNS管理的工作方式。相反，我们通常根据名称空间不同部分的需要，在不同的地方划分名称结构。在很多情况下，我们可能想创建一个子域，负责自己的DNS服务器操作；也有一些情况下，我们可能不想这样做。名称层次中的 "切分 "的意义在于，进行这样的切分实质上代表了切分下面的节点对切分上面的节点的DNS独立性的声明。

回到我们的例子，如果googleplex.edu负责它自己的DNS服务器，那么在 "googleplex.edu "和下一级的.EDU之间的名称空间中会有一个 "切口"。这意味着.EDU的DNS服务器不再负责 "googleplex.edu "域名的DNS；相反，大学本身或他们雇用的第三方必须为其提供DNS。在这种情况下，我们假设Googleplex大学自己运行他们自己的DNS。在不做任何其他削减的情况下，"googleplex.edu "域名将是一个单一的区域，包含该名称下面的所有内容，包括 "finearts.googleplex.edu "和 "compsci.googleplex.edu"。

然而，在我们的例子中，我们将在 "googleplex.edu "和 "compsci.googleplex.edu "之间做另一个 "切割"。这实际上是解放了 "compsci.googleplex.edu"，允许其管理员负责他们自己的DNS服务器。这样一来，我们就有了两个不同的区域：一个包括 "googleplex.edu"、"finearts.googleplex.edu "和 "admin.googleplex.edu"（以及它们下面的一切），另一个是 "compsci.googleplex.edu"（以及它下面的一切）。这在图240中有所说明。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\dnszones.png)


​                                                                                           **图240: DNS授权区**

这个例子显示了如何在DNS名称树的节点之间进行切割，以创建一个任意层次的名称授权。在这个例子中，我显示了 "googleplex.edu "的DNS树分支，每个区域用不同的背景颜色表示。IANA/ICANN负责根域（黄色），一个名为Educause的独立机构负责".EDU"（绿色）。蓝色区域覆盖了 "googleplex.edu "的大部分，只是在 "googleplex "和 "compsci "之间做了一个切割，为 "compsci.googleplex.edu "建立了一个独立的授权区域，显示为紫色。



**关键概念。**DNS名称注册的层次结构被划分为多个区域，称为授权区。每个区域代表一个独立管理的区域，由DNS名称树的一个连续的部分组成。

**区域对名称解析的影响：权威服务器**

区域的概念对于理解 DNS 名称服务器的工作方式以及名称解析的执行方式至关重要。有关区域中子域和单个设备的所有信息都使用存储在 DNS 名称服务器上的一组资源记录来表示。通常，此名称服务器与区域中最高级别的域名相关联。包含区域权威信息的名称服务器被认为是该区域的权威名称服务器。区域的权威服务器是维护区域官方信息的服务器，也是最终负责提供区域名称解析信息的服务器。我们将在有关 DNS 服务器和名称解析的部分中看到更多相关信息。

每个 DNS 区域都有一组权威服务器，通常是一对称为主（或主）和辅助（或从）服务器。但是，单个 DNS 名称服务器也可能对多个区域具有权威性。如上所述，域的实际所有者并不总是需要为其提供 DNS 服务。通常，尤其是对于小型企业或个人拥有的域，DNS 服务由第三方提供，通常是 Internet 服务提供商。

例如，我从 1997 年就将“pcguide.com”注册为域，但我的长期网络托管服务提供商 pair Networks 从一开始就为我提供 DNS 服务。这意味着“pair.com”层次结构中的配对 DNS 服务器负责“pcguide.com”。他们还为他们的客户负责许多其他领域。



###### 1.2.3.3-7 DNS私有名称注册 (部分: 1 2 )

我们现在已经看到了 DNS 名称空间的层次结构，以及管理它的权限结构。名称注册从名称层次结构根中的通用和国家代码顶级域 (TLD) 开始，然后到 TLD 内的二级域，然后是低于这些域的较低级别的子域。随着我们在名称树上的进展，我们从最一般的公共机构（IANA/ICANN，运行所有 DNS），通过高级 TLD 机构，最终下降到单个组织、公司和个人的级别.

<u>**私有域名所有权**</u>
公共权力和私人权力之间的这种“分界线”出现在名称结构的许多不同地方。无论它发生在哪里，在这条线之下，对域的责任就变成了注册它的组织的责任。它可以进一步细分名称空间，将其中的一部分授予其他组织，如果他们愿意，甚至可以转售。或者，他们可能决定使用名称空间来创建纯粹的内部结构。我将此称为私有名称注册，与我们在本节前面讨论的公共名称注册形成对比。

例如，如果一家名为 XYZ Industries 的公司注册了“xyzindustries.com”，那么他们不仅会成为该域名的所有者，而且会成为他们可能选择创建的任何子域结构或其中的命名项目的所有者。这当然是权力下放和等级结构的美丽和力量。然而，该公司必须做出一个重要的决定：他们必须选择是要创建作为全球 DNS 名称结构一部分的名称，还是要在该结构中纯粹私下使用名称。

<u>**使用可公开访问的私有名称**</u>
如果公司希望其域中的名称成为全球 DNS 名称结构的一部分，则需要执行必要的工作来正确设置和管理这些名称，以便它们适合域名系统。当然，最常见的例子是创建一个公共万维网服务器。大多数公司将此类服务器命名为以“www”开头，因此 XYZ Industries 可能希望为其 WWW 服务器地址命名为“www.xyzindustries.com”。

显然，他们希望并且需要 Internet 上的任何人都能够找到该服务器。因此，即使 XYZ 拥有“xyzindustries.com”域的私有控制权，因此拥有“www.xyzindustries.com”这个名称，他们也必须遵循适当的程序来确保为其“www”子域设置 DNS 资源记录所以互联网上的每个人都可以找到它。如果他们运行自己的 DNS 服务器，他们可以自己执行此操作，或者可能让 ISP 或其他第三方为他们执行此操作，如上一主题中所述。

<u>**使用私有名称供内部使用**</u>

另一种方法是创建仅在组织内使用的“纯私有”名称。例如，即使 XYZ 想要一个公共 Web 服务器，它也可能希望命名许多其他只能在公司内部访问的机器。在这种情况下，他们不需要设置这些机器，因此它们是公开可识别的。他们可以创建私有机器名称并在自己的网络中进行内部管理。

完成此操作的一种常见方法是使用较旧的主机表名称系统。这个系统现在对于大型互联网来说已经过时了，但由于它的简单性，在较小的公司中仍然经常使用。名称通过添加到组织内每台计算机上的主机表来“注册”，并在主机上的操作系统在使用标准 DNS 解析方法之前检查此文件时“解析”。在这种情况下，主机表补充了 DNS（它实际上并不是 DNS 的一部分）。这两个系统是互补的，可以一起工作，正如我在描述主机表的主题末尾所解释的那样。

**关键概念：**一旦一个组织注册了一个特定的域名，它就成为该名称的所有者，并可以决定是否以及如何在该域内创建子结构。如果它希望域中的对象可以在公共 Internet 上访问，则它必须构建其域以符合 Internet DNS 标准。或者，它可以使用它喜欢的任何结构和规则创建一个纯私有域。

<u>**在未连接到 Internet 的网络上使用私有名称**</u>
如果您正在运行一个根本不连接到 Internet 的“纯私有”网络，您实际上可以设置您自己的完全私有的名称层次结构并自己运行 DNS。在这种情况下，您将成为负责 DNS 根目录的“老板”，并且可以使用您喜欢的任何命名系统。这有时被认为是有吸引力的，因为人们可以在小型网络上使用非常简单的机器名称，而无需执行任何公共注册，甚至无需使用与全局层次结构相对应的名称。 XYZ Industries 的计算机不被命名为“accounting.xyzindustries.com”，在内部它可以被命名为“accounting”。您也可以在访问资源时将它们与真实的 DNS 名称混合，这样 Joe 的机器就可以称为“joe”，而 UPS 的网站当然仍然是“www.ups.com”。

这种私有名称和公共名称混合的最常见示例是计算机环回地址的私有本地名称的定义。大多数 Windows 和 UNIX 机器将名称“localhost”定义为地址 127.0.0.1，这在任何 TCP/IP 机器上都表示“这台计算机”。



###### 1.2.3.4 DNS名称服务器和名称解析

前面两节描述了域名系统的分层名称空间，以及管理它和负责名称注册的机构。名称空间和名称注册这两个要素是名称系统中较为“无形”的部分，它们定义了名称系统的创建和管理方式。名称系统的“有形”方面是启用其主要“活动功能”的一组软件和硬件：名称解析。这是允许名称系统用易于使用的文本名称替换繁琐的数字地址的特定任务。

名称解析是 DNS 中最受关注的部分，因为它是大多数人每天使用的系统部分。 DNS 使用功能强大的客户端/服务器名称解析方法，该方法利用名称信息的分布式数据库。 DNS 名称解析过程最常用的实现当然是用于 Internet 本身的那个，它每天解析数十亿个名称请求。

在本节中，我将详细解释 DNS 名称解析功能的概念和操作。本节分为三个小节。前两个涵盖了协同工作以实现 DNS 客户端/服务器名称解析功能的两个关键软件元素中的每一个。第一部分描述了 DNS 名称服务器，以及它们在调用解析时如何表示、管理和提供数据。第二部分描述了 DNS 客户端（称为解析器）、它们如何启动解析以及解析过程中涉及的步骤。在这些之后，我有第三个小节，通过查看这些单元之间的消息交换，并描述消息、资源记录和 DNS 主文件的格式，将有关名称服务器和解析器的信息联系在一起。

**背景信息：**本节中的材料假定您已经熟悉前两节中的主题，并在适当的地方引用了这些节。如果您还没有阅读有关 DNS 名称空间和名称注册的部分，您至少应该回顾一下 DNS 组件和一般功能的概述。

**相关信息：**管理员可以使用一组称为 nslookup、host 和 dig 的相关 TCP/IP 实用程序来查询 DNS 名称服务器的信息。它们可用于多种用途，包括手动确定主机的 IP 地址、检查为 DNS 名称维护的特定资源记录以及验证名称解析功能。请参阅有关 TCP/IP 管理实用程序的部分中讨论这些程序的主题。



###### 1.2.3.4-1 DNS 名称服务器概念和操作

在组合形成域名系统的所有组件和功能元素中，DNS 名称服务器可以说是最重要的。这些服务器可能是专用设备，也可能是在同时执行其他任务的机器上运行的软件进程，它们是 DNS 的主力。他们存储和管理有关域的信息，并响应客户的解析请求——在某些情况下，每天响应数百万次。了解他们如何执行这项最基本的任务以及他们还负责的许多支持工作对于从整体上理解 DNS 至关重要。

在本节中，我将描述与 DNS 名称服务器相关的概念，并解释它们的运作方式。我首先概述 DNS 名称服务器功能和一般操作。我描述了 DNS 名称服务器数据存储在资源记录中的方式以及类的作用。我讨论了名称服务器在 DNS 中的不同角色，并解释了最重要的根名称服务器。我讨论了如何管理 DNS 区域、域管理员和区域传输的概念，以及如何使用缓存和负载平衡来提高 DNS 的效率。最后，我简要概述了基本 DNS 服务器操作的两个增强功能，使用新的new *Notify*通知和更新Update 消息类型，以及增量区域传输 incremental zone transfers。

**相关信息：**本节中的信息应被视为对以下有关 DNS 解析器的部分中的信息的补充。




###### 1.2.3.4-1-1 DNS 名称服务器功能、名称服务器体系结构和一般操作（部分：1 2 3）

名称系统的三大功能是创建名称空间、执行名称注册和提供名称解析服务。我们在前面关于域名系统的这个较大的部分中已经看到，DNS 为其名称空间使用分层树结构，并且还为名称授权和注册使用分层树。我敢肯定，鉴于此，当我告诉您名称解析也以层次结构的概念为导向时，您将不得不努力抑制自己的惊讶。

主要负责执行启用名称解析所需功能的设备是名称服务器。它们排列在与名称系统的权限结构密切相关的层次结构中。正如权限结构补充了名称结构但并不完全相同，名称服务器体系结构补充了权限结构和名称结构，但其实际组成可能与两者不同。

<u>**DNS 名称服务器体系结构和分布式名称数据库的存储**</u>
在大型 DNS 实施中，有关域的信息并未集中在由一个机构运行的单个数据库中。相反，它分布在许多管理特定顶级域 (TLD)、二级域或低级子域的不同机构中。就全球互联网而言，数以百万计的不同“权威”合作参与运行 DNS 系统，其中许多只负责自己的本地域空间。

通过以这种方式分配注册权限，这意味着有关域的信息类似地分布在许多实体之间，从而形成分布式数据库。 DNS 名称解析中的一个关键概念是，负责维护部分名称空间的每个实体还必须安排将该信息存储在 DNS 服务器上。这是必需的，以便服务器可以在执行解析时提供有关该部分名称空间的信息。正如您所看到的，结构化的权限层次结构的存在直接意味着需要一个存储该层次结构名称信息的服务器层次结构。

每个 DNS 授权区域都需要有一个或多个 DNS 服务器“负责”管理有关该区域的信息。据说这些服务器对该区域具有权威性。存储区域中有关域、子域和对象的信息是通过将数据记录在从管理员维护的 DNS 主列表中读取的特殊资源记录中来完成的。然后服务器响应对该信息的请求。

由于 DNS 中的信息以分布式形式存储，因此没有一台服务器拥有系统中每个域的信息。正如我们将在名称解析器部分中看到的那样，解析过程依赖于上面描述的名称服务器的层次结构。在 DNS 层次结构的顶部是根域，因此我们也在那里看到根名称服务器。这些是最重要的服务器，因为它们维护有关根目录中顶级域的信息。他们还了解可用于解析比他们低一级的域的服务器。这些服务器反过来负责 TLD，并且可以引用负责二级域的服务器。因此，DNS 解析可能需要将请求发送到多个服务器。

**关键概念：**DNS 公共名称信息存储在 DNS 名称服务器的分布式数据库中，这些服务器的结构类似于权威层次结构。每个区域都有一个或多个负责区域信息的 DNS 名称服务器，称为权威名称服务器。

<u>**DNS 服务器支持功能**</u>

名称数据的存储和服务（通过响应 DNS 解析器的请求）是 DNS 服务器的主要功能。但是，DNS 服务器通常还需要其他支持工作，包括：

- 与其他服务器交互：如上所述，DNS 解析过程通常需要涉及多个服务器。因此，服务器不仅必须维护名称信息，还必须维护有关其他服务器存在的信息。根据 DNS 请求的类型，服务器本身可能成为客户端并向其他服务器生成请求。

- 区域管理和传输：服务器必须提供一种方法来管理区域内的 DNS 信息。还存在允许在区域的主（主）服务器和从（辅助）服务器之间执行区域传输的工具。

- 性能增强功能：由于服务器处理大量请求，它们采用多种技术来减少响应查询所需的时间。其中最重要的是名称信息的缓存。称为 *negative caching*负缓存的常规缓存的变体也可用于提高性能，负载平衡是一项可用于提高在 DNS 系统中注册的繁忙设备的效率的功能。

- 管理：名称服务器需要各种其他管理细节，例如存储有关负责与域或区域管理相关的某些任务的不同类型“联系人”（人）的信息。

正如我们将在本节后面看到的那样，并非所有名称服务器都执行本主题上面描述的所有任务；有些只执行一个子集。

<u>**DNS 名称服务器层次结构是逻辑的，而不是物理的**</u>

与其他层次结构一样，名称服务器层次结构本质上是逻辑的。我已经提到过，它通常与权限等级并不完全相同。一方面，单个 DNS 名称服务器通常是多个域的权威服务器。即使特定组对特定域的子域具有权限，出于效率原因，他们也可能会与其父域的权限“共享”DNS 服务器。例如，一所大学可能将其部分域空间的控制权委托给不同的组（如我们在 DNS 区域主题中的示例），但仍管理同一服务器上的所有子域。实际上，子域在 DNS 名称层次结构中的级别越低，子域拥有自己的 DNS 服务器的可能性就越小。

名称服务器层次结构的逻辑性质的另一个重要方面是名称服务器的结构与其位置之间没有必然的关系。事实上，在许多情况下，出于可靠性原因，名称服务器专门放在不同的地方。最好的例子是一组根名称服务器——尽管它们都位于 DNS 服务器架构的“顶部”，但它们分布在全球各地，以防止一个问题将它们全部摧毁。还请记住不要被地缘政治 DNS 名称层次结构中的名称结构所迷惑——名为“ns1.blahblah.ca”的名称服务器可能在加拿大，但很可能不在。

**关键概念：**DNS 名称服务器层次结构本质上是逻辑的，与 DNS 名称服务器树并不完全相同。一台服务器可能负责多个域和子域。此外，DNS 名称服务器层次结构不一定表示名称服务器的物理位置。



###### 1.2.3.4-1-2 DNS 名称服务器数据存储：资源记录和类（部分：1 2 3 4）

名称服务器执行的最重要的工作之一是名称数据的存储。由于注册名称的权限是使用 DNS 在互联网上分布的，因此名称信息的数据库也是分布式的。权威服务器负责存储和管理分配给它的权限区域的所有信息。

每个 DNS 服务器本质上都是一种数据库服务器。该数据库包含有关服务器负责的域或区域内的子域和单个设备的多种信息。在 DNS 中，包含此名称信息的数据库条目称为资源记录 (RR)。一组特定的 RR 与区域内的每个节点相关联。

<u>**资源记录的二进制和文本表示**</u>
DNS 的全部要点是允许人类使用名称和计算机使用数字，我们看到这一原则进一步反映在 DNS 资源记录本身存在的两种截然不同的表示中：

- 资源记录字段格式（二进制）表示：名称服务器需要通过在 DNS 消息中发送资源记录来响应名称信息查询。显然，我们希望以尽可能高效的方式做到这一点，因此每个资源记录都使用一种特殊的字段格式在内部存储，这种格式类似于我们在其他协议中看到的用于消息的许多字段格式。所有资源记录的某些字段都使用通用字段格式，然后具有特定于资源记录类型的唯一部分。

- 主文件（文本）表示：计算机很乐意交换二进制编码的字段格式，并且可以毫无问题地记住，例如，资源记录类型 15 对应于邮件交换 (MX) 记录。但是，人类管理员希望能够快速轻松地维护 DNS 信息，而不必记住密码或使用二进制值。为此，DNS 在其用户机界面上使用主文件格式，允许以文本形式指定资源记录，以便于维护。

<u>**资源记录和主文件集**</u>

每个节点可能有可变数量的记录，这取决于节点类型和为它保留的信息。当 DNS 信息发生变化时，资源记录由对服务器计算机上的文本主文件进行修改的管理员进行添加、更改或删除。这些文件然后由 DNS 服务器软件读入内存，解析（解释）并转换为二进制形式。然后它们就可以用于解析 DNS 名称请求和其他查询。如图 241 所示。

我在有关 DNS 消息传递和格式的部分中描述了二进制 RR 字段格式和主文件格式。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\dnsrrover.png)




​                                                                 **图 241：DNS 资源记录主文件和二进制字段格式**

为了满足人类和计算机的需要，DNS 对存储在资源记录中的数据使用两种表示形式。管理员在文本 DNS 主文件中输入和维护信息。这些由 DNS 服务器软件读取并以二进制格式在内部存储以响应 DNS 请求。

**关键概念：**DNS 名称服务器以资源记录 (RR) 的形式存储 DNS 信息。每个 RR 包含有关 DNS 树中节点的特定类型的信息。资源记录有两种表示形式：传统的二进制字段格式用于 DNS 名称服务器和解析器之间的通信，而文本主文件由管理员编辑以管理 DNS 区域。

<u>**公共资源记录类型**</u>

主要的 DNS 标准 RFC 1034 和 1035 定义了许多资源记录类型。随着时间的推移，列表发生了变化，在后续标准中创建了新的 RR 类型，其他类型的使用也发生了变化。与其他 Internet 参数一样，DNS RR 类型列表在 IANA 的一个文件中进行维护。与其他 Internet 参数一样，实际上 DNS 中定义了几十个 RR，但只有少数几个是常用的；其他的现在已经过时，用于特殊目的或本质上是“实验性”的。

**在 Web 上：**当前的 DNS 资源记录列表保存在一个文件中，该文件位于：http://www.iana.org/assignments/dns-parameters


表 166 总结了最重要的资源记录类型。对于每一个，我都显示了记录的数字类型值，用于标识消息交换中的资源记录类型，以及用于主文件中 RR 的文本代码。我还提供了每个的简要说明。

​                                                                             **表 166：常见 DNS 资源记录摘要**

| **RR Type Value** | **RR Text Code** | **RR Type**          | **Description**                                              |
| ----------------- | ---------------- | -------------------- | ------------------------------------------------------------ |
| **1**             | *A*              | *Address*            | 包含 32 位 IP 地址。这是 DNS 的“核心”，因为它是存储节点地址以用于名称解析的地方。 |
| **2**             | *NS*             | *Name Server*        | 指定对该区域具有权威的 DNS 名称服务器的名称。每个区域必须至少有一个指向其主要名称服务器的 NS 记录，并且该名称还必须具有有效的 A（地址）记录。 |
| **5**             | *CNAME*          | *Canonical Name*     | 此资源记录用于允许定义指向节点真实名称的别名。 CNAME 记录提供此别名与节点的“规范”（真实）名称之间的映射。 CNAME 资源记录通常用于向外部用户隐藏内部 DNS 结构的更改，方法是让他们使用不变的别名，同时根据组织的需要修改内部名称。有关示例，请参阅有关名称解析的主题。 |
| **6**             | *SOA*            | *Start Of Authority* | SOA 资源记录用于标记 DNS 区域的开始并提供有关它的重要信息。每个区域必须只有一个 SOA 记录，其中包含区域名称、其主要（主）权威服务器名称等详细信息，以及技术详细信息，例如其管理员的电子邮件地址和从属（次要）的频率参数) 名称服务器已更新。 |
| **12**            | *PTR*            | *Pointer*            | 提供指向名称空间中另一个位置的指针。这些记录以通过 IN-ADDR.ARPA 域进行反向解析而闻名。 |
| **15**            | *MX*             | *Mail Exchange*      | 指定负责处理发送到域的电子邮件的位置（设备名称）。           |
| **16**            | *TXT*            | *Text String*        | 允许存储与域关联的任意附加文本。                             |

所有这些资源记录都以不同的方式用于在其中定义区域和设备，然后允许名称解析和其他功能发生。 我们将在有关名称解析的部分中更详细地了解如何使用它们。 您还可以在专门用于资源记录字段格式的主题中找到对其中一些格式的更详细的描述。

**相关信息：**请参阅有关 IPv6 特定资源记录类型的 IPv6 DNS 支持的主题。

<u>**资源记录类**</u>

最后，需要提及的历史记录。首次创建 DNS 时，其发明者希望它尽可能通用。为此，他们设计了这样一个 DNS 服务器，理论上可以为不止一种类型的底层协议提供名称服务。也就是说，DNS 可以同时支持 TCP/IP 和其他协议。

当然，协议有不同的寻址方案，也有不同的名称解析需求。因此，DNS 被定义为每个协议都可以有一组不同的资源记录类型。每组资源记录类型称为一个类。从技术上讲，必须使用类标识符和资源记录类型来标识资源记录。与资源记录类型一样，类有一个数字代码和一个文本缩写。 TCP/IP 类使用数字 1，文本代码为“IN”（代表“Internet”）。

实际上，这种多类资源记录的概念从未流行过。据我所知，如今 DNS 仅用于 TCP/IP。 （可能有一些模糊的例外。）RFC 1035 定义了其他几个类，它们在 IANA DNS 参数列表中，但它们用于相对模糊的、实验性的或过时的网络类型，名称如 CSNET、CHAOS 和 Hesiod。您仍然会在 DNS 消息和资源记录格式的规范中看到“类”的概念，但今天实际上只有类：TCP/IP 的“IN”。为此，在大多数情况下，在与 DNS 相关的命令和数据条目中可以省略类名，默认使用“IN”。

**关键概念：**最初创建 DNS 标准是为了允许它们通过指定每个资源记录的类来使用多种协议。今天唯一常用的类是用于 TCP/IP 的类，称为“IN”（“Internet”）。



###### 1.2.3.4-1-3 DNS 名称服务器类型和角色：主/主、辅助/从属和仅缓存服务器（部分：1 2 3）

在本节的前两个主题中，我们了解了 DNS 服务器的功能，并特别关注了存储名称服务器信息的重要工作。 Internet 上有成千上万的 DNS 服务器，但并非所有服务器都以相同的方式使用。每个 DNS 服务器在名称系统的整体运行中都扮演着特定的角色。不同类型的服务器还以我们需要了解的各种方式相互交互。

每个区域都需要至少有一个负责它的 DNS 名称服务器。这些 DNS 名称服务器被称为该区域的权威服务器，因为它们包含描述该区域的完整资源记录集。当 Internet 上的任何设备想要了解某个区域的某些信息时，它会咨询其中一个权威服务器。

从严格的理论角度来看，每个区域或域拥有一个名称服务器“足以”为整个 DNS 名称结构提供名称解析服务。然而，从实现的角度来看，名称空间的每一部分都只有一个名称服务器并不是一个明智的想法。相反，每个区域通常与至少两个名称服务器相关联：一个主要或主名称服务器，以及一个辅助或从属名称服务器。某些区域可能有多个二级名称服务器。

**注意：**DNS 标准中经常使用术语“主要”和“次要”来指代一个区域的两个权威服务器的角色。但是，“master”和“slave”现在是首选术语，因为“primary”和“secondary”在其他情况下使用时有些歧义。您应该准备好看到同时使用这两个术语。

<u>**使用从名称服务器的原因**</u>

主名称服务器显然是最重要的服务器。区域资源记录的主文件就是在此名称服务器上维护的，因此主名称服务器是区域信息的“最终决定权”。但是，有几个原因说明从服务器也很重要：

- 冗余：我们已经讨论过 DNS 的重要性，尤其是在 Internet 上；只有一个名称服务器，如果它发生故障，没有人能够将诸如“www.xyzindustries.com”之类的名称解析为 IP 地址，这将是一件坏事 [tm]。 J 从名称服务器作为它们支持的主服务器的备份。

- 维护：如果有多个服务器，我们可以在需要时轻松地关闭主服务器进行维护，而不会中断名称解析服务。

- 负载处理：繁忙区域可以使用多个服务器来分散名称解析请求的负载以提高性能。

- 效率：在许多情况下，为了提高效率，将名称服务器定位在特定的地理位置是有优势的。例如，一家公司可能在遥远的地方设有办公室，使用低速 WAN 链接进行连接。为了减少该链接上的名称解析流量，在连接两侧的名称服务器中提供该区域的信息是有意义的，因此需要两台物理服务器。

冗余是设置主从名称服务器时最重要的考虑因素。将两台机器并排放置在服务器机房中，插入相同的电力服务，都连接到同一互联网服务提供商的互联网，并将一台作为主 DNS 服务器，另一台作为从属 DNS 服务器，这并不是明智之举。理想情况下，主备服务器应尽可能独立；他们应该在物理上远离并且具有单独的 Internet 连接。

<u>**将信息从主服务器传播到从服务器**</u>
正如名称“master”和“slave”所暗示的那样，辅助名称服务器并不是区域信息的原始来源。他们通常不是从人工编辑的主文件中获取资源记录，而是从主服务器获得的更新中获取资源记录。这是使用称为区域传输的过程完成的。这些传输会定期执行，以确保从属服务器保持最新状态。然后，从服务器可以使用当前信息响应名称解析请求。 master 和 slave 都被认为是该区域的权威。

<u>**名称服务器角色**</u>

区域的“主”和“从”角色是合乎逻辑的，并不总是对应于单独的物理硬件设备。在以下情况下，单个物理名称服务器可以扮演多个角色：

- 它可以是多个区域的主名称服务器。在这种情况下，每个区域都有一组不同的资源记录，这些记录保存在单独的主文件中。

- 它可以是多个区域的从名称服务器。

- 它可以是某些区域的从名称服务器，也可以是其他区域的主要名称服务器。



但是请注意，单个物理名称服务器不能是同一区域的主服务器和辅助服务器，因为……好吧，这有什么意义呢？

**关键概念：**区域的主 DNS 服务器是其主服务器，它维护 DNS 信息的主副本。大多数 DNS 区域还有至少一个从属或辅助 DNS 服务器。这些很重要，因为它们充当主服务器的备份，并且它们还可以帮助分担繁忙区域中响应请求的负载。二级名称服务器定期从一级服务器获取信息。主服务器和从服务器都被认为对它们维护其数据的区域具有权威性。

<u>**仅缓存名称服务器**</u>
我们将在本节后面看到，出于效率原因，所有 DNS 服务器都执行 DNS 信息的缓存，以便在不久的将来请求时可以再次使用它。这包括主名称服务器和从属名称服务器。缓存的重要性如此之大，以至于有些服务器仅设置为缓存来自其他 DNS 服务器的信息。不出所料，这些被称为仅缓存名称服务器。

这些名称服务器对任何区域或域都没有权威，也不维护自己的任何资源记录。他们只能通过联系其他权威名称服务器然后中继信息来回答名称解析请求。然后他们存储信息以供将来请求。何必？原因是性能。通过战略布局，仅缓存服务器可以通过减少对权威服务器的请求来显着提高某些网络中的 DNS 解析性能。

**关键概念：**有些 DNS 服务器不维护自己的 DNS 资源记录，而只保存来自其他区域的最近使用的信息。这些称为仅缓存名称服务器，对任何区域都没有权威。





###### 1.2.3.4-1-4 DNS 区域管理、联系人和区域传输（部分：1 2 3）

特定 DNS 区域的权威负责执行各种任务来管理它。区域管理包含与区域相关的所有工作：决定区域内的名称层次结构、指定名称注册程序、与保持 DNS 服务器运行相关的技术工作以及其他各种“管理开销”。这项工作可以非常小，也可以非常大，具体取决于组织的类型。个人拥有的小域不需要太多的管理工作，而大公司的域可能需要专门的人员来维护。

<u>**域名联系人**</u>
重要的是，互联网上的任何人都可以确定域的所有者是谁，以便无论出于何种原因都可以联系到该人。在 Internet 上，每个 DNS 域都与一组三个联系人相关联，他们负责管理域的不同方面。这些是：

- 管理联系人：“主要”联系人，负责整个域。此个人或组织被视为域的整体所有者。

- 计费联系人：负责处理域服务付款和其他会计事务的联系人。

- 技术联系人：处理为域设置 DNS 并确保其正常工作的技术细节的联系人。

对于较小的域，通常没有单独的帐单联系人；它与行政联系人相同。相比之下，技术联系人通常不同于大小域中的管理联系人。大型组织会在其信息技术部门安排技术联系人。小型组织通常让他们的互联网服务提供商 (ISP) 提供 DNS 服务，在这种情况下，技术联系人将是该 ISP 的人员。

**关键概念：**每个 DNS 域都与一组三个联系人名称相关联，这些名称表明谁负责管理它。管理联系人是对域全面负责的人。账单联系人负责支付问题；这可能与行政联系人相同。技术联系人负责域的技术事务，通常与管理联系人不同，尤其是在 DNS 服务外包时。

<u>**区域传输**</u>

区域管理的最终目的是确保有关区域的信息在区域的主从名称服务器上保持最新，以便可以有效地提供给名称解析器。因此，区域的管理始于导致区域资源记录更改的决策制定和管理操作。这些反映在对该区域的主（主）DNS 服务器上的 DNS 主文件所做的更改中。

相反，每个区域的辅助 DNS 服务器充当“主”主服务器的“从属”。它们携带有关区域的信息，但不从本地编辑的本地主文件加载它。相反，他们定期从主名称服务器获取信息。负责此的过程称为区域传输。

主域名服务器上的资源记录可以随时更新；一旦主名称服务器的记录被更改，从属名称服务器上的信息就会部分过时。这通常没什么大不了的，因为大部分数据仍然是准确的，辅助服务器将继续使用它拥有的最新信息来响应解析请求。但是，定期更新从服务器显然很重要；如果不这样做，最终他们的数据将变得“陈旧”和不可靠。

<u>**使用 DNS 开始权限字段控制区域传输何时发生**</u>
为此，有必要定期执行区域传输。这需要在服务器之间实现一个由两个基本部分组成的通信过程。首先，我们需要一种机制让从服务器定期检查主服务器上数据的变化。其次，我们必须有一种机制，可以在需要时将区域的资源记录从主要名称服务器复制到次要名称服务器。

这两种机制都使用标准的 DNS 查询/响应设施，以及区域资源记录中的特殊字段。特别重要的是区域的授权起始 (SOA) 记录，它包含几个控制区域状态检查和区域传输的参数。这些参数的正式描述可以在资源记录格式的主题中找到，我将在这里讨论如何使用它们。

当从名称服务器启动时，它要么根本没有关于该区域的信息，要么它可能在其本地存储中存储了上次运行时区域资源记录的副本。在前一种情况下，它必须立即执行全区传输，因为它没有任何信息。在后一种情况下，它将从本地存储中读取该区域的“最后已知”副本；它可能会立即在主服务器上执行轮询以查看数据是否已更改，具体取决于配置。测试是通过请求区域的授权起始资源记录来完成的。

SOA 记录中的 Serial 字段包含一个序列号（可以是任意的，也可以是编码的，因此它具有特定的含义）充当主服务器区域数据库的“版本号”。每次修改区域的主文件（通过手动编辑或通过其他方式自动修改）时，该序列号都会增加。因此，从服务器可以通过查看最近的 SOA 记录中的 Serial 字段是否大于从服务器上次轮询主服务器时存储的字段来检测何时对主服务器进行了更改。如果序列号已更改，则从设备开始区域传输。

SOA 记录中的其他三个字段控制从名称服务器用于轮询和更新其信息的时间：

- 刷新：此字段指定从属服务器在两次尝试检查主服务器更新之间等待的秒数。假设 slave 可以联系，这是当 master 改变时 slave 上的数据变得“陈旧”的最长时间。

- 重试：该字段控制如果上次尝试失败，slave 在再次尝试向 master 登记之前必须等待多长时间。这用于防止“快速”尝试联系可能阻塞网络的主机。

- 过期：如果出于某种原因，从名称服务器在此字段值指定的秒数内无法与主服务器取得联系，则它必须假定它拥有的信息已经过时并停止使用它。这意味着它将停止充当该区域的权威名称服务器，直到它收到更新。

这些参数是区域 SOA 记录的一部分这一事实使区域管理员可以完全控制主名称服务器的更新频率。在变化很少的小区域，可以增加从属服务器检查的间隔；对于较大的区域或经常更改的区域，可以减少刷新间隔。

<u>**区域传送机制**</u>

当需要区域传输时，它是通过使用用于名称解析的常规 DNS 查询/响应消息传递方法（在下一节中讨论）发送到主服务器的 DNS 查询来完成的。一种称为 AXFR（地址传输）的特殊 DNS 问题类型用于启动区域传输。然后，服务器将使用一系列 DNS 响应消息来传输该区域的资源记录（假设请求传输的服务器已获得授权）。由于可靠地接收区域传输很重要，并且由于要发送的数据量很大并且需要管理，因此必须首先建立 TCP 会话并将其用于区域传输。这与用于常规 DNS 消息的更简单的 UDP 传输形成对比。这在讨论将 UDP 和 TCP 用于 DNS 的主题中进行了讨论。

一旦区域传送完成，从属名称服务器将更新其数据库并返回到常规操作。它将继续每隔 Refresh 秒对主服务器进行定期轮询。如果它在定期轮询中遇到问题，它将在Retry秒后再次尝试。最后，如果过了等于过期秒的时间，表明主名称服务器将停止提供该区域的数据，直到它与主名称服务器重新建立联系。

**关键概念：**从属名称服务器的 DNS 信息不由管理员直接管理。相反，他们通过称为区域传输的过程定期从其主名称服务器获取信息。 Start Of Authority DNS 资源记录中的几个字段控制区域传输过程，包括指定传输的频率以及从名称服务器如何处理问题情况，例如无法联系主服务器。

**请注意，**DNS 通知功能是对基本区域状态检查/区域传输模型的增强。它允许主服务器在主数据库发生变化时通知从服务器。另一个新功能允许只传输部分区域而不是整个区域。有关更多信息，请参阅有关 DNS 名称服务器增强的主题。





###### 1.2.3.4-1-5 DNS 根名称服务器（部分：1 2 3）

域名系统非常注重层次结构的概念：名称空间、注册机构和名称服务器都以树形结构排列。与这些结构一样，名称解析过程也是分层的。正如名称解析部分中详细描述的那样，完全限定的域名是通过从最不具体的域名元素（标签）开始并朝着最具体的域名开始解析的。

自然地，每个名称中最不具体的部分是整个 DNS 结构所在的根节点。这意味着，在没有缓存和其他性能增强的情况下，所有名称解析都从名称树的根开始。我们在这里找到一组负责 DNS 根的名称服务器功能的名称服务器：DNS 根名称服务器。

与所有名称服务器一样，它们存储有关“根区”内所有节点的信息并为其提供名称解析服务。这包括某些特定的顶级域和子域。但是，大多数顶级域 (TLD) 都位于自己的区域中。根名称服务器用作“转到”点，以获取每个 TLD 的权威服务器的名称和地址。例如，如果我们要解析名称“www.xyzindustries.co.uk”，根名称服务器就是解析器找到负责“uk”的名称服务器身份的地方。

<u>**确保访问根名称服务器**</u>

显然，根名称服务器对于整个 DNS 系统的运行极其重要。如果发生任何事情导致根名称服务器停止运行，则整个 DNS 系统基本上会关闭。因此，根服务器显然不是只有一台，也不是两三台；有（目前）十三个不同的根名称服务器。

事实上，实际的物理服务器远不止十三台。十三个名称服务器中的大多数被实现为多个独立物理硬件服务器的集群。有些实际上是位于不同物理位置的分布式服务器集合。最好的例子就是“F”根服务器，它已经在世界各地被实施为一组十几个镜像，以提供更好的服务。

我提到的冗余原则是为常规域选择辅助名称服务器的好主意，显然更适用于根。这就是为什么构成十三个根服务器的各种物理设备都位于全球不同的地方。他们中的许多人在美国，但即使是这些人也分布在全国的许多地方（尽管集中在加利福尼亚州和华盛顿特区附近的几个“热点”），并且被设置为使用不同的网络连接到互联网。

根名称服务器当然是相当强大的；尽管有几十个硬件来分散负载，但每个硬件都必须每天 24 小时处理大量数据。它们由确保它们有效运行的网络专业人员运行。互联网标准 RFC 2870（根名称服务器操作要求）阐明了这些名称服务器操作的基本规则和实践。它指定了广泛的程序来确保服务器的安全，并避免由于它们的关键作用而导致的性能问题。

尽管为确保根服务器的广泛分布和安全做出了所有努力，它们仍然共同代表了全球互联网中的一个弱点。数以百万计的人依赖于这些服务器。过去曾发生过互联网上的流氓分子试图通过攻击根名称服务器来破坏 DNS 的事件。一个广为人知的事件是 2002 年 10 月 21 日针对根服务器的拒绝服务 (DoS) 攻击。攻击失败了，但它显着提高了人们对这些服务器的重要性以及 DNS 安全性的重要性的认识。

**关键概念：**有关 DNS 根及其顶级域的信息由一组根名称服务器管理。这些服务器对于 DNS 的运行至关重要；他们被分为十三组，并实际分布在世界各地。

<u>**当前的根名称服务器**</u>

最初，根名称服务器被赋予反映运行它们的组织的域名。 在这些历史名人中，我们可以看到互联网发展中名副其实的“名人录”：ISI、NASA、美国军方等。 一些服务器仍然由政府机构或美国军方运行，可以增加安全措施来保护它们。 然而，为方便起见，所有根名称服务器现在都在特殊域“root-servers.net”中按字母顺序给出“字母名称”。

表 167 显示了截至本指南发布之日有关 DNS 根名称服务器的最新信息。 为了您的兴趣和娱乐，我还在图 242 中绘制了这些服务器的位置。

​                                                                 **表 167：Internet DNS 根名称服务器**

| **Root Server Name**   | **IP Address**     | **Historical Name** | **Location(s)**                                              |
| ---------------------- | ------------------ | ------------------- | ------------------------------------------------------------ |
| **a.root-servers.net** | **198.41.0.4**     | ns.internic.net     | Dulles, VA, USA                                              |
| **b.root-servers.net** | **128.9.0.107**    | ns1.isi.edu         | Marina Del Rey, CA, USA                                      |
| **c.root-servers.net** | **192.33.4.12**    | c.psi.net           | Herndon, VA and Los Angeles, CA, USA                         |
| **d.root-servers.net** | **128.8.10.90**    | terp.umd.edu        | College Park, MD, USA                                        |
| **e.root-servers.net** | **192.203.230.10** | ns.nasa.gov         | Mountain View, CA, USA                                       |
| **f.root-servers.net** | **192.5.5.241**    | ns.isc.org          | Auckland, New Zealand; Sao Paulo, Brazil; Hong Kong, China; Johannesburg, South Africa; Los Angeles, CA, USA; New York, NY, USA; Madrid, Spain; Palo Alto, CA, USA; Rome, Italy; Seoul, Korea; San Francisco, CA, USA; San Jose, CA, USA; Ottawa, ON, Canada |
| **g.root-servers.net** | **192.112.36.4**   | ns.nic.ddn.mil      | Vienna, VA, USA                                              |
| **h.root-servers.net** | **128.63.2.53**    | aos.arl.army.mil    | Aberdeen, MD, USA                                            |
| **i.root-servers.net** | **192.36.148.17**  | nic.nordu.net       | Stockholm, Sweden; Helsinki, Finland                         |
| **j.root-servers.net** | **192.58.128.30**  | —                   | Dulles, VA, USA; Mountain View, CA, USA; Sterling, VA, USA; Seattle, WA, USA; Atlanta, GA, USA; Los Angeles, CA, USA; Amsterdam, The Netherlands |
| **k.root-servers.net** | **193.0.14.129**   | —                   | London, UK; Amsterdam, The Netherlands                       |
| **l.root-servers.net** | **198.32.64.12**   | —                   | Los Angeles, CA, USA                                         |
| **m.root-servers.net** | **202.12.27.33**   | —                   | Tokyo, Japan                                                 |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\dnsrootservers.png)

​                                                       **图 242：Internet DNS 根名称服务器的地理位置**




在 Web 上：可以在文件 ftp://ftp.rs.internic.net/domain/named.root 中找到当前的根名称服务器列表。 您还可以在 http://www.root-servers.org 上以更加用户友好的格式找到信息。



###### 1.2.3.4-1-6 DNS 名称服务器缓存、负缓存和数据持久性（部分：1 2 3）

名称服务器完成的大部分“繁重工作”都是响应名称解析请求。繁忙的服务器，如根名称服务器，为顶级域传输区域信息的服务器，以及为非常繁忙的区域提供服务的服务器，每秒必须处理数百甚至数千个名称解析请求。这些请求中的每一个都需要时间和资源来解决；它还从传输数据的业务中占用了互联网带宽。因此，DNS 服务器实施必须采用机制来提高其效率并减少不必要的名称解析请求。其中最重要的一项是缓存。

<u>**名称服务器缓存**</u>
缓存这个词指的是商店，或者是存放东西的地方。在计算机世界中，该术语通常指的是一块内存区域，用于存储最近获得的信息，以便再次使用。在 DNS 的情况下，DNS 名称服务器使用缓存来存储最近的名称解析和其他请求的结果，这样如果请求再次出现，它可以从缓存中得到满足，而无需再次完整运行名称解析过程。由于大多数人使用计算机的方式，一个特定请求之后通常会跟随另一个对相同名称的请求，因此缓存可以显着减少导致完整名称解析过程的请求数量。

一个例子是说明这一点的最好方法。假设您正在使用公司本地网络上的主机。此主机可能配置为使用您公司的 DNS 名称服务器来处理解析请求。您在 Web 浏览器中键入“www.xyzindustries.com”，这会导致对该地址进行解析尝试。很可能，您的本地 DNS 服务器不知道该名称，因此它将遵循完整的名称解析过程来获取其地址。完成此操作后，您的本地 DNS 服务器将缓存名称“www.xyzindustries.com”和与之关联的地址。

如果您单击该网站页面的链接，则该新页面也可能位于“www.xyzindustries.com”站点的某个位置。这将导致另一个 DNS 解析请求再次发送到您的本地 DNS 服务器。但是，这一次，本地服务器不必执行解析；它记得这个名字在它的缓存中，并立即返回这个名字的保存地址。瞧！您可以更快地得到答案，并且避免了不必要的互联网流量。

**关键概念：**缓存是一项基本的效率功能，它通过消除对最近解析的名称的不必要请求来减少 DNS 消息流量。每当解析名称时，都会缓存生成的 DNS 信息，以便可以将其用于此后不久发生的后续请求。

<u>**缓存数据持久性和生存时间间隔**</u>

当然，事情并不完全这么简单。每个缓存系统（包括 DNS 中使用的缓存系统）都会遇到一个非常重要的问题，即缓存的新鲜度问题。假设我们的本地 DNS 服务器解析名称“www.xyzindustries.com”，然后缓存其地址。在上面的示例中，我们在 XYZ Industries 主页加载几秒钟后单击一个链接，我们不太可能太在意 DNS 数据的新鲜度。但是，如果我们关闭计算机去度假 2 周，然后回来工作并在浏览器中再次输入名称，那会怎么样呢？如果我们的本地服务器的缓存中仍然有该名称，我们如何知道“www.xyzindustries.com”的 IP 地址在那两周内没有改变？

两种不同的机制被用来解决这个问题。第一个是缓存数据时，缓存服务器还会记录数据来自的权威服务器。当解析器（客户端）请求名称解析并且地址是从缓存中提取时，服务器会将答案标记为非权威的，以明确告诉客户端该名称来自缓存。服务器还提供最初提供数据的权威服务器的名称。

然后客户端有一个选择：它可以使用非权威答案，或者从权威服务器发出一个新名称解析的请求。这是性能（使用缓存数据）和货币（每次都要求新的分辨率）之间的权衡。通常，缓存数据可以安全使用，因为 DNS 信息不会经常更改。

确保缓存数据不会太旧的第二种技术是限制 DNS 缓存数据持久性的过程。每个资源记录都与一个时间间隔相关联，称为生存时间 (TTL)。每当从服务器读取资源记录时，也会读取该记录的 TTL。任何缓存该记录的服务器都应该在该时间间隔到期后丢弃该记录。

每个区域还与要应用于该区域中所有记录的 TTL 字段的默认值相关联。这允许管理员为区域中的所有记录选择 TTL 值，而不必为每个记录单独输入 TTL 编号。同时，管理员可以为任何需要与默认值不同的数字的记录分配一个“覆盖”TTL 值。此默认 TTL 最初是在每个区域的特殊授权起始资源记录中找到的，但现在是使用区域主文件中的特殊指令完成的。

**注意：**此生存时间字段与 Internet 协议数据报中使用的字段无关。显然 IP 和 DNS 是完全不同的协议；不仅如此，尽管名称相同，但 IP 和 DNS 中的 TTL 字段根本没有相同的含义。


值得强调的是，DNS 将缓存的控制权交给了记录的所有者，而不是运行 DNS 服务器进行缓存的任何人。虽然特定的缓存服务器可以“覆盖”TTL 并指定数据将在其自己的缓存中保存多长时间，但 DNS 不应该以这种方式工作。在逐条记录的基础上指定 TTL 的能力允许缓存数据的持久性根据各个数据元素的需要进行定制。可以为经常更改的数据赋予较小的 TTL 值，而可以为不经常修改的记录赋予较高的 TTL。必须仔细选择 TTL 值；这是性能（使用更高的 TTL 值进行优化，减少对缓存数据的查询数量）和数据“新鲜度”（随着 TTL 降低而增加）之间的另一种权衡。

**关键概念：**缓存的信息会随着时间的推移变得陈旧，并导致发送给查询的错误响应。每个资源记录都可以关联一个时间间隔，称为生存时间 (TTL)，它指定记录可以在缓存中保存多长时间。该字段的值由资源记录的所有者控制，谁可以根据每个资源记录类型的特定需求对其进行定制。

<u>**Negative Caching**</u>

经典 DNS 缓存仅存储成功名称解析的结果。 DNS 服务器也可以缓存不成功的名称解析尝试的结果；这称为负缓存。扩展上面的示例，假设您误以为公司网站的名称是“www.xyz-industries.com”，并将其输入浏览器。您的本地 DNS 服务器将无法解析该名称，并会在其缓存中将该名称标记为“无法解析”；负缓存条目。

假设您输入的姓名不正确，因为有人在内部备忘录中输入错误。如果同事后来尝试使用相同的名称，DNS 服务器会说“我已经知道这是一个假名称”并且不会再次尝试解析它。由于不存在无效名称的资源记录，因此服务器本身必须决定将此负面信息缓存多长时间。负缓存可提高性能，因为解析不存在的名称会占用资源，就像解析已存在的名称一样。请注意，“常规”缓存有时被称为“正缓存”以与“负缓存”进行对比。

区域中用于负缓存的值现在由每个区域的 Start Of Authority 资源记录中的 Minimum 字段指定。如上所述，这以前用于指定区域的默认 TTL。

###### 1.2.3.4-1-7 DNS 名称服务器负载平衡

Address (A) 资源记录是 DNS 中最基本的资源记录，因为它记录了域名和 IP 地址之间的实际映射。让我们更详细地考虑一下该句子中的一个词。不，不是“地址”或“资源记录”或“映射”。 “一”字。 J 地址记录仅提及每个域名的一个地址。这意味着，正如我们到目前为止所描述的 DNS，每个域名仅映射到一个物理硬件设备。

当特定服务器或其他设备需要处理的请求数量相对较少时，这不是问题——该功能通常可以使用单个物理硬件设备来实现。如果服务器变得更忙，通常的解决方案是投入更多的硬件来解决这个问题——换一台更大的机器。但是，大型互联网络（尤其是 Internet）上的某些主机具有必须处理来自许多客户端的大量流量的服务器。没有任何一种硬件设备可以轻松处理“www.cnn.com”或“www.microsoft.com”等站点的流量，而不变得笨重。

<u>**使用多个地址记录将请求分散到一个域**</u>
像 CNN 这样的网站必须使用一种称为负载平衡的技术来将请求分散到多个硬件服务器上。一种简单的方法是使用多个机器名称；例如，CNN 可以创建多个不同的网站，分别称为“www1.cnn.com”、“www2.cnn.com”等，每个网站都指向不同的硬件设备。 DNS 当然支持这种类型的解决方案。这个解决方案的问题是它很麻烦；它要求用户记住多个服务器名称。

如果我们能自动平衡负载就更好了。 DNS 通过提供一种实现负载平衡的简单方法来支持这一点。我们可以创建多个这样的记录，而不是为名称指定单个地址资源记录，从而将多个 IP 地址与特定 DNS 名称相关联。当我们这样做时，每次该名称所在区域的权威名称服务器解析该名称时，它会将列表中的所有地址发回给请求者。服务器更改响应中提供的地址的顺序，随机选择顺序或以连续的“循环”方式选择。客户端通常会使用服务器返回的列表中的第一个地址，因此通过更改列表，服务器确保对该设备名称的请求被解析到多个硬件单元。

随着 Internet 流量的增加，负载平衡变得越来越流行。 2003 年初，我看到一项调查表明，当时大约 10% 的 Internet 名称使用了负载平衡——这是一个相当可观的数字。大多数使用两个或三个地址，但有些使用多达 60 个！顺便说一句，在最后一次检查中，“www.cnn.com”与八个不同的 IP 地址相关联。 （顺便说一句，您可以使用“主机”命令检查与名称关联的地址数。）

关键概念：不是为 DNS 域名创建单个地址资源记录，而是可以创建多个。将多个IP地址与一个名称关联起来，可用于将对一个域名的大量访问分散到多个物理IP设备上。这允许 DNS 为繁忙的 Internet 服务器实现负载平衡。

<u>**使用多个 DNS 服务器分散 DNS 请求**</u>
“DNS 负载平衡”也与我上面描述的含义完全不同。在我对 DNS 服务器角色的讨论中，我谈到了每个区域除了主要服务器之外还应该至少有一个辅助 DNS 服务器。通常所说的主要原因是冗余，以防万一某些事情导致主服务器发生故障。但是，拥有一个从服务器也可以让 DNS 解析请求的负载在多个服务器之间得到平衡。事实上，一些繁忙的域专门为此设置了两台以上的服务器。

因此，“DNS 负载均衡”既可以指使用 DNS 将请求（如网页请求）的负载分散到使用 DNS 命名的设备上，也可以指将 DNS 请求的负载分散到自己身上。



###### 1.2.3.4-1-8 DNS 名称服务器增强功能：DNS 通知、增量区域传输和 DNS 更新（动态 DNS）（部分：1 2 3 4）

如本节前面的主题所述，域名系统服务器的操作基础在主要的 DNS 标准 RFC 1034 和 1035 中有详细说明。这些文件按照计算机行业标准已经相当古老了；它们于 1987 年发布。值得称赞的是 DNS 的设计者，他们最初放入 DNS 协议的大部分内容今天仍然有效并在使用。 DNS 的创建者知道它必须能够“扩展”到一个很大的规模，而该系统实际上已经成功地处理了互联网的扩展，其程度远远超过 15 年前任何人所能想象的。

正如最初定义的那样，域名系统要求通过编辑区域主服务器上的主文件来手动更新 DNS 信息。然后使用轮询/区域传输机制将该区域完整复制到从属服务器。当互联网络相对较小并且不经常更改区域时，此方法是令人满意的。

但是，在现代 Internet 中，大区域可能需要几乎不断地更改其资源记录。手动编辑和不断复制主文件可能是不切实际的，尤其是当它们变大时，并且让从属服务器在区域传输之间过时可能会导致可靠性和性能问题。出于这些原因，多年来已经提出了 DNS 服务器操作的多项增强功能。我将在这里仔细研究其中的三个。

<u>**自动化区域传输：DNS 通知**</u>

许多 DNS 管理员想要解决的第一个问题是依赖轮询来更新从属名称服务器。想象一下，您在最喜欢的在线音乐商店下了一张新音乐 CD 的订单，但它缺货——缺货。哪个更有意义：让您每 6 小时给他们打电话询问商品是否已到，直到它到达那里，或者让商店在商品出现时直接给您打电话？

答案是如此明显，以至于这个问题看起来很荒谬。然而 DNS 使用第一种模型：从名称服务器必须不断地“呼叫”它们的区域主服务器并询问它们“有什么变化了吗？”这既会产生不必要的流量，又会导致从属名称服务器从主名称服务器发生更改到执行下一次轮询时已过时。调整区域的刷新时间只允许在更改发生时在更多轮询或更陈旧之间进行选择；两者都不是真正的“好”。

为了改善这种情况，开发了一种新技术；它在 1996 年的 RFC 1996 中正式化，并于 1996 年发布（奇怪的巧合！）该标准，即区域更改的提示通知机制 (DNS NOTIFY)，定义了一种名为 Notify 的新 DNS 消息类型，并描述了其使用协议。 Notify 消息是标准 DNS 消息类型的变体，其中一些字段重新定义以支持此新功能。

当主从名称服务器都支持此功能时，当对资源记录进行修改时，主服务器将自动向其从服务器发送通知消息，说“您的CD已到达！”呃……“数据库已经改变”。 J slave 就好像它的 Refresh timer 刚刚过期一样。启用此功能可以显着增加刷新间隔，因为从服务器不需要不断轮询主服务器以获取更改。

**关键概念：**可选的 DNS 通知功能允许主名称服务器在对区域进行更改时通知从属名称服务器。这有两个好处：它减少了从属服务器为查明 DNS 信息是否发生变化而进行的不必要的轮询，并且还减少了从属名称服务器拥有过时记录的时间。

<u>**提高区域传输效率：增量传输**</u>

常规 DNS 的第二个问题是，每当对区域的任何部分进行更改时，都需要传输整个区域。 Internet 上有许多区域拥有不断变化的巨大主文件。以“.COM”区域的主文件为例；每次更改甚至一条记录都必须将整个内容复制到从属名称服务器，这超出了“低效”的范围——这简直是疯了！

RFC 1995，DNS 中的增量区域传输，指定了一种称为增量区域传输的新型区域传输。当此功能在区域中的主从名称服务器上实现时，主服务器会跟踪对数据库所做的最新更改。每次从服务器确定发生更改并且需要更新辅助数据库时，它会向主服务器发送一个 IXFR（增量传输）查询，其中包含从数据库当前副本的序列号。然后主服务器查看自该序列号为当前序列号以来哪些资源记录发生了更改，并仅将更新后的资源记录发送到辅助服务器。

为了节省存储空间，主服务器显然不会永远保留对其数据库所做的所有更改。它通常会跟踪对数据库的最后几次修改，以及与每个修改相关联的序列号。如果从服务器发送一个包含序列号的 IXFR 请求，而主服务器上仍然有最近的更改信息，则仅发送更改作为答复。如果请求的序列号太旧以至于主服务器不再具有自该数据库版本以来的某些更改的信息，则执行完整的区域传输而不是增量传输。

**关键概念：**DNS 增量区域传输增强功能使用一种特殊的消息类型，允许从名称服务器确定自上次与主服务器同步以来发生了哪些更改。通过仅传输更改，可以显着减少用于区域传输的时间和带宽量。

<u>**处理动态 IP 地址：DNS 更新/动态 DNS**</u>

“经典”DNS 的第三个问题是它假设很少对区域进行更改，因此可以通过手动编辑主文件来处理。有些区域非常大，以致于手动编辑主文件几乎是连续的。然而，问题不仅仅是不便。常规 DNS 假定主机的 IP 地址是相对静态的。然而，现代网络利用动态主机配置协议 (DHCP) 等主机技术为设备动态分配 IP 地址。当使用 DHCP 时，区域中每台主机的 IP 地址可能每周、每天甚至每小时更改一次！显然，使用人类和文本编辑器来跟上这种变化速度是没有希望的。

1997 年 4 月，RFC 2136 发布，标题为域名系统中的动态更新 (DNS UPDATE)。该标准描述了对允许动态更新 DNS 信息的基本 DNS 操作的增强。实施此功能后，生成的系统有时称为动态 DNS (DDNS)。

RFC 2136 定义了一种新的 DNS 消息类型：更新消息。与 Notify 消息一样，Update 消息是围绕常规 DNS 消息的结构设计的，但对几个字段的含义进行了更改。顾名思义，更新消息允许在区域的主名称服务器内有选择地更改资源记录。使用特殊的消息语法，可以添加、删除或修改资源记录。

显然，必须注意如何使用此功能；我们不希望任何人“随意”地对我们的主记录进行更改。该标准指定了验证更新消息的详细过程，以及必须实施的安全程序，以便服务器仅接受来自特定个人或系统的此类消息。

动态 DNS 允许管理员更轻松地进行更改，但只有当它用于将 DNS 与其他与地址相关的协议和服务集成时，其真正的威力才会显现出来。动态 DNS 解决了传统 DNS 的一个主要弱点：无法轻松地将主机名与使用 DHCP 等协议分配的地址相关联。

通过支持此功能的 DNS 服务器，可以将 DNS 和 DHCP 集成在一起，允许自动分配地址和名称，并在主机 IP 地址更改时自动更新 DNS 记录。动态 DNS 的一种常见应用是允许那些使用动态分配 IP 地址的服务提供商访问 Internet 的人使用 DNS 名称。某些目录服务（尤其是 Microsoft 的 Active Directory）同样使用动态 DNS 将地址与设备名称相关联。

**关键概念：**对 DNS 的增强，通常称为动态 DNS，允许自动更新服务器数据库中的 DNS 信息，而不是总是需要手动编辑主文件。这不仅可以节省管理员的时间和精力，还可以让 DNS 更好地处理动态地址分配，例如 DHCP 等主机配置协议执行的类型。



###### 1.2.3.4-2 DNS 解析概念和解析器操作

在前面的三个部分中，我已经描述了域名系统的名称空间、权限和注册机制以及名称服务器。这些元素都可以被视为 DNS 基础设施的一部分；它们是系统中必须首先建立起来才能使用的部分。一旦我们有了这些组件，我们就可以开始处理手头的业务了：名称解析。这是通过使用一组特定的过程来完成的，这些过程由称为解析器的 DNS 客户端执行。

在本节中，我将描述 DNS 名称解析器和名称解析过程本身。我首先概述了 DNS 解析器执行的功能以及它们的一般工作方式。然后我描述了 DNS 中使用的两种基本的名称解析方法：迭代和递归解析。我讨论了解析器通过本地解析和缓存提高效率的方式。我描述了实际名称解析算法中的步骤。然后，我将介绍名称解析的两个特殊情况：使用特殊的 IN-ADDR.ARPA 域进行反向名称解析，以及 DNS 使用邮件交换资源记录提供邮件支持的方式。

**相关信息：**本节中的信息补充了上一节中有关 DNS 名称服务器的信息。在此处的主题中，我假设您至少对 DNS 服务器有基本的了解。




###### 1.2.3.4-2-1 DNS 解析器功能和一般操作（部分：1 2）

我们在上一节中探索的 DNS 名称服务器可以说是整个系统中最重要的部分。毕竟，它们将所有数据存储在系统上，并在为它们命名时实际提供我们需要的地址；没有这些服务器，根本就没有 DNS。当然，如果没有人请求服务，服务器有什么用呢？系统中的客户端，称为解析器，也很重要，因为它们启动名称解析过程；解析器是“橡胶遇到道路”的地方，可以这么说。

DNS 解析器的操作在两个主要的 DNS 标准中进行了解释。 RFC 1034 描述了解析器执行的功能，以及它们如何工作的一般术语。这包括对用于进行名称解析的算法的讨论。 RFC 1035 更多地涉及解析器的实现细节，以及它们如何完成工作的细节。几个后续标准当然修改了这些基本标准，改变了解析器以不同方式工作的一些方式。

<u>**名称解析服务**</u>

正如 DNS 服务器的主要工作是存储 DNS 名称数据并在收到请求时“服务”它一样，DNS 解析器的主要工作是解析。 J 虽然大多数人只认为名称解析是将 DNS 名称转换为 IP 地址的过程，但这只是 DNS 执行的几种解析服务中的一种。一些最典型的 DNS 解析类型是：

- 标准名称解析：将 DNS 名称作为输入并确定其对应的 IP 地址。

- 反向名称解析：获取 IP 地址并确定与之关联的名称。

- 电子邮件解析：根据消息中使用的电子邮件地址确定将电子邮件 (e-mail) 消息发送到何处。

还有其他类型的解析活动，但同样，大多数名称解析请求属于“标准”类型，这使其成为我们讨论的主要焦点。

<u>**名称解析器执行的解析功能**</u>

为了完成其解析职责，名称解析器执行许多相关功能：

- 提供用户界面：为了使 DNS 对 TCP/IP 用户具有最大价值，名称必须能够与地址互换使用。这通常由解析器自动完成，解析器为用户提供一个界面，允许输入名称并像地址一样使用。

- 形成和发送查询：给定要解析的名称，DNS 解析器必须使用 DNS 消息传递系统创建适当的查询，确定要执行的解析类型，并将查询发送到适当的名称服务器。

- 处理响应：解析器必须接受它向其发送查询的 DNS 服务器的返回响应，并决定如何处理响应中的信息。正如我们将看到的，可能需要联系多个服务器以进行特定的名称解析。

这看起来相当简单，在某些方面确实如此，但实施起来可能会变得相当复杂。请记住，解析器可能需要同时“处理”几个未完成的名称解析。它必须跟踪不同的请求、查询和响应，并确保一切都井井有条。

用户界面是名称解析器工作中非常重要的一部分。我们希望用户能够只使用一个名称，并让他们的软件自动将其视为地址。出于这个原因，正常的名称解析通常不涉及显式运行一个“解析器软件”。再次考虑您的 Web 浏览器。您不必说“请找到 www.xyzindustries.com 的 IP 地址”，然后再说“请连接到 XYZ Industries 的这个 IP 地址”。您只需输入“www.xyzindustries.com”，名称解析就会“神奇地”发生。

当然，没有魔法。解析器只是隐式调用而不是显式调用。 Web 浏览器识别出输入的是名称而不是 IP 地址，并将其提供给解析器，说“我需要你解析这个名称，拜托”。 （嘿，礼貌一点也无妨。）然后解析器负责解析并将 IP 地址提供回 Web 浏览器，Web 浏览器连接到该站点。因此，解析器是用户（人类用户和软件用户、浏览器）和 DNS 系统之间的接口。

**关键概念**：DNS 中的主要客户端是称为 DNS 名称解析器的软件模块。它们负责从客户端软件接受名称、生成对 DNS 服务器的解析请求以及处理和返回响应。

<u>**名称解析器执行的其他功能**</u>
名称解析器不必执行与名称服务器几乎一样多的管理工作；在这方面，客户端通常比服务器简单。然而，许多名称解析器执行的一项重要支持功能是缓存。与名称服务器一样，如果再次需要相同的解析，名称解析器可以缓存它们执行的名称解析的结果以节省时间（但是，并非所有解析器都执行缓存。）

我应该指出，尽管解析器是与名称解析最相关的 DNS 组件，但名称服务器也可以在某些类型的名称解析中充当客户端。事实上，可以建立一个网络，让每台客户端机器上的解析器只做将解析请求发送到本地 DNS 服务器并让服务器处理的事情。在这种情况下，客户端解析器只不过是一个外壳，有时称为存根解析器。这具有集中网络名称解析的优点，但潜在的性能降低的缺点。



###### 1.2.3.4-2-2 DNS 基本名称解析技术：迭代和递归解析（部分：1 2 3 4）

传统的名称解析将 DNS 名称转换为 IP 地址。在最高层次上，这个过程可以被认为有两个阶段。在第一阶段，我们找到一个 DNS 名称服务器，该服务器具有我们需要的信息：与特定名称对应的地址。在第二阶段，我们向该服务器发送一个包含我们要解析的名称的请求，它会发回所需的地址。

<u>**名称解析的困难部分：找到正确的服务器**</u>
有点讽刺的是，第二阶段（名称到地址的实际映射）相当简单。第一阶段（找到合适的服务器）可能很困难，并且包含 DNS 名称解析中的大部分工作。虽然可能令人惊讶，但这是 DNS 结构的可预测结果。 DNS 中的名称信息不是集中的，而是分布在服务器的层次结构中，每个服务器负责 DNS 名称空间中的一个区域。这意味着我们必须遵循一系列特殊的步骤才能找到具有所需信息的服务器。

名称解析的正式过程与 DNS 名称空间、权威机构和服务器的树状层次结构平行。特定 DNS 名称的解析从名称的最一般部分开始，然后从它进行到最具体的部分。自然地，每个名称中最通用的部分是 DNS 树的根，在名称中表示为尾随的“.”，有时会被省略。下一个最具体的部分是顶级域，然后是二级域，依此类推。 DNS 名称服务器是“链接”的，因为一个级别的 DNS 服务器知道负责其下一级区域中子域的服务器的名称。

假设我们从完全限定域名 (FQDN)“C.B.A.”开始。形式上，每个名称解析都从树的根开始——这就是根名称服务器如此重要的原因。根名称服务器可能对这个名称具有权威性，但也可能不是；这不是根名称服务器通常用于的目的。根名称服务器所知道的是负责顶级域“A.”的服务器的名称。

“A”的名称服务器。反过来可能有信息来解决“C.B.A.”不过，它的级别仍然相当高，因此“C.B.A”可能不直接在其范围内。在那种情况下，它不会知道我们寻找的地址，但它会知道负责“B.A.”的服务器的名称。反过来，该名称服务器可能对“C.B.A.”具有权威性，或者它可能只知道“C.B.A.”的服务器地址，这将具有我们需要的信息。如您所见，名称解析中很可能需要多个不同的服务器。

**关键概念：**由于 DNS 名称信息存储为分布在许多服务器上的分布式数据库，因此通常无法使用单个请求/响应通信来执行名称解析。首先需要找到具有解析器所需信息的正确服务器。这通常需要一系列消息交换，从根名称服务器开始，一直向下到包含客户端所需资源记录的特定服务器。

<u>**DNS 名称解析技术**</u>

DNS 标准实际上定义了两种不同的方式来遵循这种服务器层次结构以发现正确的服务器。它们最终都会导致正确的设备，但它们在需要多个步骤时如何分配解决责任方面有所不同。

<u>**迭代解析**</u>
当客户端向名称服务器发送迭代请求时，服务器会返回请求的答案（对于常规解析，我们想要的 IP 地址）或具有该信息或更接近该信息的另一台服务器的名称.然后，原始客户端必须通过向此引用的服务器发送新请求来进行迭代，该服务器可能会再次回答它或提供另一个服务器名称。该过程一直持续到找到正确的服务器；该方法如图 243 所示。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\dnsiterative.png)


​                                                                                   **图 243：迭代 DNS 名称解析**

在此示例中，客户端正在为“C.B.A.”执行名称解析。使用严格的迭代解决方案。因此，它负责形成所有 DNS 请求并处理所有回复。它首先向这个神秘层次结构的根名称服务器发送请求。该服务器没有“C.B.A.”的地址，因此它返回“A.”的名称服务器地址。客户端然后将其查询发送到该名称服务器，该服务器将客户端指向“B.A.”的服务器。该名称服务器将客户端指向实际具有“C.B.A.”地址的名称服务器，该地址将其返回给客户端。对比图 244。

<u>**递归解析**</u>

当客户端向名称服务器发送递归请求时，如果服务器有所查找的信息，则服务器会用答案进行响应。如果不是，则服务器负责通过代表原始客户端成为客户端并向其他服务器发送新请求来找到答案。原始客户端只发送一个请求，最终得到它想要的信息（如果不可用则返回错误信息）。该技术如图 244 所示。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\dnsrecursive.png)


​                                                                    **图 244：递归 DNS 名称解析**

这与我在图 243 中显示的理论 DNS 解析相同，但这一次，客户端要求名称服务器执行递归解析，并且他们同意这样做。与迭代情况一样，客户端将其初始请求发送到根名称服务器。该服务器没有“C.B.A.”的地址，但不是仅仅向客户端返回“A.”的名称服务器地址，而是向该服务器本身发送请求。该名称服务器向服务器发送“B.A.”请求，而服务器又向服务器发送“C.B.A.”请求。 “C.B.A.”的地址然后从“C.B.A.”的服务器返回请求链。到“B.A.”，然后是“A.”，然后是根，最后返回给客户。

<u>**对比迭代和递归解析**</u>

为了帮助解释这些方法之间的区别，让我们顺便看看一个真实的案例。假设您要查找多年未联系的老朋友卡罗尔的电话号码。你打电话给你的朋友乔；他没有 Carol 的电话号码，但他给了你 John 的电话号码，建议你给他打电话。所以你拨通了约翰；他没有这些信息，但他知道 Carol 最好的朋友 Debbie 的电话号码，并将其提供给您。你打电话给黛比，她给你卡罗尔的信息。这是一个迭代过程的例子。相反，假设您打电话给乔，乔说“我不知道，但我想我知道如何找到答案”。他给约翰打了电话，然后给黛比打了电话，然后用电话号码给你回了电话。这就像递归解析。

所以本质上，迭代是自己完成工作，而递归是“推卸责任”。您可能认为每个人都希望使用递归，因为它让“其他人”来完成工作。这是事实，但如果未经许可，“推卸责任”不被视为良好的形式。并非所有名称服务器都支持递归，尤其是靠近层次结构顶部的服务器。显然，我们不希望根名称服务器以及处理“.COM”和其他关键 TLD 的服务器因执行递归而陷入困境。正是出于这个原因，客户端必须请求名称服务器为它们执行递归。

经常使用递归的一个地方是网络上的本地名称服务器。解析器通常生成对本地 DNS 服务器的递归请求，然后根据需要生成对其他服务器的迭代请求，而不是让客户端机器解析器执行迭代解析。如您所见，递归和迭代请求可以组合在一个解决方案中，从而为整个流程提供显着的灵活性。这在详细介绍 DNS 名称解析过程的主题中的一个更真实的示例中进行了演示。

同样，请记住，为了理解解析，DNS 服务器实际上可以充当客户端。一旦 DNS 服务器接受了对其无法自行解析的名称的递归解析请求，它就会成为该过程中的客户端。我还应该指出，解析器通常不知道一个而是两个本地 DNS 服务器的名称，因此如果到达第一个时出现问题，他们可以尝试第二个。

**关键概念：**DNS 中名称解析的两种方法是迭代解析和递归解析。在迭代解析中，如果客户端向不具有客户端所需信息的名称服务器发送请求，服务器将返回指向不同名称服务器的指针，并且客户端向该服务器发送新请求。在递归解析中，如果客户端向没有请求信息的服务器发送请求，则该服务器负责向其他服务器发送请求以查找必要的记录，然后将它们返回给客户端。执行此操作的服务器对其他服务器的请求承担客户端的角色。



###### 1.2.3.4-2-3 DNS 名称解析效率改进：缓存和本地解析（部分：1 2 3）

从算法的角度来看，基本的解析技术——迭代和递归——可以被认为是“完整的”。通过从顶部（根）开始并向下工作，我们“保证”始终最终到达具有我们所需信息的服务器。我把“保证”放在引号中只是因为一如既往，网络中没有真正的“保证”——例如，我们可能要求一个不存在的名称，或者服务器可能有错误数据。但在没有此类非典型问题的情况下，该过程最终会导致信息。

问题是最后一个词：“最终”。迭代和递归解析都会让我们找到正确的服务器，但它们需要很长时间才能完成，尤其是当我们试图解析的名称位于 DNS 层次结构的“深层”部分时（例如，“F.E.D.C.B.A.”） ).由于解决方案经常进行，因此定义对基本解决方案过程的更改以尽可能提高效率是很有帮助的。

<u>**缓存的动机：参考位置**</u>
称为局部参考的计算机科学原理描述了与计算机（和网络）的使用方式相关的两种常见现象。第一个，有时称为引用的空间局部性，观察到如果资源靠近最近引用的另一个资源，则该资源更有可能被引用。第二，引用的时间局部性，表示资源如果最近被访问过，则更有可能被访问。

我们可以用浏览网页的例子来观察这两种现象。要观察引用的空间局部性，请注意访问 http://www.tcpipguide.com 等网站时会发生什么。初始请求向服务器请求 TCP/IP 指南的主要索引文档。但是，该文档包含指向多个图像和其他项目的链接，所有这些也都位于“tcpipguide.com”域中。当您的浏览器要求提供主文档时，不久之后还会要求提供一些图形。当然，当您浏览站点时，您将单击链接转到其他网页。同样在这里，其中大部分也将位于同一域“tcpipguide.com”中。

这意味着如果我们解析了一个特定的域名，很可能我们很快就需要再次解析它。几十次询问同一个域服务器，每次都要求它解析相同的名称，这将是愚蠢的。

第二种现象，参考时间局部性，您可能已经注意到了。与一年未曾查看的资源相比，您更有可能访问最近使用过的资源。这意味着维护有关最近使用的资源的信息可能具有内在优势。

<u>**名称解析器缓存**</u>

这两种现象是一般计算机世界缓存的基本原理，正如我们所见，尤其是在 DNS 服务器中。同样的优势也适用于解析器，它们中的许多也执行缓存，其方式与在服务器中的执行方式非常相似。在特定的客户端计算机上，一旦特定的名称被解析，它就会被缓存起来并在下次需要时保持准备就绪。同样，这消除了 DNS 服务器上的流量和负载。 （但请注意，并非所有解析器都执行缓存。）

您可能想知道为什么我们费心在解析器和服务器上进行缓存。这并不像看起来的那样“多余”。或者更确切地说，它是多余的，但以一种好的方式。要理解其中的原因，我们非常认识到缓存中的一个基本权衡是缓存提供更好的性能，它离数据请求者越近，但覆盖范围越远，它离用户越远。

如果解析器不缓存结果但我们的本地服务器缓存了结果，我们可以从服务器的缓存中获取信息，但需要等待查询和响应的交换。解析器的缓存“更接近”用户，因此效率更高。同时，这并没有消除在我们网络的本地 DNS 服务器上进行缓存的需要。服务器比解析器离用户更远，但它的缓存被许多机器共享。他们都可以从它的缓存中获益，这样一来，如果我查找了一个特定的名称，几分钟后其他人又查找了，他们就可以使用我缓存的分辨率，即使他们是第一次输入它。

名称解析器缓存遵循与名称服务器缓存相同的一般原则和规则。资源记录的时间量由其生存时间数字指定。此外，解析器不会缓存某些查询的结果，例如反向查找，并且如果他们怀疑由于某种原因返回的数据不可靠或已损坏，则解析器也可能不会缓存解析。

**关键概念：**除了 DNS 名称服务器执行的缓存之外，许多（但不是全部）DNS 解析器还缓存最近解析请求的结果。在开始名称解析之前检查此缓存，以在对同一名称进行多个请求时节省时间。

<u>**本地解析**</u>***Local Resolution\***

另一个可以提高解析效率的领域是我们尝试解析我们自己组织中的计算机名称的特殊情况。假设我是 XYZ Industries 的一名员工，想使用 FTP 从“sales.xyzindustries.com”获取一些销售信息。我的 FTP 客户端将调用我的本地解析器来解析该名称，方法是将其发送到我们的本地 DNS 服务器。现在，对于位于公司内部的服务器来说，在根名称服务器上启动解析过程是否明智？并不真地。

接受来自网络上解析器的本地解析请求的本地 DNS 服务器实际上可能是“sales.xyzindustries.com”的权威名称服务器。在其他情况下，它可能知道如何直接回答某些解决请求。显然，服务器在前往根服务器之前检查它是否可以回答解析器的查询是有意义的，因为这为客户端提供了更快的答案并节省了互联网流量。这称为局部分辨率。

在开始“正式的”自上而下的解析过程之前，大多数 DNS 服务器将执行此检查以查看它们是否具有请求所需的信息。例外是不维护任何区域信息的 DNS 服务器：仅缓存服务器。在某些情况下，客户端计算机上的 DNS 解析器也可以访问某些本地区域信息，在这种情况下，他们可以使用它而不是发送解析查询。

还有一件事我还想指出：大多数操作系统还支持使用旧的主机表机制，这对网络上的本地机器很有用。如果主机有主机表，解析器将检查主机表以查看它是否可以找到名称的映射，然后再进行更耗时的 DNS 解析过程。这在技术上不是 DNS 的一部分，但通常与它结合使用。



###### 1.2.3.4-2-4 DNS 名称解析过程（部分：1 2 3）

在前面的主题中，我描述了名称解析器的作用，解释了使用迭代和递归解析的基本自上而下解析过程，并讨论了如何使用本地解析和缓存来提高解析性能。现在我想将所有这些背景材料结合在一起，最后向您展示名称解析过程是如何作为一个整体工作的！

像往常一样，最好的方法就是以身作则。在这里，我实际上结合了我之前使用过的两个例子：虚构的公司“XYZ Industries”和不存在的大学Googleplex University。假设 XYZ Industries 为“xyzindustries.com”区域运行自己的 DNS 服务器。主名称服务器称为“ns1.xyzindustries.com”，从名称服务器是，“ns2.xyzindustries.com”。这些也用作客户端机器上解析器的本地 DNS 服务器。对于此示例，我们假设通常情况下，我们的 DNS 服务器将接受来自公司内部机器的递归请求，但不会假设其他机器将接受此类请求。我们还假设服务器和解析器都执行缓存，并且缓存是空的。

假设 Googleplex 大学为“googleplex.edu”域运行自己的 DNS 服务器，正如我在描述 DNS 区域的主题中的示例中给出的那样。共有三个子域：finearts.googleplex.edu、compsci.googleplex.edu 和 admin.googleplex.edu。其中，compsci.googleplex.edu 位于具有专用服务器的单独区域中，而其他子域位于“googleplex.edu”区域中（如图 240 所示。）

<u>**解析过程步骤**</u>

现在，假设您是 XYZ Industries 的一名员工，您的一位客户负责 Googleplex U 的网络部门。您在 Web 浏览器中键入该部门的 Web 服务器的地址，“www.net.compsci.googleplex.edu ”。简而言之，该过程将涉及以下一组步骤（图 245 以图形方式显示该过程）：

1. 您的 Web 浏览器识别名称请求并调用您的本地解析器，将名称“www.net.compsci.googleplex.edu”传递给它。

2. 解析器检查其缓存以查看它是否已经具有该名称的地址。如果是，它立即将它返回给 Web 浏览器，但在本例中我们假设它没有。解析器还会检查它是否具有本地主机表文件。如果是，它会扫描文件以查看此名称是否具有静态映射。如果是这样，它会立即使用此信息解析名称。再一次，让我们假设它没有，因为那会很无聊。

3. 解析器生成递归查询并将其发送到“ns1.xyzindustries.com”（当然，使用该服务器的 IP 地址，解析器知道）。

4. 本地 DNS 服务器接收请求并检查其缓存。同样，我们假设它没有所需的信息。如果是，它会将标记为“非权威”的信息返回给解析器。服务器还会检查它的区域资源记录中是否有可以解析“www.net.compsci.googleplex.edu”的资源记录。在这种情况下，当然不是，因为它们处于完全不同的域中。

5. “ns1.xyzindustries.com”生成对名称的迭代请求并将其发送到根名称服务器。

6. 根名称服务器不解析该名称。它返回“.edu”域的名称服务器的名称和地址。

7. “ns1.xyzindustries.com”生成一个迭代请求并将其发送到“.edu”的名称服务器。

8. “.edu”的名称服务器返回“googleplex.edu”域的名称服务器的名称和地址。

9. “ns1.xyzindustries.com”生成一个迭代请求并将其发送到“googleplex.edu”的名称服务器。

10. “googleplex.edu”的名称服务器查询其资源记录。但是，它看到这个名称位于“compsci.googleplex.edu”子域中，该子域位于一个单独的区域中。它返回该区域的名称服务器。

11. “ns1.xyzindustries.com”生成一个迭代请求并将其发送到“compsci.googleplex.edu”的名称服务器。

12. “compsci.googleplex.edu”的名称服务器是“www.net.compsci.googleplex.edu”的权威名称服务器。它将该主机的 IP 地址返回给“ns1.xyzindustries.com”。

13. “ns1.xyzindustries.com”缓存了这个解析结果。 （请注意，它可能还会缓存它在步骤 #6、#8 和 #10 中收到的一些其他名称服务器解析；我没有明确显示这些。）

14. 本地名称服务器将解析返回给本地计算机上的解析器。

15. 您的本地解析器也会缓存信息。

16. 本地解析器将地址提供给您的浏览器。

17. 您的浏览器开始向 Googleplex 机器的 IP 地址发出 HTTP 请求。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\dnsresolution.png)

​                                                                          **图 245：DNS 名称解析过程示例**

这个相当复杂的示例说明了使用迭代和递归解析的典型 DNS 名称解析。用户在 Web 浏览器中输入 DNS 名称（“www.net.compsci.googleplex.edu”），这会导致从她的客户端计算机的解析器向本地 DNS 名称服务器发出 DNS 解析请求。该名称服务器同意代表解析器递归解析名称，但使用迭代请求来完成它。这些请求被发送到 DNS 根名称服务器，然后依次是“.edu”、“googleplex.edu”和“compsci.googleplex.edu”的名称服务器。 IP 地址随后被传递到本地名称服务器，然后返回到用户的解析器，最后返回到她的 Web 浏览器软件。



看起来相当复杂和缓慢。当然，计算机的工作速度比你阅读（或者我可以打字）的速度要快。即使如此，缓存的好处也是显而易见的——如果名称在解析器或本地 DNS 服务器的缓存中，大部分这些步骤将被避免。

<u>**改变解析以处理特殊情况**</u>

此示例已高度简化，并且也仅显示了一种可能的服务器设置方式。一方面，即使“compsci.googleplex.edu”与“googleplex.edu”位于不同的区域，它们也可能使用同一台服务器。在这种情况下，过程中的一次迭代将被跳过。上面的示例也没有显示如果过程中发生错误会发生什么。

如果输入的域名是别名，由 CNAME 记录指示，这也会更改处理。 CNAME 记录用于允许向外界呈现设备的“恒定”名称，同时允许与该名称相对应的实际设备在组织内部发生变化。当使用 CNAME 时，它通过添加一个额外的步骤来更改名称解析过程：首先我们将别名解析为规范名称，然后再解析规范名称。

例如，Web 服务器的名称几乎总是以“www.”开头，因此在 XYZ Industries，我们希望人们能够通过“www.xyzindustries.com”找到我们的网站。然而，Web 服务器实际上可能与“bigserver.xyzindustries.com”上的其他服务共享。我们可以设置一条CNAME记录，将“www.xyzindustries.com”指向“bigserver.xyzindustries.com”。 “www”的解析将导致 CNAME 指向“bigserver”，然后它自己被解析。如果将来我们的业务增长并且我们决定升级我们的 Web 服务以在“biggerserver.xyzindustries.com”上运行，我们只需更改 CNAME 记录并且用户不受影响。



###### 1.2.3.4-2-5 使用 IN-ADDR.ARPA 域的 DNS 反向名称解析（部分：1 2 3 4）

如果大多数人不得不将域名系统的核心工作归结为一项功能，他们可能会说这是将对象的名称转换为与之关联的数字 IP 地址。好吧，如果他们对 DNS 了解很多的话，他们会的。因此，有时将 DNS 比作电话簿或电话“411”服务。这个类比有一定的问题，但在最高层次上它是有效的。在这两种情况下，我们都取一个名字，查询（一种或另一种类型的）数据库，并从中产生一个与该名字相匹配的数字。

<u>**反向名称解析的必要性**</u>
在现实世界中，有时您不想找到与姓名相关的电话号码，而是您有一个电话号码并想知道它属于哪个人。例如，如果您的电话记录了来电号码但您没有来电显示来显示与号码关联的姓名，则可能会发生这种情况。您可能还会在一张纸上找到一个电话号码，但不记得它是谁的号码。

同样，在网络世界中，在很多情况下我们都有一个 IP 地址并想知道它的名称。例如，万维网服务器在其服务器日志中记录了连接到它的每台设备的 IP 地址，但这些数字对人类来说通常毫无意义，他们更喜欢看到与之相关的名称。

一个更严重的例子可能是黑客试图闯入您的计算机；通过将 IP 地址转换为名称，您可能能够找出他来自世界的哪个部分，他使用的是哪个 ISP，等等。出于设置或故障排除目的，网络管理员可能想要找出与地址相关的名称的原因也有很多。

<u>**原始方法：反向查询**</u>
DNS 最初包含一个称为反向查询的功能，它允许这种类型的“相反”解析。解析器可以发送一个查询，而不是填写名称和服务器填写 IP 地址的空格，而是填写 IP 地址和名称的空格。服务器将检查其资源记录并将名称返回给解析器。

这在理论上工作得很好，即使在互联网非常小的情况下在实践中也是如此。但是，请记住，由于 DNS 信息的分布式特性，解析工作的最大部分实际上是找到正确的服务器。现在，在常规解析的情况下，我们可以通过遍历服务器的层次结构轻松找到正确的服务器。这是可能的，因为服务器按照名称层次结构连接在一起。

但是，DNS 服务器不是根据 IP 地址排列的。这意味着要使用反向查询，我们必须为要解析为名称的 IP 地址使用正确的名称服务器，而没有简单的方法可以找出它是什么。当然，我们可以尝试将反向查询发送到层次结构中每个区域的权威 DNS 服务器。如果您尝试过，您可能会比编写本指南花费的时间更长。所以我们不要去那里。所有这一切的最终结果是，除了本地服务器故障排除外，逆向查询从未流行过。它们于 2002 年 11 月通过 RFC 3425 的发布正式从 DNS 中删除。

<u>**用于反向解析的 IN-ADDR.ARPA 名称结构**</u>

这里的问题是服务器是按名称排列的，而不是 IP 地址。因此，解决方案听起来很简单：按 IP 地址排列服务器。这并不意味着我们删除名称层次结构，或复制所有服务器，或任何类似的愚蠢行为。相反，我们创建了一个额外的数字层次结构，它与名称层次结构共存。然后我们使用它从数字中查找名称，使用通常称为反向名称解析的过程。

互联网的名称层次结构是使用一个名为“IN-ADDR.ARPA”的特殊域实现的，该域位于保留的“.ARPA”顶级域中（“IN-ADDR”代表“互联网地址”。回想一下“。 ARPA”最初用于将旧的 Internet 主机转换为 DNS，现在被运行 Internet 的人们用于各种目的。

在覆盖整个 IP 地址空间的“IN-ADDR.ARPA”中创建了一个特殊的数字层次结构：

- 在“IN-ADDR.ARPA”中的第一层有 256 个子域，称为“0”、“1”、“2”等，最多为“255”。例如，“191.IN-ADDR.ARPA”。 （实际上可能不会有全部 256 个，因为一些 IP 地址是保留的，但我们暂时忽略它）。

- 在上述每个子域中，还有 256 个二级子域，编号方式相同。因此，例如，其中之一是“27.191.IN-ADDR.ARPA”。

- 同样，在上述每一层中的第三级有 256 个子域，例如“203.27.191.IN-ADDR.ARPA”

- 最后，每个三级子域内还有256个第四级子域，如“8.203.27.191.IN-ADDR.ARPA”。

该结构如图 246 所示。如您所见，在“IN-ADDR.ARPA”中，我们创建了一个与 Internet 协议的地址空间平行的名称空间。 （是的，这意味着在这部分 Internet DNS 名称空间中有数十亿个节点和分支！）

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\dnsinaddrarpa.png)


​                                                       **图 246：DNS IN-ADDR.ARPA 反向名称解析层次结构**

创建了特殊的“IN-ADDR.ARPA”层次结构，以便轻松反向查找 DNS 名称。 “IN-ADDR.ARPA”包含编号为0到255的256个子域，每个子域都有编号为0到255的256个子域，依此类推，向下四层。因此，每个 IP 地址都在层次结构中表示。在此图中，我以 DNS 域名“www.xyzindustries.com”为例进行了展示。它将有一个常规资源记录指向其 IP 地址 191.27.203.8，以及一个反向解析记录 8.203.27.191.IN-ADDR.ARPA，指向域名“www.xyzindustries.com”。

<u>**反向解析的资源记录设置**</u>

有了 IN-ADDR.ARPA 结构，我们现在可以将这个名称空间中的一个条目与“真实”DNS 名称空间中的每个条目相关联。我们使用“PTR”（指针）资源记录类型来执行此操作。例如，如果“www.xyzindustries.com”的 IP 地址为 191.27.203.8，则其区域的 DNS 服务器将有一个地址资源记录表明这一点。在主文件文本格式中，它会这样说：

​                             www.xyzindustries.com.  191.27.203.8
但是，在 IN-ADDR.ARPA 域中还会有以下条目：

​                             8.203.27.191.IN-ADDR.ARPA PTR www.xyzindustries.com
（请记住，DNS 名称不区分大小写，因此“IN-ADDR.ARPA”也可以作为“in-addr.arpa”给出）。

完成此操作后，可以通过对“8.203.27.191.in-addr.arpa”进行名称解析来轻松执行反向名称解析。如果我们这样做，“IN-ADDR.ARPA”域的服务器将返回给我们名称“www.xyzindustries.com”。这也显示在图 246 中。



<u>**为什么 IN-ADDR.ARPA 结构与普通 IP 地址相反**</u>

我相信您已经注意到 IN-ADDR.ARPA 域中的数字是“向后”的。我们已经看到了这样做的原因：名称解析从最不具体到最具体的元素进行，从右到左。相比之下，IP 地址在左侧具有最不具体的八位字节，而在右侧具有最具体的八位字节。因此，我们反转它们以保持与 DNS 名称空间的一致性。

这立即为我们带来了一个额外的好处。正如我们可以授权部分常规名称空间，例如，让“XYZ Industries”负责“xyzindustries.com”中的所有内容，我们也可以授权部分 IN-ADDR.ARPA 名称空间.例如，由于麻省理工学院拥有所有第一个八位字节为 18 的 IP 地址——至少我认为他们现在仍然这样做——如果麻省理工学院愿意，他们也有可能控制“18.IN-ADDR.ARPA”域反向查询。如果不像我们所做的那样反转八位字节，这是不可能的。

**请注意，**为了使该系统可靠地工作，“常规”名称空间和反向名称空间中的数据必须保持一致。每当注册一个新的 DNS 名称时，也必须在 IN-ADDR.ARPA 中进行适当的输入。已实施特殊程序以允许自动创建这些指针条目。

**相关信息：**使用不同反向域的类似方案用于 IPv6 下的 DNS。

**关键概念：**大多数名称解析都要求我们将 DNS 域名转换为 IP 地址。但是，在某些情况下，我们希望通过从 IP 地址开始并找出与之匹配的域名来执行反向名称解析。使用传统的 DNS 分布式名称层次结构很难做到这一点，因为没有简单的方法可以使用常规 DNS 名称层次结构找到包含特定 IP 地址条目的 DNS 服务器。为此，为反向名称查找设置了一个名为 IN-ADDR.ARPA 的特殊层次结构。该层次结构包含四个级别的数字子域结构，因此每个 IP 地址都有自己的节点。 IP 地址的节点包含一个条目，该条目指向与该地址关联的 DNS 域名。



###### 1.2.3.4-2-6 DNS 电子邮件支持和邮件交换 (MX) 资源记录（部分：1 2）

大多数精明的 Internet 用户都知道域名系统的存在，并且通常将其与最常见的 Internet 应用程序相关联。在这些应用程序中，“大魔王”当然是万维网。大多数 DNS 名称解析请求可能是由于每天在浏览器中输入数十亿次 Web 服务器域名以及用户鼠标单击和基于 Web 的应用程序生成的命名页面请求而产生的.

当然，DNS 并不专门绑定到任何一个应用程序。我们可以在 IP 地址所在的任何地方指定名称。例如，您可以使用 DNS 名称代替 FTP 客户端的地址，甚至可以用于 traceroute 或 ping 等故障排除实用程序。解析器将在每种情况下负责为您翻译名称。

有一种应用程序一直使用 DNS，但当您想到 DNS 时通常不会想到它：电子邮件。电子邮件实际上比任何其他 TCP/IP 应用程序都更依赖于 DNS。考虑一下，虽然您有时可能会为 traceroute 之类的命令键入 IP 地址，或者甚至将其键入浏览器，但您可能从未通过在电子邮件客户端中输入“joe@14.194.29.60”来向任何人发送邮件。至少我十几年来从未上网过。您改为键入“joe@xyzindustries.com”，DNS 会负责确定 XYZ Industries 的电子邮件将发送到哪里。

<u>**电子邮件名称解析的特殊要求**</u>
电子邮件地址的名称解析不同于 DNS 中的其他应用程序，原因有我在 TCP/IP 电子邮件寻址和地址解析概述主题中描述的三个原因。总结一下：首先，我们可能不希望电子邮件准确地到达地址指定的机器；其次，我们需要能够在不更改每个人的电子邮件地址的情况下更改服务器名称；第三，我们需要能够支持多个服务器来处理邮件。

例如，XYZ Industries 可能希望使用名为“mail.xyzindustries.com”的专用邮件服务器来处理收到的邮件，但实际上将其所有电子邮件地址构造为使用“@xyzindustries.com”。这使得地址更短，并允许在不影响用户地址的情况下更改服务器名称。如果公司愿意，它可能会决定使用两台服务器，“mail1.xyzindustries.com”和“mail2.xyzindustries.com”，以实现冗余，并且再次只使用“@xyzindustries.com”作为地址。

<u>**邮件交换 (MX) 记录及其使用**</u>

为了允许这些情况所需的灵活性，定义了一种特殊的 DNS 资源记录类型，称为邮件交换 (MX) 记录。每个 MX 记录指定一个特定的邮件服务器，用于处理特定域的传入电子邮件。建立此记录后，电子邮件消息的解析与常规解析的工作方式非常相似。假设我们要发送电子邮件至“joe@xyzindustries.com”。大致过程如下：

1. 我们的电子邮件客户端调用我们本地机器上的解析器来对“xyzindustries.com”执行电子邮件解析。

2. 我们的本地解析器和本地 DNS 服务器按照 DNS 名称解析主题中描述的过程找到“xyzindustries.com”的权威服务器，即“ns1.xyzindustries.com”。

3. “ns1.xyzindustries.com”找到“xyzindustries.com”的 MX 记录并回复表明“mail.xyzindustries.com”应该用于电子邮件。

当然，电子邮件客户端实际上不能向“mail.xyzindustries.com”发送任何内容；它需要它的 IP 地址。因此，它必须解析该名称。当然，这个解析请求很可能会在刚刚处理 MX 请求的同一个 DNS 名称服务器上结束。为消除两个单独解析的低效率，DNS 名称服务器可以合并这些信息。在上面的示例中，“ns1.xyzindustries.com”将在上面第 3 步发送的 DNS 消息的附加部分中包含“mail.xyzindustries.com”的 A（地址）资源记录。

也可以为特定域指定多个 MX 记录，每个记录指向不同的邮件服务器名称。这提供了冗余，因此如果一台邮件服务器出现问题，另一台可以弥补这一不足。 DNS 允许为每个邮件服务器指定一个优先值，因此您可以清楚地指出哪个是主邮件服务器，哪个是第一备份，第二备份等等。 DNS 服务器将首先选择偏好值最低的邮件服务器，然后选择次高的邮件服务器，依此类推。

**关键概念：**由于电子邮件是使用主机名而不是 IP 地址发送的，因此 DNS 包含支持站点间电子邮件传输的特殊规定。设置特殊邮件交换 (MX) DNS 资源记录，其中包含域要用于处理传入电子邮件的邮件服务器的名称。在向站点发送电子邮件之前，设备会执行名称解析以获取该站点的 MX 记录，因此它知道将消息发送到哪里。

<u>**过时的电子邮件资源记录**</u>
请注意，RFC 1035 最初还定义了其他几种与电子邮件相关的资源记录类型：邮箱 (MB)、邮件组 (MG) 和邮件重命名 (MR) 资源记录。这些在标准中被称为“实验性”。我认为实验失败了，不管它是什么，因为我不相信今天使用这些。还有两个更古老的与邮件相关的资源记录，邮件目的地 (MD) 和邮件转发器 (MF)，它们一定曾经被使用过，但在编写 RFC 1035 本身时已经过时了。



###### 1.2.3.4-3 DNS 消息和消息、资源记录和主文件格式

网络就是连接设备之间的信息通信。在域名系统的情况下，在 DNS 执行的多种操作中的每一种操作期间，都会交换有关互联网上的名称和对象的信息。这涉及在设备之间发送消息。与大多数协议一样，DNS 使用自己的一组具有不同字段格式的消息，并遵循一组特定的规则来生成它们并通过互联网传输它们。

在本节中，我解释了消息是如何在 DNS 中生成和发送的，还描述了用于消息和资源记录的格式。我首先概述 DNS 消息及其生成和传输方式的讨论。我提供了一般 DNS 消息格式及其包含的五个部分的概述。我描述了用于名称的符号和有助于减小 DNS 消息大小的特殊压缩方法。然后我在 DNS 消息标头和问题部分显示字段。我说明了用于所有资源记录的通用字段格式，以及最重要的记录类型中的特定字段。最后，我将描述用于 DNS 文本主文件的格式。



###### 1.2.3.4-3-1 DNS 消息生成和传输（部分：1 2）

在前面的部分中，我们探讨了 DNS 服务器和解析器执行的许多不同任务：常规名称解析、反向名称解析、电子邮件解析、区域传输等等。这些操作中的每一个都需要在一对 DNS 设备之间交换信息。与许多其他 TCP/IP 协议一样，DNS 旨在使用客户端/服务器模型完成此信息传输。所有 DNS 交换都从客户端发送请求开始，然后服务器返回一个答案。

<u>**DNS 客户端/服务器消息传递概述**</u>
在关于 TCP/IP 的客户端/服务器性质的概述主题中，我解释了关于这些术语的潜在混淆来源：事实上，它们指的是硬件角色、软件角色和事务角色。当涉及到 DNS 时，这个问题绝对适用。我们已经看到 DNS 实现由两组软件元素组成：充当客户端的解析器和当然是服务器的名称服务器。解析器软件通常在 PC 等客户端机器上运行，而名称服务器软件通常在专用服务器硬件上运行。

但是，这些指定是基于硬件和软件的整体作用。从消息传递的角度来看，“客户端”是通信的发起者，而不管这个发起是什么类型的机器，而“服务器”是响应客户端的设备。解析器通常充当客户端，名称服务器充当服务器。然而，在特定的交换中，至少在两种情况下，DNS 名称服务器实际上可以充当客户端。首先，在递归名称解析中，服务器向其他服务器生成请求，因此充当客户端。其次，在区域传输等管理功能中，一台服务器充当客户端并向另一台服务器发送请求。 （顺便说一下，在 DNS 中，我不知道解析器在何处充当服务器。）

DNS 中的大多数事务都由单个查询消息和单个响应消息的交换组成。作为事务客户端的设备创建查询并将其发送到服务器；然后服务器发回一个回复。这是通过下一主题中描述的过程完成的。在某些需要发送大量数据的情况下，例如区域传输，服务器可能会发回多条消息。可能需要多个此类事务才能执行完整的名称解析，如我的 DNS 解析过程示例所示。

<u>**使用 UDP 和 TCP 的 DNS 消息传输**</u>

TCP/IP 当然有两种不同的数据传输协议：用户数据报协议 (UDP) 和传输控制协议 (TCP)。 UDP 和 TCP“共享”TCP/IP 中的第 4 层，因为它们在功能和操作方面截然不同。一些应用程序协议需要 TCP 的服务并可以利用它来利用它们，而其他应用程序协议则更适合使用更简单的 UDP。 DNS 本身就是在协议族中同时使用 UDP 和 TCP 的正当理由的完美示例，因为它同时使用了两者。

<u>**UDP 消息传输**</u>
UDP 是一种简单的无连接协议，不提供任何实际功能但速度非常快。它非常适合小型、快速的信息交换，并且可以比 TCP 更快，因为不需要建立连接。这使得它成为 DNS 中使用的大多数常规查询的不错选择，因为它们通常很短，而且快速数据交换很重要。出于这个原因，DNS 标准建议使用 UDP 作为常规和反向名称解析的一部分进行查询和回复。 UDP DNS 消息限制为 512 字节；较长的消息将被截断，并在标头中设置一个特殊位以指示已发生这种情况。如果被截断的消息对其接收者造成问题，则必须使用 TCP 重复查询，如下所述。

**注意：如果实施可选的 DNS 扩展机制 (EDNS0)，则可以超过 DNS UDP 消息的 512 字节限制。这些在 RFC 2671 中有描述。**

<u>**TCP 消息传输**</u>
由于 UDP 不提供可靠的消息传递，因此 DNS 客户端必须跟踪它们发送的请求。如果在特定时间后未收到响应，则必须重新传输请求。需要处理这些细节被认为是可以接受的权衡，因为 UDP 涉及的设置成本较低，例如不需要连接。发送重传的速率通常至少设置为 2 到 5 秒，以防止互联网上出现过多的 DNS 流量。

对于某些特殊的 DNS 事务，UDP 根本不合适。这种交易最常见的例子是区域传送。虽然区域传输的查询很小，但作为响应发送的数据量可能非常大。 UDP 的 512 字节限制甚至还不够。此外，我们确实需要确保区域传输可靠地完成并具有流量控制和其他数据传输管理功能，否则我们可能会在我们的辅助 DNS 服务器数据库中损坏区域信息。

解决方案是对这些类型的交换使用 TCP。 TCP 允许消息的长度是任意的，并且作为面向连接的、公认的、可靠的协议，自动提供我们需要的机制来确保区域传输和其他冗长的操作成功完成。成本是建立连接所需的少量开销，但由于区域传输很少（与常规名称解析的绝对数量相比），这不是问题。

您可以看到 DNS 如何很好地说明 TCP 和 UDP 在 TCP/IP 中的作用。由于可以使用两种传输协议，因此名称服务器会在同一个众所周知的端口号 53 上同时侦听 UDP 和 TCP 请求。作为客户端的设备使用临时端口号进行交易。所有 DNS 消息都以单播方式从一台设备直接发送到另一台设备。

**关键概念：**DNS 使用 UDP 和 TCP 发送消息。传统的消息交换是“简短而甜蜜”的，因此非常适合使用非常快的 UDP； DNS 本身处理丢失请求的检测和重传。对于更大或更重要的信息交换，尤其是区域传输，使用 TCP——既因为它的可靠性，也因为它能够处理任何大小的消息。



###### 1.2.3.4-3-2 DNS 消息处理和通用消息格式（部分：1 2 3）

上一个主题讨论了 DNS 消息交换以及它们都是基于客户端/服务器计算原理的事实。 在特定的交换中，一个设备充当客户端，通过发送查询来启动通信； 另一个通过用答案响应查询来充当服务器。 这种“查询/响应”行为是 DNS 不可或缺的一部分，并反映在 DNS 消息使用的格式中。

通用消息格式用于 DNS 查询和响应。 该消息格式包含五个部分，为客户提出的查询提供了场所； 服务器提供的答案； 以及控制整个过程的头信息。 表 168 描述了 DNS 通用消息格式，提供了每个部分的简短摘要以及它们的使用方式。 您还可以在图 247 中看到消息格式的简化图示。


​                                                                               **表 168：DNS 通用消息格式**

| **Section Name** | **Description**                                              |
| ---------------- | ------------------------------------------------------------ |
| **Header**       | 包含描述消息类型并提供有关它的重要信息的字段。还包含指示消息其他部分中的条目数的字段。 |
| **Question**     | 携带一个或多个“问题”，即对发送到 DNS 名称服务器的信息的查询。 |
| **Answer**       | 携带一个或多个资源记录，以回答上面“问题”部分中指出的问题。   |
| **Authority**    | 包含一个或多个指向可用于继续解析过程的权威名称服务器的资源记录。 |
| **Additional**   | 传送一个或多个资源记录，这些资源记录包含与查询相关的附加信息，这些信息对于回答消息中的查询（问题）并非绝对必要。 |

​                      ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\dnsgenformat.png)                               

​																	       **图 247：DNS 通用消息格式**

<u>**标题和问题部分**</u>

Header 始终存在于所有消息中，并且长度固定。除了包含重要的 DNS 控制信息外，它还有一个标志 (QR)，用于指示消息是查询还是响应。它还有四个“计数”字段，告诉收件人其他四个部分中的条目数。

当客户端发起查询时，它会创建一条消息，其中填充了 Header 中的字段，并在 Question 部分中创建一个或多个查询（信息请求）。它将 QR 标志设置为 0 以指示这是一个查询，并在标头的 QDCount 字段中放置一个数字以指示问题部分中的问题数。其他部分中的条目数通常为零，因此它们的“计数”字段（ANCount、NSCount 和 ARCount）在标头中设置为 0。 （虽然可以将多个问题放入一个查询中，但通常只包含一个。）

当服务器收到查询时，它会处理它并执行请求的信息检索操作（如果可以的话）。然后它使用查询作为其响应消息的基础。将 Header 和 Question 部分复制到响应消息中，并将 QR 标志设置为 1 以指示该消息是回复消息。标头中的某些字段也会更改，以将信息返回给客户端。例如，服务器设置 RCode（响应代码）字段来指示查询是否成功或是否发生错误，如果确实发生，则指示问题是什么。下一个主题显示了所有 Header 字段，并说明了每个字段是如何被客户端和服务器使用的。

![image-20221116174435884](C:\Users\zy\AppData\Roaming\Typora\typora-user-images\image-20221116174435884.png)

<u>**资源记录部分：答案、权限和附加**</u>

服务器还负责填写消息的其他三个部分：Answer、Authority 和 Additional。这些部分共享相同的基本格式，每个部分都携带一个或多个使用通用记录格式的资源记录。每个部分中的记录数使用消息标头中的“计数”字段指示。这些部分仅在它们携带的记录类型方面有所不同。答案记录与所问问题直接相关，而权威记录则携带标识其他名称服务器的资源记录。因此，当服务器没有客户端请求的信息时，权限记录是名称服务器分层“链接”的方式。

附加部分的存在是为了提高 DNS 效率的特定目的。在某些情况下，服务器会提供一个它有理由相信会导致服务器也可以回答的后续问题的查询答案。例如，假设服务器在授权部分（NS 资源记录）中提供另一个名称服务器的名称。客户端可能没有该服务器的地址，这意味着它必须执行额外的名称解析才能联系引用的服务器。如果提供 NS 记录的服务器已经知道此名称服务器的 IP 地址，则可以将其包含在附加部分中。正如我在有关 DNS 邮件支持的主题中所解释的，提供 MX 记录的服务器也是如此。

**关键概念：**DNS 对所有消息使用通用消息格式。它由一个固定的 12 字节的 Header、一个包含查询的 Question 部分和三个附加部分组成，这些部分可以携带不同类型的资源记录。 Answer部分通常包含直接回答消息的Question的记录； Authority 部分包含发送回客户端的名称服务器的名称，Additional 部分包含可能对客户端有价值的额外信息，例如 Authority 部分中提到的名称服务器的 IP 地址。

**注意：**特殊的 Notify 和 Update 消息使用与常规 DNS 查询/响应消息不同的格式。这些特殊消息（其用途在有关 DNS 服务器增强的主题中进行了描述）基于常规格式，但某些字段的含义发生了变化。您可以分别在 RFC 1996 和 RFC 2136 中找到这些字段格式。



###### 1.2.3.4-3-3 DNS 消息标头和问题部分格式（部分：1 2）

使用查询/响应消息传递促进了 DNS 中的客户端/服务器信息交换。查询和响应都具有相同的通用格式，最多包含五个包含信息的单独部分。其中，两个通常在查询和响应中都可以找到：标题部分和问题部分。我将通过查看这两个部分来开始探索 DNS 消息的详细格式；下一个主题将介绍服务器用于其他三个消息部分的资源记录格式。

<u>**DNS 消息头格式**</u>
标头是任何消息中最重要的部分，因为它是携带关键控制字段的地方。在 DNS 消息中，标头部分带有几个关键控制标志，也是我们找出消息中使用了哪些其他部分的地方。检查标头可以帮助我们了解消息传递在 DNS 中工作方式的一些细微差别。

表 169 和图 248 中详细描述了所有 DNS 消息中使用的标头部分的格式。在交换中客户端和服务器使用不同字段的地方，我在表中提到了如何区分使用他们俩。


​                                                                                   **表 169：DNS 消息头格式**

| **Field Name** | **Size (bytes)** | **Description**                                              |
| -------------- | ---------------- | ------------------------------------------------------------ |
| ***ID\***      | 2                | ***Identifier:\*** 标识符：由创建 DNS 查询的设备生成的 16 位标识字段。它被服务器复制到响应中，因此该设备可以使用它将该查询与从 DNS 服务器收到的相应回复相匹配。这与在许多 ICMP 消息类型中使用标识符字段的方式类似。 |
| ***QR\***      | 1/8 (1 bit)      | ***Query/Response Flag:\***查询/响应标志：区分查询和响应。生成查询时设置为 0；当该查询被响应服务器更改为响应时更改为 1。 |
| ***Opcode\***  | 1/2 (4 bits)     | ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\aa36dfde.png) |
| ***AA\***      | 1/8 (1 bit)      | ***Authoritative Answer Flag:\*** 权威答案标志：该位在响应中设置为 1，表示创建响应的服务器对于问题部分中指定的域名所在的区域是权威的。如果为 0，则响应是非权威的。 |
| ***TC\***      | 1/8 (1 bit)      | ***Truncation Flag:\*** 截断标志：设置为 1 时，表示消息由于其长度超过所用传输机制类型允许的最大值而被截断。 TCP 对消息没有长度限制，而 UDP 消息限制为 512 字节，因此发送的这个位通常表示消息是使用 UDP 发送的并且太长而无法容纳。客户端可能需要建立一个 TCP 会话来获取完整的消息。另一方面，如果被截断的部分是附加部分的一部分，它可能会选择不去打扰。 |
| ***RD\***      | 1/8 (1 bit)      | ***Recursion Desired:\*** Recursion Desired：在查询中设置时，如果服务器支持递归解析，则请求接收查询的服务器尝试递归地回答查询。该位的值在响应中没有改变。 |
| ***RA\***      | 1/8 (1 bit)      | ***Recursion Available:\*** 在响应中设置为 1 或清除为 0，以指示创建响应的服务器是否支持递归查询。然后发送查询的设备可以记录下来以备将来使用。 |
| ***Z\***       | 3/8 (3 bits)     | ***Zero:\*** 零：三个保留位设置为零。                        |
| ***RCode\***   | 1/2 (4 bits)     | ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\aa36e036.png) |
| ***QDCount\*** | 2                | ***Question Count:\*** 问题数：指定消息“问题”部分中的问题数。 |
| ***ANCount\*** | 2                | ***Answer Record Count:\*** 指定消息的 Answer 部分中的资源记录数。 |
| NSCount        | 2                | ***Authority Record Count:\*** 指定消息的 Authority 部分中的资源记录数。 （当然，“NS”代表“名称服务器” |
| ARCount        | 2                | ***Additional Record Count:\*** 指定消息的 Additional 部分中的资源记录数。 |

​                    ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\dnsheaderformat.png)                                                    

​                                                                        **图 248：DNS 消息头格式**

**请注意，**当前的有效问题类型、查询操作代码和响应代码列表由 IANA 维护，作为其众多 Internet 参数列表之一。 响应代码 0 到 5 是“常规”DNS 的一部分，在 RFC 1035 中定义； 代码 6 到 10 实现动态 DNS，并在 RFC 2136 中定义。

<u>**DNS 问题部分格式**</u>

DNS 查询总是在问题部分至少包含一个条目，指定交换中的客户端试图找出什么。 这些条目被原封不动地复制到响应消息中，以供客户端在需要时参考。 表 170 和图 249 显示了用于 DNS 消息“问题”部分中每个条目的格式。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\dnsquestionformat.png)

​                                                                     **图 249：DNS 消息问题部分格式**



​                                                                          **表 170：DNS 消息问题部分格式**

| **Field Name** | **Size (bytes)** | **Description**                                              |
| -------------- | ---------------- | ------------------------------------------------------------ |
| ***QName\***   | Variable         | ***Question Name:\*** 问题名称：包含作为查询主题的对象、域或区域名称，使用标准 DNS 名称表示法进行编码。 |
| ***QType\***   | 2                | ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\aa204daa.png) |
| ***QClass\***  | 2                | ***Question Class:\*** 问题类别：指定请求的资源记录的类别，通常值为 1 表示 Internet (“IN”)。请参阅有关类和资源记录类型的主题以获取解释。此外，QClass 值 255 被定义为具有“任何类”的特殊含义。 |



###### 1.2.3.4-3-4 DNS 消息资源记录字段格式（部分：1 2 3 4 5）

DNS 中的信息交换由一系列客户端/服务器事务组成。客户端向服务器发送请求或查询，然后服务器发回响应。 DNS服务器当然是数据库服务器，以资源记录（RR）的形式存储DNS名称数据库信息。客户端提出的问题是对 DNS 服务器数据库的信息请求，由 DNS 服务器查找所请求的资源记录并将其放入 DNS 响应消息中来回答这些问题。

整个 DNS 消息格式的 Answer、Authority 和 Additional 部分是服务器放置要发送回客户端的 DNS 资源记录的地方。每个部分由零个或多个记录组成，理论上任何记录都可以放在任何部分中。这些部分仅在客户端从一个部分中的记录中提取的语义（含义）与另一个部分不同。有关 DNS 常规消息传递的主题包含有关这三个部分及其使用方式的更多信息。

资源记录有两种表示形式：二进制和文本。文本格式用于人工编辑的主文件，是本节后面的主题的主题。二进制表示由常规数字和文本字段组成，就像 DNS 消息格式中的其他字段一样。

<u>**DNS通用资源记录格式**</u>

有某些类型的信息是所有资源记录所共有的，还有一些是每种类型的记录所特有的。为了处理这个问题，所有的资源记录都使用通用的字段格式来表示，它包含一个单一的RData字段，因记录类型而异。表171和图250中描述了通用资源记录格式。

​                                                                                  **表171: DNS通用资源记录格式**

| **Field Name**  | **Size (bytes)** | **Description**                                              |
| --------------- | ---------------- | ------------------------------------------------------------ |
| ***Name\***     | Variable         | ***Name:\*** 名称：包含作为资源记录主题的对象、域或区域名称，使用标准 DNS 名称表示法进行编码。资源记录中的所有信息都与这个对象相关联，我将其称为记录的命名对象。 |
| ***Type\***     | 2                | ***Type:\*** 类型：指定资源记录类型的代码值。表 166 以及本主题的资源记录详细信息列表中显示了最常见类型的资源记录的类型值。 |
| ***Class\***    | 2                | ***Class:\*** Class：指定被请求的资源记录的类别，通常值为 1 表示 Internet (“IN”)。请参阅有关类和资源记录类型的主题的末尾以获取解释。 |
| ***TTL\***      | 4                | ***Time To Live:\*** 生存时间：指定记录应在读取记录的设备的缓存中保留的秒数。有关完整说明，请参阅有关 DNS 名称服务器缓存的主题。零值表示“仅将此信息用于当前名称解析；不要缓存它”。 |
| ***RDLength\*** | 2                | ***Resource Data Length:\*** Resource Data Length：表示RData字段的大小，以字节为单位。 |
| ***RData\***    | Variable         | ***Resource Data:\*** 资源数据：资源记录的数据部分。         |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\dnsrrformat.png)

​                                                                   图 250：DNS 公共资源记录格式

![image-20221116182734328](C:\Users\zy\AppData\Roaming\Typora\typora-user-images\image-20221116182734328.png)

<u>**公共资源记录的 RData 字段格式**</u>

RData 字段由一个或多个子字段组成，这些子字段携带资源记录的实际“有效负载”。 下面是最常见的资源记录类型的列表。 对于每一个，我都指出了资源记录文本代码、名称和类型值，提供了资源记录使用的简要总结，并在表格中显示了 RData 字段的结构：

<u>**A / 地址资源记录（类型值 1）**</u>
这是 DNS 中的主要资源记录类型； 它包含一个与域名关联的 32 位 IP 地址，如表 172 所示。


​                                                                    **表 172：DNS 地址资源记录数据格式**

| **ubfield Name** | **Size (bytes)** | **Description**                                              |
| ---------------- | ---------------- | ------------------------------------------------------------ |
| ***Address\***   | 4                | ***Address:\*** 地址：对应于该记录的命名对象的 32 位 IP 地址。 |

<u>**NS / 名称服务器资源记录（类型值 2）**</u>
在这条记录中，数据字段携带域 携带名称服务器的域名（表 173）。

​                                                                  **表 173：DNS 名称服务器资源记录数据格式**

| **Subfield Name** | **Size (bytes)** | **Description**                                              |
| ----------------- | ---------------- | ------------------------------------------------------------ |
| ***NSDName\***    | Variable         | ***Name Server Domain Name:\*** 名称服务器域名：名称服务器的可变长度名称，该名称服务器应对该记录的命名对象具有权威性。与所有名称一样，此名称使用标准 DNS 名称表示法进行编码。 对此资源记录类型的请求通常会导致指定名称服务器的 A 记录也被返回到响应的附加部分（如果可用）。 |

<u>**CName / 规范名称资源记录（类型值 5）**</u>
数据字段包含已使用别名引用的命名对象的真实名称（表 174）。


​                                                                             **表 174：DNS 规范名称资源记录数据格式**

| **Subfield Name** | **Size (bytes)** | **Description**                                              |
| ----------------- | ---------------- | ------------------------------------------------------------ |
| ***CName\***      | Variable         | ***Canonical Name:\*** 规范名称：命名对象的规范（真实）名称。然后使用标准 DNS 解析过程解析此名称，以获得最初指定名称的地址。 |

<u>**SOA / 开始权限资源记录（类型值 6）**</u>

该记录标志着 DNS 区域的开始，并包含有关如何管理和使用它的关键信息。 SOA 记录是最复杂的 DNS 资源记录类型； 其格式可以在表 175 和图 251 中找到。


​                                                                            **表 175：DNS 开始授权资源记录数据格式**

| **Subfield Name** | **Size (bytes)** | **Description**                                              |
| ----------------- | ---------------- | ------------------------------------------------------------ |
| ***MName\***      | Variable         | ***Master Name:\*** Master Name：作为区域数据源的名称服务器的域名；这当然通常是该区域的主要权威服务器。它使用标准 DNS 名称格式进行编码。 |
| ***RName\***      | Variable         | ***Responsible Name:\*** 负责人姓名：该区域负责人的电子邮件地址。 DNS 中的电子邮件地址使用常规 DNS 名称表示法的特殊变体进行编码。 |
| ***Serial\***     | 4                | ***Serial Number:\*** 序列号：该区域资源记录数据库的序列号或版本号。用于确定何时对数据库进行更改以触发区域传输。有关如何使用此字段的信息，请参阅有关区域传输的主题。 |
| ***Refresh\***    | 4                | ***Refresh Interval:\*** 刷新间隔：此区域的辅助名称服务器在尝试检查对主要名称服务器上的区域数据库所做的更改之间等待的秒数。有关如何使用此字段的信息，请参阅有关区域传输的主题。 |
| ***Retry\***      | 4                | ***Retry Interval:\*** 重试间隔：如果先前尝试失败，辅助名称服务器在再次尝试检查主名称服务器更改之前等待的秒数。有关详细信息，请参阅有关区域传输的主题。 |
| ***Expire\***     | 4                | ***Expire Interval:\*** 过期间隔：在辅助名称服务器必须考虑其持有的“陈旧”信息之前，与主要名称服务器成功联系之间可以经过的秒数。 |
| ***Minimum\***    | 4                | ***Negative Caching TTL:\***负缓存 TTL：最初为未指定明确 TTL 值的记录携带默认的生存时间值。现在代表区域的负缓存 TTL。请参阅有关 DNS 名称服务器缓存的主题。 |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\dnsrrsoaformat.png)

​                                                                **图 251：DNS 开始授权资源记录数据格式**

<u>**PTR / 指针资源记录（类型值 12）**</u>

该记录携带指向资源记录的指针； 用于反向地址查找。 它包含一个数据字段，如表 176 所示。


​                                                                  **表 176：DNS 指针资源记录数据格式**

| **Subfield Name** | **Size (bytes)** | **Description**                                              |
| ----------------- | ---------------- | ------------------------------------------------------------ |
| ***PTRDName\***   | Variable         | ***Pointer Domain Name:\*** 指针域名：可变长度的域名。这是资源记录“指向”的名称；有关使用此记录类型的最常见方式，请参阅反向解析的描述。 |

<u>**MX / 邮件交换资源记录（类型值 15）**</u>
此特殊记录包含有关用于向域发送电子邮件的邮件服务器的信息。 每条记录包含两个字段，如表 177 所示。


​                                                                       **表 177：DNS 邮件交换资源记录数据格式**

| **Subfield Name** | **Size (bytes)** | **Description**                                              |
| ----------------- | ---------------- | ------------------------------------------------------------ |
| ***Preference\*** | 2                | ***Preference Value:\*** 首选项值：此邮件交换的首选项级别。较低的值表示较高的偏好。 |
| ***Exchange\***   | Variable         | ***Exchange Domain Name:\*** 交换域名：使用标准 DNS 名称表示法编码的主机愿意为此命名对象提供邮件交换服务的域名。 |

<u>**TXT / 文本资源记录（类型值 16）**</u>
此描述性记录包含有关命名对象的附加描述性信息（表 178）。


​                                                                                **表 178：DNS 文本资源记录数据格式**

| **Subfield Name** | **Size (bytes)** | **Description**                                    |
| ----------------- | ---------------- | -------------------------------------------------- |
| ***TXT-Data\***   | Variable         | ***Text Data:\*** 文本数据：可变长度的描述性文本。 |



###### 1.2.3.4-3-5 DNS 名称表示法和消息压缩技术（部分：1 2 3）

显然，整个域名系统协议都是围绕处理域、子域和对象的名称而设计的。我们在前面的主题中已经看到，在 DNS 消息和资源记录中有许多字段携带对象名称、名称服务器等。 DNS 使用一种特殊的符号来编码资源记录和字段中的名称，这种符号的一种变体用于电子邮件地址，并使用一种特殊的压缩方法来减小消息的大小以提高效率。

<u>**标准 DNS 名称表示法**</u>
在描述 DNS 名称空间的部分中，我们了解了 DNS 名称是如何构造的。名称层次结构中的每个节点都有一个与之关联的标签。特定设备的完全限定域名 (FQDN) 由从树的根开始向下到该设备的标签序列组成。层次结构中每个级别的标签按顺序列出，从最高级别开始，从右到左，用点分隔。这导致了我们习惯使用的域名，例如“www.xyzindustries.com”。

可以将这些名称直接编码到资源记录或其他 DNS 消息字段中：将字母“w”放入名称的前三个字节中的每一个，然后放入“.”。进入第四个字节，“x”进入第五个字节，依此类推。这样做的缺点是当计算机正在读取名字时，它无法判断每个名字何时完成。我们需要为每个名称包含一个长度字段。

相反，DNS 使用一种特殊的 DNS 名称表示法。每个标签在名称字段中一个接一个地编码。在每个标签之前，使用一个字节来保存表示标签中字符数的二进制数。然后，标签的字符被编码，一个字节一个。名称的末尾由一个空标签表示，代表根；这当然有一个零长度，所以每个名字都以一个“0”字符结尾，表示这个零长度的根标签。

请注意，标签之间的“点”不是必需的，因为长度数字描绘了标签。读取名称的计算机在读取名称时也知道每个标签中有多少字节，因此它可以在从名称中读取标签时轻松地为标签分配空间。

例如，“www.xyzindustries.com”将被编码为：

​                      “[3] w w w [13] x y z i n d u s t r i e s [3] c o m [0]”
我在方括号中显示了标签长度以区分它们。请记住，这些标签长度是二进制编码的数字，因此单个字节可以包含 0 到 255 之间的值； “[13]”是一个字节而不是两个字节，如图 252 所示。标签实际上被限制为最多 63 个字符，我们很快就会看到为什么这很重要。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\dnsnameformat.png)


​                                                                      图 252：DNS 标准名称表示法

在 DNS 中，每个命名对象或其他名称都由一系列标签长度和标签表示，每个标签长度占用一个字节，每个标签每个字符占用一个字节。此示例显示名称“www.xyzindustries.com”的编码。



<u>**DNS 电子邮件地址表示法**</u>
电子邮件地址用在某些 DNS 资源记录中，例如 Start Of Authority 资源记录中的 RName 字段。电子邮件地址当然采用“<name>@<domain-name>”的形式。 DNS 以与常规 DNS 域完全相同的方式对这些进行编码，只是将“@”视为另一个点。因此，“johnny@somewhere.org”将被视为“johnny.somewhere.org”并编码为：

​                                                        “[6] jo h n n y [9] some where [3] or g [0]”。
请注意，没有具体指示这是一个电子邮件地址。该名称被解释为电子邮件地址，而不是基于上下文的设备名称。



<u>**DNS 消息压缩**</u>

单个 DNS 消息可能包含多个域名。现在，考虑当特定名称服务器发送包含多个域名的响应时，它们通常都在同一个区域中，或者与区域相关。这些名称中的大多数名称都有共同的元素。

考虑我们之前的客户请求“xyzindustries.com”的 MX 记录的邮件示例。对该客户端的响应将包含以下两条记录：

- MX 记录：记录名称为“xyzindustries.com”，RData 字段为“mail.xyzindustries.com”的 MX 记录。

- A 记录：假设名称服务器知道“mail.xyzindustries.com”的 IP 地址，附加部分将包含一个 A 记录，其名称为“mail.xyzindustries.com”，其 RData 字段中的地址。

这只是名称重复的一个小例子；其他类型的 DNS 消息可能会更加极端，某些字符串模式会重复多次。通常这需要使用上述编码方法完整拼出每个名称。但这会很浪费，因为这些名称中的很大一部分是常见的。

<u>**使用消息压缩避免全名重复**</u>
为了减少重复，使用了一种称为消息压缩的特殊技术。与上面使用标签和标签长度的组合编码的 DNS 名称不同，两个字节的子字段用于表示指向消息中可以找到该名称的另一个位置的指针。该子字段的前两位设置为 1（二进制值“11”），其余 14 位包含一个偏移量，用于指定在消息中可以找到名称的位置，计算消息的第一个字节（ ID 字段的第一个字节）为 0。

让我们回到我们的例子。假设在上面的 DNS 消息中，包含“mail.xyzindustries.com”的 MX 记录的 RData 字段从字节 47 开始。在第一个实例中，我们会发现完整编码的名称：

​                   “[4] m a i l [13] x y z i n d us t r i e s [3] c o m [0]”。
然而，在第二种情况下，“mail.xyzindustries.com”出现在 A 记录的名称字段中，我们改为放置两个“1”位，然后是二进制编码的数字 47。因此，这将是 16 位二进制模式“11000000 00101111”，或两个数字字节值“192”和“47”。第二个实例现在占用 2 个字节，而不是复制第一个名称实例所需的 24 个字节。

读取名称字段的设备如何区分指针和“真实”名称？这就是在字段开头使用“11”的原因。这样做可以保证指针的第一个字节的值始终为 192 或更大。由于标签的长度限制为 63 或更小，当主机读取名称的第一个字节时，如果它看到一个字节中的值是 63 或更小，它就知道这是一个“真实”名称； 192 或更大的值表示它是一个指针。



<u>**使用消息压缩来避免名称的一部分重复**</u>

上面的示例显示了如何使用指针来消除整个名称的重复：在两个地方使用了名称“mail.xyzindustries.com”，并且使用了一个指针而不是第二个。然而，指针比这更强大。它们还可以用于仅指向真实姓名的一部分，或者可以与其他标签结合使用，以提供资源记录中与另一个姓名相关的姓名的压缩表示。这提供了更大的空间节省。

在上面的示例中，这意味着即使是“mail.xyzindustries.com”的第一个实例也可以被压缩。回想一下，MX 记录的名称字段中有“xyzindustries.com”，RData 字段中有“mail.xyzindustries.com”。如果该记录的名称字段从字节 19 开始，那么我们可以将 RData 字段编码为：

​                 “[4] m a i l [pointer-to-byte-19]”。
读取记录的设备将获得第一个标签的“mail”，然后从名称字段中读取“xyzindustries.com”以获取完整名称“mail.xyzindustries.com”。

同样，假设我们在同一封邮件中有一条记录，其中包含对“xyzindustries.com”父域的引用，当然是“com”。这可以简单地编码为：

​                          “[pointer-to-byte-33]”
原因是字节 33 是我们找到名称字段的“[3] c o m [0]”部分的地方，其中包含“[13] x y z i n d u s t r i e s [3] c o m [0]”。

###### 1.2.3.4-3-6 DNS 主文件格式（部分：1 2 3 4）

DNS 服务器通过发送包含资源记录的回复消息来回答来自客户端的查询。我们已经在本节中看到了用于对这些资源记录进行编码的二进制消息格式。这些消息格式非常适合传输消息，因为它们紧凑且高效，并且计算机可以非常快速地读取字段并知道如何解释特定的 1 和 0 字符串。

另一方面，人类不能很好地处理二进制的密码。在服务器提供资源记录之前，人工管理员有必要告诉服务器这些记录是什么以及它们包含什么信息。为了使这项工作更容易，DNS 包括区域和资源记录的特殊文本表示。管理员编辑描述区域及其包含的记录的特殊主文件；这些文件随后被服务器的DNS软件读入内存，并转换为二进制形式以响应客户端请求。这在资源记录的概述主题中有更详细的描述。

每个主文件都包含一个简单的“平面文本”文件，可以使用任何类型的文本编辑器创建该文件。每个文件都包含许多行，这些行使用一组简单的语法规则来表示，这些语法规则描述了一个区域及其中的记录。 DNS 主文件的基本句法规则在 RFC 1035 的第 5.1 节中指定。某些 DNS 实现使用他们自己的标准语法变体，尽管它们都非常相似。

<u>**DNS 通用主文件记录格式**</u>

正如所有资源记录都使用通用字段格式在内部存储一样，它们也使用通用主文件格式。每条记录通常出现在文件的单独一行中。此格式如下，可选字段显示在方括号中：

<domain-name> [<ttl>] <class> <type> <rdata>
字段如下：

- <domain-name>：DNS 域名，可以是完全限定域名 (FQDN) 或部分限定名称 (PQDN)。见下文。
- <ttl>：记录的生存时间值，以秒为单位。如果省略，则使用区域的默认 TTL 值。事实上，大多数资源记录都没有指定的 TTL，只是使用 Start Of Authority 记录提供的默认值。

- <class>：资源记录类。对于现代 DNS，此字段是可选的，对于“Internet”默认为“IN”

- <type>：资源记录类型，使用“A”或“NS”等文本代码指定，而不是数字代码。

- <rdata>：资源记录数据，是一组由空格分隔的条目，取决于记录类型。

“<rdata>”可以是单条信息或一组条目，具体取决于记录类型。对于较长的记录类型，尤其是授权起始记录，多条目“<rdata>”字段分布在多行中并括在括号中；括号使所有条目就像在一行中一样。请注意，如果存在“<ttl>”字段，则它和“<class>”字段的顺序可能会互换；这不会造成任何问题，因为一个是数字，另一个是文本（“IN”）。

<u>**部分限定域名的使用和解释**</u>
域名可以在 FQDN 和 PQDN 之间混合。部分限定名称用于通过减少名称的公共部分来加快主文件的创建速度和可读性；它们是 DNS 消息压缩的“人类等价物”。 FQDN 显示为以点（“.”）结尾的完整域名，表示 DNS 名称树根。 PQDN 仅作为没有根的部分名称给出，并由读取主文件的软件解释为 FQDN（有关更多信息，请参见下面的 $ORIGIN 指令。）

记住标记 FQDN 的末尾点很重要；如果源是“xyzindustries.com”并且在其区域文件中出现名称“bigisp.net”，服务器会将其读作“bigisp.net.xyzindustries.com”——可能不是您想要的。此外，电子邮件地址（例如 SOA 记录中的 <r-name> 字段）按照标准 DNS 约定将电子邮件地址的“@”转换为点。

<u>**主文件指令**</u>

除了资源记录之外，大多数主文件实现还支持指令的使用。这些命令指定某些重要信息以指导如何解释主文件。三个最常见的指令是：

- $ORIGIN：指定附加到不合格规范的域名；这是用于将 PQDN 转换为 FQDN 的“基础”。例如，如果来源是“xyzindustries.com.”，那么“sales”等 PQDN 将被解释为“sales.xyzindustries.com.”。定义后，只需使用“@”代替名称即可引用原点，正如我们将在本主题末尾的示例中看到的那样。

- $TTL：指定要用于任何未在记录本身中指定 TTL 值的资源记录的默认生存时间值。 （此值以前由授权起始记录中的最小值字段指定。）

- $INCLUDE：允许一个主文件包含另一个主文件的内容。这有时用于保存区域之间常见的某些条目的重复项。

<u>**主文件的语法规则**</u>
DNS 主文件还有一些其他语法规则，其中一些旨在为管理员节省更多时间或精力：

- Multiple-Record Shorthand：如果多个连续记录属于同一个域，则为第一个指定“<domain-name>”，然后为后续记录留空。服务器将假设没有指示“<domain-name>”的任何资源记录适用于它看到的最后一个“<domain-name>”。

- 注释：分号（“;”）标记注释。从分号到行尾的任何文本都将被忽略。

- 转义字符：反斜杠（“\”）用于“转义”字符的特殊含义。例如，双引号 (") 用于分隔文本字符串；文字双引号字符由反斜杠-双引号组合 (\") 表示。

- White Space：制表符和空格用作分隔符，忽略空行。为了可读性，大多数聪明的管理员使用制表符缩进以更清楚哪些记录属于哪些名称，并使用空行和注释对记录进行分组。

- 大小写：与 DNS 域名一样，主文件条目不区分大小写。

**参考**: **直接看bind 规则吧**

<u>**特定资源记录语法和示例**</u>

表 179 显示了每种常见资源记录类型的特定格式和示例。 这些字段与 DNS 二进制记录格式中解释的字段基本相同。 我使用 DNS 注释格式包含了解释性“注释”。 假设此表中的示例适用于区域“googleplex.edu”：


​                                                                **表 179：DNS 主文件格式语法和示例**

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\heihei.jpg)



请注意，PTR 记录实际上当然位于 IN-ADDR.ARPA 域中。

表 180 包含一个 DNS 主文件的“真实世界”示例，取自我自己的“pcguide.com”服务器（略有修改），由 pair.com 的优秀人员托管（并提供 DNS 信息）。 请注意使用“@”作为表示“此域”（“pcguide.com”）的快捷方式：


​                                                                       **表 180：示例 DNS 主文件**

```
$ORIGIN pcguide.com.
@ IN SOA ns23.pair.com. root.pair.com. (
2001072300 ; Serial
3600 ; Refresh
300 ; Retry
604800 ; Expire
3600 ) ; Minimum

@ IN NS ns23.pair.com.
@ IN NS ns0.ns0.com.

localhost IN A 127.0.0.1
@ IN A 209.68.14.80
IN MX 50 qs939.pair.com.

www IN CNAME @
ftp IN CNAME @
mail IN CNAME @
relay IN CNAME relay.pair.com.
```



###### 1.2.3.5 支持IP版本6的DNS变化（部分：1 2）

Internet 协议第 4 版 (IPv4) 是当今 Internet 的基础，也是构建 TCP/IP 协议套件的基础。虽然 IPv4 已经为我们服务了 20 多年，但它有一些重要的缺点，如果继续使用它会限制未来的互联网。为此，下一代 IP，即 Internet 协议版本 6 (IPv6)，已经开发了很多年。 IPv6 最终将取代 IPv4，并将 TCP/IP 带入未来。

从 IPv4 到 IPv6 的变化将“波及”其他 TCP/IP 协议，包括域名系统。 DNS是一个更高级的协议，所以你可能会认为基于分层的原则，改变IP应该不会影响它。然而，这是“严格分层”并不总是适用的另一个例子。 DNS 直接与 IP 地址一起工作，IPv6 对 IP 所做的最重要的修改之一是在寻址领域，因此这意味着在 IPv6 上使用 DNS 需要对协议的工作方式进行一些更改。

<u>**IPv6 DNS 扩展**</u>
由于 DNS 在第三层与 IP 在“架构上相距甚远”，因此所需的更改并不广泛。题为 IPv6 DNS 扩展的 RFC 1886 于 1995 年 12 月发布，是 IETF 首次正式尝试描述 DNS 支持 IPv6 所需的更改。它为 IPv6 定义了对 DNS 的三个特定修改：

- 新资源记录类型 - AAAA（IPv6 地址）：常规 DNS 地址资源记录是为 32 位 IPv4 地址定义的，因此创建了一个新资源记录以允许域名与 128 位 IPv6 地址相关联。四个“A”（“AAAA”）是一个助记符，表示 IPv6 地址是 IPv4 地址大小的四倍。 AAAA 记录的结构与二进制和主文件格式的 A 记录非常相似；它只是大得多。 AAAA 的 DNS 资源记录类型值为 28。

- 新的反向解析层次结构：为 IPv6 反向查找定义了类似于 IN-ADDR.ARPA 的新层次结构，但 IETF 将其置于不同的顶级域中。新域是 IP6.INT，其使用方式类似于 IN-ADDR.ARPA 的工作方式。但是，由于 IPv6 地址是用十六进制而不是点分十进制表示的，因此 IP6.INT 有十六个子域“0”到“F”，每个子域都有十六个子域“0”到“F”，依此类推，十六层深的。是的，这会导致一个潜在的大得可怕的反向解析数据库！

- 查询类型和解决程序的更改：对查询类型和解决程序的改变。所有处理A记录或导致A记录被包含在答复的附加部分的查询类型必须改变，以便也处理AAAA记录。此外，通常会导致A记录被返回到附加部分的查询必须只在答复部分而不是附加部分返回相应的AAAA记录。

关键概念：尽管 DNS 位于 TCP/IP 协议族体系结构中的 Internet 协议之上，但它与 IP 地址密切相关。因此，需要进行更改以使其支持新的 IPv6。这些更改包括新 IPv6 地址资源记录 (AAAA) 的定义、新的反向解析域层次结构以及对消息传送方式的某些更改。

<u>**对 IPv6 DNS 扩展的拟议更改**</u>

2000 年，IETF 发布了 RFC 2874，支持 IPv6 地址聚合和重新编号的 DNS 扩展。该标准建议使用新的记录类型 A6 代替 1886 的 AAAA 来替代 RFC 1886 中引入的 IPv6 支持。 AAAA 和 A6 记录之间的主要区别在于前者只是像 A 记录一样的完整地址，而 A6 记录可以包含完整或部分地址。

RFC 2874 背后的想法是 A6 记录可以以补充单播地址的 IPv6 格式的方式设置。然后，名称解析将涉及一种称为链接的技术，以从一组部分指定的地址组件中确定名称的完整地址。从本质上讲，这将使地址的行为方式与分层名称本身的工作方式非常相似，从而提供一些潜在的灵活性优势。

几年来，RFC 1886 和 RFC 2874 都被提议为标准，这导致了相当大的混乱。 2002 年 8 月，RFC 3363 和 3364 发布，阐明了这两个提案的情况。 RFC 3363代表“最高法院的决定”，即RFC 2874和A6记录改为实验状态，保留RFC 1886的AAAA记录作为DNS IPv6标准。

该决定的完整解释可以在 RFC 3364 中找到。简而言之，它归结为 IETF 认为成功实施 RFC 2874 存在重大潜在风险。虽然 A6 记录的功能“有趣”，目前尚不清楚是否需要它们，考虑到这些风险，他们认为坚持使用 RFC 1886 是更好的选择。



### 第二章、网络文件和资源共享协议以及TCP/IP网络文件系统（NFS）

对于典型的最终用户而言，创建网络的一个主要原因是：允许信息共享。计算机上的大多数信息都以文件的形式存在于硬盘等存储设备上；因此，网络的一个主要目的是让用户共享文件。存在允许用户“手动”将文件从一个地方移动到另一个地方的文件传输和消息传输协议，但在许多情况下更可取的是更自动化的方法。网络互连协议以网络文件和资源共享协议的形式提供这种能力。

在本节中，我将从 TCP/IP 网络的角度描述网络文件和资源共享协议。我首先简要概述了此类协议的概念和操作，讨论了不同类型的一些共同元素。然后，我描述了专门为 TCP/IP 定义的最常见的一种：网络文件系统 (NFS)。

相关信息： 显然，网络文件和资源共享协议和服务与我前面提到的文件和消息传输协议密切相关。例如，NFS 可用于完成类似于 TCP/IP 文件和消息传输应用程序（如 FTP 和 HTTP）执行的任务。我认为这些协议本身更像是特定的最终用户应用程序，因此在应用程序协议部分对它们进行了描述。我意识到“手动”和“自动”文件传输之间的这种区别有点武断，但是，伟大的网络世界中的许多其他事物也是如此。

```
假设一个Unix风格的场景，其中一台计算机（客户端）需要访问存储在其他机器上的数据（NFS 服务器）：

服务端实现 NFS 守护进程，默认运行 nfsd，用来使得数据可以被客户端访问。
服务端系统管理员可以决定哪些资源可以被访问，导出目录的名字和参数，通常使用 /etc/exports 配置文件 和 exportfs 命令。
服务端安全-管理员保证它可以组织和认证合法的客户端。
服务端网络配置保证可以跟客户端透过防火墙进行协商。
客户端请求导出的数据，通常调用一个 mount 命令。
如果一切顺利，客户端的用户就可以通过已经挂载的文件系统查看和访问服务端的文件了。
提醒：NFS自动挂载可以通过—可能是 /etc/fstab 或者自动安装管理进程。
```



#### 2.1 文件和资源共享协议概念和操作概述（部分：1 2）

网络是一个相当复杂的主题 — 如果您不相信我，请尝试浏览一下本指南的主题列表。对于像您这样的人来说，他们可能正在阅读本指南以了解网络以增强您在技术世界谋生的能力，这种复杂性意味着增强的工作保障，所以不要敲它。 J 另一方面，“普通用户”的主体只是希望能够在网络上做事，而不必被迫了解底层的一切运作方式。这只是常识。

<u>**对比“手动”和“自动”文件和资源共享**</u>
创建网络和互联网络的一个主要原因是允许在计算机之间共享文件和其他资源。因此，在任何互联网络协议栈中，我们都需要某种机制，用户可以通过这种机制以简单的方式轻松地在网络上移动文件。应用层文件和消息传输协议（如 FTP 和 HTTP）就是为此目的而创建的：让用户通过网络访问资源，同时隐藏网络如何在其下层运行的详细信息。

然而，即使这些协议隐藏了较低的层，它们在本质上还是有些“手动”的：它们需要用户调用应用程序协议并使用特定的命令来完成基于网络的资源访问。事实上，此类协议的问题并不在于它们需要手动干预，而是它们使共享变得更加困难，因为它们不允许直接在另一个资源上使用文件。要理解我的意思，请考虑像 FTP 这样的协议。它确实允许我在机器之间共享文件，但在我的文件和其他人的文件之间有明确的区别。如果我想在 Joe 的机器上使用一个文件，我必须将它传输到我的机器上，使用它，然后再将它传输回来。另外，如果我不传回文件，Joe 可能永远看不到更新的版本。

当我们甚至可以隐藏文件的位置和移动它们所需的命令的细节时，文件和资源共享的最终结果就实现了。这样的系统将使用“自动”共享协议，让文件和资源在网络上无缝使用。一旦设置好，这种方案中的网络资源就可以像在本地计算机上一样使用。此类协议有时称为网络文件和资源共享协议。

正是这种本地文件和远程文件之间界限的“模糊”使得文件和资源共享协议如此强大。一旦系统设置完成，用户就可以像在自己的主机上一样轻松地访问另一台主机上的资源。这是一种极其强大的功能，尤其是在客户端/服务器计算的现代时代。例如，它允许一家公司将许多个人使用的信息存储在一个公共位置，例如服务器上的一个目录中，并允许这些个人中的每个人访问它。从本质上讲，创建了一个跨越网络设备的“虚拟文件系统”，而不是简单地位于一台计算机的一个存储设备上。

<u>**文件和资源共享协议的组件**</u>

网络文件和资源共享协议允许用户“毫不费力”地共享文件，但这并不意味着这些工作仍然不必进行。它仍然存在，但由编写协议的人和管理其操作的人承担。一般来说，这些协议至少需要以下通用组件：

- 文件系统模型和架构：一种用于定义要共享的资源和文件以及描述“虚拟文件系统”如何工作的机制。

- 资源访问方法：描述用户如何从他或她的本地主机附加或分离远程资源的过程。

- 操作集：一组操作，用于完成用户需要对其他热点上的文件执行的各种任务。

- 消息协议：携带要执行的操作、状态信息等的消息格式，以及用于在设备之间交换这些消息的协议。

- 管理工具：支持协议操作并将其他元素联系在一起所需的杂项功能。

当今 TCP/IP 中使用的最常见的文件和资源共享协议是网络文件系统 (NFS)。下一节将对其进行更详细的描述。



#### 2.2 TCP/IP 网络文件系统 (NFS)

文件和资源共享协议很重要，因为它们允许用户通过网络无缝共享文件。由于微软操作系统在业界的统治地位，很多人都熟悉微软网络可以这样使用的方式。然而，微软在文件共享协议方面有点像“强尼来晚了”。早在 Microsoft Windows 出现之前，网络文件系统 (NFS) 就允许用户使用 UNIX 操作系统通过网络共享文件。

在本节中，我简要介绍了 NFS 的操作。我从协议的概述和历史开始，并讨论其常见版本和标准。我描述了 NFS 的体系结构以及构成它的三个组件。然后我描述了 NFS 文件系统模型，以及如何使用外部数据表示 (XDR) 标准对数据进行编码。我使用远程过程调用 (RPC) 解释了 NFS 的客户端/服务器操作。然后我列出了 NFS 中使用的过程和操作，并以单独的 NFS Mount 协议的描述结束，该协议用于将网络资源附加到设备。

注意：正如我上面所说，NFS 最初是专门为 UNIX 操作系统开发的，并且仍然与 UNIX 联系最紧密。与所有协议描述一样，我试图尽可能地让我对 NFS 的讨论“独立于操作系统”，但在本节的某些地方，这并非完全可能。




##### 2.2.1 NFS 概述、历史、版本和标准（部分：1 2 3）

TCP/IP 和 Internet 的历史有着千丝万缕的联系，您可以在我对 TCP/IP 历史的讨论中自行阅读。然而，还有一个较少被提及的第三方合作伙伴，但却是这些技术发展历史的重要组成部分。那就是早期互联网机器上运行的操作系统，今天仍然在很大一部分互联网服务器上使用：UNIX 操作系统。

Sun Microsystems 是 UNIX 和 TCP/IP 网络开发的早期先驱之一。在 TCP/IP 发展的早期，创建了某些工具来允许用户通过网络访问另一台机器——毕竟，这可以说是网络的全部意义所在。 Telnet 等远程访问协议允许用户登录到另一台主机并使用那里的资源。文件传输协议 (FTP) 允许某人将文件从远程机器复制到自己的机器上并进行编辑。

然而，这些解决方案都没有真正满足允许用户以类似于使用本地文件的方式访问远程机器上的文件的要求。为满足这一需求，Sun 创建了网络文件系统 (NFS)。 NFS 是专门为消除本地文件和远程文件之间的区别而设计的。对用户而言，在执行适当的设置后，远程计算机上的文件可以像在用户本地机器上的硬盘上一样使用。 Sun 还专门设计了 NFS 以使其独立于供应商，以确保 Sun 制造的硬件和其他公司制造的硬件可以互操作。

<u>**NFS 体系结构和一般操作概述**</u>

NFS 遵循经典的 TCP/IP 客户端/服务器操作模型。管理员可以将特定计算机的硬盘或存储设备上的目录设置为共享资源。然后，此资源可以由安装共享驱动器或目录的客户端计算机访问，使其在客户端计算机上看起来像本地目录。一些计算机可能仅充当服务器或仅充当客户端，而其他计算机可能两者兼有：共享自己的一些资源和访问他人提供的资源。

NFS 使用的架构包括定义其操作的三个主要组件。外部数据表示 (XDR) 标准定义了数据在客户端和服务器之间的交换中的表示方式。远程过程调用 (RPC) 协议用作调用远程计算机上的过程的方法。然后，一组 NFS 过程和操作使用 RPC 来执行各种请求。如上所述，单独的 Mount 协议用于挂载资源。

NFS 最重要的设计目标之一是性能。显然，即使您在远程机器上设置文件就像在本地机器上一样，实际的读写操作也必须通过网络进行。通常这比在计算机内简单地发送数据要花费更多的时间，因此协议本身需要尽可能“精简”。这个决定导致了一些有趣的决定，例如使用不可靠的用户数据报协议 (UDP) 在 TCP/IP 中进行传输，而不是像大多数文件传输协议那样使用可靠的 TCP。这反过来又对协议的整体运作方式产生了有趣的影响。

NFS 的另一个关键设计目标是简单性（这当然与性能有关）。 NFS 服务器据说是无状态的，这意味着该协议的设计使得服务器不需要跟踪哪些文件已被哪些客户端打开。这允许彼此独立地发出请求，并允许服务器优雅地处理诸如崩溃之类的事件，而无需复杂的恢复过程。该协议还经过专门设计，即使请求丢失或重复，也不会发生文件损坏。

**关键概念：**创建网络文件系统 (NFS) 是为了允许客户端主机像访问本地服务器一样访问远程服务器上的文件。它的主要设计目标是性能、简单性和跨供应商兼容性。

<u>**NFS 版本和标准**</u>

由于最初是由 Sun 设计和销售的，NFS 最初是作为事实上的标准。 NFS 的第一个广泛使用的版本是版本 2，这仍然是该协议最常见的版本。当 RFC 1094，NFS：网络文件系统协议规范于 1989 年发布时，NFS 版本 2 最终被编纂为官方 TCP/IP 标准。

随后开发了 NFS 版本 3，并于 1995 年作为 RFC 1813，NFS 版本 3 协议规范发布。它类似于版本 2，但做了一些更改并添加了一些新功能。其中包括支持更大的文件传输、更好地支持设置文件属性，以及几个新的文件访问和操作过程。 NFS 版本 3 还支持比版本 2 更大的文件。

- NFS 版本 4 于 2000 年发布为 RFC 3010，NFS 版本 4 协议。 NFS 的第 3 版仅包含对第 2 版的相对较小的更改，而 NFSv4 实际上是对 NFS 的重写。它包括许多更改，最显着的是以下内容：

- NFSv4 反映了现代互联网络的需求，更加强调安全性。

- NFSv4 引入了复合过程的概念，它允许将多个更简单的过程作为一个组从客户端发送到服务器。

- NFSv4 几乎使客户端在访问 NFS 服务器上的文件时可以使用的单个过程的数量增加了一倍。

- 版本 4 还对消息传递进行了重大更改，将 TCP 规范指定为 NFS 的传输协议。

- 最后，NFS 将 Mount 协议的功能集成到基本 NFS 协议中，消除了它作为一个单独的协议，因为它在版本 2 和 3 中都是如此。

与早期标准相比，第 4 版标准还包含更多有关实现和可选功能的详细信息 — 它长达 275 页。这么多不简单！ J RFC 3010 后来于 2003 年 4 月更新为 RFC 3530，网络文件系统 (NFS) 版本 4 协议。该标准对 NFS 版本 4 的操作进行了一些进一步的修订和澄清。



##### 2.2.2 NFS 体系结构和组件（部分：1 2）

从整个 TCP/IP 协议族的角度考虑，网络文件系统 (NFS) 是一个单一的协议，它位于 TCP/IP (DOD) 模型的应用层。该 TCP/IP 层包含 OSI 参考模型的会话层、表示层和应用层。正如我之前在本指南中所说，大多数时候，我认为尝试区分第 5 层到第 7 层没有多大价值。然而，在某些情况下，这些层有助于理解协议的体系结构，NFS 就是这种情况。

<u>**NFS 体系结构和主要组件**</u>
NFS 的操作以三个主要组件的形式定义，可以将其视为逻辑上驻留在对应于 TCP/IP 应用层的三个 OSI 模型层中的每一个（参见图 253）。这些组件是：

远程过程调用 (RPC)：RPC 是一种通用的会话层服务，用于实现客户端/服务器互联功能。它将程序调用特定主机上的本地过程的概念扩展到通过网络调用远程设备上的过程。

外部数据表示 (XDR)：XDR 是一种描述性语言，允许以一致的方式定义数据类型。 XDR 在概念上位于表示层；它的通用表示允许使用 NFS 在可能使用非常不同的内部数据存储方法的计算机之间交换数据。

NFS 过程和操作：NFS 的实际功能是以过程和操作的形式实现的，这些过程和操作在概念上在 OSI 模型的第七层起作用。这些过程指定要通过网络对文件执行的特定任务，使用 XDR 表示数据，使用 RPC 来跨互联网络传输命令。
如果您愿意，这三个关键的“子协议”构成了 NFS 协议的主体。每一个都在 NFS 部分的单独主题中进行了更详细的描述。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\nfscomponents.png)

​                                                                                  **图 253：NFS 架构组件**

NFS 在体系结构上位于 TCP/IP 应用层。 尽管在 TCP/IP 模型中通常没有明确区分 OSI 参考模型的第五层到第七层的功能，但 NFS 的三个子协议很好地对应于这三个层，如图所示。

**关键概念：**NFS 在体系结构上位于 TCP/IP 模型的应用层。 它的功能主要通过三个不同的功能组件来实现，这些组件实现了 OSI 参考模型第五层到第七层的功能：远程过程调用（RPC），提供会话层服务； 外部数据表示 (XDR) 标准，它管理数据表示和转换，以及 NFS 过程和操作，允许使用其他两个组件执行应用程序层任务。

<u>**其他重要的 NFS 功能**</u>

除了这三个组件之外，NFS 协议作为一个整体还涉及许多其他功能，我认为其中一些值得特别提及：

- Mount Protocol：NFS 的创建者做出了一个特定的决定，即不让 NFS 处理文件打开和关闭的细节。相反，一个称为 Mount 协议的单独协议用于此目的。通过网络访问文件或其他资源涉及首先使用此协议安装它。 Mount Protocol 在架构上是不同的，但显然与 NFS 密切相关，甚至在 NFS 标准的附录中进行了定义。我在本节的最后一个主题中对其进行了描述。 （请注意，在 NFSv4 中，Mount 协议的功能已“适当”地合并到 NFS 中。）

- NFS 文件系统模型：NFS 使用特定模型来实现使用它的系统的目录和文件结构。该模型紧密基于 UNIX 的文件系统模型，但不仅仅特定于该操作系统。结合Mount Protocol的解释进行讨论。

- 安全性：NFS 的第 2 版和第 3 版仅包含有限的安全规定。他们使用 UNIX 风格的身份验证来检查各种操作的权限。 NFS 版本 4 极大地增加了可用于 NFS 实现的安全选项。这包括多种身份验证和加密算法的选项，以及对整个协议进行的许多更改以使其更加“安全”。

与其他TCP/IP协议一样，NFS是以实现上述功能的客户端和服务器软件的形式实现的。 NFS 标准，尤其是版本 3 和 4，讨论了许多与正确的 NFS 客户端/服务器实现相关的问题，包括服务器和客户端之间的交互、文件锁定、权限问题、缓存、重传策略、国际支持等等。其中许多问题需要进行超出本指南范围的广泛讨论。您需要参考 NFS 的标准，尤其是版本 3 和 4，以获取完整的详细信息。



##### 2.2.3 NFS 数据存储和数据类型，以及外部数据表示 (XDR) 标准（部分：1 2）

NFS 背后的总体思想是允许一台计算机上的某个人像在本地计算机上一样轻松地读取或写入另一台计算机上的文件。当然，您本地机器上的文件都存储在同一个文件系统中，使用相同的文件结构和相同的方式来表示不同类型的数据。您无法确定访问远程设备时是否会出现这种情况，这会产生 NFS 必须处理的“Tower of Babel”问题。

<u>**创建通用数据交换方法：XDR**</u>
实现表示一致性的一种方法是简单地限制对使用相同操作系统的机器上的远程文件的访问。但是，这会消除 NFS 的大部分有效性。要求每台计算机都理解其他每台计算机的内部表示也是非常不切实际的。需要一种更通用的方法来允许非常不同的机器共享数据。为此，NFS 的创建者对其进行了定义，使其使用通用数据描述语言处理数据。这种语言称为外部数据表示 (XDR) 标准，最初在 RFC 1014 中进行了描述；它于 1995 年在 RFC 1832，XDR：外部数据表示标准中更新。

XDR 背后的想法很简单，可以通过类比的形式轻松理解。如果您的代表在一次大会上说 50 种不同的语言，他们将很难沟通。您可以聘请翻译人员来提供便利，但您永远找不到能够处理所有不同可能的语言组合的翻译人员。一个更实际的解决方案是将一种语言（例如英语）声明为通用语言。然后你只需要 49 名翻译人员：一名负责将英语翻译成每一种非英语语言，然后再翻译回来。要从瑞典语翻译成葡萄牙语，您需要先从瑞典语翻译成英语，然后再从英语翻译成葡萄牙语。共同语言可以是法语、西班牙语或其他语言，只要能找到从所有其他语言到该共同语言的翻译者即可。

XDR 的工作方式相同。当有关如何访问文件的信息要从设备 A 传输到设备 B 时，设备 A 首先将其从 A 的内部表示形式转换为这些数据类型的 XDR 表示形式。信息使用 XDR 编码在网络上传输。然后，设备 B 从 XDR 转换回它自己的内部表示，因此它可以像在本地文件系统上一样呈现给用户。每个设备只需要知道如何将自己的“语言”转换为 XDR，然后再转换回来；设备 A 不需要知道设备 B 的内部细节，反之亦然。这种转换当然是表示层的经典工作，也就是 XDR 在 OSI 参考模型中的位置。 XDR 本身基于称为抽象语法表示法的 ISO 标准。

顺便说一句，这里描述的想法也用于其他协议，以允许独立于底层系统性质的数据交换。例如，使用简单网络管理协议 (SNMP) 交换管理信息的方式背后也有类似的想法。同样的基本思想构成了 Telnet 协议中使用的重要网络虚拟终端 (NVT) 范例的基础。

**关键概念：**外部数据表示 (XDR) 标准的目的是定义一种表示通用数据类型的通用方法。使用这种通用表示法，无论每个设备使用何种内部文件系统，都可以在设备之间交换数据。这使 NFS 能够在可能使用非常不同的硬件和软件平台实现的客户端和服务器之间交换文件数据。

<u>**XDR 数据类型**</u>

要使 XDR 具有通用性，它必须允许描述计算机中使用的所有常见数据类型。 例如，它必须允许交换整数、浮点数、字符串和其他数据结构。 XDR 标准使用有点类似于语言“C”的符号来描述许多数据类型的结构。 您可能知道，这是计算历史上最流行的语言之一，与 UNIX 密切相关，因此也与某些 TCP/IP 技术密切相关。

表 181 显示了 XDR 定义的数据类型，NFS 可以使用这些数据类型在客户端和服务器之间交换数据。 对于每一个，我都包含了数据类型代码、字节大小、名称和简短描述。


​                                                        **表 181：NFS 外部数据表示 (XDR) 数据类型**

| **Data Type Code** | **Size (bytes)** | **Description**                                              |
| ------------------ | ---------------- | ------------------------------------------------------------ |
| **int**            | 4                | **Signed Integer:** 有符号整数：一个 32 位有符号整数，采用二进制补码表示法，能够保存从 -2,147,483,648 到 +2,147,483,647 的值。 |
| **unsigned int**   | 4                | **Unsigned Integer:** 无符号整数：一个 32 位无符号整数，从 0 到 4,294,967,295。 |
| **enum**           | 4                | **Enumeration:** 枚举：表示有符号整数的另一种方式，其中一些整数值用于代表特定的常量值。例如，您可以通过定义值 1 代表“紫色”，2 代表“蓝色”等来表示彩虹的颜色。 |
| **bool**           | 4                | **Boolean:** 布尔值：整数的逻辑表示，类似于两级枚举，其中值 0 定义为“FALSE”，1 定义为“TRUE”。 |
| **hyper**          | 8                | **Signed Hyper Integer:** 有符号超整数：与常规有符号整数相同，但 8 字节宽以允许更大的数字。 |
| **unsigned hyper** | 8                | **Unsigned Hyper Integer:** 无符号超整数：与常规无符号整数相同，但 8 字节宽以允许更大的数字。 |
| **float**          | 4                | **Floating-Point Number:** 浮点数：一个 32 位有符号浮点数。 1 位保存符号（正或负），8 位保存指数（幂），以 2 为底，23 位保存尾数（数字的小数部分）。 |
| **double**         | 8                | **Double-Precision Floating-Point Number:** 双精度浮点数：与 float 相同，但具有更多位数以实现更高的精度。 1 位用于符号，11 位用于指数，52 位用于尾数。 |
| **quadruple**      | 16               | **Quadruple-Precision Floating-Point Number:** 四倍精度浮点数：与 float 和 double 相同，但具有更多位数以允许更高的精度。 1 位用于符号，15 位用于指数，112 位用于尾数。 |
| **opaque**         | Variable         | **Opaque Data:** 不透明数据：要在设备之间传递的数据，无需使用 XDR 进行特定表示。术语不透明意味着数据被视为内部无法看到的“黑匣子”。显然，任何使用这种数据类型的机器都必须自己知道如何处理它，因为 NFS 不知道。 |
| **string**         | Variable         | **String:** 字符串：可变长度的 ASCII 字符字符串。            |
| **(array)**        | Variable         | **Arrays:** 数组：可以在数组中指定一组上述任何单一类型的元素，例如整数、浮点数等，以允许将许多元素作为单个单元引用。它们不使用单独的数据类型代码表示。 |
| **struct**         | Variable         | **Structure:** 结构：包含来自该表的其他数据元素的任意结构。这允许定义复杂的数据类型。 |
| **union**          | Variable         | **Discriminated Union:** 歧视联盟：一种复杂的结构形式，我不能在这里用简短的描述来公正地描述它。 |
| **void**           | 0                | **Void:** Void：不包含任何内容的“空”数据类型。               |
| **const**          | 0                | **Constant:** 常量：不声明数据，只是定义一个在其他表示中使用的常量值。 |

如您所见，XDR 提供了可观的数据描述能力。 如果您了解“C”语言，那么您可能很熟悉该表中的大部分内容。 不幸的是，如果不把它变成 C 编程指南，我就无法真正详细地描述上表中许多更复杂的数据类型。

除了上述之外，XDR 还提供了一种定义新数据类型的方法，以及一种指定可选数据的方法。 这提供了比已经具体描述的大量特定类型更多的灵活性。 NFS 的每个版本都有其支持的数据类型列表略有不同。



##### 2.2.4 使用远程过程调用 (RPC) 的 NFS 客户端/服务器操作（部分：1 2 3）

几乎所有应用程序都处理文件和其他资源。当特定计算机上的软件程序想要读取文件、写入文件或执行相关任务时，它需要为此目的使用正确的软件指令。要求每个软件程序都包含这些指令的副本是低效的，因此，它们被编码为标准化软件模块，有时称为过程。为了执行一个动作，一个软件调用过程；该过程暂时接管主程序并执行诸如读取或写入数据之类的任务。然后该过程将程序的控制权返回给调用它的软件，并且还可以选择返回数据。

由于 NFS 的关键概念是使远程文件访问看起来像本地文件访问，因此它是围绕使用刚刚描述的过程调用方法的基于网络的版本而设计的。想要对文件执行某些操作的软件应用程序仍然会进行过程调用，但它会调用另一台计算机上的过程，而不是本地计算机上的过程。一组特殊的例程用于处理呼叫在网络上的传输，其方式在很大程度上对执行呼叫的软件是不可见的。

这个功能本可以直接在 NFS 中实现，但 Sun 创建了一个单独的会话层协议组件，称为远程过程调用 (RPC) 规范，它定义了它是如何工作的。 RPC 最初是作为 NFS 的一个子组件创建的，但是足够通用和有用，以至于它已被用于 TCP/IP 中的其他客户端/服务器应用程序。出于这个原因，它在许多方面确实被认为是一个独特的协议。

因为 RPC 是在 NFS 中进行通信的实际过程，所以 NFS 本身不同于许多其他 TCP/IP 协议。它的操作不能像 HTTP 或 DHCP 甚至 TCP 这样的协议那样用特定的消息交换和状态图来描述，因为 RPC 完成了所有这些。 NFS 实际上是根据一组 RPC 服务器过程和操作定义的，NFS 服务器使 NFS 客户端可以使用这些过程和操作。这些过程和操作各自允许对文件执行特定类型的操作，例如读取文件、写入文件或删除文件。

<u>**RPC 操作和传输协议使用**</u>

当客户端想要对特定机器上的文件执行某种类型的操作时，它会使用 RPC 调用该机器上的 NFS 服务器。服务器接受请求并执行所需的操作，然后根据请求将结果代码和可能的数据返回给客户端。结果代码指示操作是否成功。如果是，客户可以假设它要求完成的任何事情都已完成。例如，在写入数据的情况下，客户端可以假设数据已成功写入长期存储。

NFS 可以在会话层具有有效 RPC 实现的任何传输机制上运行。当然在 TCP/IP 中我们有两种传输协议，UDP 和 TCP。有趣的是，NFS 在其传输协议的使用方面经历了某种演变。 NFSv2 标准表示它使用 UDP“正常”运行，这仍然是 NFS 信息传输的常见方式。 NFSv3 说可以使用 UDP 或 TCP，但 NFSv4 指定 TCP 来承载数据。 NFS 使用的标称注册端口号是 2049，但实际上其他端口号有时也用于 NFS，通过使用 RPC 的“端口映射器”功能。

**关键概念：**NFS 不像大多数其他协议那样使用专用的消息格式。相反，客户端和服务器使用远程过程调用 (RPC) 协议来交换文件操作请求和数据。

<u>**NFS 中客户端和服务器的职责**</u>

由于 UDP 不可靠，使用该协议传输重要信息可能看起来很奇怪。例如，我们显然不希望我们试图写入文件的数据在传输过程中丢失。但是请记住，UDP 并不排除使用措施来确保可靠的通信，只是它本身不提供这些功能。 NFS 可以使用 UDP，因为该协议本身旨在容忍传输数据丢失并从中恢复。

与这个概念一致，NFS 的总体设计将大部分协议的实施责任放在了客户端，而不是服务器端。正如 NFSv3 标准所说，“NFS 服务器是愚蠢的，而 NFS 客户端是智能的。”这意味着服务器只专注于响应请求，而客户端必须处理协议的大部分“细节”细节，包括从失败的通信中恢复。这实际上是使用 UDP 时的常见要求，因为如果客户端请求在传输过程中丢失，服务器无法知道它是否曾经发送过。

如 NFS 概述中所述，NFS 服务器被设计为“无状态”。简而言之，这意味着 NFS 服务器不会跟踪使用它的客户端从一个请求到另一个请求的状态。每个请求都独立于前一个请求，服务器在从客户端收到新命令时，本质上对它之前所做的事情“没有记忆”。这再次需要将更多“智能”放入客户端，但具有在服务器崩溃的情况下简化恢复的重要优势。由于服务器没有为客户端跟踪任何内容，因此不会丢失任何内容。这是确保文件不会因网络问题或拥塞而损坏的重要部分。

<u>**客户端和服务器缓存**</u>
NFS 客户端和服务器都可以利用缓存来提高性能。服务器可以使用缓存来存储最近请求的信息，以备再次需要时使用。他们还可以使用预测缓存，有时称为预取。在这种技术中，接收到从文件中读取数据块的请求的服务器可能会将它之后的下一个块加载到内存中，理论上它可能会被下一个请求。客户端缓存用于满足来自应用程序的重复 NFS 请求，同时避免额外的 RPC 调用。与 NFS 的几乎所有其他内容一样，缓存在 NFS 版本 4 中的实现比以前的版本更彻底。

**关键概念：**NFS 被设计为一种无状态协议，具有智能客户端和响应请求且不维护有关哪些文件正在使用的状态信息的相对“愚蠢”的服务器。为了提高效率，NFS 最初设计为使用 UDP 进行传输。这要求 NFS 客户端负责检测丢失的请求并重新传输它们。 NFS 版本 4 使用 TCP 以利用 TCP 的可靠性和其他功能。



##### 2.2.5 NFS 服务器程序和操作（部分：1 2 3）

NFS 客户端和服务器之间的实际信息交换是由底层的远程过程调用 (RPC) 协议执行的。因此，NFS 功能不是根据特定的协议操作来描述的，而是通过描述客户端可能对驻留在服务器上的文件执行的不同操作来描述的。在 NFS 的原始版本 NFSv2 中，这些称为 NFS 服务器程序。

每个过程代表客户端可能执行的特定操作，例如从文件读取、写入文件或创建或删除目录。对文件执行的操作需要使用称为文件句柄的数据结构来引用文件。顾名思义，文件句柄就像一个真实对象的句柄，让客户端和服务器“抓住”文件。 Mount 协议用于挂载文件系统，使文件句柄能够被访问以供 NFS 过程使用。

NFS 版本 3 对服务器过程使用相同的基本模型，但进行了某些更改。删除了两个 NFSv2 过程，并添加了几个新过程以支持新功能。分配给识别每个过程的数字也发生了变化。

<u>**NFS 版本 2 和版本 3 服务器过程**</u>

表 182 显示了 NFS 版本 2 和 3 中定义的服务器过程。 该表显示了 NFSv2 和 NFSv3 的过程编号，以及每个过程的名称和对它的作用的描述。 我保持描述简短，以便该表可以作为 NFS 功能的有用总结。 它们按照 NFSv2 中使用的过程编号的顺序列出。


​                                                                  **表 182：NFS 版本 2 和版本 3 服务器过程**

| **Procedure # (v2)** | **Procedure # (v3)** | **Procedure Name** | **Procedure Summary**                            | **Description**                                              |
| -------------------- | -------------------- | ------------------ | ------------------------------------------------ | ------------------------------------------------------------ |
| **0**                | **0**                | *null*             | Do Nothing                                       | 为测试目的提供的虚拟程序。                                   |
| **1**                | **1**                | *getattr*          | Get File Attributes                              | 检索远程服务器上文件的属性。                                 |
| **2**                | **2**                | *setattr*          | Set File Attributes                              | 设置（更改）远程服务器上文件的属性。                         |
| **3**                | **—**                | *root*             | Get Filesystem Root (obsolete)                   | 此过程最初定义为允许客户端查找远程文件系统的根目录，但现在已过时。此功能现在作为 Mount 协议的一部分实现。它在 NFSv3 中被删除。 |
| **4**                | **3**                | *lookup*           | Look Up File Name                                | 返回供客户端使用的文件的文件句柄。                           |
| **5**                | **5**                | *readlink*         | Read From Symbolic Link                          | 读取使用符号链接指定的文件的名称。                           |
| **6**                | **6**                | *read*             | Read From File                                   | 从文件中读取数据。                                           |
| **7**                | **—**                | *writecache*       | Write To Cache                                   | 建议将来在版本 2 中使用，但已放弃并从版本 3 中删除。         |
| **8**                | **7**                | *write*            | Write To File                                    | 将数据写入文件。                                             |
| **9**                | **8**                | *create*           | Create File                                      | 在服务器上创建一个文件。                                     |
| **10**               | **12**               | *remove*           | Remove File                                      | 从服务器删除文件。                                           |
| **11**               | **14**               | *rename*           | Rename File                                      | 更改文件的名称。                                             |
| **12**               | **15**               | *link*             | Create Link To File                              | 创建指向文件的“硬”（非符号）链接。                           |
| **13**               | **10**               | *symlink*          | Create Symbolic Link                             | 创建指向文件的符号链接。                                     |
| **14**               | **9**                | *mkdir*            | Create Directory                                 | 在服务器上创建一个目录。                                     |
| **15**               | **13**               | *rmdir*            | Remove Directory                                 | 删除目录。                                                   |
| **16**               | **16**               | *readdir*          | Read From Directory                              | 读取目录的内容。                                             |
| **17**               | **—**                | *statfs*           | Get File System Attributes                       | 向客户端提供有关远程文件系统的一般信息，包括文件系统的大小和剩余的可用空间量。在 NFSv3 中，它被 fsstat 和 fsinfo 取代。 |
| **—**                | **4**                | *access*           | Check Access Permission                          | （NFSv3 中的新增功能。）确定用户对特定文件系统对象的访问权限。 |
| **—**                | **11**               | *mknod*            | Create A Special Device                          | （NFSv3 中的新增功能。）创建一个特殊文件，例如命名管道或设备文件。 |
| **—**                | **17**               | *readdirplus*      | Extended Read From Directory                     | （NFSv3 中的新增功能。）从目录中检索附加信息。               |
| **—**                | **18**               | *fsstat*           | Get Dynamic File System Information              | （NFSv3 中的新增功能。）返回易失（动态）文件系统状态信息，例如当前文件系统可用空间量和可用文件槽数。 |
| **—**                | **19**               | *fsinfo*           | Get Static File System Information               | （NFSv3 中的新增功能。）返回有关文件系统的静态信息，例如有关文件系统如何使用的一般数据，以及有关应如何构造对服务器的请求的参数。 |
| **—**                | **20**               | *pathconf*         | Retrieve POSIX Information                       | （NFSv3 中的新增功能。）检索文件或目录的附加信息。           |
| **—**                | **21**               | *commit*           | Commit Cached Data On A Server To Stable Storage | （NFSv3 中的新增功能。）将服务器保存在写缓存中的任何数据刷新到存储。这用于确保客户端已发送到服务器但服务器已挂起写入存储的任何数据实际上已被写出。 |

<u>**NFS 版本 4 服务器过程和操作**</u>

客户端可能希望对一个文件执行多项操作是很常见的：例如，多次连续读取。 NFSv2 和 NFSv3 中服务器过程系统的问题之一是每个客户端操作都需要单独的过程调用。 这有点低效，尤其是在通过高延迟链接使用 NFS 时。

为了提高服务器过程的效率，NFS 版本 4 对服务器过程的实现方式进行了重大更改。 不是每个客户端操作都是一个单独的过程，而是定义了一个称为复合的单一过程。 在这个“复合”过程中，封装了大量的服务器操作。 这些都作为一个单元发送，服务器按顺序解释并遵循每个操作中的指令。

此更改意味着 NFSv4 中实际上只有两个 RPC 过程，如表 183 所示。


​                                                                   **表 183：NFS 版本 4 服务器过程**

| **Procedure #** | **Procedure Name** | **Procedure Summary** | **Description**                           |
| --------------- | ------------------ | --------------------- | ----------------------------------------- |
| **0**           | *null*             | Do Nothing            | 为测试目的提供的虚拟程序。                |
| **1**           | *compound*         | Compound Operations   | 如上所述，将多个 NFS 操作合并为一个请求。 |



所有真正的客户端操作都定义为复合过程中的操作，如表 184 所示。您会注意到 NFSv4 操作的数量远远大于 NFSv2 和 NFSv3 中的过程数量。 这是由于版本 4 中添加的功能以及 NFSv4 将以前由单独的 Mount 协议执行的功能合并到 NFS 本身这一事实。


​                                                                表 184：NFS 版本 4 服务器操作

| **Operation #** | **Operation Name**     | **Operation Summary**               | **Description**                                              |
| --------------- | ---------------------- | ----------------------------------- | ------------------------------------------------------------ |
| 3               | *access*               | Check Access Rights                 | 确定用户对对象的访问权限。                                   |
| 4               | *close*                | Close File                          | 关闭文件。                                                   |
| 5               | *commit*               | Commit Cached Data                  | 将服务器保存在写入缓存中的任何数据刷新到存储，以确保永久记录任何未决数据。 |
| 6               | *create*               | Create A Non-Regular File Object    | 这类似于 NFSv3 中的 mknod 过程；它创建一个“非常规”（特殊）目标文件。 （常规文件是使用打开操作创建的。） |
| 7               | *delepurge*            | Purge Delegations Awaiting Recovery | NFSv4 具有服务器可以将某些文件的责任委托给客户端的功能。此操作删除等待从客户端恢复的委派。 |
| 8               | *delegreturn*          | Return Delegation                   | 将委托从客户端返回给授予它的服务器。                         |
| 9               | *getattr*              | Get Attributes                      | 获取文件的属性。                                             |
| 10              | *getfh*                | Get Current Filehandle              | 返回文件句柄，它是用于允许访问文件的逻辑对象。               |
| 11              | *link*                 | Create Link To A File               | 创建指向文件的“硬”（非符号）链接。                           |
| 12              | *lock*                 | Create Lock                         | 在文件上创建一个锁。锁用于管理对文件的访问，例如，防止两个客户端同时尝试写入文件并因此损坏文件。 |
| 13              | *lockt*                | Test For Lock                       | 测试对象上是否存在锁并返回有关它的信息。                     |
| 14              | *locku*                | Unlock File                         | 删除先前在文件上创建的锁。                                   |
| 15              | *lookup*               | Lookup Filename                     | 查找或查找文件。                                             |
| 16              | *lookupp*              | Lookup Parent Directory             | 返回对象父目录的文件句柄。                                   |
| 17              | *nverify*              | Verify Difference In Attributes     | 检查文件的属性是否已更改。                                   |
| 18              | *open*                 | Open A Regular File                 | 打开一个文件。                                               |
| 19              | *openattr*             | Open Named Attribute Directory      | 打开与文件关联的属性目录。                                   |
| 20              | *open_confirm*         | Confirm Open                        | 确认与打开的文件相关的信息。                                 |
| 21              | *open_ downgrade*      | Reduce Open File Access             | 调整已打开文件的访问权限。                                   |
| 22              | *putfh*                | Set Current Filehandle              | 将一个文件句柄替换为另一个。                                 |
| 23              | *putpubfh*             | Set Public Filehandle               | 将当前文件句柄设置为服务器的“公共”文件句柄。这可能与根文件句柄相同也可能不同（见下文）。 |
| 24              | *putrootfh*            | Set Root Filehandle                 | 将当前文件句柄设置为服务器文件系统的根目录。                 |
| 25              | *read*                 | Read From File                      | 从文件中读取数据。                                           |
| 26              | *readdir*              | Read Directory                      | 读取目录的内容。                                             |
| 27              | *readlink*             | Read Symbolic Link                  | 读取使用符号链接指定的文件的名称。                           |
| 28              | *remove*               | Remove Filesystem Object            | 移除（删除）一个对象。                                       |
| 29              | *rename*               | Rename Directory Entry              | 更改对象的名称。                                             |
| 30              | *renew*                | Renew A Lease                       | 更新服务器创建的 NFS 委托。 （请注意，这些租约与 DHCP 租约无关！） |
| 31              | *restorefh*            | Restore Saved Filehandle            | 允许以前保存的文件句柄成为当前文件句柄。                     |
| 32              | *savefh*               | Save Current Filehandle             | 允许保存文件句柄，以便以后需要时可以恢复。                   |
| 33              | *secinfo*              | Obtain Available Security           | 检索 NFS 安全信息。                                          |
| 34              | *setattr*              | Set Attributes                      | 更改文件的一个或多个属性。                                   |
| 35              | *setclientid*          | Negotiate Clientid                  | 允许客户端向服务器传达有关客户端希望如何使用 NFS 的信息。    |
| 36              | *setclientid_ confirm* | Confirm Clientid                    | 用于使用 setclientid 确认先前协商的结果。                    |
| 37              | *verify*               | Verify Same Attributes              | 允许客户端在继续执行特定操作之前验证某些属性。               |
| 38              | *write*                | Write To File                       | 将数据写入文件。                                             |
| 39              | *release_ lockowner*   | Release Lockowner State             | 由客户端用来告诉服务器释放与文件锁相关的某些信息。           |
| 10044           | *illegal*              | Illegal Operation                   | 当来自客户端的请求中使用无效操作时，用于支持错误报告的“占位符”（虚拟）操作。 |

**关键概念：**NFS 中的文件操作是使用 NFS 服务器程序执行的。 在 NFS 版本 2 和 3 中，每个过程执行一个操作，例如从文件中读取数据。 在版本 4 中，定义了一个特殊的复合操作，允许在单个请求中将许多单独的操作发送到服务器。



##### 2.2.6 NFS 文件系统模型和挂载协议（部分：1 2 3）

于客户端使用 NFS 来模拟对远程文件目录的访问，就好像它们是本地文件一样，因此该协议必须将文件从远程系统“呈现”给本地用户。正如本地存储设备上的文件使用特定文件系统排列一样，NFS 也使用文件系统模型来表示文件如何显示给用户。

<u>**NFS 文件系统模型**</u>
NFS 使用的文件系统模型与我们大多数人所熟悉的模型相同：包含文件和子目录的目录分层排列。层次结构的顶部是根，它包含任意数量的文件和一级目录。每个目录可能包含更多文件或其他目录，允许创建任意树结构。

可以使用文件名和路径名来唯一指定文件，该路径名显示必须从根目录遍历才能找到该文件的目录序列。由于 NFS 与 UNIX 相关联，因此 NFS 讨论中的文件通常以 UNIX 表示法显示；例如，“/etc/hosts”。同样的基本树思想也可以用微软操作系统遵循的方法来表达：“C:\WINDOWS\HOSTS”。

<u>**安装协议**</u>

在 NFS 可用于允许客户端访问远程服务器上的文件之前，必须为客户端提供访问该文件的方法。这意味着远程文件系统的一部分必须对客户端可用，并且打开文件以供访问。在创建 NFS 时做出了一个特定的决定，即不将文件访问、打开和关闭功能放入 NFS 本身。相反，创建了一个单独的协议来与 NFS 一起工作，因此如果将来需要更改提供文件访问的方法，则不需要更改 NFS 本身。这种单独的机制称为挂载协议，在 RFC 1094 (NFSv2) 的附录 A 中进行了描述。请注意，虽然功能不同，但 Mount 被视为整个 NFS 包的一部分。

当 NFS 被修订到版本 3 时，挂载协议也进行了类似的修改。安装协议的 NFSv3 版本在 RFC 1813 (NFSv3) 的附录 I 中定义。它包含对协议工作方式的一些更改，但是两个版本的 Mount 的整体操作几乎相同。

术语“装载”实际上类似于硬件术语，指的是使物理存储卷可用。在“过去”，存储设备通常是可移动磁盘组，要使用它，您需要将其安装到驱动器单元上。以类似的方式，使用 Mount 协议在逻辑上挂载 NFS 资源，这使得共享文件系统对客户端可用。然后可以打开文件并将文件句柄返回给 NFS 客户端，以便它可以引用该文件进行读取和写入等操作。

**关键概念：**NFS 版本 2 和 3 不包括打开或关闭远程服务器上的资源的过程。在这些版本上完成 NFS 任务之前，必须使用特殊的 Mount 协议来挂载文件系统并创建文件句柄以访问其中的文件；该协议还用于在不再需要时卸载文件系统。 Mount 协议的实现方式与 NFS 本身非常相似，定义了使用 RPC 和 XDR 的过程。在 NFS 版本 4 中，不再需要 Mount；它执行的任务是作为 NFSv4 操作实现的。

<u>**安装协议服务器程序**</u>

Mount 协议的实际实现与 NFS 本身非常相似。 与 NFS 一样，Mount 协议使用 XDR 来定义要在客户端和服务器之间交换的数据类型，并使用 RPC 来定义一组客户端可以用来执行不同操作的服务器过程。 Mount 和 NFS 之间的主要区别只是 Mount 定义了与打开和关闭文件系统相关的过程，而不是文件访问操作。 表 185 显示了 Mount 协议中使用的服务器过程。

​                                                                      **表 185：NFS 安装协议服务器程序**

| **Procedure #** | **Procedure Name** | **Procedure Summary**    | **Description**                                              |
| --------------- | ------------------ | ------------------------ | ------------------------------------------------------------ |
| **0**           | *null*             | Do Nothing               | 为测试目的提供的虚拟程序。                                   |
| **1**           | *mnt*              | Add Mount Entry          | 通过将服务器上的路径映射到供客户端使用的文件句柄来执行挂载操作。 |
| **2**           | *dump*             | Return Mount Entries     | 返回远程安装的文件系统的列表。                               |
| **3**           | *umnt*             | Remove Mount Entry       | 通过删除挂载条目执行“卸载”。 （应该是“下马”。技术人员很少进入语法。J） |
| **4**           | *umntall*          | Remove All Mount Entries | 删除所有挂载条目，从而消除服务器和客户端之间所有已挂载的文件系统。 |
| **5**           | *export*           | Return Export List       | 返回导出的文件系统列表，并指示允许哪些客户端安装它们。这用于让客户端查看哪些服务文件系统可供使用。 |



如本节其他主题中所述，NFS 版本 4 取消了单独的装载协议的概念，将文件装载操作直接合并到 NFS 中。



### 第三章、TCP/IP网络配置和管理协议（BOOTP、DHCP、SNMP和RMON）

有些人研究 OSI 参考模型只是为了通过测试，否则认为它“无用”。我认为这很重要，因为它显示了互联网络的不同硬件和软件组件如何组合在一起。其中一个方面是，该模型让我们清楚地看到网络的功能是如何通过在较低层上构建较高层来实现的。我们从底层开始，主要处理硬件，然后在它们之上构建在中间层构建网络和互联网络的软件和协议。 OSI 模型的最高层，尤其是应用层，运行在由下面的层实现的互联网络之上。因此，正是在这个层面上，我们通常讨论允许最终用户执行不同网络通信任务的协议和应用程序。

当然，用户是我们创建网络和互联网络的首要原因。但是，虽然应用层确实是我们找到面向用户的协议的地方，但用户并不是唯一需要在这一层使用网络应用程序的人。网络管理员有许多他们必须每天执行的功能，以保持网络平稳高效地运行，其中许多功能使用更高层的支持协议。

几十年前，管理员可能只负责少量计算机，所有这些计算机都在同一栋楼甚至同一个房间里。当网络中的某些东西需要修复或更改时，技术人员会走过去并“管理”它。今天，公司的电脑可能并不在手边；他们可能分布在一个校园、一个国家或整个世界。前往每台计算机执行各种维护任务不再可行。对于更大的网络，试图手动维护数千台计算机是不可能的，即使它们在同一栋楼里也是如此。

为了使管理在现代网络上切实可行，创建了特殊的应用程序级协议，允许管理员通过互联网本身以更自动化的方式使用远程设备。使用互联网络来帮助管理互联网络似乎具有讽刺意味，但是可以使用软件协议有效地执行许多任务，例如设备配置和管理。与手动流程相比，使用这些协议具有显着优势，并且是保持我们所依赖的互联网平稳运行的一部分。

本节介绍应用层协议提供的两类管理任务。第一部分涉及主机配置，描述了该过程背后的概念，以及用于完成互联网络主机自动配置的两个协议。第二个描述了用于远程管理、监视和控制互联网络上的远程硬件设备的协议。

作为本次讨论的一部分，我详细描述了四种实现主机配置和管理功能的 TCP/IP 协议。它们是用于主机配置的 TCP/IP 引导协议 (BOOTP) 和动态主机配置协议 (DHCP)，以及用于网络管理的简单网络管理协议 (SNMP) 和远程网络监控协议 (RMON)。



#### 3.1 主机配置和 TCP/IP 主机配置协议（BOOTP 和 DHCP）

放置在网络或互联网络上的每台主机都必须在使用前进行设置和配置。配置可确保主机正常运行，并告知主机与其他主机和设备成功通信所需的参数。在“美好的过去”，管理员会在每台主机添加到网络时手动设置它，并且还会根据需要手动更改配置。然而，现代网络非常庞大，手动配置主机是一项耗时的工作。此外，我们经常需要使用只有自动配置才能提供的功能，特别是对于没有内部存储的特殊主机。出于这些原因，开发了主机配置协议。

在本节中，我将描述主机配置协议背后的概念，然后说明当今使用的两个最重要协议的操作。我从一个提供主机配置概念和问题概述的主题开始。我描述了 TCP/IP 引导协议 (BOOTP)，这是第一个真正有能力的 IP 主机自动配置工具。然后，我将介绍 BOOTP 的后继者，即功能丰富的动态主机配置协议 (DHCP)，它广泛用于现代 TCP/IP 硬件和软件中。

**相关信息：**从技术上讲，第一个 TCP/IP 主机配置协议是反向地址解析协议 (RARP)。 RARP 是一个非常简单粗暴的协议，它允许执行非常基本的主机配置，但除此之外几乎没有。 RARP 与 BOOTP 和 DHCP 非常不同，不仅因为它的功能更有限，而且因为它像它所基于的地址解析协议 (ARP) 一样在第二层和第三层之间运行。因此，它包含在描述 ARP 的同一部分中。

##### 3.1.1 主机配置概念、问题和动机（部分：1 2 3）

将主机放在互联网络上需要遵循特定的设置和配置过程。必须选择和设置硬件，也必须选择和安装软件到硬件上。然而，一旦软件设置完成，我们还没有完成：我们还必须执行其他配置任务，告诉软件我们希望它如何运行，并给它特定的参数，以便它知道它在网络上的角色以及如何运行.

<u>**主机配置的目的**</u>
可能必须为互联网络上的每台主机执行的最重要的配置任务是赋予它一个身份，以地址的形式对其唯一。在 TCP/IP 网络中，必须为每个设备指定一个 IP 地址。主机还经常需要其他参数来确保它们正常运行。对于 TCP/IP 网络，我们可能想告诉每个主机以下一些信息：

- 本地网络上默认路由器的地址。

- 主机应使用的网络掩码。

- 为主机提供特定服务的服务器地址，例如邮件服务器或 DNS 名称服务器。

- 本地网络的最大传输单元 (MTU)。

- 用于 IP 数据报的生存时间 (TTL) 值。

可能还有更多；必须为某些网络设置许多不同的参数。其中许多可能对网络上的所有机器都是通用的，但 IP 地址必须是唯一的。因此，管理员必须确保每一个都只分配给一台计算机，即使在网络中添加和删除计算机时也是如此。

<u>**手动配置主机效率低下**</u>
如果您是负责一个小型 10 台主机 LAN 的管理员，那么执行设置和配置很简单：为每台主机设置硬件、安装软件，然后配置软件。甚至更改和跟踪 IP 地址也不是什么大问题；一张纸就足够了。但是，当您的网络中有一百台而不是十台计算机时会发生什么情况？一千呢？万？

随着网络规模的增长，手动配置所需的工作量也随之增加。虽然初始硬件设置可能很耗时，但至少主要是在主机首次设置时完成，此后很少更改。配置参数不是这种情况。如果在一个有上千台主机的网络上本地路由器的地址发生变化，你真的要到每台主机上去编辑一个配置文件吗？我绝对不会！

<u>**手动配置不可行的情况**</u>

与手动配置相关的繁重工作很重要，但手动配置的问题远远超出了效率低下的问题。在某些情况下，手动配置不仅不方便，而且实际上是不可能的：

- 远程配置：管理员不可能无处不在；现代网络可以跨越城市或国家。除非我们想培训每个用户如何配置网络主机，否则我们必须使用自动化协议。

- 移动设备配置：IP 是在计算机很大并且使用粗电缆相互连接时设计的；今天，我们的电脑可以装在衬衫口袋里，并使用无线电波进行通信。 IP 地址必须根据它们所连接的网络进行分配，这使得在移动设备时需要重新配置。这根本不利于手动配置。

- “哑”主机配置：我们今天使用的大多数主机都是成熟的计算机，有自己的内部存储。我们可以通过将地址输入设备启动时读取的文件来为此类设备分配地址。但是，有些设备不包含任何形式的存储。由于它们是批量生产的，因此它们都是相同的，并且无法在其中存储个性化参数。这样的设备依赖于配置协议来了解它需要什么才能在网络上运行——尤其是包括它的个人身份，正如我们在上面看到的那样。

- 地址共享：连接到全球 Internet 的设备激增导致必须仔细管理 IP 地址以确保它们不会浪费在不使用它们的设备上。一些组织甚至发现他们拥有的潜在主机比他们拥有的地址还多。主机配置协议可以允许在需要时将地址自动分配给主机，然后在主机离开网络时返回到公共“池”以供重新使用。这允许共享地址并减少对更多地址空间的需求。

<u>**自动化流程：主机配置协议**</u>

尽管我们大多数人没有可以自动执行设置和配置工作的硬件部分的机器人，但我们可以使用工具来简化其余工作。这包括使用特殊的主机配置协议。这些协议允许主机在设置时自动配置，并在需要时分配额外的参数。

主机配置协议通常通过让主机发送对地址和其他参数的请求来起作用，该请求由服务器的响应来满足。客户端使用响应中的信息来设置其地址、识别本地路由器以及执行其他必要的设置，以便它可以进行通信。

自动协议的使用解决了上述所有问题情况。我们可以远程配置设备，而不必走到每一台。我们可以立即为移动设备分配一个有效地址。我们可以让“哑”主机启动并获取它们运行所需的信息。最后，我们可以维护一组主机共享的地址池。

**关键概念：**主机配置协议使管理员能够设置主机，以便他们可以自动确定其地址和其他关键参数。它们之所以有用，不仅因为它们比手动配置节省了工作量，还因为它们支持远程、无存储或移动设备的自动设置。

<u>**主机配置协议在 TCP/IP 中的作用**</u>
您可能会觉得奇怪，主机配置协议会存在于应用层的“崇高高度”。听起来主机配置确实是一个与网络层更相关的功能，其中 IP 地址等互联网地址发挥作用。

事实上，一些主机配置协议，如基本的反向地址解析协议 (RARP)，确实存在于该级别。但是，将主机配置协议驻留在更高级别是有好处的。一个主要的是协议的操作不依赖于协议运行的硬件，从而使其更加通用。另一个是能够在网络之间传送主机配置消息，这对于在本地网络上运行的低级协议来说是不可能的。

这就引出了另一个公平的问题：如果设备不知道自己的地址，它如何发送和接收消息？正如我们将要看到的，答案是网络的本地广播能力。通过广播消息，没有分配 IP 地址的设备可以接收配置信息：包括 IP 地址。我们将在下一节讨论引导协议 (BOOTP) 时看到这是如何完成的。



##### 3.1.2 TCP/IP 引导协议 (BOOTP)

在 TCP/IP 网络上的设备可以有效通信之前，它需要知道自己的 IP 地址。虽然传统的网络主机可以从其内部磁盘读取此信息，但某些设备没有存储空间，因此没有这种奢侈。他们需要网络上另一台设备的帮助，为他们提供 IP 地址和其他信息和/或他们需要成为活动 IP 主机的软件。这个启动和运行新机器的问题通常称为引导，为了向 IP 主机提供此功能，创建了 TCP/IP 引导协议 (BOOTP)。

在本节中，我将相当详细地介绍 TCP/IP 引导协议。我从协议的概述和历史开始，并查看定义它的标准。然后，我将讨论 BOOTP 的一般客户端/服务器性质，以及如何在客户端和服务器之间的通信中完成寻址。逐步描述了BOOTP的运行，并说明了BOOTP报文的格式。最后，我描述了 BOOTP 供应商扩展，用于允许自定义 BOOTP 消息中发送的信息，并讨论了 BOOTP 中继代理，即使 BOOTP 服务器和客户端位于不同的网络上，它也允许协议运行.

**相关信息：**BOOTP 是动态主机配置协议的前身。 DHCP 被构建为与 BOOTP 基本兼容，因此这两个协议具有相当程度的共性。为避免重复，某些信息仅包含在 DHCP 部分，并在适当的地方提供了 BOOTP 主题的链接。另一方面，最初为 BOOTP 开发并被 DHCP 采用的供应商信息扩展和中继代理等功能背后的一些历史背景信息位于本节中，并从 DHCP 主题链接。为什么要以这种方式构建这些部分？今天 DHCP 比 BOOTP 更流行，所以我希望它的描述是完整的，但有些功能只有在最初在 BOOTP 操作的上下文中解释时才真正有意义。

如果您计划阅读有关 DHCP 和 BOOTP 的内容，我建议您先阅读本节。如果您不打算阅读 DHCP，您可能希望查看 DHCP 主题中有关 DHCP/BOOTP 互操作性的主题。




###### 3.1.2.1 BOOTP 概述、历史和标准（部分：1 2 3）

TCP/IP 协议族已经伴随我们二十多年了，如何在 IP 主机上自动配置参数的问题也几乎同样存在。早在 20 世纪 80 年代初期，网络规模较小且相对简单。由于手动配置的困难，自动化主机配置并未被视为一项重要功能。它是必需的，因为没有其他方法可以配置像无盘工作站这样的设备。

正如我在关于主机配置的概述主题中讨论的那样，如果没有内部存储形式，设备必须依靠某人或某物来告诉它“它是谁”（它的地址）以及每次启动时如何运行。当打开这样的设备时，它处于一个困难的境地：它需要使用 IP 与另一个设备通信，另一个设备将告诉它如何使用 IP 进行通信！这个过程称为自举或引导，类似于一个人“使用自己的引导程序将自己拉起来”。您以前可能遇到过这个术语，如果没有在其他时间遇到过，那么至少在某些技术支持人员告诉您“重新启动”计算机时遇到过。

<u>**BOOTP：纠正 RARP 的弱点**</u>
反向地址解析协议 (RARP) 是解决此“引导程序问题”的首次尝试。 RARP 创建于 1984 年，是对将 IP 地址绑定到链路层硬件地址的低级地址解析协议 (ARP) 的直接改编。 RARP 能够为无盘设备提供其 IP 地址，使用主机和 RARP 服务器之间的请求和回复的简单客户端/服务器交换。

RARP 的困难在于它有很多限制。它使用硬件广播在相当低的级别上运行，因此需要针对不同的硬件类型进行调整。每个物理网络还需要一个 RARP 服务器来响应第二层广播。每个 RARP 服务器必须具有由管理员手动提供的地址分配。也许最糟糕的是，RARP 只向主机提供 IP 地址，而没有提供主机可能需要的其他信息。 （我在 RARP 的主题中详细描述了这些问题。）

RARP 显然不足以满足 TCP/IP 的主机配置需求。为了同时支持无盘主机的需求和其他需要自动配置优势的情况，创建了引导协议 (BOOTP)。 BOOTP 在 1985 年 9 月发布的 RFC 951 中被标准化。这个相对简单的协议是专门为解决 RARP 的缺点而设计的：

- 它仍然基于客户端/服务器交换，但作为更高层软件协议实现，使用 UDP 进行消息传输。它不像 RARP 那样依赖于网络的特定硬件。

- 它支持向客户端发送除 IP 地址之外的其他配置信息。为了提高效率，通常可以在一条消息中发送这些额外信息。

- 它可以处理在互联网络的不同网络上拥有客户端和服务器。这允许提供 IP 地址的服务器的管理更加集中，从而节省资金以及管理时间和麻烦。

<u>**BOOTP 处理引导程序的第一阶段**</u>

应该注意的是，尽管 BOOTP 的名称暗示它定义了无存储设备“启动”所需的一切，但事实并非如此。正如 BOOTP 标准本身所描述的那样，“自举”通常需要两个阶段。首先，向客户端提供地址和其他参数。在第二种情况下，客户端下载操作系统和驱动程序等软件，使其能够在网络上运行并执行其负责的任何任务。 BOOTP 实际上只处理这些阶段中的第一个阶段：地址分配和配置。假设第二个是使用简单文件传输协议（如普通文件传输协议 (TFTP)）进行的。

**关键概念：**第一个广泛使用的 TCP/IP 主机配置协议是引导协议 (BOOTP)。它是专门为启用主机配置而创建的，同时解决了 RARP 的许多弱点。 BOOTP 旨在用作无存储设备两阶段启动过程的第一阶段——在使用 BOOTP 获取 IP 地址和其他配置参数后，设备使用 TFTP 等协议下载在网络上运行所需的软件.

<u>**供应商特定参数**</u>
创建 BOOTP 时做出的一个明智决定是包含一个特定于供应商的区域。这是为了提供一个硬件供应商可以定义与他们自己的产品相关的参数的地方。随着 TCP/IP 的复杂性增加，人们意识到该字段可用于定义一种传递 IP 主机通常需要的某些参数的方法，并且实际上是独立于供应商的。这是在 1988 年 2 月发布的 RFC 1048，BOOTP 供应商信息扩展中首次提出的。

BOOTP 可用于向客户端提供 IP 地址以外的信息，这一事实使其即使在设备已经知道其地址的情况下也很有用。 BOOTP 可用于发送管理员希望所有主机都具有的参数，以确保它们以一致的方式使用网络。此外，对于具有本地存储的设备（因此不需要 BOOTP 来获取 IP 地址），BOOTP 仍可用于让这些设备获取用于引导“第二阶段”的引导文件的名称如上所述。

<u>**BOOTP 的变化和 DHCP 的发展**</u>

BOOTP 是 20 世纪 80 年代中期到 90 年代末的首选 TCP/IP 主机配置。 RFC 1048 中引入的供应商扩展很受欢迎，多年来，定义了额外的供应商扩展； RFC 1048 相继被 RFC 1084、1395 和 1497 取代。多年来，在应如何解释 RFC 951 的某些部分以及 BOOTP 的某些功能如何工作方面也产生了一些混乱。

1993 年 10 月发布了 RFC 1542，引导协议的澄清和扩展，以解决这个问题，并对协议的操作做了一些细微的更改。 （RFC 1542 实际上是对几乎相同的 RFC 1532 的更正，其中有一些小错误。）

虽然 BOOTP 显然相当成功，但它也有其自身的某些弱点。其中最重要的一项是缺乏对动态地址分配的支持。当 Internet 在 90 年代后期真正开始腾飞时，对动态分配的需求变得更加明显。这直接导致了动态主机配置协议 (DHCP) 的开发。

虽然 DHCP 取代了 BOOTP 作为首选的 TCP/IP 主机配置协议，但说 BOOTP 已经“消失”是不准确的。它至今仍在各种网络中使用。此外，DHCP 直接基于 BOOTP，它们共享许多属性，包括通用的消息格式。 BOOTP 供应商扩展被用作 DHCP 选项的基础，它们以相同的方式工作，但包括额外的功能。事实上，RFC 1497 的后继者是 RFC 1533，它正式将 BOOTP 供应商扩展和 BOOTP 选项合并到同一个标准中。

###### 3.1.2.1  BOOTP 客户端/服务器消息传递和寻址（部分：1 2 3）

虽然 BOOTP 可用于多种设备，但其创建背后的主要动机之一是提供一种自动配置没有存储的“哑”设备的方法。大多数这些设备的功能相对有限，因此要求它们支持花哨的启动协议是没有意义的。因此，BOOTP 是一个简单的协议，它可以在没有很多花哨的概念或实现要求的情况下完成主机配置。

<u>**BOOTP 客户端和服务器**</u>
与许多其他 TCP/IP 协议一样，BOOTP 本质上是客户端/服务器。该协议的操作包括 BOOTP 客户端和 BOOTP 服务器之间的单次消息交换。 BOOTP 客户端可以是需要配置的任何类型的设备。 BOOTP 服务器是专门为响应 BOOTP 客户端请求而设置的网络设备，并已编程为可以在需要时向客户端提供的寻址和其他信息。

BOOTP 服务器维护一组关于它所服务的客户端的特殊信息。其中一个关键部分是一张表，它将每个客户端的硬件（第二层，数据链路层）地址映射到为该设备分配的 IP 地址。客户端在其请求中指定其硬件地址，服务器使用该地址查找客户端的 IP 地址并将其返回给客户端。 （也可以使用其他技术，但最常用的是映射表。）

<u>**消息传递和传输**</u>
BOOTP 消息传递使用用户数据报协议 (UDP) 作为其第四层传输协议，原因有几个。首先，UDP 比其他第四层传输协议 (TCP) 简单的多，非常适合 BOOTP 等简单的“请求/回复”协议。其次，由于客户端显然不知道BOOTP服务器的地址，请求在其本地网络上广播； UDP 支持广播，而 TCP 不支持。

UDP 为 BOOTP 服务器使用一个特殊的知名（保留）端口号：UDP 端口 67。BOOTP 服务器在端口 67 上“侦听”客户端发送的这些广播 BOOTP 请求。处理请求后，服务器将回复发送回客户端。如何处理取决于客户端是否知道自己的地址：

- 客户端知道它的地址：在某些情况下，BOOTP 客户端已经知道它自己的地址。在这种情况下，BOOTP 服务器可以使用该地址直接发回其回复。

- Client Does Not Know Its Own Address：BOOTP 当然经常用于向不知道其地址的客户端提供 IP 地址。这有时被称为“先有鸡还是先有蛋”的问题，因为它代表了一个类似于“先有鸡还是先有蛋”的古老难题的“循环”。为了解决这个难题，BOOTP 服务器有两种选择。如果操作系统支持，服务器可以使用客户端的硬件地址为设备创建一个ARP条目，然后使用二层单播来传递回复。否则，它也必须在本地网络上以广播的形式发送回复。

<u>**广播和端口的使用**</u>

BOOTP 服务器可能需要向客户端广播回的事实需要对大多数 TCP/IP 协议使用客户端端口的方式进行一些更改。回想一下，通常情况下，使用 UDP 或 TCP 的客户端/服务器事务中的客户端会生成一个临时的或短暂的端口号，用作其请求中的源端口。服务器使用该临时端口号将回复发送回客户端的 IP 地址。临时端口号对于特定 IP 地址必须是唯一的，但不一定在网络上的所有设备中都是唯一的。例如，设备 A 可能使用临时端口号 1,248 向 Web 服务器发送 HTTP 请求，而设备 B 可能使用其 TCP/IP 堆栈上的端口号 1,248 发送 DNS 请求。

由于 BOOTP 中的服务器是广播的，因此它不针对具有单播传输的特定设备。这意味着它不能安全地发送到一个临时端口号：网络上的一些其他设备可能已经为一些其他事务选择了相同的临时端口号，并且可能将 BOOTP 服务器的响应误认为是针对它自己的。为避免此问题，另一个众所周知的端口号仅用于 BOOTP 客户端：UDP 端口 68。客户端在此端口上侦听广播或单播传输，而没有发送 BOOTP 请求的设备将忽略它。这种“双重广播”BOOTP 通信过程如图 254 所示。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\bootpgenop.png)


​                                                                           **图 254：引导协议的一般操作**

BOOTP 是一种相对简单的客户端/服务器协议，它依靠广播来允许与未分配 IP 地址的设备进行通信。在此示例中，设备 A 试图确定其 IP 地址和其他参数。它使用 UDP 端口 67 在本地网络上广播 BOOTP 请求，然后在端口 68 上侦听回复。设备 D 配置为 BOOTP 服务器并在该端口上侦听。当它收到请求时，它会在端口 68 上发送广播，告诉 A 它的 IP 地址是什么。

**关键概念：**BOOTP 客户端使用广播将其请求发送到任何监听的 BOOTP 服务器。在大多数情况下，BOOTP 客户端设备在使用该协议时并不知道自己的 IP 地址。出于这个原因，BOOTP 服务器通常也会使用广播来发送其回复，以确保它到达客户端。

<u>**丢失消息的重传**</u>

将 UDP 用于 BOOTP 消息传递的简单性的缺点是我们无法获得传输质量特征。 UDP 是不可靠的，这意味着 BOOTP 请求在到达服务器之前可能会丢失，或者服务器的响应可能同样不会返回到客户端。与使用 UDP 的许多其他协议一样，BOOTP 客户端通过使用重传计时器来处理此问题。如果一段时间后客户端没有收到响应，它会重新发送请求。

然而，BOOTP 客户端必须注意它们如何实现它们的重传策略。考虑一个包含 200 个 BOOTP 客户端的网络断电的场景。这些机器几乎都是一样的，所以当电源恢复时，它们都会重新启动，并且都会尝试在大约同一时间发送 BOOTP 请求。由于所有这些请求，很可能会出现问题；有些会丢失，或者服务器可能由于过载而不得不丢弃一些。

如果所有客户端使用相同的时间进行重传，那么在这段时间过去后，一大堆机器将再次发送请求并重现原来的问题。为避免这种情况，BOOTP 标准建议对重传使用指数退避方案，从 4 秒的重传间隔开始，并在连续尝试时将其加倍。还添加了一个随机元素，以防止许多设备重叠重传。这个想法与以太网使用的退避方法非常相似（事实上，该标准甚至参考了以太网规范）。

例如，第一次重传将在 0 到 4 秒之间的随机时间段（加上或减去一个随机数）之后发生；如果需要，在 0 到 8 秒之间的随机时间间隔（加上或减去等等）之后进行第二次重传。这有助于减少重新传输丢失的机会，还有助于确保 BOOTP 流量不会阻塞网络。

**关键概念：**BOOTP 使用不提供可靠性特性的 UDP 进行传输。为此，BOOTP 客户端必须检测其请求何时丢失，并在必要时重新传输它们。



###### 3.1.2.1 BOOTP操作详解（部分：1 2）

现在我们已经大致了解了 BOOTP 消息传递的工作原理，让我们仔细看看该协议的详细操作。这将使我们更清楚地看到客户端和服务器如何创建和处理消息，也有助于理解 BOOTP 消息字段格式中的一些重要字段。了解 BOOTP 的基本操作对于我们研究 BOOTP 中继代理甚至讨论 DHCP 也是有用的。

<u>**BOOTP引导步骤**</u>
以下是客户端和服务器在常规 BOOTP 引导程序中执行的基本步骤（参见图 255）。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\bootpoperation.png)


​                                                                                   **图 255：引导协议操作**

引导协议使用简单的两步消息交换，包括广播请求和广播回复。客户端从BOOTP服务器接收到配置信息后，使用TFTP等协议完成引导过程。

 

**1.客户端创建请求**
客户机通过创建 BOOTP 请求消息开始该过程。在创建此消息时，它会填写以下信息：

- 对于 BOOTREQUEST 消息，它将消息类型 (Op) 设置为值 1。

- 如果它知道自己计划继续使用的 IP 地址，它会在 CIAddr 字段中指定它。否则，它用零填充该字段。 （有关更多信息，请参见下文。）

- 它将自己的第二层硬件地址放在 CHAddr 字段中。服务器使用它来为客户端确定正确的地址和其他参数。

- 它生成一个随机事务标识符，并将其放在 XID 字段中。

- 客户端可以指定它想要向其发送回复的特定服务器，并将其放入 SName 字段。它还可以指定它希望服务器在文件字段中提供的特定类型的引导文件的名称。

- 客户端可以特定供应商特定信息，如果被编程为这样做的话。

**2.客户端发送请求**
客户端通过将其发送到地址 255.255.255.255 来广播 BOOTREQUEST 消息。或者，如果它已经知道 BOOTP 服务器的地址，它可以发送单播请求。

**3.服务器接收请求并处理**
监听 UDP 端口 67 的 BOOTP 服务器接收广播请求并处理它。如果指定了特定服务器的名称并且此名称与该服务器的名称不同，则服务器可能会丢弃该请求。如果服务器知道客户端请求的服务器也在本地网络上，则尤其如此。如果没有指定特定的服务器，或者这个特定的服务器是客户端想要的，服务器将回复。

**4.服务器创建回复**
服务器通过复制请求消息并更改几个字段来创建回复消息：

- 对于 BOOTREPLY 消息，它将消息类型 (Op) 更改为值 2。

- 它从 CHAddr 字段中获取客户端指定的硬件地址，并在表查找中使用它来查找该主机的匹配 IP 地址。然后它将此值放入回复的 YIAddr（“您的 IP 地址”）中。

- 它处理文件字段并提供客户端请求的文件名类型，或者如果该字段为空，则提供默认文件名。

- 它将自己的 IP 地址和名称放在 SIAddr 和 SName 字段中。

- 它在 Vend 字段中设置任何特定于供应商的值。



**5.服务器发送回复**
服务器发送回复，方法取决于请求的内容：

- 如果设置了 B (Broadcast) 标志，则表明客户端无法以单播方式发送回复，因此服务器将广播它。

- 如果 CIAddr 字段不为零，则服务器会将回复单播发送回该 CIAddr。

- 如果 B 标志为零且 CIAddr 字段也为零，则服务器可以使用 ARP 条目或广播，如上一主题所述。

**6.客户端处理回复**
客户端收到服务器的回复并进行处理，存储提供的信息和参数。 （有关此处理的一个重要问题，请参见下文。）

**7.客户端完成启动过程**
配置完成后，客户端进入引导过程的“第二阶段”，使用服务器提供的文件名，使用 TFTP 等协议下载包含操作系统软件的引导文件。

<u>**客户端 IP 地址 (CIAddr) 字段的解释**</u>

当客户端选择在其请求的 CIAddr 字段中指定 IP 地址时，可能会出现复杂情况。问题是如何准确解释这个字段。是不是客户端已经在使用这个IP地址了？或者它只是上次启动时使用的那个？如果服务器在 YIAddr 中提供的地址与客户端正在使用的地址不同，那么就会出现相关的问题。服务器提供的地址是否应该覆盖客户端的地址？还是客户应该忽略它？谁做决定，服务器还是客户端？

由于原始标准在这方面的含糊不清，造成了很多混乱，这导致不同的实现选择处理这个问题的方式不一致。甚至有一些实现使用 CIAddr 表示“客户端请求此 IP 地址”，这从来不是 BOOTP 功能的一部分。这是一个特别糟糕的主意，因为它可能直接导致 BOOTP 回复永远不会到达客户端。

RFC 1542 的编写部分是为了试图清理这个烂摊子。它表明以下是处理这些字段含义的最佳方式：

- 如果客户端愿意接受服务器提供的任何 IP 地址，它会将 CIAddr 设置为全零，即使它知道以前的地址。

- 如果客户端为该字段填写一个值，则表明它将使用该地址，并且必须准备好接收发送到该地址的单播消息。

- 如果客户端在 CIAddr 中指定了一个地址，但在 YIAddr 字段中收到了一个不同的地址，则服务器提供的地址将被忽略。

请注意，并非所有硬件设备都必须同意 RFC 1542 提供的这种解释，因此这里仍然存在与旧设备的潜在互操作性问题。 RFC 1542 是在 1993 年编写的，所以这可能不再是什么大问题了。



###### 3.1.2.1 BOOTP 消息格式

BOOTP 中的信息交换采用客户端发送请求和服务器发回回复的形式。 BOOTP 与许多其他请求/答复协议一样，对请求和答复使用通用的消息格式。 客户端首先为消息留出内存空间并将其清零。 然后它会填写消息的字段并发送请求，正如我们在上一个主题中看到的那样。 服务器不是从头开始创建回复，而是通过复制请求和更改某些字段来创建回复。 BOOTP报文中包含的字段比较多，所以报文格式比较大。 它在表 186 中进行了完整描述，并在图 256 中进行了说明。                                                                   

​                                                                            **表 186：BOOTP 消息格式**

| **Field Name** | **Size (bytes)** | **Description**                                              |
| -------------- | ---------------- | ------------------------------------------------------------ |
| ***Op\***      | 1                | ***Operation Code:\*** 操作代码：指定消息的类型。值 1 表示请求（BOOTREQUEST 消息），而值 2 表示回复（BOOTREPLY 消息）。 |
| ***HType\***   | 1                | ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\aa20939f.png) |
| ***HLen\***    | 1                | ***Hardware Address Length:\*** 硬件地址长度：指定硬件地址在此消息中的长度。对于使用 IEEE 802 MAC 地址的以太网或其他网络，该值为 6。这也与 ARP 字段格式中具有相似名称 (HLN) 的字段相同。 |
| ***Hops\***    | 1                | ***Hops:\*** 跳数：客户端在发送请求之前设置为 0，BOOTP 中继代理使用它来控制 BOOTP 消息的转发。 |
| ***XID\***     | 4                | ***Transaction Identifier:\*** Transaction Identifier：客户端生成的 32 位标识字段，用于将请求与从 BOOTP 服务器收到的回复相匹配。 |
| ***Secs\***    | 2                | ***Seconds:\*** 秒数：根据 RFC 951，客户端在此字段中输入“自 [the] 客户端开始尝试启动以来经过的秒数”。这应该向 BOOTP 服务器提供信息，以帮助它们决定首先响应哪些请求。不幸的是，这个定义有些模糊。不清楚这是否意味着自机器开机以来的时间量，或者自第一个 BOOTREQUEST 消息发送以来的时间量。此外，一些设备错误地实现了这个字段。因此，它并不总是被使用。 |
| ***Flags\***   | 2                | ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\aa2093d3.png) |
| ***CIAddr\***  | 4                | ***Client IP Address:\*** Client IP Address：如果客户端有计划继续使用的当前 IP 地址，则将其放入此字段。通过填写此字段，客户端承诺响应发送到此地址的单播 IP 数据报。否则，它将此字段设置为全零以告诉服务器它想要分配一个地址。有关该字段的重要信息，请参见详细操作主题的末尾。 |
| ***YIAddr\***  | 4                | ***“Your” IP Address:\*** “您的”IP 地址：服务器分配给客户端的 IP 地址。这可能与客户端当前使用的 IP 地址不同。请参阅详细描述 BOOTP 操作的主题，以了解在这种情况下发生的情况。 |
| ***SIAddr\***  | 4                | ***Server IP Address:\*** 服务器 IP 地址：发送 BOOTREPLY 消息的 BOOTP 服务器的 IP 地址。 |
| ***GIAddr\***  | 4                | ***Gateway IP Address:\*** 网关 IP 地址：当 BOOTP 中继代理促进不同子网或网络上的客户端和服务器之间的 BOOTP 请求和回复通信时，此字段用于路由 BOOTP 消息。要理解这个名称，请记住“路由器”的旧 TCP/IP 术语是“网关”； BOOTP 中继代理通常是路由器。 请注意，此字段由客户端设置为 0，并且在处理 BOOTREPLY 时应被客户端忽略。它特别不代表服务器为客户端提供默认路由器地址的地址以用于一般 IP 路由目的。 |
| ***CHAddr\***  | 16               | ***Client Hardware Address:\*** 客户端硬件地址：发送 BOOTREPLY 的客户端的硬件（第二层）地址。它既可用于查找设备分配的 IP 地址，也可用于发送回复消息。 |
| ***SName\***   | 64               | ***Server Name:\*** 服务器名称：发送 BOOTREPLY 的服务器可以选择将其名称放在该字段中。这可以是简单的文本“昵称”或完全限定的 DNS 域名（例如“myserver.organization.org”）。 请注意，客户端在创建请求时可以在此字段中指定一个名称。如果这样做，则表明它只想从具有此名称的 BOOTP 服务器获得答复。这样做可以确保客户端能够访问仅存储在一台服务器上的特定引导文件 |
| ***File\***    | 128              | ***Boot Filename:\*** 引导文件名：包含引导文件的完整目录路径和文件名，客户端可以下载该引导文件以完成其引导过程。客户端可以通过在此处输入文本描述来请求特定类型的文件，或者可以将该字段留空，服务器将提供默认文件的文件名。 |
| ***Vend\***    | 64               | ***Vendor-Specific Area:\*** Vendor-Specific Area：最初创建是为了允许供应商根据不同类型硬件的需要自定义 BOOTP，该字段现在也用于保存额外的独立于供应商的配置信息。请参阅下一个主题，关于 BOOTP 供应商信息扩展。它可以由客户端和/或服务器使用。 |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\bootpformat.png)

​                                                                                    **图 256：BOOTP 消息格式**




正如我在 BOOTP 消息传递主题中提到的，请求和回复都被封装到 UDP 消息中进行传输。 BOOTP 标准指定 UDP 校验和的使用是可选的。 使用校验和可以防止数据完整性错误，因此推荐使用。 这可能会导致非常简单的客户端无法接受处理要求，因此可以合法地跳过校验和。

同样，为简单起见，BOOTP 假定其消息不会被分段。 这是为了让 BOOTP 客户端避免重组碎片消息的复杂性。 由于 BOOTP 消息的长度仅为 300 字节，在所有 TCP/IP 链接所需的最小 MTU 下，这通常不是问题。

![image-20221117155329518](C:\Users\zy\AppData\Roaming\Typora\typora-user-images\image-20221117155329518.png)

###### 3.1.2.1 BOOTP 专属区域和专属信息扩展（部分：1 2 3）

引导协议的创建者意识到，某些类型的硬件可能需要从服务器向客户端传递额外的信息，以便客户端启动。为此，他们将 64 字节的 Vend 字段（也称为 Vendor-Specific Area）放入 BOOTP 字段格式中。包括这个字段使 BOOTP 变得灵活，因为它允许供应商自己决定他们想如何使用该协议，并根据他们的需要对其进行定制。

<u>**供应商特定区域的传统使用**</u>
客户端在撰写请求时可以通过在字段中询问某些类型的信息来使用 Vend 字段。服务器然后可以响应这些请求，并且还可以包括它希望客户端拥有的参数，即使它们没有被请求。最初的 BOOTP 协议没有为 Vendor-Specific Area 定义任何结构，这由每个制造商决定。

显然，没有什么可以阻止一个制造商制造的客户端尝试向另一制造商制造的服务器发送请求。如果每个人都期望 Vend 字段包含不同的内容，那么结果将不尽如人意。因此，为了正确使用 Vend 字段，当谈到该字段的含义时，两个设备必须使用相同的“语言”。这是通过将字段的前四个字节设置为特殊值来完成的。每个制造商都为这个四字节的子字段选择自己的“魔法数字”，有时也称为“魔法饼干”。

**注意：**为什么它被称为神奇的“cookie”？老实说，我不确定。我听说它的起源可能是爱丽丝在《爱丽丝梦游仙境》的故事中吃了一块饼干变大或变小。谁知道。杰

<u>**BOOTP 供应商信息扩展**</u>

在 BOOTP 中包含 Vend 字段为特定于供应商的信息提供了协议可扩展性。不幸的是，原始字段格式不包括任何方式来扩展从服务器发送到客户端的信息以获取通用的、非供应商特定的 TCP/IP 信息。

这是创建协议时的重大疏忽，因为 TCP/IP 主机在启动时需要的许多类型的信息实际上与其供应商无关。例如，当主机启动时，我们可能希望它被告知默认路由器的地址；其本地子网的子网掩码；本地 DNS 服务器的地址；本地网络的 MTU；以及更多。这些东西都不是特定于供应商的，但是没有地方可以将它们放在 BOOTP 回复消息中。

由于 BOOTP 中没有“非供应商特定区域”字段，因此决定定义一种使用供应商特定区域来传达此附加通用信息的方法。这首先在 RFC 1048 中进行了标准化，然后在后来的 RFC 中进行了改进，正如我在 BOOTP 概述中所解释的那样。该方案基本上代表了一种使用 Vend 字段的特定方式，大多数 TCP/IP BOOTP 实现都选择采用这种方式，而不管他们的供应商。此增强功能正式称为 BOOTP 供应商信息扩展。

为了清楚地标明正在使用 Vend 字段的这种特殊含义，将一个特殊的通用“magic cookie”值“99.130.83.99”插入到该字段的前四个字节中。然后，剩余的 60 个字节可以包含一系列一个或多个供应商信息字段。使用供应商信息扩展时的供应商特定区域的整体结构如图 257 所示。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\bootpvendformat.png)


​                                          **图 257：显示供应商信息字段的 BOOTP 供应商特定区域格式**

BOOTP Vendor-Specific Area 以四字节的“magic cookie”开始，然后包含许多可变长度的供应商信息字段，每个字段的格式如上和表 187 所示。

**注意**：尽管使用点分十进制表示法表示值“99.130.83.99”，但这不是 IP 地址。它只是一个标记，一个被普遍认可的“神奇数字”。

**关键概念：**BOOTP 消息格式包括 Vend 字段，该字段最初用于特定于供应商的自定义字段。它后来被更改为可以将其他通用信息从 BOOTP 服务器发送到 BOOTP 客户端的地方。每个这样的参数都包含在 BOOTP 供应商信息字段中。

![image-20221117155840873](C:\Users\zy\AppData\Roaming\Typora\typora-user-images\image-20221117155840873.png)

<u>**BOOTP 供应商信息字段**</u>

每个供应商信息字段指定要传达的特定类型的信息，并使用指定字段类型、长度和值的特殊子字段结构进行编码。 这是指定选项的常用方法，称为 TLV 编码（当然是类型、长度、值）。 相同的基本方法用于编码 IPv4 和 IPv6 选项。 表 187 显示了每个供应商信息字段的子字段的结构和通用名称。


​                                                               **表 187：BOOTP 供应商信息字段格式**

| **Subfield Name** | **Size (bytes)** | **Description**                                              |
| ----------------- | ---------------- | ------------------------------------------------------------ |
| ***Code\***       | 1                | ***Vendor Information Field Code:\*** 供应商信息字段代码：指定供应商信息字段类型的单个八位字节。 |
| ***Len\***        | 1                | ***Vendor Information Field Length:\*** 供应商信息字段长度：此特定供应商信息字段中的字节数。这不包括 Code 和 Len 字段的两个字节。 |
| ***Data\***       | Variable         | ***Vendor Information Field Data:\*** Vendor Information Field Data：正在发送的数据，其长度由 Len 子字段指示，并根据 Code 子字段进行解释。 |

有两种特殊情况违反了表 187 的字段格式。代码值 0 用作填充，当子字段需要在字边界上对齐时；它不包含任何信息。值 255 用于标记供应商信息字段的结尾。这两个代码都不包含实际数据，因此为了节省空间，当使用其中一个时，只包含单个代码值； Len 和 Data 字段被省略。看到代码值为 0 的设备只是将其作为填充符跳过；看到 Code 值为 255 的设备知道它已到达此 Vend 字段中供应商信息字段的末尾。

BOOTP 的供应商信息扩展变得如此流行，以至于使用这个字段来发送额外的通用信息几乎是标准的。事实上，我什至不确定今天是否有人仍然将 Vend 字段仅用于特定于供应商的信息。

引入供应商信息扩展时，会创建一个指向可以找到供应商特定信息的文件的文件。这让设备拥有“两全其美”——它们可以使用标准的独立于供应商的字段，也可以在需要时合并特定于供应商的字段（通过引用文件）。后来，创建了另一种字段类型，允许在 BOOTP 消息中混合特定于供应商的字段和独立于供应商的字段。

创建 DCHP 时，维护并进一步增强了相同的供应商扩展机制，但该字段不再称为“供应商信息扩展”，而是重命名为“选项”。 （一个更好的名字！）BOOTP 供应商信息字段保留在 DHCP 中，并且定义了新的 DHCP 特定选项。为避免重复，我在 DHCP 部分的一组表格中列出了所有 BOOTP 供应商信息字段和 DHCP 选项。这包括讨论如何混合特定于供应商和独立于供应商的信息，正如我在上一段中提到的那样。您可能还想阅读描述 DHCP 选项的主题，并讨论它们是如何从 BOOTP 供应商信息扩展中创建的。



###### 3.1.2.1 BOOTP 中继代理（转发代理）（部分：1 2 3 4）

反向地址解析协议 (RARP) 很快被 BOOTP 取代的原因之一是 RARP 要求配置的客户端和为其提供 IP 地址的服务器位于同一物理网络上。当然，当您经营一个拥有 10 台机器的小型组织时，这很好。在这种情况下，无论如何，所有 10 个都可能在同一个物理网络上。但是，为了提高效率，必须将较大的网络划分为多个物理网络。 RARP 需要为每个网络配备一个单独的 RARP 服务器，这意味着必须将单个服务器的所有功能复制到多台机器上。更糟糕的是，所有配置信息也将被复制，并且每次都必须对所有不同的服务器进行任何更改。

<u>**为什么需要 BOOTP 中继代理**</u>
与 RARP 不同，BOOTP 旨在允许 BOOTP 服务器和它所服务的客户端位于不同的网络上。这集中了 BOOTP 服务器，大大减少了网络管理员的工作量。但是，实现此功能意味着增加协议的复杂性。特别是，我们需要在配置过程中涉及“第三方”设备。

您可能想知道为什么会这样。当然，RARP 是一种工作在链路层的低级协议，因此这就解释了为什么将客户端和服务器放在不同的物理网络上会出现问题。但是，使 BOOTP 成为能够使用 IP 的高级协议的全部意义不就在于此吗？如果 BOOTP 使用 IP，我们不能像任何基于 IP 的消息传递协议一样从一个网络任意发送到另一个网络吗？

答案是，即使我们确实在使用 IP 和 UDP，BOOTP 仍然存在与 RARP 相同的问题之一：对广播的依赖。客户端通常不知道服务器的地址，所以它必须以广播的形式发送请求，实质上是在说“任何人都可以听到这个并给我我需要的信息吗？”出于效率原因，路由器不会路由此类广播，因为它们会阻塞网络。这意味着如果服务器和客户端不在同一个网络上，服务器就听不到客户端的广播。类似地，如果服务器确实收到请求并将其回复广播回客户端，则客户端无论如何也不会收到它。

<u>**BOOTP中继代理的作用**</u>

为了使这一切正常，我们需要一些东西作为客户端和服务器之间的中介：BOOTP 中继代理。 BOOTP 中继代理的工作是位于 BOOTP 客户端可能所在的物理网络上，并充当 BOOTP 服务器的代理。代理之所以得名，是因为它在客户端和服务器之间中继消息，从而使它们能够位于不同的网络上。

**注意：**BOOTP 中继代理最初称为转发代理。该名称被认为太容易混淆 BOOTP 操作和常规路由器的一般“转发”行为。 RFC 1542 更改了名称以明确 BOOTP 中继与传统 IP 数据报转发不同的事实。


实际上，BOOTP 中继代理通常不是一个单独的硬件。它是一个软件模块，运行在执行其他功能的现有硬件上。 BOOTP 中继代理功能通常在 IP 路由器上实现。在这种情况下，路由器既充当“常规”路由器，又扮演 BOOTP 代理的角色。 BOOTP 中继代理所需的转发功能不同于路由器的正常 IP 数据报转发任务（尽管我们将看到它们有某些相似之处。）

自然地，客户端和服务器在不同网络上的放置以及中继代理的存在显着改变了 BOOTP 的正常请求/回复过程。 BOOTP 消息格式中的几个特定字段用于控制该过程。 RFC 951 在描述这个过程如何工作时相当模糊，所以 RFC 1542 描述得更详细。

**关键概念：**由于 BOOTP 使用广播，BOOTP 客户端和 BOOTP 服务器必须在同一物理网络上才能听到彼此的广播传输。对于不同网络上的客户端和服务器进行通信，需要第三方来促进事务：BOOTP 中继代理。此设备（通常是路由器）侦听来自 BOOTP 客户端的传输并将它们中继到 BOOTP 服务器。服务器响应代理，然后代理将服务器的响应发送回客户端。

<u>**使用中继代理的正常 BOOTP 操作**</u>

下面以简化的形式显示了当涉及中继代理时修改后的一组BOOTP操作步骤。为了使本主题的篇幅保持在可控范围内，我省略了基本请求/回复过程的细节，以专注于中继功能，您还可以在图 258 中以图形方式查看：

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\bootprelay.png)




​                                                                  图 258：使用中继代理的 BOOTP 操作

在此示例中，设备 A 试图访问 BOOTP 服务器，但唯一的一个位于不同的网络上；两者通过配置为充当 BOOTP 中继代理的工作组路由器连接。设备 A 广播其请求，路由器收到该请求。它将请求中继到 BOOTP 服务器设备 D，并将自己的 IP 地址 (IPR) 放入 BOOTP GIAddr 字段。 BOOTP 服务器使用地址 IPR 将回复发送回路由器。然后路由器将它广播到设备 A 的本地网络，以便 A 可以接收它。



1. 
   客户端创建请求：客户端计算机正常创建其请求。中继代理的存在对客户端是完全透明的。

2. 客户端发送请求：客户端通过将其发送到地址 255.255.255.255 来广播 BOOTREQUEST 消息。 （请注意，在客户端已经知道自己的地址和 BOOTP 服务器的地址的情况下，我们根本不需要中继代理——请求和回复都可以通过任意互联网单播发送。）

3. 中继代理接收请求并处理它：客户端所在的物理网络上的 BOOTP 中继代理代表服务器监听 UDP 端口 67。它按如下方式处理请求：

   - 它检查 Hops 字段的值。如果该值小于或等于 16，它将递增。如果该值大于 16，它会丢弃请求并且不做任何进一步的操作。

   - 它检查 GIAddr 字段的内容。如果该字段全为零，它就知道它是第一个处理请求的中继代理，并将自己的 IP 地址放入该字段。 （如果代理是路由器，它有多个 IP 地址，所以它会选择接收请求的接口之一。）



1. 
   Relay Agent Relays Request：中继代理向BOOTP服务器发送BOOTP请求。如果中继代理知道服务器的 IP 地址，它将直接向服务器发送单播。否则，如果代理是路由器，它可能会选择在与接收请求的接口不同的接口上广播请求。在后一种情况下，可能需要多个中继代理将请求传送到服务器。有关更多信息，请参见下文。

2. Server Receives Request and Processes It：BOOTP服务器接收来自BOOTP中继代理的中继请求。它正常处理它。

3. 服务器创建回复：服务器正常创建回复消息。

4. 服务器发送回复：看到请求中的 GIAddr 字段不为零，服务器知道请求已转发。它不会尝试将其回复发送回发送请求的客户端，而是将回复单播传输回 GIAddr 中指定的中继代理。

5. Relay Agent Relays Reply：BOOTP 中继代理将 BOOTREPLY 消息传回客户端。根据 CIAddr 字段和 B（广播）标志的值，它可以单播或广播执行此操作，就像服务器在非中继情况下所做的一样。

<u>**使用广播中继 BOOTP 请求**</u>

最简单的中继情况是每个网络都有一个知道 BOOTP 服务器 IP 地址的中继代理。中继代理“捕获”上面步骤 3 中的请求，并将其直接发送到 BOOTP 服务器，无论它在网络上的任何位置。该请求作为常规单播 UDP 消息进行中继，并路由到 BOOTP 服务器。 BOOTP 服务器的答复被路由回 BOOTP 中继代理，就像 IP 数据报中的任何 UDP 消息一样，中继代理转发答复。

也可以设置 BOOTP 中继代理来中继请求，即使它们不知道 BOOTP 服务器的地址。这些代理接受在一个网络上收到的请求并将它们转发到下一个网络，他们希望另一个代理继续转发过程，直到到达 BOOTP 服务器。例如，假设我们有一组三个网络。网络 N1 使用路由器 RA 连接到网络 N2，N2 使用路由器 RB 连接到 N3。这两个路由器都充当中继代理，但不知道 BOOTP 服务器的 IP 地址。如果 N1 上的客户端发送请求而服务器位于 N3 上，则会发生以下情况：

1. 客户端将发送其请求。

2. RA 将捕获请求并将其地址放入 GIAddr。它会将 Hops 字段的值增加到 1，然后在网络 N2 上广播请求。

3. RB 将捕获此请求。它会看到 GIAddr 中已经有一个地址，所以它不会管它。它会将 Hops 字段增加到 2 并在网络 N3 上广播请求。

4. BOOTP 服务器将接收请求、处理它并将答复直接返回给 RA。

5. RA 会将回复转发回客户端。

如您所见，Hops 字段的目的是确保错误的请求不会无休止地在网络中循环。每个中继代理递增它，如果超过 16 的值，请求将被丢弃。您还可以看到，除第一个以外的任何中继代理都只参与处理请求；回复被单播发送回离客户最近的代理。

顺便说一下，如果这个多步中继过程听起来像 IP 路由（仅使用广播），并且 Hops 字段听起来像 IP 数据报中的 Time To Live 字段，那么您已经注意到了。它本质上是相同的想法。



##### 3.1.3 TCP/IP 动态主机配置协议 (DHCP)

在某些方面，技术进步更像是一段旅程，而不是目的地。当一项特定技术得到改进或被更高级的技术取代时，它也被更好的技术取代通常只是时间问题。 TCP/IP 引导协议也是如此。虽然 BOOTP 比它所取代的协议 (RARP) 的功能要强大得多，但在数年之后，BOOTP 本身被一种新的 TCP/IP 配置协议所取代：动态主机配置协议 (DHCP)。

BOOTP 代表了 RARP 的革命性变化，而 DHCP 更像是 BOOTP 的演变。它是使用 BOOTP 作为基础构建的，具有相同的基本消息格式。 DHCP 中最重要的新增功能是动态分配地址给客户端并集中管理它们的能力。正是这种能力为 DHCP 命名并使其如此强大。今天的 DHCP 是标准的 TCP/IP 主机配置协议，用于从单客户端家庭网络到企业级互联网的所有领域。

在本节中，我将描述 DHCP 背后的概念并详细解释它的工作原理。我从一个提供协议概述的主题开始，讨论它的历史和定义它的标准。然后我有四个小节描述 DHCP 概念和操作。第一篇讨论 DHCP 分配地址的不同方式，重点是动态寻址。第二部分讨论 DHCP 如何运行，包括查看配置参数管理以及分配地址和管理这些分配的过程。第三部分描述了 DHCP 消息传递并说明了 DHCP 消息格式。第 4 篇深入了解 DHCP 客户端和服务器的更多细节，还研究了 DHCP 的特殊功能和问题。最后，我以描述 DHCP 如何更改以支持新的 IP 版本 6 的主题结束。

**相关信息：**由于 DHCP 建立在 BOOTP 之上，因此它们有许多共同点。例如，DHCP 利用 BOOTP 中继代理功能，DHCP 选项与 BOOTP 供应商信息字段基本相同。由于 DHCP 是这两种协议中更常见的一种，因此我已尝试在此处完整地描述这些功能的操作，特别强调它们在 DHCP 和 BOOTP 中的工作方式之间的任何差异。

但是，我避免重复这些特征中的许多存在的历史和推理。由于 BOOTP 先出现，所以我在 BOOTP 部分放置了更多的历史信息。一般来说，如果您打算阅读有关 DHCP 和 BOOTP 的内容，我建议您先阅读有关 BOOTP 的部分。如果您不打算阅读 BOOTP，您可能希望查看有关 DHCP/BOOTP 互操作性的主题。



###### 3.1.3.1 DHCP 概述、动机、历史和标准（部分：1 2 3）

BOOTP 代表了对 RARP 的重大改进，因为它解决了 RARP 的许多问题。 BOOTP 是一个高层协议，不像 RARP 那样依赖于硬件。它可以支持向客户端发送 IP 地址以外的额外信息以启用自定义配置。此外，通过使用 BOOTP 中继代理，它允许大型组织仅使用一个或两个 BOOTP 服务器来处理分布在许多物理网络上的客户端。

这样一来，BOOTP 有效地解决了管理员在手动配置时遇到的主要问题之一：“我必须自己去配置每台主机”的问题。它允许“哑”（无存储）主机自动配置自己，并为技术人员节省了需要单独跋涉到每个主机以指定重要配置参数的麻烦。

<u>**动态地址分配的必要性**</u>
BOOTP 通常使用静态方法来确定分配给设备的 IP 地址。当客户端发送请求时，它包括其硬件地址，服务器在表中查找该地址以确定该客户端的 IP 地址。 （BOOTP 可以使用其他方法来确定 IP 和硬件地址之间的关系，但通常使用静态映射。）这意味着 BOOTP 在相对静态的环境中运行良好，其中分配给不同设备的 IP 地址的变化是很少见。这样的网络在 80 年代和 90 年代初期基本上是常态。

随着时间的推移，出于多种原因，许多网络迅速开始摆脱这种模式。随着计算机变得越来越小和越来越轻，它们从一个网络移动到另一个网络变得越来越普遍，在那里他们需要使用新网络的网络 ID 的不同地址。膝上型电脑甚至掌上电脑每天都可以从一个网络移动到另一个网络很多次。另一个主要问题是 IP 地址空间即将耗尽。在许多组织中，为每台可能连接到其网络的计算机永久分配一个静态 IP 地址是他们负担不起的奢侈。

在许多组织中，试图跟踪不断变化的 IP 地址本身就成了一项艰巨的任务。 BOOTP 及其硬件地址和 IP 地址之间的静态映射表根本无法胜任这项任务。它还没有提供重用地址的方法；一旦分配了地址，设备就可以永远保留它，即使不再需要它也是如此。

<u>**DHCP：建立在 BOOTP 的优势之上**</u>

需要一种新的主机配置协议来服务于现代网络，这将摆脱静态、永久的 IP 地址分配。 IETF 以动态主机配置协议 (DHCP) 的形式提供了这一点，该协议于 1993 年 10 月在 RFC 1541 中首次正式化。（实际上，它最初确实在同月的 RFC 1531 中指定，但由于 1531 中的小错误，标准很快被修订并发布了 1541。）

当然，这并不是说 BOOTP 是一个糟糕的协议之类的。它当然运作良好，因为它能够做到这一点。它也已经被广泛部署。鉴于这些因素，从头开始使用 DHCP 确实没有意义。考虑到这样的决定意味着要处理不可避免的“痛苦”过渡，以及与 BOOTP 和 DHCP 存在多年相关的兼容性问题，情况尤其如此。

因此，DHCP 并没有放弃 BOOTP，而是建立在它之上作为基础。在最简单的形式中，DHCP 由两个主要部分组成：一个地址分配机制，以及一个允许客户端请求、服务器提供配置信息的协议。 DHCP 以类似于 BOOTP 的方式执行这两个功能，但有所改进。

<u>**DHCP 特性概述**</u>

最显着的变化是在地址分配方面，通过支持上述动态地址分配得到增强。不是使用将硬件地址绝对映射到 IP 地址的静态表，而是使用 IP 地址池来动态分配地址。这允许在许多机器之间共享地址，并提供其他好处。动态寻址允许有效分配 IP 地址，甚至在设备之间共享。同时，DHCP 在需要的地方仍然支持设备的地址静态映射。

客户端和服务器之间的整体操作和通信再次与 BOOTP 使用的类似，但有所不同。使用 UDP 的相同基本请求/回复协议被保留用于通信配置信息，但创建了额外的消息类型以支持 DHCP 的增强功能。 DHCP 使用 BOOTP 中继代理的方式与 BOOTP 客户端和服务器使用它们的方式非常相似。来自 BOOTP 的供应商信息扩展也被保留，但被正式化、重命名为 DHCP 选项，并被扩展以允许传输更多信息。

所有这些开发工作的结果是一个被广泛接受的、通用的 TCP/IP 主机配置协议，它保留了与 BOOTP 的兼容性，同时显着扩展了它的功能。今天，DHCP 已在全球数百万个网络中找到。它用于从为拥有数千个主机的公司网络分配 IP 地址到允许家庭互联网访问路由器自动向单个用户的计算机提供正确的互联网配置信息的一切。

原始 DHCP 规范于 1997 年 3 月随着 RFC 2131（也称为动态主机配置协议）的发布而修订。该标准定义了另一种新的 DHCP 消息类型，以允许活动 IP 主机请求额外的配置信息。它还对协议进行了其他一些小改动。从那时起，许多其他与 DHCP 相关的 RFC 已经发布，其中大部分定义了新的 DHCP 选项类型（DHCP 服务器可以发送给 DHCP 客户端的其他类型的信息）或稍微改进了 DHCP 在特定应用程序中的使用方式。

**关键概念：**动态主机配置协议 (DHCP) 是当前用于现代 TCP/IP 互联网络的主机配置协议。它基于 BOOTP，在许多方面与其前身相似，包括使用请求/回复消息交换和几乎相同的消息格式。但是，DHCP 包括附加功能，其中最值得注意的是动态地址分配，它允许客户端从 DHCP 服务器管理的共享池中分配 IP 地址。



###### 3.1.3.2 DHCP地址分配和动态地址分配和管理

动态主机配置协议 (DHCP) 是作为旧引导协议 (BOOTP) 的扩展而创建的。 “DHCP”中的第一个词描述了添加到 BOOTP 中的最重要的新功能：动态分配 IP 地址的能力。从静态地址分配模型转变为动态地址分配模型极大地改变了我们在 DHCP 中处理 IP 地址的方式。主机配置从告诉主机其地址和其他参数的简单方法转变为用于管理组织中 IP 地址的完整工具。

在本节中，我将通过描述 DHCP 地址分配和租约背后的概念来详细介绍 DHCP。我首先了解 DCHP 地址分配的工作原理，并描述三种 DHCP 地址分配机制。然后，我深入研究了 DHCP 租约以及用于决定如何实施 DHCP 租用的策略和技术。我提供了从开始到结束的租约“生命周期”的概述，并描述了有助于控制该过程的两个 DHCP 租约计时器。最后，我描述了 DHCP 租用地址池和范围以及地址管理背后的一般概念。



###### 3.1.3.2-1 DHCP 地址分配和分配机制（部分：1 2 3 4）

动态主机配置协议的两个主要功能是提供一种为主机分配地址的机制，以及一种客户端可以从服务器请求地址和其他配置数据的方法。这两个功能都基于 DHCP 的前身 BOOTP 中实现的功能，但是在地址分配方面的变化比在通信方面的变化要大得多。从这里开始研究 DHCP 是有意义的，因为这自然会引导我们详细讨论 DHCP 的定义特征：动态寻址。

<u>**DHCP 地址分配机制**</u>
向客户端提供 IP 地址是主机配置协议执行的最基本的配置任务。为了在不同类型的客户端上灵活地配置地址，DHCP 标准包括三种不同的地址分配机制：

- 手动分配：特定的 IP 地址由管理员预先分配给单个设备。 DHCP 仅将 IP 地址传送给设备。

- 自动分配：DHCP 自动为设备永久分配一个 IP 地址，从可用地址池中选择它。

- 动态分配：DHCP 在服务器选择的有限时间内从地址池中分配一个 IP 地址，或者直到客户端告诉 DHCP 服务器它不再需要该地址。

我不太喜欢“自动”和“动态”分配这两个名称，因为它们没有很好地清楚地传达这些方法之间的区别。两者都可以被认为是“自动的”，因为在每个 DHCP 服务器中分配一个地址而无需管理员干预。它们之间的真正区别仅在于 IP 地址保留多长时间，以及主机地址是否随时间变化。我认为更好的名称是“静态/永久自动分配”和“动态/临时自动分配”。但是，没有人真正关心我的想法。狗头😂

不管您怎么称呼它们，这三种方法都存在，用于使用 DHCP 配置 IP 主机。管理员没有必要从其他人中选择一个。相反，他或她通常会结合这些方法，将每种方法用于最有意义的设备。

<u>**手动分配**</u>

手动分配是最简单的方法，相当于 BOOTP 用于地址分配的方法。每个设备都有一个管理员提前给它的地址，所有 DHCP 所做的就是在表中查找地址并将其发送给它的目标客户端。这种技术对于作为网络“中流砥柱”的设备（例如服务器和路由器）最有意义。它也适用于出于任何原因必须具有稳定、永久 IP 地址的其他设备。

好的，现在你可能有一个公平的问题。在手动分配的情况下，DHCP 基本上类似于 BOOTP。但是 BOOTP 是为需要配置帮助的设备创建的。服务器和路由器是具有自己内部存储的复杂设备，并且显然不需要像无盘工作站那样的 DHCP 服务器来告诉它们它们的 IP 地址，那么为什么还要为它们使用 DHCP 呢？

好吧，事实上，您可以直接手动将地址分配给设备并告诉 DHCP 忽略这些地址。但是，使用 DHCP 进行手动分配会产生不同的好处：管理上的好处。它将所有 IP 地址信息集中在 DHCP 地址数据库中，而不需要管理员逐台检查地址并确保没有重复地址。更新也可以在一个地方进行。

<u>**动态分配**</u>

虽然在 DHCP 中可以进行手动分配，但动态分配才是其真正的“存在理由”。管理员设置一个可供使用的 IP 地址池（通常是一个范围或一组范围）。每个配置为使用 DHCP 的客户端在需要 IP 地址时都会联系服务器。服务器跟踪哪些 IP 地址已经分配，并将池中的一个空闲地址租给客户端。服务器决定租约的持续时间。当时间到期时，客户端必须请求允许继续使用该地址（续订租约）或必须获得一个新地址。租赁问题及其处理方式将是本节其余大部分内容的主题。

动态分配是现代启用 DHCP 的 IP 互联网络中大多数客户端计算机使用的方法。它提供了许多好处，包括：

- 自动化：每个客户端都可以在需要时自动分配一个 IP 地址，无需干预，也不需要管理员手动决定哪个地址与哪个客户端对应。

- 集中管理：所有的IP地址都由DHCP服务器统一管理。管理员可以轻松查看哪些设备正在使用哪些地址并执行其他网络范围的维护任务。

- 地址重用和共享：通过限制每台设备持有 IP 地址的时间，DHCP 服务器可以确保 IP 地址池仅供活跃使用网络的设备使用。一段时间后，不再使用的地址将返回到池中，以允许其他设备使用它们。这允许互联网络支持的设备总数大于可用 IP 地址的数量，只要不是所有设备同时连接到互联网络即可。

- 可移植性和通用性：BOOTP（和DHCP 手动分配）都要求DHCP 服务器“知道”连接到它的每个客户端的身份，这样服务器才能找到客户端分配的地址。使用动态分配时，没有预定义的分配，因此任何客户端都可以请求 IP 地址。这本质上使动态分配成为支持在网络之间移动的移动设备的理想选择。

- 避免冲突：由于 IP 地址都是从 DHCP 服务器管理的池中分配的，因此可以避免 IP 地址冲突。

当然，最后一点假设所有客户端都使用 DHCP。管理员必须确保地址池不被非DHCP设备使用。在稍后有关 DHCP 地址范围和地址管理的主题中会详细介绍这一点。

<u>**自动分配**</u>

第三个选项，自动分配，可以用于每个可能连接到网络的设备都有足够的 IP 地址，但设备并不真正关心它们使用的 IP 地址的情况。一旦将地址分配给客户端，该设备将继续使用它。自动分配可以被认为是动态分配的“特例”：它本质上是动态分配，其中客户端使用 IP 地址的时间限制（租用长度）是“永远”。

在实践中，自动分配不像动态分配那样被广泛使用，原因很简单：自动永久分配一个 IP 地址给设备是一个冒险的举动。大多数管理员认为，对于真正需要永久 IP 地址分配的有限数量的机器，最好使用手动分配，而对其他机器使用动态寻址。我们将在下一个主题中对此进行更多讨论。

**关键概念：**DHCP 定义了三种基本的地址分配机制。动态分配是最常用的方法，其工作原理是让每个客户端从 DHCP 服务器租用一个地址一段时间；服务器从共享地址池中动态选择地址。自动分配类似于动态分配，但地址是永久分配的，而不是租用的。手动分配为特定设备预先分配一个地址，就像 BOOTP 所做的那样，并且通常仅用于服务器和其他永久性重要主机。



###### 3.1.3.2-2 DHCP 租约、租约长度策略和管理（部分：1 2 3 4）

在 DHCP 支持的三种地址分配方法中，动态地址分配是迄今为止最流行和最重要的。动态寻址对 TCP/IP 中 IP 地址使用方式的改变的重要性可以从 DHCP 中地址处理方式的语义中看出。按照惯例，主机被称为拥有 IP 地址，而当使用动态地址分配时，主机被称为租用地址。

“租约”的概念非常准确地传达了动态分配与其他类型之间的区别。主机不再严格“有权”使用特定地址，服务器仅告诉它地址是什么。在 DHCP 中，服务器仍然是地址池中所有 IP 地址的真正所有者，只是允许客户端在一段时间内使用该地址。服务器保证它不会仅在这段时间内尝试使用另一个客户端的地址。如果客户端想要继续使用该地址，则客户端负责采取某些操作，如我们将在本节后面看到的那样。如果一段时间后它没有成功重新获得使用该地址的权限，它必须停止使用它，否则就有可能在网络上造成 IP 地址冲突。

**关键概念：**DHCP 最重要的新特性是动态分配，它改变了 IP 地址的管理方式。在传统 IP 中，每个设备都拥有一个特定的 IP 地址，而在 DHCP 中，服务器拥有地址池中的所有地址，每个客户端从服务器租用一个地址，通常只租用一段有限的时间。

<u>**DHCP 租用期限策略和选择租用期限**</u>

当使用动态地址分配时，网络管理员必须向 DHCP 服务器提供参数以控制租约的分配和管理方式。要做出的最重要的决定之一是互联网络的租约长度策略：管理员希望客户端租约持续多长时间。当然没有“正确答案”——正确的租约长度间隔取决于网络、服务器和客户端。与许多其他网络参数一样，租用时间的选择归结为稳定性和分配效率之间的权衡。

使用长租用时间的主要好处是设备地址相对稳定。设备不必担心其 IP 地址一直在变化，其用户也不必担心。在许多情况下，这是一个显着的优势，尤其是当客户端需要执行某些服务器功能、接受传入连接或使用 DNS 域名（暂时忽略动态 DNS 功能）时。在这些情况下，让设备的 IP 地址到处移动会导致严重的并发症。

使用长租约的主要缺点是，它们会大大增加 IP 地址（一旦不再需要）在可以重复使用之前被“捆绑”的时间。在最坏的情况下，分配的“浪费时间”几乎与租约本身一样长。如果我们给一个设备一个特定的地址六个月，两周后设备关闭不再使用，那么它使用的 IP 地址在另外五个半月内仍然“不可用”。

出于这个原因，许多管理员更喜欢使用短期租约。这迫使客户在需要时不断续订租约。当它不再请求许可时，该地址会迅速放回池中。这使得在地址数量有限且必须保留的环境中，更短的租约成为更好的主意。当然，缺点与长租约的好处相反：不断变化的 IP 地址。

<u>**共同租赁期限**</u>

管理员不需要从“短”和“长”租约期限中挑选。他或她可以通过选择最适合网络的数字来“妥协”。租赁时间的一些示例及其背后的原因：

- 一小时或更短：确保在非常动态的环境中获得最大的 IP 地址分配效率，其中有许多设备连接和断开网络，并且 IP 地址的数量有限。

- One Day：适用于“访客”机器通常停留一天的情况，以在许多员工兼职工作时提高IP效率，或者以其他方式确保每个客户端必须每天再次请求使用地址的权限。

- 三天：这是 Microsoft 使用的默认值。仅这一点就使它成为一个受欢迎的选择。

- 一周：较短时间和较长时间之间的合理“妥协”。

- 一个月：另一个“妥协”，更接近租赁时间范围的较长一端。

- 三个月：提供合理的 IP 地址稳定性，以便地址在合理的静态环境中不会经常更改。如果有许多可用的 IP 地址并且机器经常一次关闭数天或数周，这也是一个好主意。可在大学环境中使用，以确保返校学生的 IP 地址在暑假期间得到维护。

- 一年：“无限”租约的近似值；见下文。

<u>**按客户类型分配租期**</u>
事实上，管理员不仅不受有限数量的可能租约期限的限制，而且管理员也没有必要为所有客户端选择恒定的租约期限策略。根据 DHCP 服务器的能力，管理员可以为某些客户端选择与其他客户端不同的租约长度。例如，管理员可能决定对永久分配给特定子网且不会移动的台式计算机使用长租期，并为笔记本电脑和“访客”使用短期租用地址池。在某些 DHCP 实现中，这可以通过将客户端分配给特定的“类”来完成。当然，这需要更多的工作（甚至可能需要多台服务器。）

<u>**将租约续约纳入租约期限选择**</u>

在选择租用时间策略时，管理员还必须记住，默认情况下，在租用时间过半后，客户端将开始尝试续订租用。这可能使使用更长的租约时间更可取，以增加客户端尝试续订租约和租约到期之间的时间量。例如，在具有单个 DHCP 服务器的网络中，管理员可能希望使用不少于八小时的租约。这为服务器维护提供了一个四小时的“窗口”，租约不会到期。

当租约很短时，比如几分钟或几小时，它通常会在客户端机器关闭一段时间后到期，比如一夜之间。更长的租约将在重新启动后持续存在。在这种情况下，客户端每次重新启动时仍会联系 DHCP 服务器以重新分配地址——确认它可以继续使用分配给它的地址。

**关键概念：**使用 DHCP 的网络管理员必须做出的一个关键决定是网络的租约长度策略。较长的租约允许设备避免过于频繁地更改地址，而较短的租约在重新分配不再需要的地址方面效率更高。管理员可以从各种不同的租用时间中进行选择，并且可以为某些设备选择比其他设备更长的租用时间。

<u>**“无限”租约的问题**</u>
除了选择一个特定的租用长度数字之外，还可以为某些客户端指定一个“无限”的租用长度持续时间。这有效地将动态分配转变为针对特定客户端的自动分配。然而，正如我在上一个主题中所说的那样，通常不会这样做。原因是无限期租约永不过期，正如老话所说，“永远不会是很长的时间”。杰

从池中永久分配 IP 地址是一个有点“冒险”的举动，因为一旦分配，如果发生任何导致该地址不再使用的情况，它就永远无法恢复。最坏的情况是访问公司站点的访问者将笔记本电脑接入网络以查看电子邮件或传输文件。如果使用自动分配为该机器分配了 IP 地址，则访问者离开时将“随身携带”。显然，这不是一个好主意。

出于这个原因，大多数管理员更喜欢使用动态分配，将地址设置为很长的时间范围，例如一年或两年。这被认为是“接近无穷大”，它近似于永久分配，但如果设备出于某种原因停止使用 IP 地址，则最终可以恢复 IP 地址。在这样的策略中，任何真正需要永久分配的东西都会使用手动分配来分配地址，这需要有意识地决定将地址专用于特定设备。

**相关信息：**有关租用长度选择的更多信息，请参阅有关 DHCP 服务器实施问题和问题的主题。



###### 3.1.3.2-3 DHCP 租用“生命周期”概述（分配、重新分配、续订、重新绑定和释放）和租用计时器（部分：1 2）

在 DHCP 中使用动态地址分配意味着一种全新的地址思考方式。客户不再拥有地址，而是租用它。这意味着当客户端机器被设置为使用 DHCP 动态寻址时，它永远不能假设它有一个永久的地址。每次启动时，它都必须与 DHCP 服务器进行通信以开始或确认地址租用。随着时间的推移，它还必须执行其他活动来管理此租约并可能终止它。

<u>**DHCP 租用“生命周期”**</u>
调用动态地址分配租约是一个很好的类比，因为 DHCP IP 地址租约在许多方面类似于“现实世界”租约。例如，当您租用公寓时，您签署租约。然后你使用公寓一段时间。通常，假设您对这个地方感到满意，您会在租约到期前续租，这样您就可以继续使用它。如果在您的租约即将到期时，公寓的所有者不允许您续租，您可能会租用另一间公寓以确保您有地方住。如果你决定，比如说，搬出这个国家，你可能会终止租约并且根本不会再得到另一个租约。

DHCP 租约遵循类似的租约“生命周期”，通常包括以下阶段：

- 分配：客户端开始时没有活动租约，因此没有 DHCP 分配的地址。它通过分配过程获得租赁。

- 重新分配：如果客户端已经有一个现有租约的地址，那么当它重新启动或关机后启动时，它会联系授予它租约的 DHCP 服务器以确认租约并获取操作参数。这有时称为重新分配；它类似于完整的分配过程，但更短。

- 正常操作：一旦租约处于活动状态，客户端就会正常运行，在租约的“主要部分”期间使用分配给它的 IP 地址和其他参数。据说客户端绑定到租约和地址。

- 续订：在租用时间的某一部分到期后，客户端将尝试联系最初授予租用的服务器，以续订租用，以便它可以继续使用其 IP 地址。

- 重新绑定：如果与原始租用服务器的续订失败（例如，因为服务器已脱机），则客户端将尝试重新绑定到任何活动的 DHCP 服务器，尝试与任何允许它的服务器延长其当前租约这样做。

- 释放：客户端可以随时决定不再使用分配给它的 IP 地址，并可以终止租约，释放 IP 地址。就像公寓租户搬出国外一样，例如，如果设备移动到不同的网络，则可以这样做。当然，与 DHCP 服务器不同，房东通常不会让您随意取消租约，但是嘿，没有比喻是完美的。

图 259 使用跨越三个租约的示例说明了 DHCP 生命周期。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\dhcplife.png)




​                                                                                        **图 259：DHCP“生命周期”示例**

在此示例中，初始租约的持续时间为八天，从第 0 天开始。T1 和 T2 计时器分别设置为 4 天和 7 天。当 T1 计时器到期时，客户端进入续订期，并在第 5 天成功续订新的 8 天租约。当第二个租约的 T1 计时器到期时，客户端无法与原始服务器续订。当它的 T2 计时器关闭时，它进入重新绑定期，并被授予与不同服务器的续订 8 天租约。租约三天后，它被转移到另一个网络并且不再需要它的租用地址，所以它自愿释放它。

<u>**更新和重新绑定计时器**</u>

更新和重新绑定的过程旨在确保客户端的租约可以在计划结束之前延长，因此客户端机器的用户不会发生功能损失或中断。每次分配或重新分配地址时，客户端都会启动两个计时器来控制更新和重新绑定过程：

1. 续订计时器 (T1)：此计时器默认设置为租期的 50%。当它到期时，客户端将开始续租的过程。在 DHCP 标准中简称为“T1”。

2. 重新绑定计时器 (T2)：此计时器默认设置为租约长度的 87.5%。当它过期时，客户端将尝试重新绑定，如上所述。它在 DHCP 标准中被赋予了活泼的名称“T2”。

自然地，如果客户端在 T1 计时器到期时成功续订租约，这将导致“新租约”，并且两个计时器都将被重置。 T2 只有在更新不成功时才会起作用。可以更改这些计时器设置的时间量，但显然 T1 必须在 T2 之前到期，而 T2 又必须在租约本身结束之前到期。这些通常不会更改默认值，但在某些情况下可能会被修改。

**关键概念：**DHCP 租约遵循一个概念性的生命周期。租约首先通过分配过程分配给客户；如果设备稍后重新启动，它将重新分配租约。在续订计时器 (T1) 控制的一段时间后，设备将尝试与分配它的服务器续订租约。如果失败，重新绑定计时器 (T2) 将关闭，设备将尝试将租约与任何可用服务器重新绑定。如果客户端不再需要它，它也可以释放它的 IP 地址。

租约生命周期在 DHCP 标准中以客户端在获取租约、使用租约、然后续订或结束租约时所经历的状态形式进行描述。关于 DHCP 配置的下一节描述了这些状态以及客户端和服务器之间为完成不同租用活动而进行的特定消息交换。



###### 3.1.3.2-4 DHCP 租用地址池、范围（范围）和地址管理（部分：1 2 3 4）

更简单的主机配置方法，例如 BOOTP（或 DHCP 手动分配）将单个 IP 地址与每个客户端机器相关联。 DHCP 动态寻址消除了这种一对一的对应关系，有利于“根据需要”灵活地将地址映射到客户端。客户端不再拥有地址，而是从真正的所有者服务器那里租用它们。显然，DHCP 服务器和该服务器的管理员的主要工作就是维护和管理这些客户端地址。

<u>**地址池大小选择**</u>
DHCP 服务器可用于分配的所有地址的集合通常称为地址池。与地址管理相关的第一个问题是确保地址池足够大以服务所有将使用该服务器的客户端。所需地址的数量取决于多种因素：

- 客户数量：显然。

- 客户端使用的稳定性和频率：如果大多数客户端一直保持在线并连接到网络，您可能需要为每个客户端规划一个地址。相比之下，如果您为兼职员工或经常出差的顾问提供服务，则可以共享较少数量的地址。

- 过度分配的后果：如果某些客户端无法获得免费地址是一个问题，您需要更仔细地管理地址池以确保您不会用完。如果让客户得不到地址是绝对不能接受的，请确保您拥有与客户一样多或更多的地址。

我相信您可能已经注意到这些问题与我在本节前面讨论租约期限时提出的问题类似。事实上，这两件事是密切相关的。一般来说，拥有更多地址可以让管理员“奢侈”地使用更长的租约。如果您的地址不足，您可能需要使用较短的租约来减少任何未使用的地址继续分配给不需要它们的设备的可能性。

<u>**租赁地址范围（范围）**</u>

在最简单的形式中，地址池采用 DHCP 服务器为动态客户端分配保留的所有地址的列表形式。与每个地址一起，服务器存储某些参数，例如地址的默认租用长度和分配该地址时要发送给客户端的其他配置信息（例如，子网掩码和默认路由器的地址).所有这些数据都存储在服务器上的一个特殊数据库中。

当然，很多客户端会从这个池中请求地址。就 DHCP 服务器而言，这些客户端中的大多数都是“平等的”，并且每个客户端获得哪个地址都无关紧要。这意味着存储在池中每个地址的大部分信息可能是相同的，除了地址编号本身。由于这种相似性，必须单独指定每个地址及其参数是低效的。相反，地址范围通常作为为特定网络或子网定义的单个组来处理。这些在 DHCP 标准中没有给出任何特定名称，但通常称为范围。 Microsoft 在其 DHCP 服务器实现中普及了该术语。其他操作系统有时只是将这些地址块称为范围，但我更喜欢“范围”，所以这就是我在这里使用的。

**关键概念：**每个 DHCP 服务器都维护一组 IP 地址，用于为客户端分配租约。这些通常是由管理员分配给服务器的连续地址块，称为 DHCP 地址范围或作用域。

<u>**单个作用域的简单地址分配**</u>

设置作用域的确切方法取决于特定的操作系统和 DHCP 服务器软件，我不打算在这里深入探讨。但是，每个范围定义通常首先使用起始和结束 IP 地址指定地址范围。例如，如果一家公司被分配了 IP 地址块 111.14.56.0/24，则管理员可以设置一个包含地址 111.14.56.20 到 111.14.56.254 的范围，如图 260 所示。然后对于该范围，管理员可以设置up 各种参数指定给每个client分配一个地址范围。

​        ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\dhcpscope.png)                                         		                                             

​                                            **图 260：DHCP 作用域**




为什么不从 111.14.56.1 开始呢？通常我们会希望留出某些 IP 地址，用于手动配置服务器、路由器和其他需要固定地址的设备。一种简单的方法是简单地保留 DHCP 未使用的地址块。或者，大多数 DHCP 服务器软件将允许您指定一个范围，但从该范围中排除一个地址或一组地址。因此，我们可以指定 111.14.56.1 到 111.14.56.254，并单独标记为我们手动分配的“不可用”地址。或者指定保留 111.14.56.1 到 111.14.56.19。

<u>**多个范围的地址分配**</u>

服务器可以使用多个范围，而不是将其所有地址（排除的地址除外）放在一个范围内。后一种方法的一个常见原因是在一台服务器上支持多个子网。当使用多个 DHCP 服务器为相同的客户端提供服务时，也通常使用多个作用域。有两种方法可以做到这一点：重叠或不重叠的范围。

重叠作用域允许每个服务器分配同一池中的任何地址。但是，DHCP 标准没有指定服务器在分配地址时相互通信的任何方式，因此如果两台服务器都被告知可以从同一地址池中分配地址，这可能会导致两台服务器都尝试分配一个两个不同设备的特定地址。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\dhcpscopeoverlap.png)


​                                                            图 261：DHCP 多服务器非重叠范围

已为 DHCP 服务器 A 和 B 分配了非重叠范围，以确保它们不会发生冲突。这是通过从两者的相同范围定义开始来完成的。公共保留范围被排除在外。然后，服务器 A 排除了服务器 B 的地址范围（顶部紫色阴影），B 排除了 A 的地址范围（蓝色阴影，底部）。


因此，如果您使用两个 DHCP 服务器（出于冗余原因通常建议这样做），管理员通常会为它们分配不同的、不重叠的范围。或者，为每个服务器提供相同的范围，并告知每个服务器排除使用其他服务器正在分配的地址。

例如，假设我们有两个 DHCP 服务器：A（主服务器）和 B（备用服务器）。我们希望将大部分地址分配给 A，将少数地址作为备用地址分配给 B。我们可以为 A 和 B 提供范围 111.14.56.1 到 111.14.56.254。我们将从两者中排除 111.14.56.1 到 111.14.56.19。然后我们从服务器 A 中排除范围 111.14.56.200 到 111.14.56.254，并从服务器 B 中排除范围 111.14.20 到 111.14.56.199。图 261 显示了这是如何工作的。这种方法的主要优点是，如果一台服务器宕机，管理员可以迅速解除排除，让剩下的服务器访问所有地址。此外，如果一台服务器用完了地址而另一台服务器有足够的地址，则分配可以很容易地转移。

<u>**地址管理的其他问题**</u>
还有许多与地址管理相关的其他问题，这些问题开始进入 DHCP 服务器实施的“核心”。例如，与 BOOTP 的情况一样，当 DHCP 服务器负责与它自己不同的子网上的地址时，我们可能需要使用中继代理。还有一些特殊的 DHCP 功能会影响地址的管理方式。例如，DHCP 冲突检测功能实际上可以允许两个服务器具有重叠的范围，尽管我们上面已经说过了。有关 DHCP 实现和功能的部分更详细地讨论了这些问题。

**关键概念：**如果一个站点有多个 DHCP 服务器，则可以为它们设置重叠或不重叠的范围。重叠范围允许每个服务器从同一个池中进行分配，提供了灵活性，但增加了两个客户端被分配相同地址的可能性，除非使用服务器冲突检测等功能。非重叠范围“更安全”，因为每个服务器都有一组专用地址供其使用，但这意味着一个服务器可能会用完地址而另一个服务器仍有很多地址，如果服务器出现故障，其地址将暂时无法分配.



###### 3.1.3.3 DHCP配置和操作

DHCP 中的“大新闻”是动态地址分配和地址租用的概念。事实上，正是这种新功能使 DHCP 比其前身复杂得多。 BOOTP 是一个简单的请求/回复协议，因为服务器只需要查找客户端的硬件地址并发回客户端分配的 IP 地址和其他参数。相比之下，DHCP 客户端和服务器必须做更多的工作来执行参数交换和管理 IP 地址租用所需的许多任务。

在本节中，我将深入探讨 DHCP 如何运行的“具体细节”。我从两个背景话题开始。第一部分概述了客户端和服务器在 DHCP 中的职责，并概括说明了它们之间的关系。第二部分讨论 DHCP 配置参数以及它们的存储和通信方式。

其余五个主题详细说明了 DHCP 的操作。五个中的第一个描述了 DHCP 客户端有限状态机，它将让您从高层次了解整个客户端租约“生命周期”，包括地址分配、重新分配、续订、重新绑定和可选的租约终止。这个理论描述然后被用作几个主题的基础，这些主题解释了 DHCP 客户端租用活动发生的实际过程。这些显示了客户端和服务器采取的具体操作，以及何时以及如何创建和发送 DHCP 消息。五个主题中的最后一个主题描述了不使用 DHCP 进行地址分配的设备可以请求配置参数的特殊机制。

注意：如果您要阅读本节，我强烈建议您按顺序阅读前三个主题。然后，如果您打算阅读以下四个“过程”主题中的任何一个，请从第一个有关分配的主题开始，因为它包含许多也适用于其后主题的重要说明。



###### 3.1.3.3-1 客户端和服务器职责的 DHCP 概述（部分：1 2）

DHCP 是最新和最新的 TCP/IP 主机配置协议。然而，正如我们在其概述中看到的那样，它并不是“从头开始”构建的——它被设计为引导协议的扩展。在许多方面，DHCP 就像“具有更多功能的 BOOTP”，这可以从协议的基本设置及其工作方式中看出。

BOOTP 和 DHCP 都是基于客户端/服务器操作的通用 TCP/IP 模型设计的。在任何交互中，一个设备扮演客户端的角色，另一个扮演服务器的角色。每个人都有特定的职责，并且必须按照 DHCP 标准中描述的协议发送和接收消息。不同之处在于，BOOTP 涉及服务器和客户端的工作相对较少，并使用简单的单一消息交换进行通信，而 DHCP 要求服务器和客户端做更多的工作，并使用多种类型的消息交换。

<u>**DHCP 服务器职责**</u>
DHCP 服务器是一种网络设备，已被编程为向客户端提供 DHCP 服务。服务器在 DHCP 中起着核心作用，因为 DHCP 的主要功能是主机配置，服务器是配置与之通信的主机（客户端）的东西。在较小的网络上可能只有一台服务器来支持许多客户端，而较大的网络可能使用多台服务器；无论服务器数量多少，每台服务器通常都会为许多客户端提供服务。

以下是服务器使 DHCP 工作的主要职责：

- 地址存储和管理：DHCP 服务器是所有 DHCP 客户端使用的地址的所有者。服务器存储地址并管理它们的使用，跟踪哪些地址已分配，哪些地址仍然可用。

- 配置参数存储和管理：DHCP 服务器还存储和维护旨在在请求时发送给客户端的其他参数。其中许多是重要的配置值，详细指定了客户端的操作方式。

- 租约管理：正如我们在上一节中看到的，DHCP 服务器使用租约在有限的时间内为客户端动态分配地址。 DHCP 服务器维护有关它已授予客户端的每个租约的信息，以及租约长度等策略信息。

- 响应客户端请求：DHCP 服务器响应来自客户端的不同类型的请求以实现 DHCP 通信协议。这包括分配地址、传送配置参数以及授予、更新或终止租约。

- 提供管理服务：为支持上述所有内容，DHCP 服务器包含允许人工管理员输入、查看、更改和分析地址、租约、参数和运行 DHCP 所需的所有其他信息的功能。

<u>**DHCP 客户端职责**</u>

DHCP 客户端是向服务器发送 DHCP 请求以获取 IP 地址或其他配置信息的任何设备。由于 DHCP 的优势，当今 TCP/IP 互联网络上的大多数主机计算机都包含 DHCP 客户端软件，如果管理员选择启用该功能，它们将成为潜在的 DHCP 客户端。 DHCP客户端的主要职责是：

- 配置启动：客户端通过启动通信交换来发挥主动作用，导致它被赋予一个 IP 地址和其他参数。相比之下，服务器是被动的，在客户端进行联系之前不会真正为客户端做任何事情。

- 配置参数管理：客户端维护与其配置有关的参数，其中一些或全部参数可以从 DHCP 服务器获得。

- 租约管理：假设其地址是动态分配的，客户端会跟踪自己的租约状态。它负责在适当的时间续租，如果无法续租则重新绑定，如果不再需要该地址则提前终止租约。

- 消息重传：由于 DHCP 使用不可靠的用户数据报协议进行消息传递，客户端负责检测消息丢失并在需要时重传请求。

<u>**DHCP 设备角色和交互**</u>

DHCP 服务器和客户端显然起着互补的作用。服务器维护所有客户端的配置参数；每个客户端都维护自己的参数，这将在下一个主题中讨论。 IP 地址分配和租约创建、更新、重新绑定和终止是通过使用一组八种 DHCP 消息类型的特定交换来完成的，我们将在本节后面看到。为完成此消息传递，需要遵循特殊规则来生成、寻址和传输消息，这些规则在 DHCP 消息传递部分的主题中进行了解释。

与 BOOTP 一样，DHCP 也支持第三种类型的设备，即中继代理。中继代理既不是客户端也不是服务器，而是促进服务器和客户端之间跨网络通信的中介。它们在有关 DHCP 实现和功能的部分中有更详细的描述（您还可以在其中找到服务器和客户端的更多实现细节。）

**关键概念：**DHCP 服务器是被编程为向客户端提供 DHCP 服务的设备。它们管理地址信息和其他参数并响应客户端配置请求。 DHCP 客户端是已设置为使用 DHCP 来确定其配置的 TCP/IP 设备。他们发送请求并读取响应，并负责管理自己的租约，包括在必要时续订或重新绑定租约。





###### 3.1.3.3-2 DHCP 配置参数、存储和通信（部分：1 2）

DHCP 的前身 BOOTP 中一个更重要的疏忽是，原始协议只允许服务器告诉客户端三个信息：它的 IP 地址、它可以用来下载引导文件的服务器的名称，以及要使用的引导文件的名称。这是 BOOTP 遗留下来的协议的结果，它主要是为了让无盘工作站能够被引导而创建的。

显然，IP 地址是一个非常重要的参数，但在现代网络中，它并不是客户端正常运行所需的唯一参数。典型的主机需要获得其他基本信息，以使其知道应如何在其本地网络上运行并与其他设备交互。例如，它需要知道默认本地路由器的地址、它所在子网的子网掩码、创建传出 IP 数据报的参数等等。

<u>**配置参数管理**</u>
无法在 BOOTP 中指定额外配置参数的问题已通过为独立于供应商的供应商信息字段使用特殊的 BOOTP 供应商特定区域解决，正如 RFC 1048 中首次定义的那样。在 DHCP 中，这个想法得到了进一步扩展，更重要的是，形式化，作为使 DHCP 成为更通用的配置工具的一部分。配置参数的存储、维护和通信不再是可选功能，而是主机配置过程中必不可少的部分。

正如 DHCP 服务器是拥有和管理 IP 地址的“老板”一样，它们也充当属于 DHCP 客户端的其他配置参数的存储库。这种参数存储的集中化提供了许多与 DHCP 中的 IP 地址集中化相同的好处：可以在一个地方检查和调整参数，而不必去每台客户端机器。

每个 DHCP 服务器都用参数进行编程，这些参数在分配地址时除了 IP 地址之外还要与客户端通信。或者，已经使用某种其他机制分配了地址的客户端仍可以使用 DHCPINFORM 消息类型查询 DHCP 服务器以获取参数信息。 （这实际上是添加到 RFC 2131 中的协议中；它不在原始 DHCP 标准中。）

客户端参数的确切存储方法在某种程度上取决于实现。通常，会有一些参数适用于所有客户端。例如，在只有一个路由器的小型网络中，无论地址如何，该路由器可能都是每个 DHCP 客户端的默认路由器。



<u>**客户端特定参数和客户端标识符**</u>

DHCP 服务器还将具有特定于客户端的某些参数； IP 地址本身就是一个明显的例子，但还有其他参数可能仅适用于网络上的某些客户端。这些参数存储在某种数据库中，并使用特定的客户端标识符进行索引。

默认标识符由客户端的 IP 子网号及其硬件地址组成。因此，当服务器收到来自特定子网的请求时，它可以在请求中使用客户端的硬件地址来查找特定于客户端的参数并返回它们。如果需要不同的识别方案，则可以更改客户端标识符。

<u>**客户端参数存储**</u>
客户端也负责参数存储，但当然只是他们自己的参数。其中许多将从 DHCP 服务器获得，但有些可能以其他方式提供。客户端的具体实现决定了它认为哪些参数重要以及它们是如何被发现的。

<u>**配置参数通信**</u>
DHCP 客户端和服务器之间的配置参数通信是使用 DHCP 选项完成的，它取代了 BOOTP 供应商信息字段。首次创建 DHCP 时定义了一些选项，并且多年来又创建了其他新选项。今天有几十个这样的选择。显然，能够将如此多的不同参数自动传递给客户端的能力为管理员提供了极大的主机配置灵活性。 DHCP 选项在有关 DHCP 消息格式的部分中有进一步描述。



###### 3.1.3.3-3 DHCP 通用操作和客户端有限状态机

动态地址分配可能是 DHCP 引入的最重要的新功能。在上一节中，我详细讨论了从 IP 地址所有权到 IP 地址租赁的转变的意义。通过提供 DHCP 租约“生命周期”的概述，我还提供了租约中涉及的活动的高级视图。

此类概述有助于大致了解租约的工作原理，但要真正了解 DHCP 地址分配和客户端/服务器通信的机制，我们需要更多有关设备行为方式和它们发送的消息的详细信息。网络工程师经常用来描述协议的一种工具是称为有限状态机 (FSM) 的理论模型。在这种技术中，协议的特定行为通过显示设备可能处于的不同状态、从一种状态到另一种状态存在哪些可能的转换、哪些事件导致转换发生以及响应事件执行哪些操作来说明。 TCP 操作概述包含有关有限状态机的更多一般背景信息。

DHCP标准使用FSM从DHCP客户端的角度来描述租约生命周期。客户端从没有租约的初始 INIT 状态开始，然后在获取、更新、重新绑定和/或释放其 IP 地址时过渡到各种状态。 FSM 还指示服务器和客户端在不同阶段发生的消息交换。

有些人认为有限状态机有点“密集”且难以理解，我明白这是为什么。你当然可以跳过这个主题，但我认为 FSM 提供了一种有用的方式来全面说明 DHCP 客户端的大部分行为。表 188 描述了每个 DHCP 客户端状态，总结了客户端在每个状态下发送和接收的消息，并显示了响应中发生的状态转换。 FSM 的状态、事件和转换在图 262 中更容易想象，它还包含一个颜色编码方案，因此您可以看到哪些状态与每个主要 DHCP 进程相关联。


​                                                                      **表 188：DHCP 客户端有限状态机**

| **State**          | **State Description**                                        | **Event and Transition**                                     |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| ***INIT\***        | 这是初始化状态，客户端开始获取租约的过程。当租约结束或租约协商失败时，它也会返回此处。 | **Client Sends \*DHCPDISCOVER\*:** 客户端发送 DHCPDISCOVER：客户端创建 DHCPDISCOVER 消息并广播它以尝试找到 DHCP 服务器。它转换到 SELECTING 状态。 |
| ***SELECTING\***   | 客户端正在等待从一个或多个 DHCP 服务器接收 DHCPOFFER 消息，因此它可以选择一个。 | **Client Receives Offers, Selects Preferred Offer, Sends \*DHCPREQUEST\*:** 客户端接收报价，选择首选报价，发送 DHCPREQUEST：客户端选择已发送的报价之一，并广播 DHCPREQUEST 消息以告知 DHCP 服务器其选择是什么。它转换到 REQUESTING 状态。 |
| ***REQUESTING\***  | 客户端正在等待从其向其发送请求的服务器收到回复。             | **Client Receives \*DHCPACK\*, Successfully Checks That IP Address Is Free:** Client Receives DHCPACK, Successfully Checks That IP Address Is Free：客户端从其选择的服务器收到 DHCPACK 消息，确认它可以拥有提供的租约。它检查以确保地址未被使用，并假设它未被使用，记录服务器发送给它的参数，设置租用计时器 T1 和 T2，并转换到 BOUND 状态。.**Client Receives \*DHCPACK\*, But IP Address Is In Use:** 客户端收到 DHCPACK，但 IP 地址正在使用：客户端从其选择的服务器收到一条 DHCPACK 消息，确认它可以拥有提供的租约。但是，它会检查并找到已在使用的地址。它向服务器发送回 DHCPDECLINE 消息，并返回到 INIT 状态。.**Client Receives \*DHCPNAK\*:** Client Receives DHCPNAK：客户端从其选择的服务器接收到 DHCPNAK 消息，这意味着服务器已撤回其提议。客户端返回到 INIT 状态。 |
|                    |                                                              |                                                              |
|                    |                                                              |                                                              |
| ***INIT-REBOOT\*** | 当一个已经有有效租约的客户端在掉电或重启后启动时，它从这里开始而不是 INIT 状态。 | **Client Sends \*DHCPREQUEST\*:** 客户端发送 DHCPREQUEST：客户端发送 DHCPREQUEST 消息以尝试验证其租约并重新获取其配置参数。然后它会转换到 REBOOTING 状态以等待响应。 |
| ***REBOOTING\***   | 使用分配的地址重新启动的客户端正在等待服务器的确认回复。     | **Client Receives \*DHCPACK\*, Successfully Checks That IP Address Is Free:** Client Receives DHCPACK, Successfully Checks That IP Address Is Free：客户端从服务器收到一个DHCPACK报文，里面有它的租约信息，确认租约仍然有效。为了安全起见，客户端无论如何都会检查以确保该地址尚未被其他设备使用。假设不是，客户端记录服务器发送给它的参数并转换到 BOUND 状态。.**Client Receives \*DHCPACK\*, But IP Address Is In Use:**Client Receives DHCPACK, But IP Address Is In Use：客户端从有租约的服务器收到 DHCPACK 消息，确认租约仍然有效。但是客户端查看发现，在客户端离线的时候，有其他设备抢走了它的租用IP地址。客户端向服务器发回 DHCPDECLINE 消息，并返回到 INIT 状态以获得新的租约。.**Client Receives \*DHCPNAK\*:** Client Receives DHCPNAK：客户端从服务器接收到 DHCPNAK 消息。这告诉它它当前的租约不再有效；例如，客户端可能已经移动到一个新网络，在那里它不能再使用当前租约中的地址。客户端返回到 INIT 状态。. |
|                    |                                                              |                                                              |
|                    |                                                              |                                                              |
| ***BOUND\***       | 客户端具有有效租约并处于正常运行状态。                       | **Renewal Timer (\*T1\*) Expires:** 更新计时器 (T1) 到期：客户端转换到更新状态。.**Client Terminates Lease, Sends \*DHCPRELEASE\*:** Client Terminates Lease, Sends DHCPRELEASE：客户端决定终止租约（例如，由于用户命令）。它发送 DHCPRELEASE 消息并返回到 INIT 状态。 |
|                    |                                                              |                                                              |
| ***RENEWING\***    | 客户正在尝试续租。它定期向为其指定当前租约的服务器发送 DHCPREQUEST 消息，并等待回复。 | **Client Receives \*DHCPACK\*:** Client Receives DHCPACK：客户端收到对其 DHCPREQUEST 的 DHCPACK 回复。它的租约被更新，它重新启动 T1 和 T2 定时器，并返回到 BOUND 状态。.**Client Receives \*DHCPNAK\*:** 客户端收到 DHCPNAK：服务器拒绝续订客户端的租约。客户端进入 INIT 状态以获得新租约。.**Rebinding Timer (\*T2\*) Expires:** Rebinding Timer (T2) Expires：在尝试更新其租约时，T2 定时器到期，表明更新期已结束。客户端转换到 REBINDING 状态。 |
|                    |                                                              |                                                              |
|                    |                                                              |                                                              |
| ***REBINDING\***   | 客户端未能与最初授予它的服务器续租，现在寻求与任何可以听到它的服务器的租约延期。它周期性地发送没有指定服务器的 DHCPREQUEST 消息，直到它得到回复或租约结束。 | **Client Receives \*DHCPACK\*:** Client Receives DHCPNAK：网络上的服务器专门告诉客户端它需要重新启动租赁过程。如果新服务器愿意授予客户端租约，但条件与客户端当前租约不同，则可能会出现这种情况。客户端进入 INIT 状态。.**Client Receives \*DHCPNAK\*:** 租约到期：客户端在租约到期之前没有收到任何回复。它返回到 INIT 状态。 |
|                    |                                                              |                                                              |
|                    |                                                              |                                                              |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\dhcpfsm.png)

​                                                                  **图  262：DHCP 客户端有限状态机**

此图显示了 DHCP 客户端使用的有限状态机。彩色背景区域显示了 DHCP 客户端在通过四个主要 DHCP 进程时所进行的转换：分配、重新分配、更新和重新绑定。


这只是有限状态机的总结，并没有显示所有可能的事件和转换，因为它已经足够复杂了。例如，如果在 SELECTING 状态下收到两个提议的客户端在 REQUESTING 状态下从其选择的服务器收到 DHCPNAK，它可能会选择将新的 DHCPREQUEST 发送到它的“第二选择”，而不是从头开始。此外，如果客户端在各种状态下未收到对已发送消息的回复，例如在 SELECTING 状态下未收到任何报价，则客户端必须具有允许其“超时”的逻辑。接下来的几个主题将更详细地讨论这些问题。

另请注意，DHCP 标准并未以有限状态机的形式描述 DHCP 服务器的行为，仅描述了客户端的行为。在接下来的页面中，也有更多关于 DHCP 服务器具体做什么的信息。

我还应该明确指出，这个有限状态机适用于动态分配的客户端；也就是说，那些有传统租约的。使用“自动”分配配置的设备将经历相同的基本分配过程，但不需要续订租约。手动分配的过程有些不同。



###### 3.1.3.3-4 DHCP 租约分配过程（部分：1 2 3）

实施 DHCP，管理员必须首先设置 DHCP 服务器并为其提供配置参数和策略信息：IP 地址范围、租约长度规范以及 DHCP 主机需要传送给它们的配置数据。然后主机设备可以启用其 DHCP 客户端软件，但在客户端启动与服务器的通信之前什么也不会发生。当 DHCP 客户端第一次启动时，或者当它没有当前的 DHCP 租约时，它将处于初始状态，它没有地址并且需要获取地址。它将通过启动租赁分配过程来做到这一点。

<u>**租赁通讯说明的注意事项**</u>
在我开始之前，关于此描述的一些注意事项也适用于本节中有关 DHCP 租用通信的后续主题：

- 寻址：DHCP 假定客户端通常会广播消息，因为它们在发起联系时不知道服务器的地址，但服务器会向客户端发送单播回复。这甚至可以在客户端拥有 IP 地址之前通过在链路层发送消息来完成。有些客户不支持这一点，而是要求广播给他们的消息。有关如何创建和寻址消息的详细信息，请参阅有关 DHCP 消息传递的部分。

- DHCP 消息字段和选项：DHCP 使用许多与 BOOTP 相同的基本字段，但协议所需的许多额外信息都包含在 DHCP 选项中。显然，其中一些“选项”并不是真正可选的，尽管名称如此——它们是 DHCP 基本功能所必需的。一个明显的例子是 DHCP 消息类型选项，它指定了消息类型本身。同样，您可以在 DHCP 消息传递部分找到所有 DHCP 字段和选项的完整描述。

- DHCP 中继代理：我假设这里没有使用中继代理；有关它们如何更改分配过程（和其他过程）的更多信息，请参阅有关 DHCP/BOOTP 中继代理的主题。

<u>**租赁分配流程步骤**</u>

下面我描述了 DHCP 客户端和服务器在初始分配 IP 地址租约时遵循的步骤。这是一个基本的描述，我没有包括客户端和服务器所做的所有细节，因为那样会让这个描述变得非常长。相反，我专注于每个设备执行的最重要的任务，还指定了交换的消息类型和每条消息中包含的关键数据片段，以及客户端状态和转换。该过程也在图 263 中进行了说明。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\dhcpallocation.png)


​                                                                          **图 263：DHCP 租约分配过程**

此图显示了 DHCP 客户端租约分配中涉及的步骤。此图与本指南中的大多数其他客户端/服务器交换图有点不同，因为我显示了两个服务器而不是一个。这显示了客户端如何处理来自多个 DHCP 服务器的响应，以及每个服务器如何根据客户端是否选择租约提供不同的反应。

 



**<u>1.客户端创建 DHCPDISCOVER 消息</u>**
客户端以 INIT（初始化）状态开始。它没有 IP 地址，甚至不知道网络上是否有 DHCP 服务器或位于何处。为了找到一个，它会创建一条 DHCPDISCOVER 消息，其中包括以下信息：

- 它自己的硬件地址在消息的 CHAddr 字段中，以标识自己。

- 一个随机交易标识符，放入 XID 字段。这用于将以后的消息标识为同一事务的一部分。

- 可选地，客户端可以使用请求的 IP 地址 DHCP 选项来请求特定的 IP 地址，使用 IP 地址租用时间选项来请求特定的租用长度，和/或通过在消息中包括参数请求列表选项来请求特定的配置参数。

<u>**2.客户端发送DHCPDISCOVER报文**</u>
客户端在本地网络上广播 DHCPDISCOVER 消息。客户端转换到 SELECTING 状态，等待对其消息的回复。

3.服务器接收并处理DHCPDISCOVER报文
本地网络上的每个 DHCP 服务器接收客户端的 DHCPDISCOVER 消息并检查它。服务器在其数据库中查找客户端的硬件地址，并确定它是否能够向客户端提供租约，以及租约的条款。如果客户端请求特定的 IP 地址、租用期限或其他参数，服务器将尝试满足这些请求，但并非必须这样做。如果服务器没有被编程为为其提供服务、它没有剩余的 IP 地址或出于其他原因，它可能会决定不向特定客户端提供租约。

<u>**4.服务器创建 DHCPOFFER 消息**</u>
每个选择响应客户端的服务器都会创建一个 DHCPOFFER 消息，其中包含以下信息：

- 在 YIAddr 字段中分配给客户端的 IP 地址。如果服务器之前有此客户端的租约，它将尝试重新使用上次使用的 IP 地址。如果失败，它将尝试使用客户端请求的地址（如果存在）；否则，它将选择任何可用地址。

- 提供的租约期限。

- 客户端请求的或编程到服务器中以返回给客户端的任何特定于客户端的配置参数。

- 要返回给所有客户端或该客户端类中的客户端的任何常规配置参数。

- DHCP 服务器标识符选项中的服务器标识符。

- DHCPDISCOVER 消息中使用的相同事务 ID (XID)。



<u>**5.服务器探测和/或保留提供的地址（可选）**</u>
DHCP 标准规定，在向客户端发送 DHCPOFFER 之前，服务器“应该”通过向该地址发送 ICMP Echo 消息来检查该 IP 地址是否已被使用。如果进行了探测并且地址正在使用中，服务器当然不会将其提供给客户端。这可能会被管理员禁用。它被认为是 DHCP 服务器冲突检测功能的关键部分。

无论它是否探测提供的地址，服务器也可以保留该地址，以便如果客户端决定使用它，它将可用。这不是强制性的，因为正如我们将在下面看到的，该协议处理撤回提供的租约的情况。如果服务器保留地址，效率会更高，但如果 IP 地址非常短缺，这种保留可能不切实际。

<u>**6.服务器发送DHCPOFFER报文**</u>
每个服务器发送其 DHCPOFFER 消息。当然，它们可能不会全部同时发送。如前所述，消息以单播或广播方式发送。

<u>**7.客户端收集并处理DHCPOFFER报文**</u>
客户端等待 DHCPOFFER 消息到达以响应其 DHCPDISCOVER。此处客户端的确切行为取决于实现。为了方便起见，客户可能决定简单地接受它收到的第一个报价。或者，它可以选择等待一段时间来“货比三家”。然后，它可以处理每个报价并接受条款最优惠的报价——例如，租期最长的报价。

如果没有收到DHCPOFFER报文，客户端会进入重传模式，在一段时间内再次尝试发送DHCPDISCOVER。

<u>**8.客户端创建DHCPREQUEST消息**</u>
客户端为其选择的服务器提议创建 DHCPREQUEST 消息。此消息有两个目的：它告诉服务器客户已接受其报价“是的，我接受你的报价，假设它仍然可用”，并告诉其他服务器“抱歉，你的报价被拒绝了”。 （好吧，除了“抱歉”部分；服务器对拒绝的态度相当厚脸皮。J）在此消息中，客户端包含以下信息：

- DHCP Server Identifier 选项中“选择的”服务器的标识符，因此每个人都知道“谁赢了”。

- DHCP 服务器在 DHCPOFFER 消息中分配给客户端的 IP 地址，客户端将其放入 Requested IP Address DHCP 选项中作为确认。

- 它在消息中的参数请求列表选项中需要的任何其他配置参数。

**<u>9.客户端发送DHCPREQUEST报文**</u>
客户端发送 DHCPREQUEST 消息。由于它不仅适用于选定的 DHCP 服务器，而且适用于所有服务器，因此它是广播的。这样做之后，客户端转换到请求状态，等待来自所选服务器的回复。

<u>**10.服务器接收并处理DHCPREQUEST报文**</u>
每个服务器接收并处理客户端的请求消息。未被选中的服务器会将消息视为拒绝。但是，请注意，客户可能会选择一个要约，尝试请求租约，但交易不会成功完成。然后客户端可以返回并通过发送包含不同服务器标识符的 DHCPREQUEST 来尝试其“第二选择”提议。这意味着，如果服务器 A 收到一个带有服务器 B 的服务器标识符的单个 DHCPREQUEST，这并不一定意味着服务器 A 已完成事务。出于这个原因，“被拒绝”的服务器将等待一段时间，然后再向另一个客户端提供先前提供的租约。

<u>**11.服务器发送DHCPACK或DHCPNAK报文**</u>
所选服务器将看到其租约已被选择。如果它之前没有保留提供给客户端的 IP 地址，则它必须检查以确保它仍然可用。如果不是，则服务器发回 DHCPNAK（否定确认）消息，这实质上意味着“没关系，该租约不再可用”。然而，通常服务器仍将拥有该租约。它将为该客户端创建绑定，并发回 DHCPACK（确认）消息，确认租约并包含客户端的所有相关配置参数。

<u>**12.客户端接收并处理DHCPACK或DHCPNAK报文**</u>
客户端收到对其请求的肯定或否定确认。如果消息是 DHCPNAK，则客户端转换回 INIT 状态并重新开始：回到原点（步骤 #1）。如果是DHCPACK，客户端从YIAddr字段中读取IP地址，并从各个消息字段和DHCP选项中记录租约长度和其他参数。

如果客户端没有收到消息，它可能会重传 DHCPREQUEST 消息一次或多次。如果它仍然没有听到任何声音，那么它必须断定服务器出现故障并返回到步骤 #1。

<u>**13.客户端检查地址未被使用**</u>
客户端设备应执行最终检查以确保在结束租赁过程之前新地址尚未使用。这通常是通过在本地网络上生成地址解析协议 (ARP) 请求来完成的，以查看是否有任何其他设备认为它已经拥有该客户端刚刚租用的 IP 地址。如果另一个设备响应，客户端将 DHCPDECLINE 消息发送回服务器，这基本上意味着“嘿服务器，你搞砸了，有人已经在使用该地址”。然后，您猜对了，客户返回到第 1 步并重新开始。

<u>**14.客户完成租赁分配**</u>
假设该地址尚未被使用，客户端完成租约并转换到 BOUND 状态。它还设置了它的两个租约计时器，T1 和 T2。现在可以正常运行了。

<u>**处理丢失消息或分配过程失败**</u>

您可以在该描述中看到，可能会出现多种情况，需要客户端重新传输消息。这是因为 DHCP 使用不可靠的 UDP，可能会导致消息丢失。如果重传不能解决问题，例如没有从服务器接收到 DHCPOFFER 或 DHCPACK，客户端可能不得不从头开始分配过程。客户端必须包含足够的“智能”以防止它在可能没有意义的情况下永远尝试获得租约——例如，如果网络上没有 DHCP 服务器，则重新传输的次数将无济于事。

因此，在多次重试之后，客户端将放弃并且分配过程将失败。如果客户端配置为使用自动专用 IP 寻址功能，这就是它用于为客户端提供默认地址的地方。否则，客户就会“死在水里”。

**关键概念：**DHCP 中最重要的配置过程是租约分配过程，客户端使用它来获取租约。客户端广播请求以确定是否有任何 DHCP 服务器可以听到它。每个愿意授予客户端租约的 DHCP 服务器都会向其发送一个要约。客户端选择它喜欢的租约，并向所有服务器发送一个响应，告诉它们它的选择。选定的服务器然后向客户端发送其租用信息。



###### 3.1.3.3-5 DHCP 租约重新分配过程（部分：1 2）

当DHCP客户端第一次启动时没有租约，它从INIT（初始化）状态开始，经过上一主题描述的分配过程获得租约。当租约结束时使用相同的过程，如果租约更新失败，或者某些错误或其他事件导致客户端需要新的租约。

<u>**重新分配的情况**</u>
在某些情况下，客户端启动时仍然有租约。在这种情况下，客户端不需要完成获取 IP 地址分配和新租约设置的整个过程。相反，它只是尝试通过我称之为重新分配的过程重新建立其现有租约。

客户端执行重新分配而不是分配的主要情况有两种：

- Power On With Existing Lease：客户租约的持续时间从几分钟到几年不等；这完全是管理员为网络和客户端设置的租约长度策略的问题。许多（如果不是大多数的话）客户端机器并不是每天 24 小时都连接到网络；它们白天打开，晚上关闭，周末也关闭。一个租约很短的客户端被关闭然后又重新启动时可能会发现它的租约已经过期，并且必须获得一个新的租约。但是，如果租期超过几天，当客户端再次启动时它可能仍然有效。

- 重新启动：客户端有时也会重新启动，以安装新软件或更正问题。在这种情况下，即使租约长度很短，重新启动的客户端在启动时仍将具有有效租约。

<u>**租赁重新分配流程步骤**</u>

重新分配过程本质上是上一主题中描述的分配过程的简化版本。客户端不需要经历整个“哟呵，那里的任何服务器都想给我租约”的例程。相反，客户端会首先尝试找到为其提供租约的服务器，寻求确认租约仍然有效并且它可以恢复使用其先前分配的 IP 地址。它还收到它应该使用的参数的确认。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\dhcpreallocation.png)


​                                                                          图 264：DHCP 租约重新分配流程

租约重新分配过程包括七个步骤，大致对应于图 263 中所示的完整租约分配过程的第 8 步到第 14 步。在此示例中，最初向客户端授予租约的服务器是服务器 #2，因此通常是唯一回应的人。

 




以下步骤总结了重新分配过程，也显示在图 264 中。（请注意，我在讨论租约分配时提到的关于寻址字段、中继代理等的相同注释也适用于此）：

1.客户端创建DHCPREQUEST消息
客户端开始于 INIT-REBOOT 状态而不是 INIT 状态。它创建一个 DHCPREQUEST 消息来尝试找到一个服务器，其中包含有关其当前租约的信息。请注意，这可能是也可能不是最初授予租约的服务器；从理论上讲，负责租约的服务器可能会在客户端获得租约后的时间内发生变化。因此，与分配过程中步骤#8 中的 DHCPREQUEST 消息不同，客户端不包括 DHCP 服务器标识符选项。它确实包括以下信息：

- 它自己的硬件地址在消息的 CHAddr 字段中，以标识自己。

- 其现有租约的 IP 地址，在 Requested IP Address DHCP 选项中。请注意，此地址未放入 CIAddr 字段中。

- 一个随机交易标识符，放入 XID 字段。这用于将以后的消息标识为同一事务的一部分。


- 它想要的任何其他配置参数，在消息的参数请求列表选项中。

2.客户端发送DHCPREQUEST报文
客户端广播 DHCPREQUEST 消息。然后它转换到 REBOOTING 状态，等待服务器的回复。

3. 服务器接收并处理 DHCPREQUEST 消息并生成回复
网络上的每个服务器接收并处理客户端的请求。服务器在其数据库中查找客户端，试图找到有关租约的信息。然后每个服务器决定如何回复客户端：

- Server Has Valid Client Lease Information：服务器有关于客户端租约的信息。它发送 DHCPACK 消息以确认租约。它还将重申客户端应该使用的任何参数。

- Server Determines Client Lease Is Invalid：服务器确定客户端的租约不再有效。发生这种情况的常见原因是客户端在移动到不同的网络后或至少实际上已经过期后试图确认租约。在这种情况下，服务器会发送一条 DHCPNAK 消息来否定租用请求。

- Server Has No Definitive Information About Client Lease：没有关于租约信息的服务器不响应。还要求服务器不响应，除非它的信息被保证是准确的。因此，例如，如果服务器知道旧的过期租约，它不能假定租约不再有效并发送 DHCPNAK，除非它也确定没有其他服务器对该客户端有更新的有效租约.

4.服务器发送回复
将要响应客户端的 DHCPREQUEST 的服务器发送它们的 DHCPACK 或 DHCPNAK 消息。

5.客户端接收并处理DHCPACK或DHCPNAK报文
客户端等待一段时间以获得对其请求的回复。同样，存在三种与上一步中的三种匹配的可能性：

- Positive Acknowledgement：客户端收到DHCPACK报文；这证实了租约的有效性。客户端将准备再次开始使用租约，并继续下面的下一步。

- Negative Acknowledgment：该消息是 DHCPNAK，它告诉客户端其租约不再有效。客户端转换回 INIT 状态以获得新的租约——分配过程中的第 1 步。

- 无回复：如果客户端根本没有收到回复，它可能会重传 DHCPREQUEST 消息。如果一段时间后没有收到回复，它会断定没有服务器有关于其租约的信息，并会返回到 INIT 状态，尝试获得新的租约。



6.客户端检查地址未被使用
在恢复使用其租约之前，客户端设备应执行最终检查以确保新地址尚未被使用。即使当租约已经存在时不应该出现这种情况，但无论如何都会这样做，作为某种“安全措施”。检查与分配过程的第 13 步中描述的相同：在本地网络上发出 ARP 请求，以查看是否有任何其他设备认为它已经拥有该客户端刚刚租用的 IP 地址。如果另一台设备响应，则客户端向服务器发回一条 DHCPDECLINE 消息，告诉它租约无效，因为其他设备正在使用该地址。客户端然后返回到 INIT 状态以获得新的租约。

7.客户完成租赁分配
假设该地址尚未被使用，客户端完成租约并转换到 BOUND 状态。现在可以正常运行了。

**关键概念：**如果客户端启动并且已经有租约，则不需要经历完整的租约分配过程；相反，它可以使用更短的重新分配过程。客户端广播请求以查找具有当前租约信息的服务器；该服务器响应以确认客户端的租约仍然有效。



###### 3.1.3.3-6 DHCP 租约续订和重新绑定过程（部分：1 2 3）

一旦 DHCP 客户端完成分配或重新分配过程，它就会进入 BOUND 状态。客户端现在处于常规操作模式，具有从 DHCP 服务器接收到的有效 IP 地址和其他配置参数，并且可以像任何常规 TCP/IP 主机一样使用。

当客户端处于 BOUND 状态时，DHCP 基本上处于休眠状态。只要客户端保持正常运行，在此状态下就不会发生真正的 DHCP 活动。导致 DHCP“唤醒”并再次激活的最常见情况是租约续订时间到了。续订确保租约永久有效，因此可以长期使用，并涉及其自己的消息交换过程。 （客户端离开 BOUND 状态的另一种方式是提前终止租约。）

如果使用 DHCP 的自动分配，或者如果使用无限租期的动态分配，客户端的租约将永远不会到期，因此永远不需要续订。如果没有提前终止，设备将永远保持在 BOUND 状态，或者至少直到它重新启动。然而，正如我们已经讨论过的，大多数租约本质上都是有限的。客户端必须采取行动以确保延长其租约并继续正常操作。

为了管理租约延长过程，在分配租约时设置了两个计时器。续订计时器 (T1) 关闭以告诉客户端是时候尝试与最初授予它的服务器续订租约了。如果客户端未成功与该服务器续订，则重新绑定计时器 (T2) 会关闭，并告诉它尝试任何服务器来延长租约。如果续租或重新租约，客户端将恢复正常操作。如果不能反弹，它将到期，客户将需要寻求新的租约。

<u>**租约续订/重新绑定流程步骤**</u>

以下步骤总结了更新/重新绑定过程。显然，客户端采取的确切操作顺序取决于它尝试联系服务器时发生的情况；例如，如果更新成功，则永远不需要尝试重新绑定。图 265 中说明了更新和重新绑定的示例。另请注意，我在分配过程主题中提到的关于寻址字段、中继代理等的相同注释也适用于此处。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\dhcpreallocation.png)




​                                                                 图 265：DHCP 租约续订和重新绑定流程

此图显示了一个客户端的示例，该客户端当前持有与服务器 #2 的租约，试图联系它以续订租约。但是，在这种情况下，服务器 #2 已停机进行维护。服务器无法响应，客户端仍然停留在续订/重新绑定过程中的第 2 步。它一直向服务器 #2 发送 DHCPREQUEST 消息，直到其 T2 计时器到期。然后它进入重新绑定状态并广播 DHCPREQUEST 消息，服务器 #1 听到该消息，在这种情况下同意延长其当前租约。

 


1.更新定时器（T1）到期
续订计时器 T1 默认设置为租约长度的 50%。当计时器关闭时，客户端从 BOUND 状态转换为 RENEWING 状态。

请注意，如果需要，客户端可以在 T1 计时器到期之前启动租约更新。

2.客户端发送DHCPREQUEST更新报文
客户端创建一个 DHCPREQUEST 消息来标识自己及其租约。然后它将消息直接传输到最初授予租约的服务器，单播。请注意，这与分配/重新分配过程中使用的 DHCPREQUEST 消息不同，在分配/重新分配过程中，DHCPREQUEST 是广播的。客户端可能会请求特定的新租约长度，就像它可能会在分配期间在其请求中请求租约长度一样，但与往常一样，服务器对租约长度进行最终调用。

3.服务器接收并处理DHCPREQUEST报文并创建回复
假设服务器可达，它将接收并处理客户端的续订请求。有两种可能的响应：

- Server Agrees To Renew Client Lease：服务器决定可以续订客户端的租约。它准备向客户端发送 DHCPACK 消息以确认租约的续订，指示新的租约长度以及自租约创建或上次续订以来可能已更改的任何参数。

- 服务器拒绝续订客户端租约：服务器出于任何原因决定不续订客户端的租约。它将创建一条 DHCPNAK 消息。

4.服务器发送回复
服务器将 DHCPACK 或 DHCPNAK 消息发送回客户端。

5.客户端接收并处理服务器回复
客户端采取适当的操作来响应服务器的回复：

- 肯定确认：客户端收到 DHCPACK 消息，续租。客户端记下新的租约到期时间和服务器发送的任何更改的参数，重置 T1 和 T2 计时器，然后转换回 BOUND 状态。请注意，客户端在续订时不需要进行 ARP IP 地址检查。

- Negative Acknowledgment：消息是一个DHCPNAK，它告诉客户端它的租约更新请求被拒绝了。客户端将立即转换到 INIT 状态以获得新的租约——分配过程中的第 1 步。



6.重新绑定定时器 (T2) 到期
如果客户端没有收到服务器的回复，它会保持RENEWING状态，并定期向服务器重传单播DHCPREQUEST。在这段时间内，从用户的角度来看，客户端仍然在正常运行。如果没有收到来自服务器的响应，最终重新绑定计时器 (T2) 将到期。这将导致客户端转换到 REBINDING 状态。回想一下，默认情况下，T2 计时器设置为租约长度的 87.5%（7/8）。

7.客户端发送DHCPREQUEST重新绑定消息
没有收到最初授予租约的服务器的响应，客户端“放弃”该服务器并尝试联系可能能够延长其现有租约的任何服务器。它创建一个 DHCPREQUEST 消息并将其 IP 地址放入 CIAddr 字段，清楚地表明它目前拥有该地址。然后它在本地网络上广播请求。

8、服务器接收并处理DHCPREQUEST报文并发送回复
每个服务器收到请求，并根据它为客户端提供的信息进行响应（没有租约信息或可能具有过时信息的服务器不响应）：

- 服务器同意重新绑定客户端租约：服务器有关于客户端租约的信息并同意延长它。它为客户端准备 DHCPACK 消息以确认租约的续订，指示自租约创建或上次续订以来可能已更改的任何参数。

- Server Decides Client Cannot Extend Its Current Lease：服务器确定无论出于何种原因，不应延长此客户端的租约。它准备好向客户端发送回 DHCPNAK 消息。

9.服务器发送回复
每个响应客户端的服务器都发送其 DHCPACK 或 DHCPNAK 消息。

10.客户端收到服务器回复
客户端针对上一步中的两种可能性采取适当的操作：

- 肯定确认：客户端收到 DHCPACK 消息，重新绑定租约。客户端记下现在负责此租约的服务器、新的租约到期时间以及服务器发送的任何更改的参数。它重置 T1 和 T2 定时器，并转换回 BOUND 状态。 （它也可能像在常规租约分配期间那样探测新地址。）

- Negative Acknowledgement：该消息是 DHCPNAK，它告诉客户端某些服务器已确定不应延长租约。客户端立即转换到 INIT 状态以获得新的租约——分配过程中的第 1 步。

11.租约到期
如果客户端没有收到对其广播重新绑定请求的响应，它将在 RENEWING 状态下定期重传请求。如果在租约到期时没有收到响应，它会转换到 INIT 状态以获得新的租约。

<u>**两步重新绑定/更新过程的目的**</u>

一个有效的问题是：为什么要费心进行两步过程，即重新绑定和更新？原因是这提供了效率和灵活性的最佳结合。我们首先尝试使用单播请求联系授予租约的服务器，以避免占用其他 DHCP 服务器的时间并通过广播流量扰乱整个网络。通常这会起作用，因为 DHCP 服务器不会经常更改并且通常会一直保持打开状态。如果失败了，我们就会退回到广播，让其他服务器有机会接管客户端的现有租约。

**关键概念：**每个客户端的租约都有一个与其相关联的更新计时器 (T1)，通常设置为租约长度的 50%，以及一个重新绑定计时器 (T2)，通常为租约长度的 87.5%。当 T1 计时器关闭时，客户端将尝试通过联系最初授予它的服务器来续订租约。如果客户端在 T2 计时器到期时无法续订租约，它将向任何可用的服务器广播重新绑定请求。如果租约在租约到期时没有续订或重新租用，则客户端必须重新开始租约分配过程。



###### 3.1.3.3-7 DHCP 提前终止租约（释放）流程

如果没有 IP 地址，TCP/IP 主机实际上不能做很多事情；它是 Internet 协议的基本组成部分，所有 TCP/IP 协议和应用程序都在其上运行。当主机拥有手动 IP 地址分配或“无限”租约时，它显然永远不必担心丢失其 IP 地址。当一台主机有一个有限的 DHCP 租约时，它将使用更新/重新绑定过程来尝试尽可能长时间地“挂在”其现有的 IP 地址上。

因此，在正常情况下，客户将继续尝试无限期地延长其现有租约。然而，在某些情况下，房东可能会决定终止其租约。这通常不会是客户自发决定做的事情；它将响应用户终止租约的特定请求而发生。用户可能出于多种原因终止租约，其中包括：

- 客户端正在移动到不同的网络；

- 网络正在重新编号其 IP 地址；

- 用户希望主机与不同的服务器协商新的租约；

- 用户想要重置租约以解决某种问题。

在任何这些情况下，用户都可以通过称为提前终止租约或解除租约的流程来结束租约。这是一种非常简单的单向通信。客户端向持有其当前租约的服务器发送一个特殊的 DHCPRELEASE 消息单播，告诉它不再需要该租约。服务器然后记录租约已经结束。它不需要回复客户端。

客户端可以假设租约终止成功的原因是这不是 DHCP 协议的强制性部分。让客户端发送 DHCPRELEASE 以结束租约被认为是一种礼貌，而不是一种要求。让客户端在不再需要租约时通知服务器会更有效，这也允许更快地重用已终止租约中的 IP 地址。但是，DHCP 服务器旨在处理客户端“消失”而没有正式终止现有租约的情况。



###### 3.1.3.3-8 非DHCP地址客户端的DHCP参数配置流程（部分：1 2）

大多数 DHCP 客户端使用该协议来获取 IP 地址和其他配置参数。这就是为什么这么多的 DHCP 都是围绕地址分配和租用的。传统的 DHCP 客户端在获取 IP 地址的同时获取其所有配置参数，使用我们在本节前面的主题中看到的消息交换和过程。

<u>**不同参数配置过程的动机**</u>
但是，在某些情况下，使用 DHCP 以外的方法分配 IP 地址的设备仍然希望使用 DHCP 服务器来获取其他配置参数。这样做的主要优点是管理方便；它允许具有静态 IP 地址的设备仍然能够像常规 DHCP 客户端一样自动获取其他参数。

具有讽刺意味的是，可以使用此功能的一种常见情况是……自行配置 DHCP 服务器！管理员通常不使用 DHCP 向 DHCP 服务器提供 IP 地址，但他们可能希望使用它来告知服务器其他参数。在这种情况下，请求参数的服务器实际上充当客户端，目的是与另一台服务器进行交换。

最初的 DHCP 标准没有为这种非 IP 配置的发生提供任何机制。 RFC 2131 修订了该协议，添加了一种新的消息类型 (DHCPINFORM)，允许设备请求配置参数而无需经过完整的租赁过程。此消息用作简单双向通信的一部分，与我们目前所见的租赁通信不同。由于它不涉及 IP 地址分配，因此它不是租约“生命周期”的一部分，也不是 DHCP 客户端有限状态机的一部分。

<u>**参数配置流程步骤**</u>

以下步骤显示具有外部配置地址的设备如何使用 DHCP 获取其他参数（另请参见图 266）。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\dhcpinform.png)


​                                                                               **图266：DHCP参数配置流程**

已经拥有 IP 地址的设备可以使用上面显示的简单请求/回复交换从 DHCP 服务器获取其他配置参数。在本例中，我展示了客户端广播其请求。


1.客户端创建DHCPINFORM消息
客户端（同样可能是充当客户端的 DHCP 服务器）创建 DHCPINFORM 消息。它在 CIAddr 字段中填写自己的 IP 地址，因为该 IP 地址是最新且有效的。它可以使用参数请求列表选项请求特定参数，或者简单地接受服务器提供的默认值。

2.客户端发送DHCPINFORM报文
客户端发送 DHCPINFORM 消息单播，如果它知道 DHCP 服务器的身份和地址，否则，它广播它。

3、服务器接收并处理DHCPINFORM报文
消息由一个或多个 DHCP 服务器接收和处理（如果有多个并且请求是广播的）。每个服务器检查它的数据库中是否有客户端需要的参数。

4.服务器创建 DHCPACK 消息
每个具有客户端所需信息的服务器都会创建一个 DHCPACK 消息，其中在适当的 DHCP 选项字段中包含所需的参数。 （通常这只是一个服务器。）

5.服务器发送DHCPACK报文
服务器将消息单播发送回客户端。

6.客户端接收并处理DHCPACK报文
客户端收到服务器发送的DHCPACK报文，对其进行处理，并据此设置自己的参数。

处理配置过程失败
如果客户端没有收到对其 DHCPINFORM 消息的回复，它将定期重传。重试期后，它将放弃并使用默认配置值。它通常还会生成错误报告，以将问题通知管理员或用户。

**关键概念：**不使用 DHCP 获取 IP 地址的设备仍然可以利用其其他配置功能。客户端可以广播 DHCPINFORM 消息以请求任何可用的服务器向它发送关于如何使用网络的参数。 DHCP 服务器以请求的参数和/或默认参数响应，这些参数在 DHCPACK 消息的 DHCP 选项中携带。



###### 3.1.3.4 DHCP 消息、消息类型和格式

有关 DHCP 配置和操作的主题通过展示完成各种租赁和信息交换活动的过程来展示 DHCP 的工作原理。所有这些过程都严重依赖于客户端和服务器之间的信息交换，这些信息在 DHCP 消息中进行。与所有协议一样，DHCP 使用特殊的消息格式和一组规则来管理消息的创建、寻址和传输方式。

在本节中，我提供了 DHCP 如何创建和发送消息的详细信息，并展示了用于 DHCP 消息和选项的格式。我首先描述 DHCP 如何创建、寻址和传输消息，以及它如何处理消息重传。然后我概述了 DHCP 通用消息格式，展示了它与它所基于的 BOOTP 消息格式的相似之处以及不同之处。我描述了 DHCP 选项、用于它们的格式以及用于提高效率的特殊选项“重载”功能。我以 DHCP 选项的完整列表结束本节。

**相关信息：**DHCP 在消息传递领域与 BOOTP 的关系最为密切，因此您会在本节中找到很多对 BOOTP 的引用。请特别注意，DHCP 选项紧密地基于 BOOTP 供应商扩展，并且许多特定的 DHCP 选项类型与 BOOTP 供应商信息字段相同。为避免重复，本节中的摘要表列出了两种协议的选项/扩展，指出哪些被 BOOTP 和 DHCP 使用，哪些仅被 DHCP 使用。




###### 3.1.3.4-1 DHCP 消息生成、寻址、传输和重传（部分：1 2 3）

在上一节中，我们广泛研究了 DHCP 的操作及其客户端/服务器性质。几乎协议操作的每个方面都围绕着客户端设备与服务器交换信息的概念。我们还可以在 DHCP 消息传递的所有主要特征中看到这一点。这包括 DHCP 消息的格式，以及 DHCP 消息如何创建、寻址和传输以及在必要时重新传输的细节。

<u>**消息生成和通用格式**</u>
DHCP 消息传递在许多方面类似于 BOOTP，后者是 DHCP 所基于的协议。 BOOTP 只定义了两种消息类型，请求和回复。 DHCP 当然要复杂得多，它使用大约八种不同类型的消息，但这些消息仍被归类为请求或回复消息，具体取决于发送消息的人和发送原因。 DHCP 使用特殊的 DHCP 消息类型选项来指示确切的 DHCP 消息类型，但仍然将来自客户端的消息视为请求信息，并将来自服务器的包含信息的响应视为回复。

客户端使用与 BOOTP 消息格式非常相似的通用 DHCP 消息格式生成消息。当服务器回复客户端消息时，它不会将回复生成为全新的消息，而是复制客户端请求，适当更改字段，然后将回复发送回客户端。一个特殊的事务标识符 (XID) 被放置在请求中并在回复中维护，它允许客户端知道哪个回复与特定请求相关。

<u>**消息传输**</u>
DHCP 与 BOOTP 一样使用 UDP 进行传输，并且出于相同的原因：简单性和对广播的支持。它也有许多与我们在 BOOTP 消息传递和寻址主题中讨论的相同的寻址问题。客户端通常会在本地网络上通过广播发送请求，以允许它们联系任何可用的 DHCP 服务器。例外情况是当客户端试图与它已知的服务器续订租约时。为了与 BOOTP 兼容，DHCP 使用相同的众所周知的（保留的）UDP 端口号 67 来处理客户端对服务器的请求。

<u>**使用广播和第二层消息传递**</u>

某些 DHCP 消息交换需要服务器响应具有有效和活动 IP 地址的客户端。一个示例是为回复 DHCPINFORM 请求而发送的 DHCPACK。在这种情况下，服务器总是可以向客户端发送回复单播。然而，其他消息交换呈现出与我们在 BOOTP 中看到的相同的“先有鸡还是先有蛋”的难题：如果客户端使用 DHCP 获取 IP 地址，我们不能假设该 IP 地址可用于我们发送请求回复。

在 BOOTP 中，针对这种情况有两种具体的解决方案：第一，服务器也可以使用广播寻址来发回它的回复；其次，服务器可以直接向第二层的主机发回回复。由于与广播相关的性能问题，DHCP 尝试使后一种方法成为服务器回复的默认方法。它假定客户端的 TCP/IP 软件能够接受和处理在第二层传送的 IP 数据报，甚至在 IP 堆栈初始化之前。

正如标准本身所说，“DHCP 需要创造性地使用客户端的 TCP/IP 软件和对 RFC 1122 的自由解释”。 RFC 1122 是描述 TCP/IP 主机的详细实现要求的关键标准。然而，DHCP 标准承认并非所有设备都支持此行为这一事实。它允许客户端强制服务器使用广播发回回复。这是通过客户端在其请求中将特殊广播 (B) 标志设置为 1 来完成的。

由于 DHCP 与 BOOTP 一样，必须使用第二层传送或第三层广播来进行服务器回复，因此它需要一个单独的众所周知的端口号供服务器发送。同样，为了与 BOOTP 兼容，使用相同的端口号 68。无论服务器回复是单播还是广播发送，都使用此端口号。

**关键概念：**来自 BOOTP 客户端的请求通常以广播方式发送，以到达任何可用的 DHCP 服务器。但是，也有某些例外情况，例如在续租时，当请求直接发送到已知服务器时。 DHCP 服务器可以发送它们的回复，或者广播到为 DHCP 客户端保留的特殊端口号，或者使用第二层单播。 DHCP 标准指定应尽可能使用第二层传送以避免不必要的广播流量。

<u>**丢失消息的重传**</u>

使用 UDP 为 DHCP 提供了诸如简单和高效等好处，但由于 UDP 不可靠，因此无法保证消息一定会到达目的地。这可能会导致客户方面的潜在混淆。例如，考虑客户端发送 DHCPDISCOVER 消息并等待 DHCPOFFER 消息作为回复。如果它没有得到响应，这是否意味着没有 DHCP 服务器愿意为其提供服务，或者只是它的 DHCPDISCOVER 在网络的某个地方被“吞噬”了？这同样适用于大多数其他请求/回复序列，例如客户端等待 DHCPACK 或 DHCPNAK 以回复 DHCPREQUEST 或 DHCPINFORM。

消息可能丢失的事实意味着 DHCP 本身必须跟踪发送的消息，如果没有响应，则重新传输它们。由于 DHCP 中有如此多的消息交换，因此“出错”的可能性要大得多。与在 BOOTP 中一样，DHCP 将此责任完全放在客户端的肩上。这是有道理的，因为客户端发起联系并且可以最容易地跟踪发送的消息并在需要时重新传输它们。服务器无法知道客户端的请求何时丢失，但客户端可以对服务器的回复丢失作出反应。

在任何请求/回复消息交换中，客户端使用一个重传计时器，该计时器设置了一个时间段，表示它等待响应的合理时间。如果在计时器到期时没有收到回复，则客户端假定其请求或返回的响应丢失。客户端然后重新传输请求。如果这个请求再次没有得到回复，客户端将继续重传一段时间。

为了防止大量 DHCP 客户端同时重新传输请求（这可能会阻塞网络），客户端必须使用随机指数退避算法来确定何时进行重新传输。与 BOOTP 一样，这类似于以太网中用于从冲突中恢复的技术。 DHCP 标准指定延迟应基于客户端和服务器之间的底层网络速度。更具体地说，它表示在标准以太网网络中，第一次重传应延迟 4 秒加上或减去 0 到 1 秒之间的随机值——换句话说，在 3 到 5 秒之间选择某个值。然后，每次后续传输（7 到 9 秒，然后 15 到 17 秒，依此类推）延迟加倍，最多可达 64 +/- 1 秒。

为了防止它无休止地重试，客户端通常具有限制重试次数的逻辑。重传的时间长短取决于发送的请求类型；也就是说，正在进行什么过程。如果客户端由于重试次数过多而被迫“放弃”，它通常会采取某种默认操作或生成错误消息。

**关键概念：**与 BOOTP 一样，DHCP 使用不提供可靠性功能的 UDP 进行传输。 DHCP 客户端必须检测何时发送了请求并且没有收到响应，并定期重新传输请求。特殊逻辑用于防止客户端在困难的网络条件下发送过多的请求。



###### 3.1.3.4-2 DHCP 消息格式

创建 DHCP 时，它的开发人员遇到了一些与他们应该如何精确地构造 DHCP 消息有关的问题。 BOOTP 已经被广泛使用，保持 DHCP 和 BOOTP 之间的兼容性是一个重要目标。这意味着 DHCP 的设计者需要继续使用现有的 BOOTP 消息格式。然而，DHCP 比 BOOTP 具有更多的功能，这意味着比有限的 BOOTP 消息格式更容易保存的信息更多。

这个明显的矛盾以两种方式得到解决。首先，为基本功能保留了现有的 BOOTP 消息格式，但 DHCP 客户端和服务器被编程为以稍微不同的方式使用 BOOTP 消息字段。其次，BOOTP 供应商扩展被正式化并成为 DHCP 选项，正如我们将在接下来的两个主题中看到的那样。尽管名称为“选项”，但其中一些实际上是基本 DHCP 功能所需的附加字段，并且是强制性的。杰

通过这种双重方法，DHCP 设备可以访问它们需要的额外信息。同时，基本字段格式不变，这允许 DHCP 服务器与较旧的 BOOTP 客户端通信，忽略与它们无关的额外 DHCP 信息。有关更多信息，请参阅有关 BOOTP/DHCP 互操作性的主题。

表 189 描述了 DHCP 报文的格式，如图 267 所示。在表中，我特别指出了哪些字段在 DHCP 中的使用方式与它们在 BOOTP 中的使用方式类似，哪些有明显的不同。

​                                                                            **表 189：DHCP 消息格式**

| **Field Name** | **Size (bytes)** | **Description**                                              |
| -------------- | ---------------- | ------------------------------------------------------------ |
| ***Op\***      | 1                | ***Operation Code:\*** 操作代码：指定消息的一般类型。值 1 表示请求消息，而值 2 表示回复消息。 此代码表示 DHCP 消息的一般类别；向服务器发送请求的客户端使用 Op 代码 1，而服务器回复使用代码 2。因此，例如，DHCPREQUEST 将是一个请求，而 DHCPACK 或 DHCPNAK 是一个回复。实际特定类型的 DHCP 消息使用 DHCP 消息类型选项进行编码。 |
| ***HType\***   | 1                | ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\aa20cf0f.png) |
| ***HLen\***    | 1                | ***Hardware Address Length:\*** 硬件地址长度：指定硬件地址在此消息中的长度。对于以太网或其他使用 IEEE 802 MAC 地址的网络，该值为 6。这也与 ARP 字段格式 HLN 中的一个字段相同。 |
| ***Hops\***    | 1                | ***Hops:\*** 跳数：在传输请求之前由客户端设置为 0，中继代理使用它来控制 BOOTP 和/或 DHCP 消息的转发。 |
| ***XID\***     | 4                | ***Transaction Identifier:\*** Transaction Identifier：客户端生成的 32 位标识字段，用于将请求与从 DHCP 服务器收到的回复相匹配。 |
| ***Secs\***    | 2                | ***Seconds:\*** 秒：在 BOOTP 中，这个字段定义模糊，并不总是被使用。对于 DHCP，它被定义为自客户端开始尝试获取或续订租约以来经过的秒数。当多个客户端请求未完成时，繁忙的 DHCP 服务器可能会使用它来确定回复的优先级。 |
| ***Flags\***   | 2                | ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\aa20cf6b.png) |
| ***CIAddr\***  | 4                | ***Client IP Address:\***Client IP Address：当且仅当它在 BOUND、RENEWING 或 REBINDING 状态下有一个有效的 IP 地址时，客户端将自己当前的 IP 地址放在这个字段中；否则，将该字段设置为0。客户端只能在其地址实际有效可用时使用该字段，而不是在获取地址的过程中。具体来说，客户端不使用此字段来请求租约中的特定 IP 地址；它使用 Requested IP Address DHCP 选项。 |
| ***YIAddr\***  | 4                | ***“Your” IP Address:\*** “您的”IP 地址：服务器分配给客户端的 IP 地址。 |
| ***SIAddr\***  | 4                | ***Server IP Address:\*** 服务器 IP 地址：此字段的含义在 DHCP 中略有变化。在BOOTP中，是发送BOOTREPLY报文的BOOTP服务器的IP地址。在 DHCP 中，它是客户端在引导过程的下一步中应该使用的服务器地址，它可能是也可能不是发送此回复的服务器。 发送服务器始终在服务器标识符 DHCP 选项中包含自己的 IP 地址。 |
| ***GIAddr\***  | 4                | ***Gateway IP Address:\***Gateway IP Address：这个字段就像在 BOOTP 中一样使用，当涉及 BOOTP 中继代理时路由 BOOTP 消息，以促进不同子网或网络上的客户端和服务器之间 BOOTP 请求和回复的通信。请参阅有关 DHCP 中继的主题。与 BOOTP 一样，该字段不被客户端使用，并且不代表服务器为客户端提供默认路由器的地址（这是使用 Router DHCP 选项完成的）。 |
| ***CHAddr\***  | 16               | ***Client Hardware Address:\*** Client Hardware Address：客户端的硬件（二层）地址，用于识别和通信。 |
| ***SName\***   | 64               | ***Server Name:\*** 服务器名称：发送 DHCPOFFER 或 DHCPACK 消息的服务器可以选择将其名称放在该字段中。这可以是简单的文本“昵称”或完全限定的 DNS 域名（例如“myserver.organization.org”）。 该字段也可用于携带 DHCP 选项，使用“选项过载”功能，由 DHCP 选项过载选项的值指示。 |
| ***File\***    | 128              | ***Boot Filename:\*** 引导文件名：客户端可选地使用它来请求 DHCPDISCOVER 消息中的特定类型的引导文件。由 DHCPOFFER 中的服务器使用以完全指定引导文件目录路径和文件名。 该字段也可用于携带 DHCP 选项，使用“选项过载”功能，由 DHCP 选项过载选项的值指示。 |
| ***Options\*** | Variable         | ***Options:\*** 选项：保存 DHCP 选项，包括基本 DHCP 操作所需的几个参数。请注意，此字段在 BOOTP 中固定为 64 字节长度，但在 DHCP 中长度可变。有关详细信息，请参阅接下来的两个主题。客户端和服务器都可以使用该字段。 |

 

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\dhcpformat.png)                           

​                                                       **图 267：DHCP 报文格式**

 


DHCP 标准没有指定 DHCP 消息如何封装在 UDP 中的细节。 我假设由于与 BOOTP 的其他相似之处，DHCP 保持 BOOTP 对消息校验和的可选使用。 它还很可能假设消息不会被分段（发送时 IP 数据报中的 Do Not Fragment 位设置为 1）。 这是为了让 BOOTP 客户端避免重组碎片消息的复杂性。

然而，我应该指出，与 BOOTP 的固定消息大小相比，DHCP 消息的长度是可变的。 这是通过将 BOOTP 的 64 字节 Vend 字段更改为可变长度的 Options 字段来完成的。 DHCP 比 BOOTP 更依赖选项，并且设备必须能够接受选项字段长度至少为 312 字节的消息。 SName 和 File 字段也可用于携带选项，如下一主题所述。



###### 3.1.3.4-3 DHCP 选项、选项格式和“选项重载”（部分：1 2 3 4）

最初开发 BOOTP 时，其消息格式包括一个 64 字节的 Vend 字段，称为 Vendor-Specific Area。该字段背后的想法是为协议提供灵活性。 BOOTP 标准没有定义使用该字段的任何特定方式。相反，该领域对不同类型硬件的创建者开放，可以使用它来定制 BOOTP 以满足他们的客户端和/或服务器的需要。

包括这种“未定义”字段总是一个好主意，因为它使协议易于扩展。也就是说，允许协议在未来通过定义新字段轻松增强，同时不干扰任何现有字段。然而，BOOTP Vendor-Specific Area 的问题在于可扩展性实际上是特定于供应商的。它仅对特定于单个供应商的特殊字段有用。

真正需要的是一种为通用目的、独立于供应商的参数通信定义新字段的方法，但 BOOTP 消息格式中没有字段可以让这种情况发生。解决方案以 RFC 1048 的形式出现，它定义了一种称为 BOOTP 供应商信息扩展的技术。该方法重新定义了特定于供应商的区域，以允许其在客户端和服务器之间携带通用参数。这个想法非常成功，以至于它在很大程度上取代了 Vend 字段的旧供应商特定用途。



<u>**选项和选项格式**</u>

DHCP 维护、形式化并进一步扩展了使用 Vend 字段携带通用参数的想法。这些字段现在不再称为供应商信息扩展或供应商信息字段，而是简称为 DHCP 选项。同样，Vend 字段已重命名为 Options 字段，反映了其作为一种在客户端和服务器之间传送独立于供应商的选项的方式的新角色。

为了保持 BOOTP 和 DHCP 之间的兼容性，DHCP 选项字段在大多数方面与 RFC 1048 引入的 BOOTP Vend 字段的供应商独立解释相同。该字段的前四个字节仍然带有“魔法” cookie”值“99.130.83.99”，以将信息标识为独立于供应商的选项字段。 Option 字段的其余部分由一个或多个子字段组成，每个子字段都具有 BOOTP 中的“类型、长度、值”（TLV 编码）子结构。 BOOTP 供应商信息字段和 DHCP 选项之间的主要区别在于字段名称和 DHCP 选项字段长度可变的事实，而 BOOTP Vend 字段固定为 64 字节。 DHCP Options字段的整体结构如图268所示；每个选项的子字段名称在表 190 中描述。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\dhcpoptionformat.png)


​                                                                               **图 268：DHCP 选项字段格式**

不出所料，DHCP 选项字段的格式与 BOOTP 供应商特定区域的格式非常相似，如图 257 所示。选项字段以相同的四字节“魔术饼干”开头，然后包含许多变量-length 选项字段。每个选项都具有表 190 中描述的格式。



​                                                                                     **表 190：DHCP 选项格式**

| **Subfield Name** | **Size (bytes)** | **Description**                                              |
| ----------------- | ---------------- | ------------------------------------------------------------ |
| ***Code\***       | 1                | ***Option Code:\*** 选项代码：指定选项类型的单个八位字节。   |
| ***Len\***        | 1                | ***Option Length:\*** 选项长度：此特定选项中的字节数。这不包括 Code 和 Len 字段的两个字节。 |
| ***Data\***       | Variable         | ***Option Data:\*** Option Data：发送的数据，其长度由 Len 子字段指示，并根据 Code 子字段进行解释。 |

所有 DHCP 选项都遵循表 190 的格式，除了两种特殊情况，同样与 BOOTP 相同。 当子字段需要在字边界上对齐时，代码值为 0 用作填充； 它不包含任何信息。 值 255 用于标记供应商信息字段的结尾。 这两个代码都不包含实际数据，因此为了节省空间，当使用其中一个时，只包含单个代码值； Len 和 Data 字段被省略。 看到代码值为 0 的设备只是将其作为填充符跳过； 看到代码值为 255 的设备知道它已到达此选项字段中字段的末尾。

<u>**选项类别**</u>

在 DHCP 发明之前，发布了一系列 BOOTP 标准，定义了 BOOTP 供应商信息扩展的当前列表。开发 DHCP 时，创建了一个单一标准，它合并了 BOOTP 供应商信息扩展和 DHCP 选项，因为它们基本上是相同的。其中最新的是 RFC 2132，标题为 (ta-da!) DHCP 选项和 BOOTP 供应商扩展。

RFC 2132 列出了几十个可用作 DHCP 选项或 BOOTP 供应商信息字段的字段。为了更容易“消化”，这些被分为几类。此外，还有一组字段只在 DHCP 中使用，在 BOOTP 中不使用。尽管被称为“选项”，但实际上只有一些是可选的；其他是 DHCP 基本操作所必需的。它们作为“选项”字段携带的原因只有一个：允许 DHCP 继续使用与 BOOTP 相同的基本消息格式以实现兼容性。表 191 总结了用于 DHCP 选项的类别。

​                                                                                 **表 191：DHCP 选项类别**

| **Option Category**                        | **Description**                                              |
| ------------------------------------------ | ------------------------------------------------------------ |
| ***RFC 1497 Vendor Extensions\***          | RFC 1497 中定义的 BOOTP 供应商扩展，最后一个 RFC 描述特定于 BOOTP 的供应商扩展字段（在创建 DHCP 之前）。为了便于参考，在创建 DHCP 选项时将它们保存在一个组中，即使它们所代表的某些功能可能更适合属于其他类别。 |
| ***IP Layer Parameters Per Host\***        | 控制 Internet 协议在主机上运行的参数，这些参数会影响整个主机，而不是特定于接口的。 |
| ***IP Layer Parameters Per Interface\***   | 影响主机特定接口的 Internet 协议操作的参数。 （当然，有些设备只有一个接口，而另一些则有更多。） |
| ***Link Layer Parameters Per Interface\*** | 影响主机数据链路层操作的参数，基于每个接口。                 |
| ***TCP Parameters\***                      | 影响TCP层操作的参数；在每个接口的基础上指定。                |
| ***Application and Service Parameters\***  | 用于配置或控制各种杂项应用程序或服务的操作的参数。           |
| ***DHCP Extensions\***                     | 特定于 DHCP 的参数，用于控制 DHCP 协议本身的操作。           |

下一个主题提供了 RFC 2132 中定义的 DHCP 选项的完整列表。由于 DHCP 的普及，自该标准发布以来已经定义了其他几个选项。每次创建新选项时，记录它都需要 RFC 2132 的新继任者，这会造成混乱和耗时。相反，这些选项/扩展的维护已从 RFC 流程转移到由 IANA 维护的一组文件，就像许多其他参数一样。还有一个过程，开发人员可以通过该过程请求将其他标准扩展添加到 DHCP。这在 RFC 2132 的第 10 节中进行了描述。

**关键概念：**DHCP 采用 BOOTP 的供应商信息扩展并将它们形式化为称为 DHCP 选项的官方功能。 BOOTP Vendor-Specific Area 字段成为 DHCP Options 字段，并且可以包含任意数量的参数以从服务器发送到客户端。其中一些包括一些数据，这些数据实际上是 DHCP 成功运行所必需的。有几十个 DHCP 选项，它们分为功能类别。

<u>**选项重载**</u>

由于 DHCP 比 BOOTP 更依赖于选项的使用，因此 Options 字段的大小在理论上会变得非常大。但是，由于 DHCP 使用 UDP 进行传输，因此消息的整体大小是有限的。这在理论上可能会导致消息可能用完空间并且无法携带其所有选项的情况。同时，消息格式中有两个“宽敞”的字段，SName 和 File，分别为 64 字节和 128 字节。在某些情况下甚至可能不需要这些字段，因为许多设备使用 DHCP 来获取租约和参数，而不是下载引导映像。即使需要它们，它们携带的信息也可能比其固定大小所允许的信息少得多。

为了更好地利用消息格式中的总空间，DHCP 包括一个称为选项重载的特殊功能，它允许这两个字段用于携带更多选项字段而不是它们的常规信息。使用此选项本身是通过使用 DHCP 选项 Option Overload 指示的，它告诉接收消息的设备如何解释这两个字段。如果使用选项重载，则在解析 Option 字段中的所有选项后，将以与 Options 字段相同的方式读取和解释 SName 和/或 File 字段。如果消息确实需要携带服务器名称或引导文件，这些将作为单独的选项（分别为编号 66 和编号 67）包含在内，它们是可变长度的，因此可以精确地设置为所需的长度。同样，请参阅下一个主题以了解详细信息。

**关键概念：**由于 DHCP 消息可以包含如此多的选项，因此创建了一个称为选项重载的特殊功能。启用后，重载允许选项使用 DHCP 消息格式中的大 SName 和 File 字段作为选项。

<u>**结合供应商独立信息和供应商特定信息**</u>
顺便说一下，DHCP 的创建者确实认识到，尽管与供应商无关的选项很重要，但供应商可能希望能够像原始 BOOTP 定义的那样发送特定于供应商的信息。为此，他们创建了一个名为 Vendor Specific Information 的 DHCP 选项。此选项允许供应商将一组特定于供应商的选项字段封装在正常的 DHCP 选项结构中。

本质上，您可以将此视为在单个 DHCP 选项中嵌套传统 BOOTP Vend 字段（可变长度）的一种方式。可以同时携带其他 DHCP 选项，但受总体消息长度限制。请注意，这补充了一个已经存在的 BOOTP 选项，该选项允许引用包含供应商特定信息的文件。





###### 3.1.3.4-4 DHCP 选项/BOOTP 供应商信息字段摘要（部分：1 2 3 4 5 6）

BOOTP 供应商信息字段用于承载附加的独立于供应商的配置参数。这些被用作 DHCP 选项的基础，它扩展了概念以包括用于管理 DHCP 作为一个整体的操作的参数，如上一主题中所述。由于 BOOTP 供应商信息字段和 DHCP 选项在本质上是相同的（除了特定于 DHCP 的字段），因此它们在相同的 TCP/IP 标准中进行了描述，因此在本指南主题中进行了描述。

下面我包含了一些表格，按 RFC 2132 选项类别组织，列出了每个 DHCP 选项/BOOTP 供应商信息字段。我已经显示了每个选项的代码值，以及该选项的数据子字段的长度（以字节为单位）。然后我提供了该选项的正式名称及其使用方法的简要说明。为简单起见，在下表中我只说“选项”；请将“选项”阅读为“选项/供应商信息字段”，因为它们是相同的（同样，DHCP 特定选项除外。）

这些表中有很多选项，其中一些定义了我可能不会在本指南中涵盖的有些晦涩的协议使用的参数，所以如果简短描述不足以让您完全理解，请不要推迟了解如何使用每个选项。根据本指南中的其他讨论，其他选项对您来说似乎非常熟悉。请特别注意，许多用于传达特定类型服务器地址的原始 BOOTP 供应商信息字段现在已经过时，可能不再使用。

<u>**RFC 1497 供应商扩展**</u>

表 192 显示了最初在 RFC 1497 中定义的 DHCP/BOOTP 选项。


​                                                 **表 192：DHCP/BOOTP 选项：RFC 1497 供应商扩展**

| **Code Value** | **Data Length (bytes)**  | **Name and Description**                                     |
| -------------- | ------------------------ | ------------------------------------------------------------ |
| **0**          | 0                        | ***Pad:\***填充：用作“填充符”的单个字节，用于在字（双字节）边界上对齐后续字段。不包含任何信息。两个选项之一，长度为单字节，没有数据子字段（另一个是下面的 End 选项。） |
| **1**          | 4                        | ***Subnet Mask:\*** 子网掩码：提供给客户端在当前网络上使用的 32 位子网掩码。如果两者都存在，则必须出现在路由器选项之前的选项列表中。 |
| **2**          | 4                        | ***Time Offset:\*** 时间偏移量：指定客户端子网与协调世界时（UTC，以前称为格林威治标准时间或 GMT）的时间偏移量（以秒为单位）。正值表示本初子午线以东的区域（在英国），负值表示以西的区域。本质上，这用于指示子网的时区。 |
| **3**          | Variable (Multiple of 4) | ***Router:\*** 路由器：指定供客户端在本地网络上使用的 32 位路由器地址列表。路由器按照客户端使用的优先顺序列出。 |
| **4**          | Variable (Multiple of 4) | ***Time Server:\*** 时间服务器：指定客户端在本地网络上使用的时间服务器地址列表（根据 RFC 868）。服务器按客户端使用的优先顺序列出。 |
| **5**          | Variable (Multiple of 4) | ***IEN-116 Name Server:\*** IEN-116 名称服务器：指定 IEN-116 名称服务器地址列表，供客户端在本地网络上使用。服务器按客户端使用的优先顺序列出。请注意，此选项不用于 DNS 名称服务器；见下文。 |
| **6**          | Variable (Multiple of 4) | ***DNS Name Server:\***DNS 名称服务器：指定供客户端在本地网络上使用的 DNS 名称服务器地址列表。服务器按客户端使用的优先顺序列出。 |
| **7**          | Variable (Multiple of 4) | ***Log Server:\*** 日志服务器：指定 MIT-LCS UDP 日志服务器地址列表，供客户端在本地网络上使用。服务器按客户端使用的优先顺序列出。 |
| **8**          | Variable (Multiple of 4) | ***Cookie Server:\*** Cookie 服务器：指定 RFC 865“cookie”服务器地址列表，供客户端在本地网络上使用。服务器按客户端使用的优先顺序列出。 |
| **9**          | Variable (Multiple of 4) | ***LPR Server:\*** LPR 服务器：指定 RFC 1179 行式打印机服务器地址列表，供客户端在本地网络上使用。服务器按客户端使用的优先顺序列出。 |
| **10**         | Variable (Multiple of 4) | ***Impress Server:\*** Impress 服务器：指定客户端在本地网络上使用的 Imagen Impress 服务器地址列表。服务器按客户端使用的优先顺序列出。 |
| **11**         | Variable (Multiple of 4) | ***Resource Location Server:\*** 资源位置服务器：指定客户端在本地网络上使用的 RFC 887 资源位置服务器地址列表。服务器按客户端使用的优先顺序列出。 |
| **12**         | Variable                 | ***Host Name:\*** 主机名：指定客户端的主机名。这可能是也可能不是 DNS 主机名；请参阅下面的选项 #15。 |
| **13**         | 2                        | ***Boot File Size:\*** 引导文件大小：指定客户端默认引导映像文件的大小，以 512 字节为单位。 |
| **14**         | Variable                 | ***Merit Dump File:\*** Merit Dump File：指定文件的路径和文件名，客户端在崩溃时应将其核心映像转储到该文件。 |
| **15**         | Variable                 | ***Domain Name:\*** 域名：指定客户端的 DNS 域名。与选项 #12 比较。 |
| **16**         | 4                        | ***Swap Server:\*** 交换服务器：指定客户端的交换服务器地址。 |
| **17**         | Variable                 | ***Root Path:\*** Root Path：指定客户端根磁盘的路径名。这允许客户端使用 NFS 等协议访问它可能需要的文件。 |
| **18**         | Variable                 | ***Extensions Path:\*** Extensions Path：指定包含供应商特定字段的文件的名称，客户端可以用与 DHCP/BOOTP 消息中的 Options 或 Vend 字段相同的方式解释这些字段。这被定义为允许客户端和服务器仍然交换特定于供应商的信息，即使 Option/Vend 字段现在用于本主题中描述的通用字段。另请参阅下面的选项 #43。 |
| **255**        | 0                        | ***End:\*** End：放置在所有其他选项之后，以标记选项列表的结尾。两个选项之一，长度为单字节，没有数据子字段（另一个是上面的 Pad 选项。） |

<u>**每个主机的 IP 层参数**</u>

这些是控制 IP 在主机上作为一个整体（不是特定于接口）的操作的参数，请参见表 193。


​                                                     **表 193：DHCP/BOOTP 选项：每个主机的 IP 层参数**

| **Code Value** | **Data Length (bytes)**  | **Name and Description**                                     |
| -------------- | ------------------------ | ------------------------------------------------------------ |
| ***19\***      | 1                        | ***IP Forwarding Enable/Disable:\*** IP Forwarding Enable/Disable：值为 1 将在具有该功能的客户端上打开 IP 转发（即路由）；值为 0 将其关闭。 |
| ***20\***      | 1                        | ***Non-Local Source Routing Enable/Disable Option:\*** Non-Local Source Routing Enable/Disable Option：值为 1 表示能够路由的客户端允许使用非本地源路由转发 IP 数据报。值 0 告诉客户端不允许这样做。 有关这方面的更多信息和下面的选项 #21，请参阅源路由 IP 数据报选项。 |
| ***21\***      | Variable (Multiple of 8) | ***Policy Filter:\*** 策略过滤器：一组用于过滤非本地源路由数据报的地址/掩码对。 |
| ***22\***      | 2                        | ***Maximum Datagram Reassembly Size:\*** 最大数据报重组大小：告诉客户端客户端应该准备重组的最大数据报的大小。最小值为 576 字节。 |
| ***23\***      | 1                        | ***Default IP Time-To-Live:\*** 默认 IP 生存时间：指定客户端在创建 IP 数据报时应该用于生存时间字段的默认值。 |
| ***24\***      | 4                        | ***Path MTU Aging Timeout:\*** 路径 MTU 老化超时：指定客户端在使用路径 MTU 发现确定的老化路径 MTU 值中应使用的秒数。 |
| ***25\***      | Variable (Multiple of 2) | ***Path MTU Plateau Table:\*** Path MTU Plateau Table：指定用于执行路径 MTU 发现的值表。 |



<u>**每个接口的 IP 层参数**</u>
这些参数特定于 IP 级别的特定主机接口（表 194）

​                                                                  **表 194：DHCP/BOOTP 选项：每个接口的 IP 层参数**

| **Code Value** | **Data Length (bytes)**  | **Name and Description**                                     |
| -------------- | ------------------------ | ------------------------------------------------------------ |
| **26**         | 2                        | ***Interface MTU:\*** 接口 MTU：指定最大传输单元 (MTU) 用于此接口上的 IP 数据报。最小值为 68。 |
| **27**         | 1                        | ***All Subnets Are Local:\*** All Subnets Are Local：当设置为 1 时，告诉客户端它可以假设它所在的 IP 网络的所有子网都具有与其自己的子网相同的 MTU。当为 0 时，客户端必须假定某些子网的 MTU 可能小于客户端的子网。 |
| **28**         | 4                        | ***Broadcast Address:\*** Broadcast Address：告诉客户端在这个接口上应该使用什么地址进行广播。 |
| **29**         | 1                        | ***Perform Mask Discovery:\*** Perform Mask Discovery：值 1 告诉客户端它应该使用 ICMP 来发现本地子网上的子网掩码。值 0 告诉客户端不要执行此发现。 |
| **30**         | 1                        | ***Mask Supplier:\*** Mask Supplier：设置为 1 以告诉客户端它应该响应此接口上的 ICMP 子网掩码请求。 |
| **31**         | 1                        | ***Perform Router Discovery:\*** 执行路由器发现：值 1 告诉客户端使用 ICMP 路由器发现过程来请求本地路由器。值为 0 告诉客户端不要这样做。请注意，DHCP 本身可用于使用上面的选项 #3 指定一个或多个本地路由器。 |
| **32**         | 4                        | ***Router Solicitation Address:\*** 路由器请求地址：告诉客户端地址用作路由器请求的目的地。 |
| **33**         | Variable (Multiple of 8) | ***Static Route:\*** 静态路由：为客户端提供可以放入其路由缓存中的静态路由列表。该列表由一组 IP 地址对组成；每对定义一个目的地和一个用于到达目的地的路由器。 |



<u>**每个接口的链路层参数**</u>

表 195 列出了特定于特定链路层（第二层）接口的 DHCP/BOOTP 选项。

​                                      表 195：DHCP/BOOTP 选项：每个接口的链路层参数

| **Code Value** | **Data Length (bytes)** | **Name and Description**                                     |
| -------------- | ----------------------- | ------------------------------------------------------------ |
| **34**         | 1                       | ***Trailer Encapsulation:\***Trailer Encapsulation：当设置为 1 时，告诉客户端协商尾部的使用，如 RFC 893 中所定义。0 值告诉客户端不要使用此功能。 |
| **35**         | 4                       | ***ARP Cache Timeout:\*** ARP 缓存超时：指定客户端应在其 ARP 缓存中保留条目的时间（以秒为单位）。 |
| **36**         | 1                       | ***Ethernet Encapsulation:\*** 以太网封装：告诉客户端在第二层通过以太网传输时使用什么类型的封装。如果选项值为 0，则指定应根据 RFC 894 使用以太网 II 封装；当值为 1 时，告诉客户端根据 RFC 1042 使用 IEEE 802.3 封装。 |

<u>**TCP 参数**</u>
影响 TCP 操作的选项如表 196 所示。


​                                                           **表 196：DHCP/BOOTP 选项：TCP 参数**

| **Code Value** | **Data Length (bytes)** | **Name and Description**                                     |
| -------------- | ----------------------- | ------------------------------------------------------------ |
| **37**         | 1                       | ***Default TTL:\*** 默认 TTL：指定客户端在发送 TCP 段时应使用的默认生存时间。 |
| **38**         | 4                       | ***TCP Keepalive Interval:\*** TCP Keepalive Interval：指定客户端在发送“keepalive”消息之前应在空闲 TCP 连接上等待多长时间（以秒为单位）。值 0 指示客户端不要发送此类消息，除非应用程序特别指示这样做。 |
| **39**         | 1                       | ***TCP Keepalive Garbage:\*** TCP Keepalive Garbage：当设置为 1 时，告诉客户端它应该发送 TCP keepalive 消息，其中包含一个八位字节的“垃圾”，以便与需要它的实现兼容。 |

<u>**应用程序和服务参数**</u>

这些是控制各种应用程序和服务操作的杂项选项（表 197）。


​                                                         **表 197：DHCP/BOOTP 选项：应用程序和服务参数**

| **Code Value** | **Data Length (bytes)**  | **Name and Description**                                     |
| -------------- | ------------------------ | ------------------------------------------------------------ |
| **40**         | Variable                 | ***Network Information Service Domain:\*** 网络信息服务域：指定客户端的 NIS 域。对比选项#64。 |
| **41**         | Variable (Multiple of 4) | ***Network Information Servers:\*** 网络信息服务器：指定客户端可能使用的 NIS 服务器的 IP 地址列表。服务器按客户端使用的优先顺序列出。对比选项#65。 |
| **42**         | Variable (Multiple of 4) | ***Network Time Protocol Servers:\*** 网络时间协议服务器：指定客户端可能使用的网络时间协议服务器的 IP 地址列表。服务器按客户端使用的优先顺序列出。 |
| **43**         | Variable                 | ***Vendor Specific Information:\*** 供应商特定信息：允许将任意一组供应商特定信息作为单个选项包含在 DHCP 或 BOOTP 消息中。此信息的结构使用与“选项”或“供应”字段本身相同的格式，只是它不以“魔术饼干”开头。有关更多详细信息，请参阅上一主题的末尾。 |
| **44**         | Variable (Multiple of 4) | ***NetBIOS Over TCP/IP Name Servers:\*** TCP/IP 名称服务器上的 NetBIOS：指定客户端可以使用的 NetBIOS 名称服务器的 IP 地址列表（根据 RFC 1001/1002）。服务器按客户端使用的优先顺序列出。 |
| **45**         | Variable (Multiple of 4) | ***NetBIOS Over TCP/IP Datagram Distribution Servers:\*** TCP/IP 数据报分发服务器上的 NetBIOS：指定客户端可以使用的 NetBIOS 数据报分发服务器（根据 RFC 1001/1002）的 IP 地址列表。服务器按客户端使用的优先顺序列出。 |
| **46**         | 1                        | ![img](http://www.tcpipguide.com/free/aa36e9b2.png)          |
| **47**         | Variable                 | ***NetBIOS Over TCP/IP Scope:\*** NetBIOS Over TCP/IP 范围：指定客户端的 NetBIOS over TCP/IP 范围参数。 |
| **48**         | Variable (Multiple of 4) | ***X Window System Font Servers:\*** X 窗口系统字体服务器：指定客户端可能使用的 X 窗口系统字体服务器的 IP 地址列表。服务器按客户端使用的优先顺序列出。 |
| **49**         | Variable (Multiple of 4) | ***X Window System Display Manager:\*** X 窗口系统显示管理器：指定运行客户端可能使用的 X 窗口系统显示管理器的系统的 IP 地址列表。地址按客户使用的优先顺序列出。 |
| **64**         | Variable                 | ***Network Information Service+ Domain:\*** Network Information Service+ 域：指定客户端的 NIS+ 域。对比选项#40。 |
| **65**         | Variable (Multiple of 4) | ***Network Information Service+ Servers:\*** Network Information Service+ Servers：指定客户端可能使用的 NIS+ 服务器的 IP 地址列表。服务器按客户端使用的优先顺序列出。对比选项#41。 |
| **68**         | Variable (Multiple of 4) | ***Mobile IP Home Agent:\*** Mobile IP Home Agent：指定客户端可以在Mobile IP中使用的Home Agent的IP地址列表。代理按优先顺序列出，供客户使用；通常指定单个代理。 |
| **69**         | Variable (Multiple of 4) | ***Simple Mail Transport Protocol (SMTP) Servers:\***简单邮件传输协议 (SMTP) 服务器：指定客户端可能使用的 SMTP 服务器的 IP 地址列表。服务器按客户端使用的优先顺序列出。 |
| **70**         | Variable (Multiple of 4) | ***Post Office Protocol (POP3) Servers:\*** 邮局协议 (POP3) 服务器：指定客户端可能使用的 POP3 服务器的 IP 地址列表。服务器按客户端使用的优先顺序列出。 |
| **71**         | Variable (Multiple of 4) | ***Network News Transfer Protocol (NNTP) Servers:\*** 网络新闻传输协议 (NNTP) 服务器：指定客户端可能使用的 NNTP 服务器的 IP 地址列表。服务器按客户端使用的优先顺序列出。 |
| **72**         | Variable (Multiple of 4) | ***Default World Wide Web (WWW) Servers:\*** 默认万维网 (WWW) 服务器：指定客户端可能使用的万维网 (HTTP) 服务器的 IP 地址列表。服务器按客户端使用的优先顺序列出。 |
| **73**         | Variable (Multiple of 4) | ***Default Finger Servers:\*** 默认 Finger 服务器：指定客户端可能使用的 Finger 服务器的 IP 地址列表。服务器按客户端使用的优先顺序列出。 |
| **74**         | Variable (Multiple of 4) | ***Default Internet Relay Chat (IRC) Servers:\***默认 Internet 中继聊天 (IRC) 服务器：指定客户端可以使用的 Internet 中继聊天 (IRC) 服务器的 IP 地址列表。服务器按客户端使用的优先顺序列出。 |
| **75**         | Variable (Multiple of 4) | ***StreetTalk Servers:\***StreetTalk 服务器：指定客户端可能使用的 StreetTalk 服务器的 IP 地址列表。服务器按客户端使用的优先顺序列出。 |
| **76**         | Variable (Multiple of 4) | ***StreetTalk Directory Assistance (STDA) Servers:\*** StreetTalk 目录服务 (STDA) 服务器：指定客户端可能使用的 STDA 服务器的 IP 地址列表。服务器按客户端使用的优先顺序列出。 |

<u>**DHCP 扩展**</u>

最后但同样重要的是，表 198 描述了控制 DHCP 协议操作的 DHCP-only 选项。


​                                                      **表 198：DHCP 选项：DHCP 扩展**

| **Code Value** | **Data Length (bytes)** | **Name and Description**                                     |
| -------------- | ----------------------- | ------------------------------------------------------------ |
| **50**         | 4                       | ***Requested IP Address:\*** 请求的 IP 地址：在客户端的 DHCPDISCOVER 消息中用于请求特定的 IP 地址分配。 |
| **51**         | 4                       | ***IP Address Lease Time:\*** IP 地址租用时间：用于客户端请求向服务器询问特定的 DHCP 租用期限，或用于服务器回复以告知客户端提供的租用时间。它以秒为单位指定。 |
| **52**         | 1                       | ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\aa365ceb.png) |
| **53**         | 1                       | ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\aa365d08.png) |
| **54**         | 4                       | ***Server Identifier:\*** 服务器标识符：特定 DHCP 服务器的 IP 地址。此选项包含在 DHCP 服务器发送的消息中，以将它们自己标识为消息的来源。客户端在 DHCPREQUEST 消息中也使用它来指定它正在接受哪个服务器的租约。 |
| **55**         | Variable                | ***Parameter Request List:\*** 参数请求列表：由 DHCP 客户端用来从 DHCP 服务器请求特定配置参数值的列表。 |
| **56**         | Variable                | ***Message:\*** 消息：由服务器或客户端用来指示错误或其他消息。 |
| **57**         | 2                       | ***Maximum DHCP Message Size:\*** 最大 DHCP 消息大小：由 DHCP 客户端或服务器用来指定它愿意接受的 DHCP 消息的最大大小。最小合法值为 576 字节。 |
| **58**         | 4                       | ***Renewal (T1) Time Value:\*** 续订 (T1) 时间值：告诉客户端用于其续订计时器的值。 |
| **59**         | 4                       | ***Rebinding (T2) Time Value:\*** 重新绑定 (T2) 时间值：告诉客户端要为其重新绑定计时器使用什么值。 |
| **60**         | Variable                | ***Vendor Class Identifier:\*** 供应商类标识符：包含在 DHCP 客户端发送的消息中，用于指定其供应商和配置。这可用于提示服务器使用选项 #43 发送正确的特定于供应商的信息。 |
| **61**         | Variable                | ***Client Identifier:\*** 客户端标识符：客户端可选地使用它来为自身指定一个不同于 DHCP 默认值的唯一客户端标识。服务器期望此标识符在所有 DHCP 客户端中是唯一的，并用于索引 DHCP 服务器的配置参数数据库。 |
| **66**         | Variable                | ***TFTP Server Name:\*** TFTP 服务器名称：当 DHCP 消息的 SName 字段已用于使用选项重载功能的选项时，可以包含此选项以指定通常出现在 SName 字段中的 TFTP 服务器名称。 |
| **67**         | Variable                | ***Bootfile Name:\*** 引导文件名称：当 DHCP 消息的文件字段已用于使用选项重载功能的选项时，可以包含此选项以指定通常出现在文件字段中的引导文件名称。 |





###### 3.1.3.5 DHCP 客户端/服务器实现、特性和问题

前面三个部分描述了 DHCP 地址租用系统、配置过程和消息传递。在它们之间，这些部分提供了对 DHCP 操作的所有基础知识的解释。有了这个基础，我们现在可以继续研究 DHCP 是如何实现的一些更有趣的细节。我们还可以深入研究一些改变我们已经研究过的基本 DHCP 机制的额外功能和特殊特性。

在本节中，我将讨论 DHCP 客户端/服务器实现问题、增强协议的特殊功能以及与使 DHCP 工作相关的一些问题。我首先讨论 DHCP 服务器和客户端的实现和管理问题。我讨论了 DHCP 消息中继以及它如何与用于 BOOTP 的中继功能相关。我描述了当客户端无法联系服务器时提供自动默认寻址的 DHCP 特性，以及多台服务器的冲突检测特性。然后，我介绍了一些与 DHCP 和 BOOTP 的互操作性相关的问题，并概述了一些更重要的问题和与 DHCP 安全性相关的问题。

**背景信息：**本节假定您已经熟悉 DHCP 的基本操作。特别是，您应该确保在继续之前已经通读并理解了有关 DHCP 操作的部分。

###### 3.1.3.5-1 DHCP 服务器一般实施和管理问题（部分：1 2 3）

DHCP 是一种客户端/服务器协议，依赖于服务器和客户端来履行某些职责。在这两个设备角色中，DHCP 服务器可以说是更重要的，因为 DHCP 的大部分功能实际上是在服务器中实现的。服务器维护配置数据库，跟踪地址范围并管理租约。因此，DHCP 服务器通常也比 DHCP 客户端复杂得多。

本质上，没有 DHCP 服务器，就没有 DHCP。因此，决定如何实现 DHCP 服务器是实现协议的很大一部分。这一整章都是关于描述像 DHCP 这样的协议的功能，而不是详细介绍如何实现它们。但是，我觉得了解一些与 DHCP 服务器的设置和使用方式相关的一般问题很有用，有助于了解该协议的实际工作原理。

<u>**DHCP 服务器实现**</u>
“经典”DHCP 服务器由运行在某种服务器硬件平台上的 DHCP 服务器软件组成。除非在非常大的网络中，否则 DHCP 服务器通常不会是专用计算机。硬件服务器更常见的是提供 DHCP 服务并执行其他功能，例如充当应用程序服务器、通用数据库服务器、提供 DNS 服务等。因此，DHCP 服务器不必是一台特殊的计算机；任何可以运行 DHCP 服务器实现的设备都可以充当服务器。

事实上，DHCP 服务器甚至可能根本不需要是主机。今天，许多路由器都包含 DHCP 功能。将路由器编程为充当 DHCP 服务器允许连接到路由器的客户端自动分配 IP 地址。这在多个客户端共享有限数量的公共 IP 地址或使用 IP 网络地址转换 (NAT) 动态共享少量地址的环境中提供了许多潜在优势。由于 DHCP 需要数据库，充当 DHCP 服务器的路由器需要某种形式的永久存储。这通常使用路由器上的闪存来实现，而“真正的”服务器当然使用硬盘存储。

几乎所有现代操作系统都支持 DHCP，包括大多数 UNIX 变体、Linux、更新版本的 Microsoft Windows、Novell NetWare 等。在某些情况下，您可能需要运行操作系统的“服务器版本”才能让主机充当 DHCP 服务器。例如，虽然 Microsoft Windows XP 支持 DHCP，但我不认为 DHCP 服务器出现在“Windows XP Home”（“家庭用户”版本）中。 （当然，你可以自己安装一个！）

<u>**DHCP 服务器软件功能**</u>

在大多数网络中，您将根据大量因素来选择操作系统。操作系统的选择将决定您在选择 DHCP 服务器软件时有哪些选项。大多数常见的操作系统都有许多可用于软件的选项。虽然所有这些都将实现核心 DHCP 协议，但它们在通常的软件属性方面有所不同：成本、性能、易用性等。它们在功能方面也可能有所不同，例如：

- 它们如何允许定义地址范围（作用域）。

- 如何对客户端进行分组和管理。

- 管理员对返回给客户端的参数的控制级别。

- 管理员对协议的一般操作的控制级别，例如 T1 和 T2 计时器和其他变量的规范，以及如何分配租用和处理续订。

- 安全功能。

- 能够与 DNS 交互以支持动态设备命名。

- 可选功能，例如 BOOTP 支持、冲突检测和自动专用 IP 寻址。

<u>**选择服务器数量**</u>
在为网络设置 DHCP 时，需要考虑许多重要因素并做出决定。最关键的因素之一是您想要拥有的服务器数量。理论上，每个网络只需要一个 DHCP 服务器；实际上，这通常不是一个好主意。服务器有时会遇到硬件或软件故障，或者必须停机进行维护。如果只有一台服务器并且客户端无法访问它，则没有 DHCP 客户端能够获取地址。因此，经常使用两个或多个服务器。

如果您确实使用了不止一台服务器，则必须仔细计划如何配置每台服务器。您需要做出的首要决定之一是哪些服务器将负责哪些地址和客户端。您必须确定是否希望服务器具有不同或重叠的地址池，如 DHCP 地址范围主题中所述。不同的池确保地址保持唯一，但如果服务器出现故障，则会导致无法分配地址；重叠地址更灵活，但除非使用冲突检测等功能，否则存在地址冲突的风险。

<u>**服务器放置、设置和维护**</u>

一旦知道需要多少台服务器，就必须确定要将它们放置在网络的哪个部分。如果您有许多物理网络，您可能还需要使用 DHCP 中继来允许所有客户端访问服务器。当然，网络结构可能会影响您使用的服务器数量，因此其中许多决定是相互关联的。

您必须做出与我们之前看到的所有 DHCP 操作参数相关的策略决策。两个大人物决定地址池的大小和结构，并制定租约策略决策，例如租约长度和 T1 和 T2 定时器的设置。您还必须决定哪些客户端将被动态分配地址，以及如何处理手动配置的客户端。

最后，管理员必须记住，组织的 DHCP 服务器是数据库服务器，必须进行相应的处理。与任何数据库服务器一样，它必须小心维护和管理。必须实施管理策略以确保服务器的安全和高效运行。此外，与某些其他类型的数据库系统不同，DHCP 数据库不会自动复制；因此，服务器数据库应该定期备份，使用 RAID 存储也是一个好主意。

###### 3.1.3.5-2 DHCP 客户端一般实施和管理问题

我在前面的话题中说过，没有DHCP服务器就没有DHCP，这是事实。 DHCP 服务器是实现大部分协议的地方，因此它们是协议的核心。对于服务器，你有 DHCP，但如果没有客户端，就没有什么可以实际使用 DHCP，所以没有人会关心。因此，即使从协议的角度严格来看，它们不如服务器重要，但 DHCP 客户端仍然非常重要。

正如 DHCP 服务器由在服务器平台上运行的服务器软件或充当服务器的硬件组成一样，DHCP 客户端只是在客户端设备上运行的 DHCP 客户端软件。大多数情况下，客户端设备是连接到 TCP/IP 互联网络的主机。 DHCP 如今已被广泛接受，几乎所有主机都包含 DHCP 客户端软件。 DHCP 客户端通常集成到图形操作系统（如 Windows）中，或者使用特定的客户端守护程序（如 UNIX/Linux 上的 dhclient 或 dhcpcd）实现。

由于 DHCP 背后的整个思想是让服务器负责参数存储、配置和地址管理，因此 DHCP 客户端相对简单。客户端实现消息传递协议，并根据需要将从 DHCP 服务器接收到的参数传递给其余的 TCP/IP 软件组件。它并没有做很多其他事情。

事实上，管理员设置客户端使用 DHCP 并不需要做太多事情。在某些操作系统中，它就像“打开开关”一样简单，只需在客户端本身内启用 DHCP 支持即可。这会提示客户端停止使用任何手动配置的参数并开始搜索 DHCP 服务器。服务器然后负责客户端的配置和地址分配。

由于除了与服务器通信之外，客户端在 DHCP 中并没有做很多事情，因此 DHCP 客户端的用户软件方式不需要太多。在大多数情况下，对 DHCP 客户端软件的控制是使用 TCP/IP 配置实用程序完成的。 Windows 客户端使用程序 ipconfig 或 winipcfg 来显示其当前 DHCP 租约的状态。这些程序还允许客户手动解除当前租约或续租。

释放租约意味着使用 DHCPRELEASE 消息提前终止租约。这通常是终止租约的唯一方式。续租是自动续租过程的手动版本。释放和续订租约可以按顺序进行，以重置处于混乱状态或具有某种其他类型的 DHCP 或连接问题的客户端。



###### 3.1.3.5-3 DHCP 消息中继和 BOOTP 中继代理（部分：1 2）

DHCP 是 TCP/IP 的第三代主机配置协议。我们已经广泛了解它是如何直接基于引导协议的； BOOTP 又是早期反向地址解析协议 (RARP) 的增强版。尽管每个新协议都比其前身有了重大改进，但每次迭代都保留了某些限制，这些限制实际上对所有主机配置协议都是通用的。

主机配置协议最重要的限制之一是依赖广播进行通信。每当我们处理客户端需要通信但不知道其 IP 地址并且不知道将提供它的服务器地址的情况时，客户端需要使用广播寻址。但是，出于性能原因，广播通常只在本地网络上传播。这意味着客户端和服务器始终需要在同一物理网络上才能进行主机配置。当然，我们不希望出现这种情况。这将要求大型互联网络在每个网络上都有不同的服务器，从而大大降低了集中配置信息的好处，并造成了大量的管理麻烦。

<u>**为 DHCP 使用 BOOTP 中继代理**</u>
RARP 对客户端和服务器在不同网络上的问题没有任何解决方案，这也是它的用途如此有限的原因之一。 BOOTP 做到了：它允许客户端和服务器通过使用 BOOTP 中继代理位于不同的网络上。中继代理是一种不是 BOOTP 服务器的设备，但它运行一个特殊的软件模块，允许它代替服务器运行。可以将中继代理放置在有 BOOTP 客户端但没有 BOOTP 服务器的网络上。中继代理拦截来自客户端的请求并将它们中继到服务器。然后服务器响应代理，代理将响应转发给客户端。在讨论它们的主题中可以找到 BOOTP 中继代理操作的完整基本原理和描述。

DHCP 的设计者对已经使用多年的 BOOTP 中继代理背后的基本概念和操作感到满意。为此，他们做出了继续使用 DHCP 中的 BOOTP 中继代理功能的具体决定。事实上，这也是决定在 DHCP 中保留 BOOTP 消息格式以及基本的双消息“请求/回复”通信协议的原因之一。这允许 BOOTP 中继代理像处理 BOOTP 消息一样处理 DHCP 消息。

这也是为什么在本主题的标题中提到 BOOTP 不是错字——DHCP 实际上使用 BOOTP 中继代理。甚至 DHCP 标准也说“BOOTP 中继代理是在 DHCP 客户端和 DHCP 服务器之间传递 DHCP 消息的 Internet 主机或路由器”。实际上，代理有时确实被称为“DHCP 中继代理”；您可能还会看到混合术语“BOOTP/DHCP 中继代理”和“DHCP/BOOTP 中继代理”。

<u>**DHCP中继过程**</u>

由于 DHCP 是专门为支持 BOOTP 中继代理而设计的，因此代理在 DHCP 中的行为与在 BOOTP 中的行为非常相似。当然，DHCP 有更复杂的消息交换，但正如我们已经看到的，它们仍然是围绕客户端请求和服务器响应的概念设计的。只有更多的请求和响应。 BOOTP 代理查找客户端发送的广播，然后按照 BOOTP 中继代理行为主题中所述将它们转发到服务器，然后从服务器返回回复。 DHCP 协议中的附加信息是通过以 DHCP 选项的形式对 BOOTP 消息格式进行添加来实现的，中继代理不会查看这些信息。它只是像对待 BOOTP 请求和回复一样对待它们。

因此，总而言之，当使用中继代理时，DHCP 操作部分中的各种客户端请求和服务器回复将变为：

- Client Request：当客户端广播请求时，中继代理在UDP 67端口上拦截它。它检查Hops字段，如果值大于16则丢弃该请求；否则它会增加字段。代理将自己的地址放入 GIAddr 字段，除非另一个中继代理已经将其地址放入该字段。然后它将客户端请求转发到 DHCP 服务器，或者在另一个网络上进行单播或广播。

- 服务器回复：服务器在 GIAddr 中看到一个非零值，并将回复发送给 IP 地址在该字段中的中继代理。然后，中继代理使用单播或广播将回复发送回客户端，如 DHCP 寻址主题中所述。

BOOTP 和 DHCP 之间的一个区别是从客户端到服务器的某些通信是单播的。最明显的例子是当客户端试图与特定的 DHCP 服务器续租时。由于它以单播方式发送此请求，因此它可以使用常规 IP 路由到达不同网络上的 DHCP 服务器，而无需中继代理参与。

**关键概念：**为了允许 DHCP 客户端和 DHCP 服务器驻留在不同的物理网络上，需要一个中间设备来促进网络之间的消息交换。为此，DHCP 使用与 BOOTP 相同的机制：部署 BOOTP 中继代理。中继代理捕获客户端请求，将它们转发给服务器，然后将服务器的响应返回给客户端。



###### 3.1.3.5-4 DHCP 自动配置/自动专用 IP 寻址 (APIPA)（部分：1 2 3）

在许多方面，TCP/IP 主机的 IP 地址就是它的标识。每个 TCP/IP 网络都要求所有主机都具有唯一的地址以促进通信。当网络为每个主机手动配置不同的 IP 地址时，主机将永久知道“他们是谁”。当主机成为 DHCP 客户端时，它们不再具有永久身份；他们依靠 DHCP 服务器来告诉他们“他们是谁”。

<u>**客户端获取IP地址失败的恢复**</u>
DHCP 客户端对服务器的依赖性不是问题，只要 DHCP 正常运行并且主机可以获得租约，实际上有很多我们已经探索过的好处。遗憾的是，可能会出现多种情况，导致其中一个 DHCP 进程不会为客户端产生租约。客户端可能无法获得租约、重启后重新获得租约或续订现有租约。发生这种情况的可能原因有很多：

- DHCP 服务器可能出现故障，或者可能被关闭进行维护；

- 客户端本地网络上的中继代理可能发生故障；

- 其他硬件故障或电源故障可能导致无法通信；

- 网络可能已用完可分配地址。

没有租约，主机就没有 IP 地址，没有地址，主机实际上就死在了水里。如果主机无法成功获得租约，基本的 DHCP 规范并没有真正指定主机的任何追索权。基本上由实现者决定要做什么，当 DHCP 首次创建时，许多主机实现只会显示一条错误消息并使主机无法使用，直到管理员或用户采取行动。

显然，这远非理想情况。如果我们可以让无法访问服务器的 DHCP 客户端自动配置自己，那就更好了。事实上，IETF 为此预留了一个特殊的 IP 地址块。此块 169.254.0.1 到 169.254.255.254（或无类表示法中的 169.254.0.0/16）保留用于自动配置，如 RFC 3330 中所述：

“主机通过自动配置获取这些地址，例如当可能找不到 DHCP 服务器时。”
然而，奇怪的是，没有定义 TCP/IP 标准来指定这种自动配置的工作方式。为了填补空白，Microsoft 创建了一个称为自动专用 IP 寻址 (APIPA) 的实现。由于微软的市场影响力，APIPA已部署在数百万台机器上，并因此成为业界事实上的标准。许多年后，IETF 在 RFC 3927 IPv4 链路本地地址的动态配置中确实为该功能定义了一个正式标准。

<u>**APIPA操作**</u>

APIPA 真的很简单，以至于有人花了这么长时间才想出这个主意，这真是令人惊讶。它会在任何 DHCP 租用过程失败时接管。 APIPA 不是仅仅通过错误消息停止，而是在上述私有寻址块中随机选择一个地址。然后它执行一个非常类似于 DHCP 分配过程中步骤#13 的测试：它使用 ARP 在本地网络上生成一个请求，以查看是否有任何其他客户端使用它选择的地址进行响应。如果有回复，APIPA 会尝试另一个随机地址并重复测试。当 APIPA 软件发现未使用的地址时，会将其作为默认地址提供给客户端。然后，客户端将为它通常从 DHCP 服务器接收的其他配置参数使用默认值。这个过程如图 269 所示。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\dhcpapipa.png)




​                                                                  **图 269：DHCP 自动专用 IP 寻址 (APIPA)**

在此示例中，客户端 #1 试图从其 DHCP 服务器获取 IP 地址，但服务器没有地址，因此它不会响应客户端的请求。客户端配置为使用 APIPA，因此它从 APIPA 地址块中随机选择一个地址。它在本地网络上发送 ARP 请求以查看是否有任何其他设备正在使用该地址；在这种情况下，通常不会有冲突，但这里 Client #2 实际上正在使用该地址，因此它会做出响应。客户端 #1 选择了一个不同的地址，这次没有得到回复。它开始使用该地址，同时继续定期检查是否有 DHCP 服务器上线。


使用自动配置地址的客户端将继续尝试定期联系 DHCP 服务器。默认情况下，此检查每五分钟执行一次。如果找到，它将获得租约并用正确的租用地址替换自动配置的地址。

APIPA 非常适合小型网络，其中所有设备都位于单个物理链路上。可以想象，在具有单个 DHCP 服务器的网络上有 20 个启用 APIPA 的 DHCP 客户端，您可以关闭服务器进行维护，并且所有客户端仍然可以正常工作，使用 169.254.x.x 地址。

<u>**APIPA 限制**</u>

请记住，APIPA 不是完全 DHCP 的适当替代品。 169.254.0.0/16 块是私有 IP 范围，具有私有 IP 地址的所有限制，包括无法在 Internet 上使用这些地址。此外，APIPA 无法提供客户端可能需要从 DHCP 服务器获取的其他配置参数。最后，APIPA 将无法与代理 ARP 一起正常工作，因为代理会对任何私有地址做出响应，因此它们都将显示为已使用。

由于它使用 ARP 检查地址冲突，APIPA 不太适合大型互联网络。要在具有多个子网的互联网络上使用它，您需要允许每个子网使用完整 169.254.0.0/16 块的不同部分的软件，以避免冲突。实际上，APIPA 是一种针对小型网络的解决方案；大型互联网络通过确保客户端始终可以联系 DHCP 服务器来处理无法联系 DHCP 服务器的问题。杰

关键概念：开发了一种称为自动专用 IP 寻址 (APIPA) 的可选 DHCP 功能，以允许客户端在无法从 DHCP 服务器获取 IP 地址的情况下仍然能够进行通信。启用后，客户端从专用 IP 地址的特殊保留块中选择一个随机地址，并检查以确保该地址尚未被其他设备使用。它继续定期检查 DHCP 服务器，直到它能够找到一个。



###### 3.1.3.5-5 DHCP 服务器冲突检测（部分：1 2）

正如我们在本节的第一个主题中看到的，任何使用 DHCP 的 TCP/IP 管理员必须做出的主要决定之一是要部署多少 DHCP 服务器。单个服务器具有简单的优点，但在发生故障时不提供冗余。这也意味着只要 DHCP 服务器关闭，客户端就无法获取地址。由于这些原因，大多数较大的网络使用两个或多个服务器。

<u>**需要防止重复分配同一地址**</u>
当您有两台或更多服务器时（为了便于讨论，我们只说两台），您需要做出另一个决定：如何在服务器之间划分地址池？正如我在讨论 DHCP 地址池时详细探讨的那样，有两种选择：要么为服务器提供重叠地址，要么使它们不重叠。不幸的是，在经典的 DHCP 中，这两者都不是真正好的解决方案。重叠范围意味着两台服务器可能会尝试分配相同的地址，因为 DHCP 不包括服务器之间通信的规定。非重叠范围避免了这个问题，但仅使某些地址可用于每个服务器。

奇怪的是 DHCP 标准没有为跨服务器协调提供更好的支持，尽管显然需要它。然而，某些 DHCP 实现实现了一个可选功能，实际上允许两个服务器具有重叠范围而不会发生地址冲突。同样，这是 Microsoft DHCP 服务器上常见的功能，也可能存在于其他实现中。它被称为 DHCP 服务器冲突检测。

<u>**冲突检测操作**</u>

冲突检测背后的想法非常简单。假设 DHCP 服务器从客户端接收到 DHCPDISCOVER 消息并决定为其提供租约。在发送 DHCPOFFER 消息之前，服务器通过向它计划提供的地址发送 ICMP Echo (ping) 消息来进行探测。然后它会等待一小段时间，以听取是否收到任何返回的 ICMP Echo Reply 消息。如果是这样，它就知道该 IP 地址正在使用并选择一个不同的地址。

如果所有 DHCP 服务器都配置为在提供地址之前执行此操作，则可以为所有这些服务器分配相同的重叠地址。他们不会有任何方式相互协调，但只要他们通过执行 ICMP 检查“先询问”，就不会有任何问题。这为管理员提供了重叠地址范围的优势——所有服务器的简单性和对所有地址的访问——没有地址冲突的风险。唯一的小缺点是执行检查需要一些额外的网络流量，如果需要选择新地址，则可能需要几毫秒的服务器 CPU 时间。

如果您在阅读 DHCP 分配过程时留心，您可能会注意到我在这里描述的内容听起来很熟悉。事实上，这是真的：这个功能真的不是什么新东西。在提供地址之前使用 ICMP 检查地址实际上在 RFC 2131 中提到，作为标准 DHCP 分配过程的一部分，您可以在本指南的分配过程中找到它作为步骤 #5 提到的。

那么为什么“冲突检测”需要成为一个额外的功能呢？很简单：ICMP 的使用不是强制性的，因为标准说服务器应该这样做，而不是他们必须这样做。这就是他们在标准中将这些词大写的原因。 J 做出此选择是为了在实施 DHCP 时提供灵活性，但这种灵活性是有代价的。所以，如果你想使用这个功能，你需要在你的服务器软件中寻找对它的支持。

**关键概念：**一些 DHCP 实现包括称为服务器冲突检测的功能。激活此功能后，它会导致每个服务器在将地址授予客户端之前始终检查以确保地址未被使用。当网络上的所有 DHCP 服务器都使用冲突检测时，可以为服务器分配重叠范围，因此每个服务器都可以分配组织的任何 IP 地址，同时无需担心两个客户端分配了相同的地址由不同的服务器。



###### 3.1.3.5-6 DHCP 和 BOOTP 互操作性（部分：1 2）

我已经广泛讨论了 DHCP 是如何基于引导协议设计的，以及它们如何使用相同的基本通信方法和消息格式。这样做有几个原因，其中最重要的一个是确保两个协议的互操作性。鉴于此，您可能希望我们可以简单地说 BOOTP 和 DHCP 彼此兼容，仅此而已。话又说回来，鉴于您可以看到我对这个主题有一个完整的话题，也许您根本不会认为……

事实上，DHCP 确实旨在与 BOOTP 兼容。 RFC 2131 将以下内容列为 DHCP 的设计目标之一：“DHCP 必须为现有的 BOOTP 客户端提供服务。”。这似乎很清楚。 BOOTP 消息格式的“重用”是 DHCP 和 BOOTP 兼容性的关键之一。 DHCP 功能不是通过新字段实现的，而是通过特定于 DHCP 的选项实现的，例如指定 DHCP 消息的所有重要类型的 DHCP 消息类型选项。 DHCP 设备可以查找此额外信息，而 BOOTP 设备可以忽略它。

然而，虽然 DHCP 和 BOOTP 相似，但它们并不相同，因此当它们一起使用时会出现一些互操作性问题。 DHCP 消息格式在结构上与 BOOTP 格式相同，但某些字段的解释略有不同。 BOOTP 客户端不理解 DHCP，因此当 BOOTP 和 DHCP 一起使用时，DHCP 客户端或服务器有时必须表现得略有不同以进行补偿。更复杂的是，并非所有 DHCP 和 BOOTP 的实现都必须完全相同，而且 DHCP 标准中的某些规范不是强制性的。

由于这些原因，我们不能假设 DHCP 和 BOOTP 将协同工作。为了解决其中一些问题，IETF 在最初创建 DHCP 的同时发布了 RFC 1534，即 DHCP 和 BOOTP 之间的互操作。本文档着眼于协议如何协同工作，重点关注两种不同的客户端/服务器互操作组合：连接到 DHCP 服务器的 BOOTP 客户端和连接到 BOOTP 服务器的 DHCP 客户端。让我们一次一个地考虑每个案例。

<u>**BOOTP 客户端连接到 DHCP 服务器**</u>

正如上面引用自 RFC 2131 的内容所示，DHCP 专门用于允许 DHCP 服务器处理来自 BOOTP 客户端的请求。协议本身就是为了实现这一点而设置的，但它确实需要 DHCP 服务器具有一定的智能才能知道如何处理 BOOTP 客户端。当然，最重要的问题之一是 BOOTP 客户端将遵循 BOOTP 配置过程而不是 DHCP 租用过程。 DHCP 服务器在与 BOOTP 客户端打交道时，必须使用 BOOTP 消息，字段具有 BOOTP 含义。服务器通过查找是否存在 DHCP 消息类型选项来确定客户端正在使用 BOOTP 而不是 DHCP，该选项必须存在于所有 DHCP 消息中，但当然不会用于 BOOTP。

如果 DHCP 服务器检测到它正在与 BOOTP 客户端打交道，它可以响应客户端的配置信息。服务器可以为客户端使用手动或自动分配。自动分配当然意味着服务器从其未使用的地址池中选择一个地址，但永久分配它。 BOOTP 客户端不能进行动态分配，因为 BOOTP 本质上是静态的。

DHCP 服务器可以在其对 BOOTP 客户端的响应中包含 BOOTP 供应商信息字段，包括自创建 BOOTP 以来定义的字段。但是，它显然不能发送任何特定于 DHCP 的选项。

<u>**连接到 BOOTP 服务器的 DHCP 客户端**</u>
现在，对于另一种情况。 DHCP 客户端可以从 BOOTP 服务器获取配置信息，因为服务器会像响应 BOOTP BOOTREQUEST 消息一样响应客户端的初始 DHCPDISCOVER 消息。 DHCP 客户端可以判断已收到 BOOTP 回复，因为没有 DHCP 消息类型选项。来自 BOOTP 服务器的响应应被视为无限租约，因为这就是 BOOTP 所支持的全部内容。请注意，如果 DHCP 客户端从 BOOTP 服务器和 DHCP 服务器收到响应，它应该使用 DHCP 响应而不是 BOOTP 响应（即使这意味着它获得更短的租约）。

###### 3.1.3.5-7 DHCP 安全问题

DHCP 设计于 20 世纪 90 年代初期，当时互联网上的组织数量还比较少。此外，它基于 BOOTP，创建于 1980 年代，当时我们今天所知道的互联网几乎不存在。在那些日子里，Internet 安全不是什么大问题，因为在 Internet 上使用 TCP/IP 的主要是一小部分研究和教育组织。因此，与那个时代的许多协议一样，DHCP 并没有为解决安全问题做太多工作。

实际上，这有点低估了。不仅 DHCP 在本质上不安全的 IP 和 UDP 上运行，而且 DHCP 协议本身实际上也没有任何安全规定。这在现代网络中是一个相当严重的问题，因为 DHCP 的强大功能：该协议处理关键配置信息。有两类与 DHCP 相关的潜在安全问题：

- 未经授权的 DHCP 服务器：如果恶意人员植入“流氓”DHCP 服务器，则此设备可能会响应客户端请求并向它们提供虚假配置信息。这可用于使客户端在网络上无法使用，或者更糟的是，设置它们以便以后进一步滥用。例如，黑客可以利用伪造的 DHCP 服务器来引导 DHCP 客户端使用黑客控制下的路由器，而不是客户端应该使用的路由器。

- 未经授权的 DHCP 客户端：可以设置一个客户端，伪装成合法的 DHCP 客户端，从而获取用于该客户端的配置信息；这可以在以后用于破坏网络。或者，“坏人”可以使用软件生成大量虚假的 DHCP 客户端请求，以耗尽 DHCP 服务器池中的所有 IP 地址。更简单地说，小偷可以利用它从组织中窃取 IP 地址供自己使用。

<u>**为 DHCP 添加安全性**</u>
这些显然是严重的问题。针对这些风险的正常推荐解决方案通常涉及在较低层提供安全性。例如，防止未经授权的服务器和客户端的最重要技术之一是仔细控制对网络的物理访问：第一层安全。在第二层实施的安全技术也可能有用，例如，在无线局域网的情况下。由于 DHCP 在 UDP 和 IP 上运行，因此可以在第三层使用 IPSec 来提供身份验证。

<u>**DHCP认证**</u>
为了尝试解决 DHCP 本身的一些更具体的安全问题，IETF 在 2001 年 6 月发布了 RFC 3118，DHCP 消息的身份验证。该标准描述了一种用经过身份验证的消息替换普通 DHCP 消息的增强功能。客户端和服务器检查身份验证信息并拒绝来自无效来源的消息。该技术涉及使用新的 DHCP 选项类型、身份验证选项，以及对几个租赁过程的操作更改以使用此选项。

不幸的是，2001 年在 DHCP 游戏中已经很晚了，周围有数百万的 DHCP 客户端和服务器不支持这个新标准。客户端和服务器都必须编程为使用身份验证，此方法才有价值。支持身份验证的 DHCP 服务器可以为支持该功能的客户端使用它，而为不支持该功能的客户端跳过它。然而，这个选项不是通用的，这意味着它没有得到广泛部署，大多数网络必须依赖更传统的安全措施。



###### 3.1.3.6 DHCP For IP 版本 6 (DHCPv6)（部分：1 2）

DHCP 目前是 TCP/IP 协议族的标准主机配置协议。 TCP/IP 建立在 Internet 协议版本 4 之上，有时也称为 IPv4。然而，自 1990 年代初以来，IPv4 的后继版本即 Internet 协议第 6 版或 IPv6 的开发工作一直在进行。这个新的 IP 标准将是 TCP/IP 的未来；它在本指南的相应部分中有详细描述。

虽然 IPv6 带来的大部分变化都会影响 TCP/IP 体系结构模型较低层的技术，但这些修改的重要性意味着许多其他 TCP/IP 协议也会受到影响。对于使用地址或配置信息（包括 DHCP）的协议尤其如此。因此，IPv6 需要新版本的 DHCP。 DHCP For IPv6（有时也称为 DHCPv6）的开发已经进行了相当长的一段时间。在我写这篇文章的时候，DHCPv6 还没有正式发布——它仍然是一个正在讨论中的互联网草案。我将在此处提供该协议的摘要，稍后可能会将其扩展到更大的部分。

**注意**：在纯粹围绕 IPv6 的讨论中，DHCPv6 有时被称为“DHCP”，而原来的 DHCP 被称为“DHCPv4”，所以要小心！出于显而易见的原因，我不打算在这里这样做。

<u>**IPv6 中自动配置的两种方法**</u>
IPv6 中引入的众多增强功能之一是简化 IP 设备管理（包括主机配置）的总体策略。为 IPv6 主机的自动配置定义了两种基本方法：

- 无状态自动配置：定义为允许主机在没有任何其他设备帮助的情况下自行配置的方法。

- “有状态”自动配置：一种由服务器向主机提供配置信息的技术。

使用哪种方法取决于网络的特性。无状态自动配置在 RFC 2462 中进行了描述，并在 IPv6 部分的单独主题中进行了讨论。 IPv6 的“有状态”自动配置由 DHCPv6 提供。与常规 DHCP 一样，DHCPv6 可用于获取 IP 地址和其他配置参数，或者仅在客户端已有 IP 地址时获取配置参数。

<u>**DHCPv6 操作概述**</u>

DHCPv6 的操作与 DHCPv4 类似，但协议本身已被完全重写。它不是基于较旧的 DHCP 或 BOOTP，概念上除外。它仍然使用 UDP，但使用了新的端口号、新的消息格式和重组的选项。所有这些都意味着新协议并不严格兼容 DHCPv4 或 BOOTP，尽管我相信正在研究一种允许 DHCPv6 服务器与 IPv4 设备一起工作的方法。

**关键概念：**由于 DHCP 使用 IP 地址和其他配置参数，从 IPv4 到 IPv6 的更改需要一个新版本的 DHCP，通常称为 DHCPv6。这个新的 DHCP 代表了对原始 DHCP 的重大改变，并且仍在开发中。 DHCPv6 用于 IPv6“有状态”自动配置；另一种方法是无状态自动配置，这是 IPv6 的一项功能，它允许客户端在不需要服务器的情况下确定其 IP 地址。


DHCPv6 也面向 IPv6 寻址方法，尤其是链路本地范围多播地址的使用。这甚至可以在客户端分配 IP 地址之前实现高效通信。一旦客户端有了地址并知道服务器的身份，它就可以使用单播寻址直接与服务器通信。

<u>**DHCP 消息交换**</u>
DHCPv6 中使用了两种基本的客户端/服务器消息交换：四消息交换和两消息交换。前者在客户端需要获取IPv6地址和其他参数时使用。这个过程类似于常规的 DHCP 地址分配过程；高度简化，它涉及以下步骤：

- 客户端发送多播 Solicit 消息寻找 DHCPv6 服务器并请求租用。

- 任何可以满足客户请求的服务器都会用 Advertise 消息对其进行响应。

- 客户端选择其中一个服务器并向其发送请求消息，要求确认提供的地址和其他参数。

- 服务器以 Reply 消息响应以完成该过程。

上面的四消息过程还有一个更短的变体，其中客户端发送一个 Solicit 消息并指示服务器应该立即用 Reply 消息响应。

如果客户端已经有一个 IP 地址，可以手动分配或以其他方式获得，则可以进行更简单的处理，类似于在常规 DHCP 中使用 DHCPINFORM 消息的方式：

- 客户端多播一个 Information-Request 消息。

- 带有客户端配置信息的服务器发回回复消息。

与常规 DHCP 一样，DHCPv6 客户端会在一段时间后通过发送 Renew 消息来更新其租约。与 DHCPv4 一样，DHCPv6 也支持中继代理功能。

#### 3.2 TCP/IP 网络管理框架和协议（SNMP 和 RMON）

现代网络和互联网络比过去几年的前辈更大、更快、更强大。随着我们扩展、加速和增强我们的网络，它们变得更加复杂，因此更难以管理。多年前，管理员可以使用非常简单的工具来维持网络运行，而如今这已经远远不够了。需要更复杂的网络管理技术来匹配我们网络的复杂性。

网络管理员“工具箱”中一些最重要的工具现在实际上是软件，而不是硬件。为了管理庞大的、异构的和复杂的互联网络，已经开发了允许使用互联网络本身收集信息和控制设备的软件应用程序。 TCP/IP 作为最流行的网络套件，当然有这样的软件工具。其中最重要的一个是一对协议，它们已作为称为 TCP/IP Internet 标准管理框架的整体网络管理方法的一部分实施。

在本节中，我详细描述了 TCP/IP Internet 标准管理框架，研究了它的每个体系结构和协议组件以及它们如何互操作。第一部分概述了网络管理框架本身，并作为对后续部分的介绍。第二小节讨论了网络管理信息的结构化和排列称为管理信息库 (MIB) 的信息存储中的方式。第三小节描述了 TCP/IP 网络管理中的关键协议——简单网络管理协议 (SNMP) 的操作。最后，我简要介绍了远程网络监控 (RMON)，这是对 SNMP 的一种增强——有时称为协议，尽管它实际上不是——为管理员提供了对 TCP/ IP互联网络。

**注意：**虽然您可能想直接跳到有关 SNMP 的小节，但如果您按顺序阅读此处的小节，那里写的内容会更有意义。



##### 3.2.1 TCP/IP 互联网标准管理框架概述、体系结构、组件和概念

TCP/IP 网络管理功能最常与负责实现这些功能的关键协议相关联：简单网络管理协议 (SNMP)。许多人都听说过 SNMP，SNMP 通常被认为是在 TCP/IP 中执行网络管理的“方式”。

这在一定程度上是正确的，但实际上过于简单化了。实际的 SNMP 协议只是称为 Internet 标准管理框架的更高级别网络管理策略的一部分。为了真正理解 SNMP 的工作原理，我们首先需要了解网络管理的整体结构。

在本节中，我通过描述 TCP/IP Internet 标准管理框架的概念和组件来介绍 TCP/IP 网络管理。我从框架的概述和历史开始，并讨论它与简单网络管理协议 (SNMP) 的关系。我描述了 TCP/IP 网络管理模型和构成网络管理系统的关键组件。我提供了 Internet 标准管理框架体系结构的摘要。然后我描述了 Framework 和 SNMP 的三个主要版本，以及它们的相同点和不同点。最后，我将讨论用于描述该技术的许多标准。

###### 3.2.1.1 TCP/IP 互联网标准管理框架和简单网络管理协议 (SNMP) 的概述和历史（部分：1 2 3）

职业体育界的一句格言说，当你忘记他的存在时，棒球裁判做得很好。在许多方面，网络管理员也可以这样说。当网络运行如此流畅和高效以至于用户忘记了管理员的存在时，管理员就做得很好。因为管理员非常清楚，一有问题，用户很快就会记住他或她在那里。😄

这意味着网络管理员的主要工作是密切关注网络并确保其正常运行。有关网络上的硬件和软件的信息是正确执行此任务的关键。当网络规模较小时，管理员可以使用简单的方式随时了解硬件和软件的状态，例如亲自走到计算机前并使用它，或者使用低级链路层管理协议。

这对于现代互联网络来说是根本不可能的，因为现代互联网络规模庞大、地域多样，而且通常由许多不同的底层技术组成。通常，网络上所有设备的唯一共同点是特定网络协议套件（如 TCP/IP）的实现。这使得互联网络本身成为促进设备和网络管理员之间网络管理信息通信的合乎逻辑的方式。

<u>**SNMP的早期发展**</u>
许多人在 Internet 的早期认识到 TCP/IP 需要某种网络管理技术。不幸的是，起初并没有单一的标准——在 80 年代，不同的工作组开发了几种不同的技术。共有三个主要参赛者：RFC 1021 至 1024 定义的高级实体管理系统 (HEMS) / 高级实体管理协议 (HEMP)；由 RFC 1028 定义的简单网关监控协议 (SGMP)；和通用管理信息协议 (CMIP)，它实际上是 OSI 协议族的一部分。

Internet 工程任务组 (IETF) 认识到拥有统一的 TCP/IP 管理标准的重要性，并于 1988 年发布了 RFC 1052，即 IAB 关于制定 Internet 网络管理标准的建议。这份备忘录不是标准，而是更多的关于这个主题的会议的意向声明和文件。 RFC 1052 的结论是，SGMP 被用作称为简单网络管理协议 (SNMP) 的新 Internet 标准的基础。该开发将由 SNMP 工作组执行。

<u>**“SNMP”的两种含义**</u>

名称“简单网络管理协议”中中间两个词的基本原理是显而易见的，但其他两个词的问题略多。 J “协议”一词意味着 SNMP 只是一种 TCP/IP 通信协议，就像其他协议（如 DHCP 或 FTP）一样。不幸的是，这既正确又不正确：术语“SNMP”含糊不清。

在较低的层次上，SNMP 确实特指在设备之间承载网络管理信息的实际协议。这实际上是大多数人在谈论“SNMP”时所想到的。然而，正如 SNMP 工作组所定义的，TCP/IP 网络管理解决方案作为一个整体由许多不同的元素组成，这些元素排列在一个体系结构中。

这个架构最初没有具体的名称，现在被称为互联网标准管理框架。奇怪的是，这个更高级别的框架并没有缩写为“ISMF”或类似的东西；它也称为“SNMP”，这意味着上下文对于理解该术语很重要。

**注意：**为避免混淆，我经常使用短语“SNMP 框架”和“SNMP 协议”来区分术语“SNMP”的这两种用法。

<u>**SNMP 的设计目标**</u>
“简单网络管理协议”中的“简单”一词是我的另一个痛处；在研究并撰写了有关这项技术的文章后，我现在认为“SNMP”这个名称中出现这个术语几乎是一种嘲讽。让我们这样说吧：如果脑外科医生告诉你某事是一个“简单的手术”，你可能会对此持保留态度——好吧，这同样适用于这里。即使在第一次迭代中，它也只是有些简单；最新版本的 SNMP 确实相当复杂，有许多不同的标准定义了 SNMP 框架、SNMP 协议本身和许多支持元素。

那为什么叫“简单”呢？好吧，正如他们所说，一切都是相对的；与其他更复杂的协议相比，SNMP 是“简单的”。通过查看 Internet 标准管理框架和整个 SNMP 协议的基本目标可以看出其中的一些内容：

- SNMP 定义了一种通用方式，可以轻松地为任何对象定义管理信息，然后在该对象和旨在促进网络管理的设备之间交换；

- SNMP 将管理信息的定义和通信功能与用于网络管理的应用程序分开；

- 实际的 SNMP 协议相当简单，仅由几个易于理解的协议操作组成；

- SNMP 的实现对于产品的设计者和制造者来说是比较简单的。

由于 SNMP 是一个 TCP/IP 应用层协议，理论上它可以运行在多种传输机制之上。当然，它最常通过 IP 实现，但最新版本还定义了传输映射，允许 SNMP 信息通过其他网络技术传输。同样，我的重点将继续几乎完全集中在 TCP/IP 上。

**关键概念：**简单网络管理协议 (SNMP) 定义了一组允许网络管理员远程监控和管理 TCP/IP 网络设备的技术。术语“SNMP”既指特定的通信协议（有时称为 SNMP 协议），也指 Internet 管理的总体框架（SNMP 框架）。

<u>**SNMP的进一步发展及SNMP变异问题**</u>

上面的描述提供了第一个 SNMP 版本的开发历史，导致 1988 年第一个 Internet 标准管理框架的发布；现在称为 SNMP 版本 1 (SNMPv1)。这个初始版本的 SNMP 获得了广泛的接受，它可能仍然是最常见的 SNMP 版本。

从那时起，SNMP 的大部分历史都是相当混乱的“标准噩梦”。 SNMPv1 有很多弱点，尤其是在安全领域。出于这个原因，在 SNMPv1 完成后不久，就开始了新版本的 SNMP。不幸的是，这项工作陷入了困境，许多竞争性的 SNMPv2 变体被创建出来。经过多年的混乱，没有一个 SNMPv2 变体取得重大成功。

最近，发布了 SNMP 框架和协议的第三个版本，它添加了新的功能并再次将 SNMP“重新组合”在一个单一的通用协议下。本节后面有关 SNMP 版本和 SNMP 标准的主题进一步探讨了 SNMP 自 1988 年以来的历史；它们可以被视为该主题的延续，因为它们有助于澄清过去十五年来 SNMP 版本背后非常混乱的故事。

这份概述可能比它回答的问题更多地让您想到有关 Internet 标准管理框架和 SNMP 的问题。这就是为什么我说这东西并不是真的那么简单的部分原因。 J 本节接下来的两个主题提供了有关框架及其组件以及这些组件的作用的更多信息，因此您可以更好地理解框架的全部内容。

**相关信息：**有关 SNMP 协议本身的更多背景信息可以在实际协议本身的概述主题中找到。



###### 3.2.1.2 TCP/IP SNMP 操作模型、组件和术语。 （部分：1 2 3）

因此，“简单”网络管理协议 (SNMP) 似乎并不是那么简单。 SNMP有很多版本、标准和用途，我们需要学习的东西也很多。我认为了解 SNMP 功能的一个好起点是查看其操作模型，并检查构成 TCP/IP 网络管理系统的组件以及用于描述它们的术语。

<u>**SNMP 设备类型**</u>
正如我们在前面的高级概述主题中看到的，SNMP 背后的总体思想是允许使用 TCP/IP 交换网络管理所需的信息。更具体地说，该协议允许网络管理员利用与其他网络设备交互的特殊网络设备从它们收集信息，并修改它们的操作方式。那么，在最简单的意义上，定义了两种不同的基本类型的硬件设备：

- 被管节点：网络上的常规节点，这些节点配备了允许使用 SNMP 对其进行管理的软件。一般来说，这些是传统的 TCP/IP 设备；它们有时也称为托管设备。

- 网络管理站（NMS）：一个指定的网络设备，它运行特殊的软件以允许它管理上面提到的常规被管节点。网络上必须存在一个或多个 NMS，因为这些设备才是真正“运行”SNMP 的设备。

<u>**SNMP 实体**</u>

每个使用 SNMP 参与网络管理的设备都运行一个软件，通常称为 SNMP 实体。 SNMP 实体负责实现 SNMP 协议的所有各种功能。每个实体由两个主要软件组件组成。哪些组件构成设备上的 SNMP 实体当然取决于该设备是被管节点还是网络管理站。

<u>**受管节点实体**</u>
SNMP 受管节点几乎可以是任何可以使用 TCP/IP 进行通信的网络设备，只要它使用适当的 SNMP 实体软件进行编程即可。 SNMP 旨在允许管理常规主机，以及智能网络互连设备，如路由器、网桥、集线器和交换机。其他“非常规”设备同样可以被管理，只要它们连接到 TCP/IP 互联网：打印机、扫描仪、消费电子设备，甚至专业医疗设备等等。

被管节点上的 SNMP 实体由以下软件元素和构造组成：

- SNMP 代理：实现 SNMP 协议并允许受管节点向 NMS 提供信息并接受来自它的指令的软件程序。

- SNMP 管理信息库 (MIB)：定义存储的有关节点的信息类型，这些信息可以收集并用于控制被管节点。使用 SNMP 交换的信息采用来自 MIB 的对象形式。

<u>**网络管理实体**</u>
在较大的网络上，网络管理站可能是一台独立的、高性能的 TCP/IP 计算机，专用于网络管理。但是，真正把一个设备做成NMS的是软件，所以NMS不一定是一个单独的硬件设备。它可以充当 NMS，也可以在网络上执行其他功能。

网络管理站上的 SNMP 实体包括：

- SNMP 管理器：实现 SNMP 协议的软件程序，允许 NMS 从被管节点收集信息并向它们发送指令。

- SNMP 应用程序：一个或多个软件应用程序，允许网络管理员使用 SNMP 来管理网络。

<u>**SNMP 术语摘要**</u>

因此，为了整合和重申所有这些，让我们总结一下。 SNMP 由少量网络管理站 (NMS) 组成，这些网络管理站与称为受管节点的常规 TCP/IP 设备交互。 NMS 上的SNMP 管理器和被管节点上的SNMP 代理实现SNMP 协议并允许交换网络管理信息。 SNMP 应用程序在 NMS 上运行并为人工管理员提供接口，并允许从每个 SNMP 代理的 MIB 收集信息，如图 270 所示。简单！看，这个名字终究是好听的。狗头😢

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\snmpmodel.png)


​                                                                               **图 270：SNMP 操作模型**

此图显示了 SNMP 的简化实现，其中一个网络管理站用于维护三个被管节点。每个设备都有一个 SNMP 实体，它们使用 SNMP 消息进行通信。 NMS的SNMP实体由SNMP Manager和一个或多个SNMP Application组成；每个被管节点都运行一个 SNMP 代理并维护一个管理信息库 (MIB)。

**关键概念：**SNMP 允许网络管理员使用网络管理站 (NMS) 来控制一组被管节点。每个设备都包含一个实现该技术的 SNMP 实体。在 NMS 中，实体由一个 SNMP 管理器模块和一组 SNMP 应用程序组成；在受管节点中，SNMP 代理和管理信息库 (MIB)。



###### 3.2.1.3 TCP/IP 互联网标准管理框架体系结构和协议组件（部分：1 2）

TCP/IP 网络管理基于简单网络管理协议，缩写为 SNMP。然而，正如我们在概述主题中看到的那样，这个术语是模棱两可的。虽然它通常用于指代用于交换网络管理信息的实际通信协议，但该术语还指代支持 TCP/IP 网络管理的整套技术。这个更大的体系结构的技术名称是 Internet 标准管理框架。同样，尽管看起来很奇怪，但该术语实际上在标准中缩写为“SNMP”。为了简单起见，我将其简称为“SNMP 框架”，以区别于 SNMP 协议。

Internet 标准管理框架包含构成 TCP/IP 网络管理解决方案的所有技术。 SNMP 框架由许多架构组件组成，这些组件定义管理信息的结构、存储方式以及使用 SNMP 协议交换信息的方式。该框架还描述了不同的组件如何组合在一起、如何在网络设备中实施 SNMP 以及设备如何交互。

<u>**SNMP 框架组件**</u>
正如我们稍后将更详细地探讨的那样，Internet 标准管理框架完全是面向信息的。它包括以下主要组件（参见图 271）：

- 管理信息结构 (SMI)：为确保各种设备的互操作性，我们希望有一种一致的方式来描述要使用 SNMP 管理的设备的特性。在计算机科学中，数据描述语言 (DDL) 是完成这项工作的工具。管理信息结构 (SMI) 是定义 SNMP 中管理信息的结构、语法和特征的标准。

- 管理信息库 (MIB)：每个受管设备都包含一组用于管理它的变量。这些变量表示有关发送到网络管理站的设备操作的信息，和/或发送到被管理设备以对其进行控制的参数。管理信息库 (MIB) 是这些变量的完整集合，用于描述特定类型设备的管理特征。

- MIB 中的每个变量称为 MIB 对象，并使用 SMI 数据描述语言定义。一个设备可能有许多对象，对应于它包含的不同硬件和软件元素。最初，一个单一的文件定义了 SNMP 的 MIB，但这个模型是不灵活的。为了更容易定义新的 MIB 对象，相关的 MIB 对象组现在在称为 MIB 模块的单独 RFC 标准中定义。到目前为止，已经定义了 100 多个这样的 MIB 模块。

- 简单网络管理协议 (SNMP)：这是实际的 SNMP 协议本身。它定义了如何在 SNMP 代理和网络管理站之间交换信息。 SNMP 协议操作定义了各种 SNMP 消息以及它们的创建和使用方式。 SNMP 传输映射描述了如何在各种底层互联网络（如 TCP/IP、IPX 等）上使用 SNMP。

- 安全和管理：对于上面的三个主要架构组件，SNMP 框架添加了许多支持元素。这些增强了 SNMP 协议的安全操作，并解决了与 SNMP 实施、版本转换和其他管理问题相关的问题。



![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\snmpcomponents.png)

​                                                                  **图 271：TCP/IP 互联网标准管理框架的组件**

<u>**SNMP框架架构**</u>

SNMP 的创建者特别将框架设计为模块化，因为最初创建 SNMP 时，它被视为只是一个临时解决方案，直到可以从 OSI 协议套件过渡到另一个网络管理协议。模块化架构将定义、数据和功能（协议）元素分开，以允许在不改变网络管理信息的定义和描述方式的情况下替换 SNMP 协议本身。

这种向 OSI 协议的转变从未发生过，但该体系结构在定义 SNMP 的整个范围和简化其实施方面仍然被证明是有价值的。上面的每个主要组件，SMI、MIB 和 SNMP 本身，都在不同的标准中进行了描述。 SNMP 框架的模块化还允许相对独立地对这些组件进行更改，从而使 SNMP 版本之间的转换比如果一个巨大的文档定义所有内容更容易。

**关键概念：**互联网标准管理框架（SNMP 框架）的三个主要组成部分是管理信息结构（SMI）、管理信息库（MIB）和 SNMP 协议本身。这些由 SNMP 安全和管理元素支持。



###### 3.2.1.4 TCP/IP 互联网标准管理框架和 SNMP 版本（SNMPv1、SNMPv2 变体、SNMPv3）（部分：1 2 3 4）

在本指南开头附近的“网络基础”一章中，我有一节讨论网络标准及其重要性。我还解释了专有标准、事实标准和开放标准之间的区别，并解释了开放标准的诸多好处。历史上充满了技术成功的例子，因为它们使用了一种开放标准，而竞争标准是专有的。

TCP/IP 和 Internet 经常被奉为正确开放标准开发的典范。使用众所周知的“征求意见”（“RFC”）标准化过程已经开发和发布了数以千计的 TCP/IP 标准。其结果是计算历史上最成功的一组互联网络协议，在全球范围内被接受和使用。

然而，没有人是完美的，也没有过程是完美的。在引入 SNMP 第 2 版时出现了一些问题，导致通常顺利的协议标准化方法几乎崩溃，并且我们不习惯在 TCP/IP 中看到的不兼容“变体”的激增。这背后的故事是本节前面的一般 SNMP 概述和历史的延续，并解释了许多 SNMP 标准名称和编号，因此您可以理解它们。同时，讨论生动地提醒了正确的标准开发是多么重要，以及如果没有就标准应该如何发展达成普遍共识时会产生什么后果。

<u>**SNMPv1**</u>

SNMP 的第一个版本于 1988 年初开发，并于 88 年 8 月以三个 RFC 标准的形式发布。这个第一个版本现在称为 SNMP 版本 1 或 SNMPv1。三个 SNMPv1 标准提供了三个主要的 Internet 标准管理框架组件的初始描述：管理信息结构 (SMI)、管理信息库 (MIB) 和 SNMP 协议本身。但是，当时并没有实际使用“互联网标准管理框架”一词。

SNMPv1 被普遍接受并广泛部署在许多网络中。 SNMPv1 完成了任务并成为 TCP/IP 网络管理的标准；它今天仍然被广泛使用。它是 SNMP 版本的“老忠实”。随着时间的推移，对初始标准进行了轻微修改，并且定义了越来越多的 MIB 模块，但该技术多年来一直保持不变。

与任何技术一样，随着时间的推移，SNMPv1 的用户发现了它的弱点和改进的机会。 SNMPv1 最受批评的领域之一是安全领域。 SNMP 版本 1 只使用了一种“简单的”（如 RFC 3410 所说的）身份验证方案，该方案使用一种称为社区字符串的类似密码的结构。

安全问题最终成为争论的焦点，最终导致 SNMP 开发出现严重问题。有些人认为社区字符串已足够安全，但许多其他人认为将更好的安全性放入 SNMP 很重要。提出了许多不同的方法来增加 SNMP 的安全性，但没有就如何做到这一点达成一致。正如我在 SNMP 协议操作部分中探讨的那样，关于原始 SNMPv1 中安全弱点的观点有一定的道理。

<u>**SNMPsec**</u>
1992 年 7 月发布的三项标准首次尝试为 SNMP 添加安全性，这些标准使用称为各方的逻辑标识符定义了一种新的安全机制。这有时称为 SNMP 安全或 SNMPsec。这种方法比原来的 SNMPv1 更安全，但 SNMPsec 从未被广泛接受，现在被认为是“历史性的”。

<u>**SNMPv2**</u>

虽然 SNMPsec 消失了，但它引入的基于方的安全理念从未消失。当 SNMP 版本 2 (SNMPv2) 于 1993 年 4 月在 RFC 1441 到 1452 中发布时，它被用作 SNMP 第一次完整修订版定义的基础。这个新版本包含了新的安全模型，并对实际的 SNMP 协议操作，对管理信息结构 (SMI) 标准的更改（定义 SMI 的版本 2，SMIv2），以及正式确定 Internet 标准管理框架的概念。

不幸的是，这个新标准也从未被普遍接受。有些人认为整个新版本是一个很大的进步，但其他人则对基于party-based的安全提出异议，声称它太复杂了。我不熟悉所有的细节，但据我所知，在接下来的几年里发生了大量的辩论和讨论，试图让每个人都“接受”新版本。

<u>**SNMPv2 变体**</u>
接受 SNMPv2 从未发生过。相反，不同的“分裂组织”分道扬镳并开始研究 SNMPv2 的变体。为防止混淆，最初的 SNMPv2 被称为 SNMPv2 经典版（让人想起特定软饮料的名称）或 SNMPv2p，其中“p”指的是“party-based”的安全性。当提出和/或开发以下内容时，事情变得非常有趣（和令人困惑）：

- SNMPv1.5：我可以立即判断，当一个想法提出的版本号低于已经标准化的版本号时，它可能会成为一个问题。 SNMPv1.5 试图保留 SNMPv2p 中“无争议”的元素——对 SNMP 协议和 SMI 的增强——同时回到 SNMPv1 中基于社区的安全性。它本身从未成为标准，但成为了……的基础

- 基于社区的 SNMPv2 (SNMPv2c)：这是 SNMPv2p，修改为使用社区字符串而不是基于方的安全性；本质上，与 SNMPv1.5 的想法相同，但具有更“官方”的名称和一些变化。有趣的是，定义它的标准 RFC 1901 仍然处于“实验”状态，尽管事实上 SNMPv2c 实际上取得了某种程度的商业成功，而“标准”SNMPv2p 没有。

- SNMPv2c 由标准 RFC 1902 到 1908 定义，其中包含其他更改，包括新版本的 SMI (SMIv2)。

- 基于用户的 SNMPv2 (SNMPv2u)：这是 SNMPv2c 的另一种安全方法，它基于用户而不是社区字符串。它被认为比基于方的安全性更简单，但比社区字符串安全性更安全。它由 RFC 1909 和 RFC 1910 定义。它也被正式认为是“实验性的”。

- SNMPv2**：似乎上述所有内容还不够，一家知名供应商决定定义另一种称为 SNMPv2* 的变体，它结合了 SNMPv2p 和 SNMPv2u 的元素。这从未被正式标准化。 （是的，那是名字中的星号。不，这个主题的底部没有脚注，所以不要费心去寻找。是的，在名字中加星号非常混乱。不，我不知道营销人员怎么会因为想出这样的名字而得到高薪。J)

现在，假设您是 20 世纪 90 年代中期的一名网络管理员，并且面对 SNMPv2p、SNMPv2c、SNMPv2u 和 SNMPv2*。你会选哪一个？好吧，如果您和大多数人一样，您会选择“以上都不是”，说“我想我会坚持使用 SNMPv1，直到这些版本 2 的人齐心协力”。这基本上就是发生的事情。这些变体的一些支持者推动了它们，但从未达成任何协议，结果是所有各种各样的 SNMPv2 的成功都受到限制。正如我所说，这是通用标准化重要性的经典例证。

<u>**SNMPv3**</u>

我可以想象，在某个时候，每个人都意识到情况一团糟，并决定“够了”。 1996 年，开始采用新方法解决突出问题并恢复 SNMP 的普遍性。 1998 年，开发了 SNMP 版本 3 (SNMPv3)，其中包括对 SNMP 的额外增强，并最终让所有玩家回到同一个团队。

SNMPv3 是 SNMP 的最新版本，并且仍在积极修订中。 SNMPv3 中的一个重要变化是一种更正式的方式来处理 SNMP 的不同安全方法——显然，这是从 SNMPv2 经验中吸取的教训。

SNMPv3 使用 SNMPv2 协议操作及其 PDU 消息格式，以及来自 SNMPv2 的 SMIv2 标准。 SNMPv3 允许将多种不同的安全方法整合到其架构中，包括描述 SNMPv2u 和 SNMPv2* 中定义的基于用户的安全性的标准，以及新的基于视图的访问控制模型。它还包括辅助管理 SNMP 的附加工具。



###### 3.2.1.5 TCP/IP 互联网标准管理框架和 SNMP 标准

我们现在已经看到存在三个不同版本的 Internet 标准管理框架。其中一些版本有不同的变体。框架的每个版本或变体都包含多个模块化组件。每个组件都有一个或多个定义它的文档。其中一些有多个修订版。加上为 SNMP 和其他支持文档定义的数十个单独的管理信息库 (MIB)，您有什么？一大堆 TCP/IP 标准，就是这样。与任何其他单一 TCP/IP 协议或技术相比，定义 SNMP 部分的 RFC 可能更多。

特别是因为与 SNMP 相关的版本、组件和文档太多，所以我觉得保持所有标准的正确性很重要。为此，我创建了许多表格，这些表格显示了 SNMP 框架的每个版本和变体的主要 SNMP 标准。每个单独的 RFC 定义一个版本的框架的一个组件。

RFC 的通常工作方式是，当发布标准的新版本直接替代旧版本时，旧版本将被新版本“淘汰”。对于SNMP，由于版本较多，变体存在争议，这点不太清楚。例如，IETF 不认为定义 SNMPv2p 的标准会废弃 SNMPv1 的标准，但 IETF 表示 SNMPv2c 和 SNMPv2u 的标准确实会废弃 SNMPv2p 的标准。

为了保持所有这些不同，我决定分别显示每个版本或变体的标准。我只将 RFC 编号用于过时的 RFC，其中这些 RFC 用于相同的 SNMP 版本或变体。例如，RFC 3410 废弃了 2570，因为它们都处理 SNMPv3，而 3410 是 2570 的直接替代品。此外，在少数情况下，标准名称在 RFC 编号之间略有变化；我已经显示了当前名称。

下面六个表中的每一个都显示了其中一个 SNMP 版本或变体的当前和过时标准：SNMPv1（表 199）； SNMPSec（表 200）； SNMPv2p（表 201）； SNMPv2c（表 202）； SNMPv2u（表 203）和 SNMPv3（表 204）。 （SNMPv2* 未使用常规 RFC 流程进行标准化。）


​                                                         **表 199：SNMP 版本 1 (SNMPv1) 标准**

| **Obsolete RFCs** | **Most Recent RFC** | **Date of Most Recent RFC** | **Standard Name**                                  |
| ----------------- | ------------------- | --------------------------- | -------------------------------------------------- |
| 1065              | **1155**            | May 1990                    | 基于 TCP/IP 的互联网管理信息的结构和标识           |
| 1066              | **1156**            | May 1990                    | *用于基于 TCP/IP 的因特网网络管理的管理信息库*     |
| 1067, 1098        | **1157**            | May 1990                    | *简单网络管理协议 (SNMP)*                          |
| 1158              | **1213**            | March 1991                  | *基于 TCP/IP 的互联网网络管理的管理信息库：MIB-II* |

​                                                                   **表 200：SNMP 安全 (SNMPSec) 标准**

| **Obsolete RFCs** | **Most Recent RFC** | **Date of Most Recent RFC** | **Standard Name**                  |
| ----------------- | ------------------- | --------------------------- | ---------------------------------- |
| —                 | **1351**            | July 1992                   | *SNMP 管理模型*                    |
| —                 | **1352**            | July 1992                   | *SNMP 安全协议*                    |
| —                 | **1353**            | July 1992                   | *用于管理 SNMP 方的管理对象的定义* |

​                                                            表 201：基于**Party-Based**的 SNMP 版本 2 (SNMPv2p) 标准

| **Obsolete RFCs** | **Most Recent RFC** | **Date of Most Recent RFC** | **Standard Name**                                     |
| ----------------- | ------------------- | --------------------------- | ----------------------------------------------------- |
| —                 | **1441**            | April 1993                  | *Internet 标准网络管理框架第 2 版简介*                |
| —                 | **1442**            | April 1993                  | *简单网络管理协议 (SNMPv2) 版本 2 的管理信息结构*     |
| —                 | **1443**            | April 1993                  | *简单网络管理协议 (SNMPv2) 版本 2 的文本约定*         |
| —                 | **1444**            | April 1993                  | *简单网络管理协议 (SNMPv2) 版本 2 的一致性声明*       |
| —                 | **1445**            | April 1993                  | *简单网络管理协议 (SNMPv2) 版本 2 的管理模型*         |
| —                 | **1446**            | April 1993                  | *简单网络管理协议 (SNMPv2) 版本 2 的安全协议*         |
| —                 | **1447**            | April 1993                  | *简单网络管理协议 (SNMPv2) 版本 2 的参与方 MIB*       |
| —                 | **1448**            | April 1993                  | *简单网络管理协议 (SNMPv2) 版本 2 的协议操作*         |
| —                 | **1449**            | April 1993                  | *简单网络管理协议 (SNMPv2) 版本 2 的传输映射*         |
| —                 | **1450**            | April 1993                  | *简单网络管理协议 (SNMPv2) 版本 2 的管理信息库*       |
| —                 | **1451**            | April 1993                  | *Manager-to-Manager Management Information Base*      |
| —                 | **1452**            | April 1993                  | *Internet 标准网络管理框架版本 1 和版本 2 之间的共存* |

​                                                              表 202：基于Community-Based 的 SNMP 版本 2 (SNMPv2c) 标准

| **Obsolete RFCs** | **Most Recent RFC** | **Date of Most Recent RFC** | **Standard Name**                                     |
| ----------------- | ------------------- | --------------------------- | ----------------------------------------------------- |
| —                 | **1901**            | January 1996                | *基于社区的SNMPv2简介*                                |
| —                 | **1902**            | January 1996                | *简单网络管理协议 (SNMPv2) 版本 2 的管理信息结构*     |
| —                 | **1903**            | January 1996                | *简单网络管理协议 (SNMPv2) 版本 2 的文本约定*         |
| —                 | **1904**            | January 1996                | *简单网络管理协议 (SNMPv2) 第 2 版的一致性声明*       |
| —                 | **1905**            | January 1996                | *简单网络管理协议 (SNMPv2) 版本 2 的协议操作*         |
| —                 | **1906**            | January 1996                | *简单网络管理协议 (SNMPv2) 版本 2 的传输映射*         |
| —                 | **1907**            | January 1996                | *简单网络管理协议 (SNMPv2) 版本 2 的管理信息库*       |
| —                 | **1908**            | January 1996                | *Internet 标准网络管理框架版本 1 和版本 2 之间的共存* |



​                                         **Table 203: User-Based SNMP Version 2 (SNMPv2u) Standards**

| **Obsolete RFCs** | **Most Recent RFC** | **Date of Most Recent RFC** | **Standard Name**           |
| ----------------- | ------------------- | --------------------------- | --------------------------- |
| —                 | **1909**            | February 1996               | *SNMPv2 的管理基础设施*     |
| —                 | **1910**            | February 1996               | *SNMPv2 基于用户的安全模型* |

​                                     **Table 204: SNMP Version 3 (SNMPv3) Standards**

 

| **Obsolete RFCs** | **Most Recent RFC** | **Date of Most Recent RFC** | **Standard Name**                                            |
| ----------------- | ------------------- | --------------------------- | ------------------------------------------------------------ |
| —                 | **2576**            | March 2000                  | *Internet 标准网络管理框架版本 1、版本 2 和版本 3 之间的共存* |
| —                 | **2578**            | April 1999                  | *管理信息版本 2 (SMIv2) 的结构*                              |
| —                 | **2579**            | April 1999                  | *SMIv2 的文本约定*                                           |
| —                 | **2580**            | April 1999                  | *SMIv2 的一致性声明*                                         |
| 2570              | **3410**            | December 2002               | *互联网标准管理框架简介和适用性声明*                         |
| 2261, 2271, 2571  | **3411**            | December 2002               | *描述简单网络管理协议 (SNMP) 管理框架的体系结构*             |
| 2262, 2272, 2572  | **3412**            | December 2002               | *简单网络管理协议 (SNMP) 的消息处理和调度*                   |
| 2263, 2273, 2573  | **3413**            | December 2002               | *简单网络管理协议 (SNMP) 应用程序*                           |
| 2264, 2274, 2574  | **3414**            | December 2002               | *简单网络管理协议 (SNMPv3) 第 3 版的基于用户的安全模型 (USM)* |
| 2265, 2275, 2575  | **3415**            | December 2002               | *用于简单网络管理协议 (SNMP) 的基于视图的访问控制模型 (VACM)* |
| —                 | **3416**            | December 2002               | *简单网络管理协议 (SNMP) 的协议操作版本 2*                   |
| —                 | **3417**            | December 2002               | *简单网络管理协议 (SNMP) 的传输映射*                         |
| —                 | **3418**            | December 2002               | *简单网络管理协议 (SNMP) 的管理信息库 (MIB)*                 |



除了所有这些表格之外，正如我之前提到的，还有许多描述 MIB 模块的补充 RFC，并且还阐明了与 SNMP 相关的各种操作要点。 列出所有这些会……让我发疯。 抱歉，那些桌子已经够糟糕了。  您可以通过搜索“MIB”或“SNMP”在 RFC 在线列表中找到所有 MIB。

在 internet ：可以在以下位置找到完整的 RFC 超链接列表：http://www.rfc-editor.org/rfc-index.html



##### 3.2.2 管理信息 (SMI) 和管理信息库 (MIB) 的 TCP/IP 结构

互联网标准管理框架定义了三个主要部分，即 描述了如何在一个TCP/IP网络上管理设备。其中之一，实际的 简单网络管理协议（SNMP）是相对知名的，但它只是整体的一部分。但它只是整体的一部分。SNMP描述了SNMP实体之间是如何交换信息的。但另外两个部分也同样重要，因为它们描述了信息的 本身。

在这一节中，我将描述TCP/IP互联网的这两个重要的支持元素 标准管理框架：管理信息库（MIB）标准。管理信息库（MIB）标准描述了SNMP工作的信息类型，以及管理信息结构（SMI）标准。信息结构（SMI）标准，它规定了MIB信息的定义方式。了解 理解SNMP框架的这两个部分是在我们研究实际的SNMP协议本身之前的一个重要的初始步骤。实际的SNMP协议本身。

由于SMI和MIB的关系非常密切，所以在这里对它们进行了综合描述。我首先概述了SMI的数据描述语言，以及管理信息库（MIB）是怎样的。信息库（MIBs）的工作方式。我讨论了MIB对象名称的层次结构和用来指代名称的符号 用来指代名称的符号。我还描述了MIB对象如何工作，讨论了不同的 对象类型和MIB对象组。

**背景信息。**如果你还没有读过描述 SNMP互联网标准管理框架的章节，你应该在阅读之前 在这里继续。
**注意：**我在这里描述了所有版本的SNMP所共有的MIB概念，并且 讨论了这些版本中使用的SMI的具体版本（SMIv1和SMIv2）。SNMP版本中使用的SMI的具体版本（SMIv1和SMIv2）。

###### 3.2.2.1 TCP/IP管理信息结构（SMI）和管理信息库（MIB）概述

真正理解TCP/IP网络管理的关键是理解整个Internet标准管理框架（SNMP Framework）的信息化本质。为了明白我的意思，让我们退后一步，从一般意义上考虑网络管理问题，更具体地说，是管理网络设备的问题。

<u>**了解 SNMP 的面向信息的设计**</u>
网络管理员需要执行两种基本类型的操作：收集有关设备的数据以了解它们的工作方式，以及向设备发出命令以改变它们的工作方式。用最简单的话来说，第一类可以看作是“读”操作，第二类相当于“写”操作。

实现此功能的经典方法是定义通信协议。大多数此类协议都是面向命令的——它们由一组特定的命令组成，用于执行我们上面提到的“读”和“写”操作。例如，网络管理协议可能有一个读取命令，如“报告设备已使用的小时数”，以及一个写入命令，如“将此设备置于测试模式”。网络管理员将通过发出适当的命令来控制设备。

面向命令的管理协议具有简单的优点：命令的用途和使用方式一目了然。它可能相当适合在某些环境中使用，但在大型、异构的 TCP/IP 互联网络上效果不佳。这样做的主要原因是命令导向不可避免地将协议与被管理的设备联系在一起。考虑：

- 每种类型的设备都可能需要一组不同的命令。例如，给路由器的命令可能需要与给主机的命令不同。这将导致协议中命令的激增，或者导致对不同设备类型的适当管理不灵活。

- 每当一家公司创造出一种新型设备，或制作一种设备的独特版本时，网络管理协议都必须更改。

- 每当一种设备的操作发生变化时，可能由于另一种协议的变化，管理协议就需要更新。

- 在不影响大量硬件的情况下，协议本身无法轻易更改。

面向命令的管理协议问题的解决方案是使用面向信息的模型。不是定义询问或控制设备的特定命令，而是根据要在设备和管理站之间交换的信息单元来定义设备。

我们有可以“读”或“写”的变量，而不是“读”命令和“写”命令。举前面提到的两个例子。代替“报告设备已使用小时数”之类的命令，设备保留一个名为“使用小时数”的变量，网络管理站可以将其作为许多变量之一“读取”，无需需要特定的协议命令。设备有一个名为“当前模式”的变量，而不是名为“将此设备置于测试模式”的“写入”命令。网络管理员可以通过更改变量的值将设备的模式更改为“测试”。

这种差异看似微妙，但实际上是 SNMP 工作方式的各个方面的基础。我认为 SNMP 框架难以理解的部分原因是因为没有充分强调以“SNMP 方式”看待事物，这意味着考虑信息对象而不是命令。

**关键概念：**与大多数面向命令的协议不同，SNMP 是面向信息的。 SNMP 操作是使用被管理设备中维护的称为变量的对象来实现的。网络管理站不是发布命令，而是通过读取变量来检查设备的状态，并通过更改（写入）变量来控制设备的操作。

<u>**管理信息库 (MIB) 和 MIB 对象**</u>

在这种背景下，我们可以用新的眼光来看待 SNMP 框架。我们将在下一节中研究的实际 SNMP 协议本身只有几个通用命令来完成上面提到的“读取”和“写入”任务。它只涉及在 SNMP 代理和 SNMP 网络管理站之间交换网络管理信息的方法。网络管理信息确实是 TCP/IP 网络管理的核心。

因此，SNMP 不是根据用于控制特定设备的命令定义的，而是根据管理信息变量（通常称为对象）定义的。每个对象都描述了设备的特定特性。有些对象相当通用，对 TCP/IP 网络上的任何设备都有意义；例如，描述与 Internet 协议本身相关的事物的对象，例如设备的 IP 地址。其他对象可能特定于特定类型的设备；例如，路由器将具有常规主机的以太网网络接口卡所没有的对象。

SNMP 中使用的对象集合称为管理信息库或 MIB。 （事实上，SNMP 对象通常称为 MIB 对象。）SNMP 的第一个版本 SNMPv1 具有为 SNMP 定义整个 MIB 的单一标准。然而，较新的版本通过使用不同的 MIB 模块提供了更大的灵活性，这些模块定义了特定于设备使用的硬件或软件的变量集。

使用模块定义对象允许在定义允许管理不同类型设备的变量时具有显着的灵活性。一个设备可以包含所有适用于它使用的硬件和软件的 MIB 模块。例如，如果您有一个使用以太网的设备，它将包含来自以太网 MIB 的变量；使用令牌环的人将使用令牌环 MIB。两个设备还将使用所有 TCP/IP 设备使用的公共 SNMP MIB。还可以根据需要包含其他模块。我们将在本节后面看到更多它是如何工作的。

**关键概念：**受管设备中的管理数据变量保存在称为管理信息库 (MIB) 的逻辑集合中。 MIB 中的对象通常称为 MIB 对象，并且通常被收集到称为 MIB 模块的集合中。

<u>**定义 MIB 对象：管理信息结构 (SMI)**</u>

MIB 对象的使用解决了网络管理协议绑定到网络管理信息的问题。但是，我们必须非常注意如何定义这些对象。同样，原因是 TCP/IP 允许连接在一起的设备种类繁多。每个设备可能以不同的方式表示信息；为了让它们相互通信，我们需要确保管理信息以一致的方式表示。

确保 MIB 对象通用性的 SNMP 框架部分是管理信息结构 (SMI) 标准。 SMI 定义了如何构建 MIB 对象和 MIB 模块的规则。在 SMI 中，使用一组精确的定义来描述 MIB 对象，这些定义基于称为 ISO 抽象语法表示法 1 (ASN.1) 标准的数据描述语言。

那么本质上，我们在 SNMP 中确实具有三个“抽象级别”。实际的 SNMP 协议移动代表管理设备状态的值。 MIB 定义了这些变量是什么。 SMI 定义了 MIB 中的变量本身是如何定义的。

有两个主要的 SMI 标准。最初的 SMIv1 是 RFC 1155 中定义的第一个 SNMP 框架 SNMPv1 的一部分。它规定了管理信息库和 MIB 变量的基本规则。第二个是 SMIv2，在 RFC 1442 中定义为 SNMPv2p 的一部分，并在 RFC 2578（SNMPv3 的一部分）中进一步更新。它与早期版本相似，但定义了更多的对象类型以及 MIB 模块的结构。

这些 SMI 标准负责定义 SNMP 中的以下重要信息元素：

- 与所有 MIB 对象关联的一般特征。 SMI 定义了描述所有 MIB 对象的标准方式。

- 可以创建的不同类型的 MIB 对象，例如整数、字符串和更复杂的数据类型。

- 用于命名 MIB 对象的层次结构，因此可以以一致的方式对它们进行寻址，而不会出现名称重叠。

- 与每个 MIB 模块关联的信息。

**关键概念：**管理信息结构 (SMI) 标准负责定义 MIB 对象的结构、描述和组织方式的规则。 SMI 允许不同的设备通过确保它们对所有管理信息使用通用数据表示来进行通信。


事实上，SMI 和 MIB 标准密切相关，很难单独讨论其中一个。本节的其余部分将参考 SNMP 框架组件讨论 SNMP 管理信息结构。我们将了解 MIB 对象的定义方式和每个对象的特征，并了解 MIB 数据类型、用于组织 MIB 对象的结构以及 MIB 模块和对象组的工作方式。

**注：**由于名称的关系，管理信息库常被称为“数据库”。严格来说，这是不准确的。 MIB 是对象的描述。设备中的实际 MIB 可以作为软件数据库来实现，但并非必须如此。



###### 3.2.2.2 TCP/IP MIB对象、对象特征和对象类型

Internet 标准管理框架（SNMP 框架）旨在促进管理信息的交换。管理信息库 (MIB) 定义了设备的管理信息。 MIB 包含许多称为 MIB 对象的变量；它们也称为托管对象。这些对象是根据管理信息结构 (SMI) 标准中规定的规则定义的。

查看 MIB 对象的最佳起点是检查定义它们的 SMI 规则。正如我在本节前面提到的，已经创建了两个不同版本的 SMI：SMIv1 作为原始 SNMP 的一部分，SMIv2 作为 SNMPv2 和 SNMPv3 的一部分。两者在 MIB 对象的描述方式上相似，但 SMIv2 允许更多信息与每个对象相关联。

<u>**MIB 对象强制特性**</u>
正如典型的协议使用字段格式来指定使用协议在设备之间发送的消息的内容一样，SMI 使用指定每个 MIB 对象的基本特征的格式。其中最基本的是 SMIv1 中定义的五个强制性特征。这些也在 SMIv2 中使用，但更改了几个名称，并且还修改了某些字段的可能值。图 272 从概念上显示了这一点。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\images\snmpmibobjects (1).png)


​                                                                        图 272：SNMP 管理信息库 (MIB)

此图显示了包含“N”个 MIB 对象的 SNMP 管理信息库。每个对象都有五个强制性特征和数量可变的可选特征。

<u>**对象名称**</u>
每个对象都有一个名称，用于唯一标识它。实际上，这并不完全正确。每个对象实际上有两个名称：称为对象描述符的文本名称和指示对象在 MIB 对象名称层次结构中位置的数字对象标识符。我敢肯定这对您来说毫无意义，但这就是为什么我包含了下一个主题，讨论对象命名，希望它会（有意义。）

<u>**语法**</u>

对象的语法定义了它的数据类型和描述它的结构。 MIB 对象的这个属性非常重要，因为它定义了对象包含的信息的数据类型。允许的数据类型有两种基本类别：

- 常规数据类型：这些是单条信息，属于我们习惯于定期处理的类型；例如整数或字符串。这些在 SMIv2 中称为基本类型。 SMIv1 区分原始类型（如 ASN.1 中定义的整数）和作为原始类型特殊形式的已定义类型，这些原始类型仍然是单条信息，但在它们的使用方式上具有特定的特殊含义。 SMIv2 不使用这两个术语。

- 表格数据：多个数据元素的集合。这可以采用基本类型列表或基本类型表的形式。例如，可以构造一个整数表来表示一组值。在 SMIv1 中，这些被称为构造函数类型；在 SMIv2 中，它们是概念表。可以使用专为读取表格而设计的特殊 SNMP 机制来访问它们。有关表的更多信息，请参阅有关 SNMP 表遍历的主题。

<u>**访问（SMIv2 中的最大访问）**</u>
该字段定义 SNMP 应用程序通常使用该对象的方式。在 SMIv1 中，有四种不同的可能值：只读、读写、只写和不可访问。

在 SMIv2 中有五个值，它们被描述为排序的层次结构。 SMIv2 将此特性称为 Max-Access（最大访问权限），以明确表示较高的访问级别也包括较低的级别。例如，具有读-创建访问权限的对象也可以在“低于它”的任何模式下使用，例如读写，但反之则不行。表 205 显示了五个 SMIv2 访问值，按访问的降序排列。请注意，只写已在 SMIv2 中删除：


​                                                             **表 205：SNMP SMI 版本 2 最大访问值**

| ***Max-Access\* Value**      | **Description**                           |
| ---------------------------- | ----------------------------------------- |
| ***read-create\***           | 可以读取、写入或创建对象。                |
| ***read-write\***            | 对象可以被读取或写入。                    |
| ***read-only\***             | 对象只能被读取。                          |
| ***accessible-for-notify\*** | 只能使用 SNMP 通知（SNMP 陷阱）使用对象。 |
| ***not-accessible\***        | 用于特殊用途。                            |

<u>**状态**</u>
表示对象定义的单位。在SMIv1中，有三个值：强制性的、可选的和过时的。在SMIv2中，前两个被合并成简单的current，意味着当前的定义。obsolete值被保留，deprecated被添加，意味着该定义已经过时，但为了兼容而保留。

<u>**定义（SMIv2中的描述）**</u>
该对象的文本描述。

**关键概念。**每个管理信息变量，称为MIB对象，都有与之相关的五个关键属性：其名称、语法、最大访问量、状态和定义。它还可能有一些可选特性。

<u>**SMIv2 MIB 对象可选特性**</u>

SMIv2 添加了以下可能出现在对象定义中的可选特征：

- 组织：与对象关联的单位的文本描述。

- 参考：对相关文档或与对象相关的其他信息的文本交叉引用。

- 索引：用于定义实际上是其他对象的更复杂“行”的对象的值。

- 增强：索引字段的替代方法。

- DefVal：为对象定义可接受的默认值。

<u>**SMI 常规数据类型**</u>
表 206 显示了 SMIv1 和 SMIv2 中对象支持的常规数据类型。 （其中带有“32”的名称是 SMIv2 中使用的名称；它们已更改以使类型的位大小明确。）表中的前五个条目是原始类型，其余是定义类型，使用 SMIv1 术语。


​                                                         **表 206：SNMP SMI 常规数据类型**

| **Data Type Code**                 | **Description**                                              | **SMIv1?** | **SMIv2?** |
| ---------------------------------- | ------------------------------------------------------------ | ---------- | ---------- |
| ***Integer / Integer32\***         | 二进制补码表示法中的 32 位有符号整数，能够保存从 -2,147,483,648 到 +2,147,483,647 的值。也可以用来表示一个枚举类型；例如，其中 1 表示特定常数，2 表示不同的常数，依此类推。 | Yes        | Yes        |
| ***Octet String\***                | 二进制或文本数据的可变长度字符串。                           | Yes        | Yes        |
| ***Null\***                        | Nothing.                                                     | Yes        | —          |
| ***Bits\***                        | 命名位的枚举。用于允许将一组位标志视为单一数据类型。         | —          | Yes        |
| ***Unsigned\***                    | 一个 32 位无符号整数，从 0 到 4,294,967,295。                | —          | Yes        |
| ***Network Address / IpAddress\*** | IP 地址，编码为 4 字节八位字节字符串。                       | Yes        | Yes        |
| ***Counter / Counter32\***         | 一个 32 位无符号整数，从 0 开始增加到 4,294,967,295，然后返回到 0。 | Yes        | Yes        |
| ***Gauge / Gauge32\***             | 一个 32 位无符号整数，可能具有从 0 到 4,294,967,295 的值，并且可以增加或减少，就像一个仪表。最小值和最大值与仪表关联，指示其正常范围。 | Yes        | Yes        |
| ***TimeTicks\***                   | 一个 32 位无符号整数，指示自某个任意开始日期以来的百分之一秒数。用于时间戳和计算经过的时间。 | Yes        | Yes        |
| ***Opaque\***                      | 使用任意 ASN.1 语法的数据将在设备之间传递而不被解释。与 NFS 的 XDR 一样，术语“不透明”意味着数据被视为内部细节不可见的“黑匣子”。 | Yes        | Yes        |
| ***Counter64\***                   | 一个像 Counter32 但 64 位宽的计数器，允许值从 0 到 18,446,744,073,709,551,615。 | —          | Yes        |



<u>**SMIv2 文本约定**</u>

除了这些类型之外，还创建了其他定义的类型，以再次指示特定数据类型的更具体的语义。 这些称为文本约定，在 SMIv2 的 RFC 2579 中进行了描述。 例如，定义了一个名为 TimeStamp 的类型，它与 TimeTicks 相同。 但是，看到一个对象使用前者而不是后者可以更清楚地表明该变量代表特定的时间戳值。 另一个称为 TimeInterval，它也只是其名称下的一个整数，但传达了不同的解释含义。

<u>**SMIv2 对象定义示例**</u>
如果以上所有内容让您感到很困惑，请注意本主题实际上是 SMI 对象定义的重要简化。 SNMP 非常有趣！ 如果示例有帮助，请查看表 207，它显示了 RFC 3418 中使用 SMIv2 的对象定义。


​                                                                **表 207：示例 SNMP SMIv2 对象定义**

```
sysLocation OBJECT-TYPE
SYNTAX DisplayString (SIZE (0..255))
MAX-ACCESS read-write
STATUS current
DESCRIPTION "The physical location of this node (e.g., 'telephone closet, 3rd floor'). If the location is unknown, the value is the zero-length string."
::= { system 6 }
```

请注意，DisplayString 是显示文本字符串的文本约定。 最后一部分，“{system 6}”，将在下一个主题中解释。



###### 3.2.2.3 TCP/IP MIB对象描述符和标识符以及对象名称层次和名称符号

在众多 MIB 对象特征中，只有一个非常有趣，值得单独阐述。 或者我应该说，只有一个足够复杂，它确实如此。 J 这是对象名称，是用于 MIB 对象的更大命名系统的一部分。

正如我之前所说，每个 MIB 对象实际上有两个名称：对象描述符和对象标识符。 对象描述符是一个传统的文本名称，它提供了一个“用户友好的句柄”来引用对象。 该名称是根据对象所在的特定 MIB 对象组分配的。 在我在上一主题末尾给出的示例定义中，sysLocation 是该 MIB 对象的对象描述符。 我将在下一个主题 MIB 模块和对象组中更详细地描述这些名称。

<u>**MIB 对象名称层次结构**</u>

文本名称很方便，但它们通常是非结构化的。目前有超过 10,000 个不同的 MIB 对象，即使每个对象都有不同的文本名称，大量此类名称也无助于我们管理这些对象并了解它们之间的关系。为此，我们需要一种更加结构化的方法来对对象进行分类和命名。

这个问题类似于您可能记得读过的另一个问题：如何在 Internet 上分配名称的问题。最初主机的名称是简单的“平面”名称，但这很快就变得笨拙了。域名系统 (DNS) 将域名的结构化层次结构形式化。 DNS 分层名称空间允许将每个设备排列成一个单一的分层树结构。设备的名称可以通过从上到下遍历树到设备的位置来形成，列出遍历的标签以点分隔。例如，The PC Guide 的 Web 服务器位于“www.pcguide.com”。

这个完全相同的概念用于在 SNMP 中组织 MIB 对象。使用包含所有 MIB 对象的单一通用层次结构。它本质上是分层的，从最一般到最具体分为多个级别。每个对象在层次结构中都有一个特定的位置。名称是按照标签从树的顶部向下到对象所在的位置形成的，并用“点”将它们分隔开。 （然而，SNMP 并不像 DNS 那样颠倒标签的顺序。它们是从左到右自上而下列出的。）

MIB 名称层次结构与 DNS 名称层次结构之间还有另一个重要区别：MIB 名称层次结构甚至比 DNS 名称层次结构更为通用。所有 MIB 对象的整个子树只是 ISO 和 ITU 维护的完整国际对象层次结构的一个分支。这个对象标识层次结构非常通用，它可以包含全世界任何技术使用的每个对象或变量的名称。可能还有其他行星。或太阳系。杰

我开玩笑的原因马上就会明白。可以说，这个对象树是巨大的。这棵树中的每个节点都用一个标签和一个整数来标识。标签用于描述目的；对象（或子树）标识符是通过从树的顶部到节点的顺序列出数字来形成的，用点分隔。 （文本标签也可以用于名称，但不是因为树结构有多深，它们会变得很长。）

**关键概念：**SNMP MIB 对象有两个名称。第一个是文本对象描述符，它提供了一种以人类熟悉且容易的方式寻址对象的方法。第二个是对象标识符，它由一系列整数组成，指定对象在国际标准机构 ISO 和 ITU 维护的全局对象层次结构中的位置。

<u>**MIB 对象名称层次结构**</u>

让我们探索 MIB 对象树的结构，更重要的是，SNMP MIB 对象如何融入其中（您可能会发现参考图 273 对您很有用。）树的根没有标签，有三个孩子：

- ccitt(0)：用于 ITU（以前的 CCITT）标准。 （也被视为 itu(0)）。

- iso(1)：用于 ISO 标准。

- joint-iso-ccitt(2)：用于联合标准。 （也被视为 joint-iso-itu(2)）。

在 iso(1) 节点之后，我们在接下来的几个级别中看到以下内容：

- 在 iso(1) 中，ISO 创建了一个供其他组织使用的子树，称为 org(3)。

- 在 org(3) 中，有一个美国国防部的子树，您可能记得它是 Internet 的发起者：dod(6)。

- 在 dod(6) 中，有一个名为 internet(1) 的子树。

我们在 SNMP 中使用的所有东西都在这个非常具体的子树下：1.3.6.1，如果我们使用文本标签将是“iso.org.dod.internet”。 在这部分名称空间中，有以下六个子树：

- directory(1)：保留供 ISO 将来使用。

- mgmt(2)：MIB对象所在的主子树。这是“1.3.6.1.2”。它包含一个名为 mib(1) 的子树，即 1.3.6.1.2.1。创建 MIB-II 时，使用相同的编号 1.3.6.1.2.1 创建了名为 mib-2(1) 的子树。

- experimental(3)：包含用于正在开发的标准的对象。这是“1.3.6.1.3”。

- private(4)：用于私人公司定义的对象。这个节点 1.3.6.1.4 有一个名为 enterprise(1) 的子树，即 1.3.6.1.4.1。

- security(5)：保留用于安全用途。

- snmpV2(6)：定义专门用于 SNMP 版本 2 的对象。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\images\snmptree.png)

​                                                               **图 273：全局对象名称层次结构和 SNMP MIB 层次结构**

此图显示了 ISO 和 CCITT (ITU) 定义的对象名称层次结构，以允许所有类型的对象被普遍表示。在这个较大的树中到与 SNMP 相关的树枝的“路径”可以通过彩色框找到。用于 SNMP 的两个子树以浅蓝色显示。每个都包含自己的子结构（其中一些用紫色框表示），定义了数千个不同的 MIB 对象。左侧的分支用于通用 MIB 对象，右侧的分支用于私有对象。还为 SNMP V2 定义了一个单独的层次结构。


呸。那么，这一切的底线是什么？好吧，基本上所有 MIB 模块对象都在整个对象树的这两个分支之一中命名：

- 常规 MIB 对象：这些位于 mgmt(2) 下的 mib(1) 子树中：1.3.6.1.2.1。

- 私有 MIB 对象：这些对象位于 private(4) 下的 enterprise(1) 子树中，即 1.3.6.1.4.1。例如，在 enterprise(1) 中有一个用于 Cisco Systems 的条目 cisco(9)。因此，所有 Cisco 特定的 MIB 对象都以 1.3.6.1.4.1.9 开头。

清澈如泥，对吧？为什么他们不直接创建一个单独的层次结构，其中“mib”位于顶部而不是 6 层深？你怎么敢提出这样的建议。你不明白全球标准的重要性吗？杰

撇开这些玩笑不谈，这个名称层次结构处理起来有点麻烦（好吧，不止一点），但它确实允许我们以合理的方式组织 MIB 对象。在 1.3.6.1.2.1 子树中，我们找到了 SNMP 中使用的大多数常规 MIB 对象。 1.3.6.1.2.1 中的每个子树对应于一个常规 SNMP 对象组或一个特定的 MIB 模块。

**关键概念：**所有 MIB 对象都具有适合全局对象层次结构的两个分支的对象标识符。常规 MIB 对象（不是供应商特定的）适合 mgmt(2) 下的 mib(1) 子树：1.3.6.1.2.1。可以由硬件供应商创建以协助管理该供应商的产品的私有对象位于 private(4) 下的 enterprise(1) 子树中，即 1.3.6.1.4.1

<u>**MIB 对象标识符的递归定义**</u>

如表 207 所示，通过将对象的名称放在对象的开头，为对象提供文本对象描述符，但数字对象标识符的定义同样更加复杂。 这是通过仅定义对象在其特定子树中的编号来完成的。 这意味着对象标识符是递归定义的（一个基于另一个）并且没有为每个对象明确说明。 语法精确，但很难一眼看出任何特定对象的数字是多少。

再次考虑表 207 中的示例。对于此对象，sysLocation 是对象描述符，“{system 6}”是对象标识符。 这意味着它是节点系统中的第 6 个对象，又定义为“{ mib-2 1 }”——它是 mib-2 子树中的第一个节点。 正如我们上面所说，由于 mib-2 是 1.3.6.1.2.1，这意味着系统是 1.3.6.1.2.1.1，sysLocation 是 1.3.6.1.2.1.1.6。



###### 3.2.2.4 TCP/IP MIB模块和对象组

管理信息库 (MIB) 包含 MIB 对象的集合，这些对象使用 Internet 标准管理框架（SNMP 框架）描述设备的特征。最初创建 SNMP 时，MIB 中没有那么多对象。此外，它们大多是相当普遍地应用于整个 TCP/IP 设备的“通用”对象。事实上，大多数 MIB 对象都是与 IP、TCP 和 ICMP 等 TCP/IP 协议的操作相关的变量。

出于这个原因，最初，一个文档定义了 SNMP 的“the”管理信息库 (MIB)。这些文档中的第一个是 RFC 1066，它是初始 SNMPv1 规范的一部分。然后在 RFC 1156 中对其进行了修订。在 RFC 1158 中，定义了 MIB 的第二个版本 MIB II，它在本质上是相同的，但做了一些更改。

<u>**将 MIB 对象组织成对象组**</u>
这些标准中定义的 MIB 对象数量相对较少。但是，仍然有几十个，并且从一开始就意识到会及时创建更多。为了帮助以逻辑方式组织对象，将它们排列成对象组。这些组的目的是分离对象并定义如何在整个对象名称层次结构中为它们提供对象标识符。

每个组都与三个重要信息相关联：

- Group Name：我们在上一个主题中看到的对象标识树中用作文本标签的名称。这些对象都位于“iso.org.dod.internet.mgmt.mib”子树中。因此，例如，组系统将是“iso.org.dod.internet.mgmt.mib.system”。

- 组号：与组名对应的数字，用于从对象名称树中制作数字标识符。例如，组系统的编号为 1，因此组的对象标识符为 1.3.6.1.2.1.1。该组中的所有对象都将在那棵树下；例如，sysUpTime 为 1.3.6.1.2.1.1.3。

- Group Code：文本标签，可以与组名相同，也可以是缩写。它用作制作对象描述符（对象的文本名称）的前缀。例如，对于组系统，代码是 sys，因此该组中的对象是 sysUpTime。

<u>**通用 MIB 对象组**</u>

表 208 显示了 RFC 1158 中定义的八个通用 SNMP 组及其代码、名称和编号。


​                                                                  **表 208：SNMP 通用 MIB 对象组**

| **Group Name**                  | **Group Code** | **Group Number** | **Full Group Identifier** | **Description**                                              |
| ------------------------------- | -------------- | ---------------- | ------------------------- | ------------------------------------------------------------ |
| ***system\***                   | ***sys\***     | 1                | 1.3.6.1.2.1.1             | 与所有或大多数设备相关的一般对象。例如，设备的一般描述是这个组中的一个对象，作为对象的标识符也是如此。后来的 MIB 版本极大地扩展了该组中的变量数量。 |
| ***Interfaces\***               | ***if\***      | 2                | 1.3.6.1.2.1.2             | 与此设备和互联网之间的 IP 接口相关的对象；回想一下，一台普通主机通常有一个接口，而路由器有两个或更多接口。 |
| ***at (address translation)\*** | ***at\***      | 3                | 1.3.6.1.2.1.3             | 用于 IP 地址转换的对象。 （不再使用。）                      |
| ***ip\***                       | ***ip\***      | 4                | 1.3.6.1.2.1.4             | 与整个设备的 IP 层相关的对象（与 if 组中的接口特定信息相对）。 |
| ***icmp\***                     | ***icmp\***    | 5                | 1.3.6.1.2.1.5             | 与 Internet 控制消息协议的操作相关的对象。                   |
| ***tcp\***                      | ***tcp\***     | 6                | 1.3.6.1.2.1.6             | 与传输控制协议操作相关的对象。                               |
| ***udp\***                      | ***udp\***     | 7                | 1.3.6.1.2.1.7             | 与用户数据报协议操作相关的对象。                             |
| ***egp\***                      | ***egp\***     | 8                | 1.3.6.1.2.1.8             | 与外部网关协议操作相关的对象。                               |
| ***cmot\***                     | ***cmot\***    | 9                | 1.3.6.1.2.1.9             | 与在 TCP 上运行 CMIP 协议相关的对象（历史的，未使用。）      |
| ***transmission\***             | ***trans\***   | 10               | 1.3.6.1.2.1.10            | 与系统上各个接口使用的特定信息传输方法相关的对象。           |
| ***snmp\***                     | ***snmp\***    | 11               | 1.3.6.1.2.1.11            | 用于管理 SNMP 本身的对象。                                   |

此表中的所有组都相当通用，除了关于 EGP 的组外，几乎适用于每个使用 SNMP 的 TCP/IP 系统。 前五组和最后一组对所有系统都是“强制性的”； 其他仅由使用指定协议或功能的设备使用。 提到 EGP，一种现在被认为过时的路由协议，显示了这个列表的年代。

<u>**MIB 模块**</u>

表 208 最引人注目的是不在其中的组。大多数其他 TCP/IP 协议都没有组，特定硬件类型可能需要的变量也没有组。例如，大多数主机都会有一个使用第二层协议（如以太网或令牌环）的网卡；管理者如何检查或控制该硬件的运行？ OSPF 或 BGP 等较新的路由协议怎么样？与运行域名系统相关的对象如何？

不断更新 MIB 文档是不切实际的。相反，在 SNMPv2 中，管理信息库从单个文档更改为一组文档。保留了对象组的基本组织，但不是所有组都在同一标准中，而是分为多个标准。还为如何创建 MIB 模块定义了一种方法，该模块描述特定于特定技术的新对象组。这些模块的列表由 IANA 维护，该组织维护所有这些类型的编号。

internet：可在此处找到当前的 SNMP MIB 模块列表：http://www.iana.org/assignments/smi-numbers


MIB 模块的使用使得将 SNMP 支持放入设备有点像“去购物”。将所有设备通用的基本组合并到每个设备中，然后根据需要使用其他模块/组。表 209 提供了 MIB 模块的简要选择，让您了解那里有什么，还显示了模块的组号（在 1.3.6.1.2.1 名称子树中）：

​                                                            **表 209：一些常见的 SNMP MIB 模块**

| **MIB Module Name**  | **Group Number** | **Description**                                              |
| -------------------- | ---------------- | ------------------------------------------------------------ |
| **ospf**             | 14               | 与开放最短路径优先协议相关的对象。OSPF                       |
| **bgp**              | 15               | 与边界网关协议相关的对象。bgp                                |
| **rmon**             | 16               | 用作远程网络监控 (RMON) 的一部分的对象，我们将在本章稍后部分对其进行研究。 |
| **snmpDot3 RptrMgt** | 22               | 与 IEEE 802.3（以太网）中继器相关的对象。                    |
| **rip-2**            | 23               | 用作路由信息协议版本 2 的一部分的对象。                      |
| **snmpDot3 MauMgt**  | 26               | 与 IEEE 802.3（以太网）媒体连接单元相关的对象。              |
| **etherMIB**         | 35               | 类似以太网的通用对象。                                       |
| **mipMIB**           | 44               | 移动 IP 对象。                                               |
| **ipMIB**            | 48               | SNMPv2 的 Internet 协议对象。                                |
| **tcpMIB**           | 49               | SNMPv2 的传输控制协议对象。                                  |
| **udpMIB**           | 50               | SNMPv2 的用户数据报协议对象。                                |

当然还有很多很多。 上表中的最后三个条目可能看起来有点混乱，因为在上面的第一个表中已经有 IP、TCP 和 UDP 组。 这样做的原因是，当在 SNMPv2 中创建 MIB 对象的新模块化架构时，作为 SNMPv1 中“一个文档”一部分的各个协议的对象定义被分离到各个 MIB 文档中以保持一致性，并且 允许它们独立更新。 事实上，“基础”SNMPv2 和 SNMPv3 MIB 文档现在只定义系统和 snmp 组中的对象。

**关键概念：**在 SNMP 历史早期创建的 MIB 对象被组织成位于 mib(1) 子树中的 MIB 对象组，从标识符代码 1.3.6.1.2.1 开始。 随着 TCP/IP 的普及，集中定义所有 MIB 对象变得不切实际，因此现在在 MIB 模块中指定特定于不同硬件设备的对象集。

<u>**MIB 模块格式**</u>

MIB 模块的格式在管理信息结构标准版本 2 (SMIv2) 中进行了描述。该文档通过列出每个模块描述中必须包含的一组特征，指定了如何以与定义对象本身非常相似的方式定义模块。模块字段是：

- 模块名称：模块的名称。请记住，模块在句法上确实是对象，因此与常规对象一样，它们具有文本对象描述符（如 tcpMIB）和对象标识符（在 tcpMIB 的情况下，数字为 50）。

- 上次更新：模块上次修订的日期和时间。

- 组织：管理模块开发的组织的名称。

- 联系信息：该模块“负责人”的姓名、地址、电话号码和电子邮件地址。

- 描述：模块的描述。

- 修订和修订说明：为模块的每个修订放置一个修订条目以显示其历史。每个条目都有一个与之关联的描述。

在定义了模块本身之后，描述了模块中的对象。例如，请参阅 RFC 2012，它定义了我们在此示例中讨论的 SNMPv2 TCP MIB。

 

##### 3.2.3 TCP/IP 简单网络管理协议 (SNMP) 协议

TCP/IP 网络的整体网络管理解决方案是 Internet 标准管理框架。在最后两小节中，我们从整体上了解了该框架，还讨论了定义在 TCP/IP 设备之间传输的管理信息以完成网络管理的两个组件。 SNMP 框架的第三个主要部分是实际的简单网络管理协议 SNMP，它负责在设备之间移动管理信息。

在本节中，我将描述实际 SNMP 协议的概念和操作。我从协议的简要概述和历史开始，一般性地讨论它。然后我有两个小节详细描述 SNMP 的操作。第一部分涵盖协议执行的不同操作及其工作原理。第二个讨论协议消息传递和消息格式。

**背景信息：**在继续本节之前，请确保您对 SNMP 管理信息库 (MIB) 和 MIB 对象有充分的了解。




###### 3.2.3.1 SNMP 协议概述、历史和一般概念（部分：1 2）

我已经将 TCP/IP Internet 标准管理框架（SNMP 框架）描述为面向信息的。在 SNMP 框架的设计中做出了一个特定的决定，以将 SNMP 代理和 SNMP 管理器之间传送的管理信息与用于携带该信息的协议分离。这为整个技术提供了许多好处，其中最主要的是灵活性和模块化。

在此模型中，管理协议的操作未根据检查设备状态或更改其操作方式的特定命令来定义。相反，该协议是根据称为对象的管理信息变量和允许网络管理员检查或更改这些对象的通信协议来定义的。我在概述 SNMP 管理信息库 (MIB) 和管理信息结构 (SMI) 的主题中详细描述了这个概念。

MIB 和 SMI 阐明了如何创建和描述 MIB 对象的规则。这些 MIB 对象描述了可以从设备读取或写入设备的信息类型。最后一块拼图是负责这些“读”和“写”操作的实际协议。这是简单网络管理协议本身，我给它起了一个有点多余的名称 SNMP 协议，以区别于 SNMP 框架。

协议与其承载的管理信息分离的结果是协议本身的复杂性显着降低。 SNMP 协议不必定义数十个甚至数百个操作来指定特定的网络管理功能，它只需要处理 MIB 对象信息在 SNMP 代理和管理器之间的传输。 SNMP 协议本身并不关注这些对象中的内容；它只关心移动它们。在某些方面，SNMP 协议是 SNMP 中唯一真正简单的部分！

<u>**SNMPv1的早期发展**</u>
SNMP 协议的历史可以追溯到 SNMP 框架的前身简单网关监控协议 (Simple Gateway Monitoring Protocol, SGMP)，它于 1987 年在 RFC 1028 中定义。正如我在 SNMP 框架概述中所解释的那样。然而，在这个标准中可以找到许多作为现代 SNMP 协议基础的基本设计概念。

SGMP 标准通过仅检索或更改存储在 Internet 网关（路由器）上的变量来描述 SGMP 协议，从而指定了 SNMP 中使用的基本设计模型。该标准还概述了少量协议操作，这些操作仍然是当今 SNMP 操作的基础。

SNMP 框架的第一个版本 SNMPv1 在 RFC 1067（后来由 RFC 1098 和 1157 修订）中包含了 SNMP 协议的第一个正式定义。该标准细化了 SGMP 文件中给出的协议操作。它使 SNMP 协议的操作适合整个 SNMP 框架，与正式定义的 MIB 对象一起工作。

<u>**SNMPv2 和 SNMP 划分为协议操作和传输映射**</u>

创建 SNMPv2 时，描述 SNMP 协议的单一文档被分成两个标准，以使该协议更加模块化并更好地反映互联网络中使用的层。这个划分在 SNMPv3 中也得到了维护。这两类文件规定了以下内容：

- 协议操作：该对文档中的第一个文档描述了使用特定 SNMP 消息类型在 SNMP 设备之间移动 MIB 对象的实际机制。在 SNMPv3 中，它是 RFC 3416，简单网络管理协议 (SNMP) 的协议操作版本 2。当人们只谈论“SNMP 标准”时，他们通常指的是该文档。

- Transport Mappings：第二个文档详细说明了上面第一个标准中描述的 SNMP 协议操作如何可以通过各种不同的协议套件进行传输。通过使用正确的映射，可以使用 IP 以外的低层技术执行 SNMP 操作。该标准在 SNMPv3 中由 RFC 3417，简单网络管理协议 (SNMP) 的传输映射表示。

我在有关 SNMP 消息传递的主题中更详细地讨论了传输映射，但是由于 IP/UDP 是迄今为止最常见的传输机制，因此关于 SNMP 协议的这方面没有太多要说的。我们对 SNMP 的大部分关注将集中在 SNMP 协议操作上：使用什么消息、它们的结构如何以及它们如何交换。在检查这些消息时，我们将看到 SNMP 中发生信息交换的两种主要方式（通过轮询和通过中断），还将发现 SNMP 协议如何与 MIB 对象一起工作。

**关键概念：**用于在网络管理站和被管理设备之间传递管理信息的实际机制称为简单网络管理协议，为了区别于 SNMP 框架，可将其称为 SNMP 协议。它包含许多描述设备之间发生的实际消息交换的协议操作，以及一组定义这些消息如何在各种类型的互联网上传输的传输映射。 Internet 协议是用于 SNMP 的最常见的传输映射。



###### 3.2.3.2 SNMP 协议操作

简单网络管理协议 (SNMP) 是负责允许 TCP/IP 互联网络上的网络管理站对受管设备执行管理任务的协议。该协议的核心由一组协议操作组成，这些操作允许在 SNMP 代理和管理器之间交换管理信息。之前检查了 SNMP 的一般性以及 MIB 对象是什么，我们现在可以深入了解管理信息实际如何使用 SNMP 进行通信的“细节”。是的，您终于可以真正了解 SNMP 是如何“工作”的了。

在本节中，我将详细描述 SNMP 协议执行的操作。我首先概述了 SNMP 的运作方式和设备用于通信的两种基本方法；我还描述了 SNMP 的消息类。然后我提供的主题详细描述了在 SNMP 中执行的每个基本操作以及用于这些目的的消息：基本请求/响应、表遍历、对象修改和通知。最后，我讨论了 SNMP 安全问题，并总结了每个 SNMP 版本中的安全方法。

请注意，SNMP 中协议操作的数量和类型在 SNMPv1 和 SNMPv2 之间发生了变化。 SNMPv2 中定义的操作已被转移到最新版本 SNMPv3 中。大多数讨论都集中在 SNMPv3 作为最新的实现，同时提到它与原始的和仍然广泛使用的 SNMPv1 之间有什么区别。

###### 3.2.3.2-1 SNMP 协议一般操作、通信方法和消息类别（部分：1 2）

SNMP 协议的主要功能是允许管理信息以管理信息库 (MIB) 对象的形式在支持 SNMP 的设备之间进行通信。 SNMP 协议的协议操作描述了如何执行此通信。在分别详细查看这些操作之前，全面了解 SNMP 中使用的信息交换方法是有益的。

<u>**SNMP 通信方法**</u>
要使 SNMP 在网络管理中发挥作用，它必须允许网络管理员使用网络管理站 (NMS) 轻松检查受管设备中 SNMP 代理的状态。在数据通信中，有两种通用技术用于一个实体需要随时了解另一个实体的活动或事件的情况：

- 轮询驱动：该术语指的是让需要信息的人提出要求的一般技术；就像有人可能会进行政治投票一样。在 SNMP 中，NMS 将轮询 SNMP 代理以获取信息。轮询的一个常见“现实生活”示例是普通邮件服务使用的模型；每天你去检查你的邮箱，看看你有没有邮件。

- 中断驱动：这个术语指的是让一个设备带有另一个需要知道的信息来决定发送它自己的“意志”信息。在 SNMP 中，这指的是 SNMP 代理在没有被询问的情况下向 NMS 发送信息。这就是最著名的“中断器”电话所使用的模型。trap

哪个更好”？我的引号又出卖了我。通常的答案适用于此：没有普遍的好坏之分，这就是为什么这两种选择都存在的原因。由于这些模型的明显优势和劣势，SNMP 协议旨在同时使用这两种模型。轮询用于定期收集例行信息，例如检查设备的使用统计信息和一般状态。中断以网络管理员可以在受管设备上设置的陷阱的形式使用。当导入事件发生时，这些陷阱会导致 SNMP 代理中断 NMS。



**关键概念：**SNMP 使用两种基本方法来交换管理信息。例行通信使用轮询驱动技术，其中网络管理站从被管节点请求信息。还支持中断驱动模型：在受管设备需要立即将发生的情况告知管理站的情况下，它可以发送陷阱消息而无需等待管理站的请求。

<u>**SNMP 消息和协议数据单元 (PDU)**</u>

SNMP 协议中的实际信息通信以与大多数其他协议类似的方式通过 SNMP 消息的交换来执行。这些消息有时称为协议数据单元或 PDU。这是您可能在其他协议中听说过的一个术语，也是 OSI 参考模型中数据封装的正式定义的一部分。消息当然是“协议”使用的“数据单元”。 SNMP 消息的名称末尾都有“-PDU”以标识它们。

有人认为“协议数据单元”类似于军方使用“长方形金属头手动紧固件加速装置”来指代锤子。公平地说，严格来说，在 SMNP 中，PDU 和消息并不完全相同。 PDU 是 SNMP 封装的高层数据，如 OSI 模型所述。 SNMP 消息格式是一种包装器，它封装了一个 PDU 以及标头字段，正如我在 SNMP 消息传递部分中所描述的那样。但是，消息的重点是发送 PDU，因此两者“足够接近”，有时可以互换使用。

<u>**SNMP PDU 类**</u>

SNMPv1 最初定义了六个 PDU。 扩展了 PDU 的数量，并对其名称和在 SNMPv2 和 SNMPv3 中的使用进行了一些更改。 当前的 SNMP 框架将 PDU 分为不同的类别。 这些类描述了每种消息类型的功能以及它们用于执行任务的通信类型（轮询与中断）。

表 210 显示了主要的 SNMPv2/SNMPv3 PDU 类别，对其进行了描述，并显示了 SNMPv2/SNMPv3 中每个类别中的 PDU。 这些类未在 SNMPv1 中使用，但为了清楚起见，我还展示了来自 SNMPv1 的哪些消息在概念上属于这些类：


​                                                                         **表 210：SNMP PDU（消息）类别**

| **SNMPv3 PDU Class** | **Description**                                  | **SNMPv1 PDUs**                      | **SNMPv2/SNMPv3 PDUs**                                   |
| -------------------- | ------------------------------------------------ | ------------------------------------ | -------------------------------------------------------- |
| ***Read\***          | 使用轮询机制从受管设备读取管理信息的消息。       | *GetRequest-PDU, GetNextRequest-PDU* | *GetRequest-PDU, GetNextRequest-PDU, GetBulkRequest-PDU* |
| ***Write\***         | 更改受管设备上的管理信息以影响设备操作的消息。   | *SetRequest-PDU*                     | *SetRequest-PDU*                                         |
| ***Response\***      | 为响应先前请求而发送的消息。                     | *GetResponse-PDU*                    | *Response-PDU*                                           |
| ***Notification\***  | 设备用来向 SNMP 管理器发送类似中断的通知的消息。 | *Trap-PDU*                           | *Trapv2-PDU, InformRequest-PDU*                          |

GetBulkRequest-PDU 和 InformRequest-PDU 消息是 SNMPv2/v3 中的新消息。 GetResponse-PDU 消息被重命名为 Response-PDU（因为它实际上是一个响应，而不是“获取”任何东西的消息），并且新的 Trapv2-PDU 取代了 Trap-PDU。

当前的 SNMP 框架定义了另外三个“特殊”类，我们不太感兴趣，因为它们没有定义主动使用的消息，但为了完整性我应该提及。 Internal 类包含为内部 SNMP 通信定义的称为 Report-PDU 的特殊消息。 SNMP 标准还提供了两个类，称为 Confirmed 和 Unconfirmed，用于根据消息是否被确认对我上表中的消息进行分类。 Report-PDU、Trapv2-PDU 和 Response-PDU 消息被认为是未确认的，其余的是已确认的。

接下来的几个主题将展示如何使用四个主要类中的主要消息类型。请注意，一般而言，SNMP 中的所有协议交换都是根据一个 SNMP 实体向另一个实体发送消息来描述的。最常见的是，发送请求的实体是 SNMP 管理器，而响应者是 SNMP 代理，除了由代理发送的陷阱。为了更清楚起见，我尽可能使用这些更具体的术语（经理或代理人），而不仅仅是“实体”。

**关键概念：**SNMP 消息由一组围绕称为协议数据单元或 PDU 的数据元素的字段组成。在某些情况下，术语“消息”和“PDU”可以互换使用，尽管它们在技术上并不相同。 SNMP PDU 根据其功能分为几类。



###### 3.2.3.2-2 使用 GetRequest 和 (Get)Response 消息的 SNMP 协议基本请求/响应信息轮询

我们详细了解 SNMP 协议操作的明显起点是最简单的信息交换类型。这将是一个简单的轮询操作，用于读取一个或多个管理信息变量，由一个 SNMP 实体（通常是 SNMP 管理器）使用它来请求或读取来自另一个实体（通常是受管设备上的 SNMP 代理）的信息。 SNMP 将此实现为简单的双消息请求/响应协议交换，类似于许多 TCP/IP 协议中的请求/回复过程。

此信息请求过程通常始于应用程序的用户想要检查设备的状态或查看有关它的信息。正如我们所见，所有这些信息都以 MIB 对象的形式存储在设备上。因此，通信采用对特定 MIB 对象的请求和来自包含这些对象值的设备的回复的形式。在简化形式中，流程中的步骤如下（如图 274 所示）：

1. SNMP Manager Creates GetRequest-PDU：基于应用程序和用户所需的信息，网络管理站上的 SNMP 软件创建 GetRequest-PDU 消息。它包含应用程序要检索其值的 MIB 对象的名称。

2. SNMP 管理器发送 GetRequest-PDU：SNMP 管理器将 PDU 发送到被轮询的设备。

3. SNMP 代理接收并处理 GetRequest-PDU：SNMP 代理接收并处理请求。它查看消息中包含的 MIB 对象名称列表，并检查它们是否有效（代理实际实现的）。它查找正确指定的每个变量的值。

4. SNMP 代理创建响应 PDU：代理创建一个响应 PDU 以发送回 SNMP 管理器。此消息包含请求的 MIB 对象的值和/或错误代码以指示请求的任何问题，例如无效的对象名称。

5. SNMP Agent Sends Response-PDU：代理将响应发送回 SNMP 管理器。

6. SNMP 管理器处理 Response-PDU：管理器处理从代理接收到的 Response-PDU 中的信息。



![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\images\snmpget.png)

​                                                                                  **图 274：SNMP 信息轮询流程**

基本的 SNMP 信息轮询过程涉及 SNMP 管理器发送的 GetRequest-PDU 和 SNMP 代理返回的 Response-PDU 的简单交换。

**关键概念：**SNMP 中最基本的通信类型是信息轮询，它允许网络管理站使用简单的请求/回复消息交换从被管节点读取一个或多个 MIB 对象。


Response-PDU消息在SNMPv1中称为GetResponse-PDU。据推测，选择这个名称是因为它是对 get 操作的响应，以使名称 GetRequest-PDU 和 GetResponse-PDU 在某种程度上对称。问题在于这个名称令人困惑，原因有二。首先，有些人听起来像是 PDU 的目的是“获得响应”。其次，GetResponse-PDU也被定义为对“gets”以外的操作的响应消息，包括对SetRequest-PDU的响应消息。发送“GetResponse”消息以回复“SetRequest”令人不安；新名称更通用，避免了这些问题。





###### 3.2.3.2-3 使用 GetNextRequest 和 GetBulkRequest 消息遍历 SNMP 协议表（部分：1 2）

我们在上一主题中检查的 GetRequest-PDU 消息是应用程序用来请求 SNMP 管理对象的管理信息库中的常规单个变量值的消息。然而，正如我在描述 MIB 对象的主题中提到的，管理信息结构 (SMI) 还允许管理信息库包含表格数据。

MIB 表是设备存储和组织一组相关数据项的有用方法。尝试将这些项构造为常规对象的集合是相当低效的。例如，一个设备可能有多个 IP 地址。如果定义一个名为 ipAddr1 的 MIB 对象和另一个名为 ipAddr2 的 MIB 对象来存储 IP 地址信息，效率会很低。相反，在原始 SNMPv1 MIB 中定义了一个名为 ipAddrTable 的对象，它指定了一个包含一个或多个名为 ipAddrEntry 的条目的表。每个条目都包含设备接口之一的 IP 地址和子网掩码。

<u>**使用 GetNextRequest 的 SNMPv1 表遍历**</u>
需要有一种方法让 SNMP 管理器可能希望从设备读取这些表的内容。这可以使用常规的 GetRequest-PDU 消息，通过一个接一个地指定表中的每个条目来完成。然而，这有点粗糙，并且会留下一个问题：SNMP 管理器可能不知道表中有多少条目，因此也不知道它应该请求多少条目。

表遍历问题在 SNMPv1 中通过创建称为 GetNextRequest-PDU 的新消息类型得到解决。您可以将其视为常规 GetRequest-PDU 的“相对”版本。 GetNextRequest-PDU 包含表格变量的名称，以及表格中的特定条目。接收 GetNextRequest-PDU 的设备使用它来查找表中的下一个值并在 GetResponse-PDU 消息中返回它。

实际的协议交换与上一主题中描述的大致相同：请求由 SNMP 管理器发送，回复由 SNMP 代理返回。不同之处在于，SNMP 代理不返回指定变量的值，而是返回表中下一个变量的值。然后将其用作下一个请求的值，依此类推，直到到达表中的最后一个条目。一旦发生这种情况，并且包含最后一个条目的 GetNextRequest-PDU 被发送，响应设备通过返回概念上遵循管理信息库实现中的表的 MIB 对象来指示这一点。这向 SNMP 管理器发出信号，表示已完全遍历该表。

**关键概念：**SNMP GetNextRequest-PDU 消息允许网络管理站请求管理信息库中的一系列连续变量。这最常用于允许更轻松地检索表格数据，而无需单独指定表中的每个变量。

<u>**使用 GetBulkRequest 的 SNMPv2/v3 表遍历**</u>

GetNextRequest-PDU 消息是有效的，但虽然它比使用常规的 GetRequest-PDU 消息更优雅，但它并没有变得更高效——表中的每个条目仍必须一次请求一个。这意味着检索表中的信息需要很长时间，并且由于必须发送的请求和回复数量而导致产生大量流量。

为了使表遍历更容易和更节省网络资源，SNMPv2 引入了一种称为 GetBulkRequest-PDU 的新消息类型。您可能可以从名称中推测出这里的想法。 GetBulkRequest-PDU 不是指定要获取或“获取下一个”的特定 MIB 对象，而是允许 SNMP 管理器发送单个请求，该请求导致表中的多个条目在 Response-PDU 消息中返回。

GetBulkRequest-PDU 旨在允许在单个请求中检索常规变量和表。 PDU 包括一个对象列表，就像在 GetRequest-PDU 或 GetNextRequest-PDU 中一样。列表的组织方式是先出现常规对象，然后是表格对象。请求中包含两个特殊参数，称为 Non Repeaters 和 Max Repetitions。其中第一个指定要检索的非重复、规则对象的数量；这是对象列表开头的常规对象数。第二个指定迭代次数或条目数，以读取剩余的表格对象。

例如，假设 SNMP 管理器想要从表中请求 4 个常规变量和 3 个条目。 GetNextRequest-PDU 将包含五个 MIB 对象规范，最后是表格。 Non Repeaters 字段将设置为 4，Max Repetitions 字段设置为 3。

SNMPv1中使用GetRequest-PDU和GetNextRequest-PDU遍历表的原始方法在SNMPv2和SNMPv3发展时得到了保留。然而，更高效的 GetBulkRequest-PDU 的引入意味着 GetNextRequest-PDU 不像在 SNMPv1 中那么重要。但是请记住，使用 GetBulkRequest-PDU 确实需要请求实体知道要请求多少条目。因此，如果条目数未知，可能需要进行一些“试错”或多次请求才能获得整个表。

**关键概念：**为了提高表遍历的效率，SNMPv2 引入了 GetBulkRequest-PDU 消息，它允许网络管理站使用对被管节点的单个请求从表中请求一系列 MIB 对象。



###### 3.2.3.2-4 使用 SetRequest 消息修改 SNMP 协议对象

GetRequest-PDU、GetNextRequest-PDU 和 GetBulkRequest-PDU 消息是 SNMP“读取”类 PDU 的三个成员——它们用于让 SNMP 管理器从 MIB 代理读取 MIB 对象。相反的功能由 SNMP“Write”类表示，它包含一个成员：SNMP SetRequest-PDU 消息。

这个 PDU 的用途相当明显；其中三个 Get PDU 之一指定一个变量，其值将被检索，SetRequest-PDU 消息包含对其值将由网络管理员修改的变量的规范。请记住，SNMP 不包含让网络管理员控制受管设备的特定命令。这实际上是“控制方法”，通过设置影响被管理设备操作的变量。

set过程是get过程的补充；几乎相同的基本想法，但对象如何重视“旅行”以及如何处理它们的方式发生了逆转。该过程遵循以下步骤（参见图 275）：

1. SNMP管理器创建SetRequest-PDU：基于用户通过SNMP应用程序指定的信息变化，网络管理站上的SNMP软件创建一个SetRequest-PDU消息。它包含一组 MIB 对象名称和它们要设置的值。

2. SNMP 管理器发送 SetRequest-PDU：SNMP 管理器将 PDU 发送到被控制的设备。

3. SNMP Agent Receives and Processes SetRequest-PDU：SNMP Agent接收并处理set请求。它检查请求中的每个对象以及对象要设置的值，并确定是否应该接受请求。

4. SNMP 代理进行更改并创建响应 PDU：假设请求中的信息是正确的（并且已满足任何安全规定），SNMP 代理对其内部变量进行更改。代理创建一个 Response-PDU 发送回 SNMP 管理器，它要么指示请求成功，要么包含错误代码以指示在处理过程中发现的请求的任何问题。

5. SNMP Agent Sends Response-PDU：代理将响应发送回 SNMP 管理器。

6. SNMP Manager Processes Response-PDU：管理器对Response-PDU中的信息进行处理，以查看设置的结果。

   

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\images\snmpset.png)

​                                                                                      **图 275：SNMP 对象修改过程**

设置 MIB 对象值的通信过程与读取 MIB 对象值的通信过程非常相似。当然，主要区别是对象值从 SNMP 管理器发送到 SNMP 代理，在 SetRequest-PDU 消息中携带。

<u>**对象修改请求的验证**</u>
显然，告诉设备更改变量的值是比仅要求设备读取值更重要的请求。为此，被管设备必须非常仔细地分析和验证请求中的信息，以确保请求有效。执行的检查包括：

- 验证要更改的对象的名称。

- 验证是否允许修改对象（基于它们的 Access 或 Max-Access 对象特征。）

- 检查请求中包含的值以确保其类型和大小对于要更改的对象有效。

这也是通用协议安全问题变得更加重要的地方。

**关键概念：**SNMP 网络管理站通过更改这些设备上的 MIB 对象来控制被管理设备的操作。这是使用 SetRequest-PDU 消息完成的，该消息指定要修改的对象及其值。

###### 3.2.3.2-5 使用 Trap(v2) 和 InformRequest 消息的 SNMP 协议信息通知（部分：1 2）

本节的第一个主题介绍了在 SNMP 设备之间进行信息通信的两种基本方法：使用轮询或中断。到目前为止，我们在本节中检查的所有消息类型和交换都是轮询驱动的：它们包括一个 SNMP 管理器发出一个特定的请求，该请求导致采取的行动，以及一个由 SNMP 代理生成的响应。

<u>**SNMP 中陷阱的必要性**</u>
轮询是交换需要定期收集的例行信息的理想选择。例如，常规的 Get 请求可用于验证设备上的设置、检查一段时间内的错误计数、检查其正常运行时间或使用统计信息。显然，轮询是执行 Set 操作的唯一真正方法，其中数据已更改。

但是轮询不太适合需要快速传达的重要信息。原因是轮询驱动的通信总是由信息的接收者发起：SNMP 管理器。如果托管设备上发生了管理器未预料到的重大事件，则管理器不会发现它，除非它特别要求查看已更改的变量。这意味着重要的变量需要由 SNMP 管理器一直检查，这是非常高效的。

在现实世界中，使用轮询来实现需要发送关键信息的情况就像让镇上的紧急响应服务每小时给每个人打电话，看看他们是否需要救护车或消防车。同样，在 SNMP 中，需要一种机制让 SNMP 代理发起信息通信。通过包含 Trap-PDU 消息类型，此功能最初成为 SNMPv1 协议的一部分。

在计算机科学中，陷阱只是设备持续监控的一组条件。如果出现适当的条件，陷阱就会被触发并导致某种动作发生。在 SNMP 中，陷阱被编程到 SNMP 代理中，当它们被触发时，SNMP Trap-PDU 消息被发送到 SNMP 管理器以通知它发生了。 SNMPv1 规范中的陷阱示例包括在通信链路故障、设备重启或身份验证问题时触发的陷阱。

<u>**使用 SNMP 陷阱和 Trapv2 消息**</u>
陷阱情况下的通信是微不足道的； SNMP 代理发送陷阱，SNMP 管理器因此被视为“已获悉”发生的情况。差不多就是这样。这些是“未确认”消息，没有回复给 SNMP 代理。 Trap的触发可能导致网络管理员对发送Trap的设备采取后续行动。

特定管理信息库的设计者必须确定为特定对象组创建哪些陷阱。实现必须指定陷阱触发的条件，以及发生这种情况时 Trap-PDU 消息将发送到的目的地。在SNMPv2中，原有的Trap通知消息以Trapv2-PDU消息的形式保留下来。

<u>**使用 SNMPv2 InformRequest 消息**</u>

SNMPv2 还包含第二种通知消息类型：InformRequest-PDU。这种类型的消息与陷阱不同，但它与陷阱相关的原因有两个。首先，这两种消息类型都用于在收件人不启动过程的情况下传达信息，其次，这两种消息有时会结合使用。

InformRequest-PDU的目的实际上是为了方便网络管理站之间的信息交流。一个 NMS 上的 SNMP 管理器可以选择通过向另一个 SNMP 管理器发送 InformRequest-PDU 来“通知”另一条信息。接收管理器然后用 Response-PDU 回复发送 InformRequest-PDU 的管理器，确认收到通知消息。

使用此消息的一种常见方式是在陷阱发生时“传播消息”。假设设备遇到电源故障，导致 Trapv2-PDU 被发送到 NMS #1。网络管理员可能希望设置 NMS #1，以便接收到特定的陷阱，从而使陷阱中的信息“转发”到另一个。 InformRequest-PDU 将用于携带从 NMS #1 到 NMS #2 的信息。

**关键概念：**SNMP 管理的设备可以通过向网络管理站发送 Trap-PDU 或 Trapv2-PDU 消息来通知网络管理站发生了重要事件。网络管理员确定在何种情况下应传输这些消息之一。 SNMPv2 向此功能添加了 InformRequest-PDU 消息，该消息可用于在管理站之间传播有关事件的信息。



###### 3.2.3.2-6 SNMP 协议安全问题和方法（部分：1 2 3）

在我对各种 SNMP 版本的描述中，我可能对那些在 1990 年代使用 SNMP 的人有点苛刻。许多 SNMP 第 2 版变体的激增确实很不幸，这在 TCP/IP 世界中并不常见。然而，既然我们已经了解了 SNMP 所做的工作，协议中对安全性的需求似乎就很清楚了。鉴于此，并考虑到初始 SNMPv1 协议的安全级别非常低，在某种程度上可以理解为什么会出现安全问题冲突。

<u>**为什么安全在 SNMP 中很重要**</u>
SNMP 中的安全需求是显而易见的，因为正在通信的 MIB 对象包含有关网络设备的关键信息。我们不希望任何人“窥探”我们的网络以找出我们的 IP 地址，或者我们的机器运行了多长时间，或者我们的链接是否断开，或者几乎任何其他东西。当涉及到使用 SetRequest-PDU 的对象写入操作时，关注点被放大了：我们绝对不希望陌生人能够通过发出伪造命令来更改控制设备操作的 MIB 对象来控制或干扰我们的托管设备！

<u>**SNMPv1 安全**</u>

不幸的是，纳入 SNMPv1 的安全性极其有限；它实际上只采取了一项政策和一项简单技术的形式：

- “弱对象”：SNMP 的创建理念是协议中使用的 MIB 对象相对较弱。这意味着对象的设计使得使用它们时出现的任何问题都会导致最小的损坏。 SNMP 设计者的策略是正常读取的 MIB 对象不应包含关键信息，写入的对象不应控制关键功能。

- 因此，包含机器描述的只读 MIB 对象是可以的，但包含管理密码的 MIB 对象则不行。同样，控制计算机下次重启时间的读写 MIB 对象是可以接受的，但告诉对象重新格式化其硬盘的对象（绝对）不是！

- 社区字符串：由一组特定的网络管理站管理的 SNMP 网络中的所有设备都被视为在“社区”中。在社区成员之间发送的每条 SNMPv1 消息都由出现在消息头字段中的社区字符串标识。这个字符串就像一个简单的密码；接收到的任何带有错误字符串的消息都将被收件人拒绝。

这些安全功能总比没有好，但并不多。弱物体的使用类似于一项政策，该政策规定不要将车门未锁定且钥匙放在点火开关上的情况下不要将车停在便利店前——这基本上是在说“不要自讨苦吃”。这是明智的，但它不是一个完整的安全解决方案。社区字符串可防止以未经授权的消息形式出现的明显篡改。然而，这些字符串以纯开放文本形式发送，很容易被发现，然后被用来危害“社区”。所以这就像停车时锁门一样——它可以防止偶然的小偷，但不能防止专业人士。

当然，对于一些人来说，车子不开，停车锁门就足够安全了，SNMPv1的安全性对一些SNMP用户来说也足够了。但是在更新、更大的互联网中，尤其是那些跨越很远的距离或使用公共运营商的互联网，SNMPv1 无法胜任这项任务。这就是为什么所有这些有趣的事情都发生在 SNMP 第 2 版中。

<u>**SNMPv2/v3 安全方法**</u>

在 SNMPv2 变体的“演变”以及最终 SNMPv3 的创建过程中，创建了几个新的安全模型来提高 SNMPv1 的安全性：

- 基于参与方的安全模型：这是原始 SNMPv2 标准的安全模型，现在称为 SNMPv2p。为指定特定身份验证协议和隐私（加密）协议的通信定义称为一方的逻辑实体。该信息用于验证特定请求的真实性，并确保发送方和接收方就如何加密和解密数据达成一致。

- 基于用户的安全模型 (USM)：这是在 SNMPv2u 变体中开发的，并在 SNMPv2*（SNMPv2 星号）中使用；它最终在 SNMPv3 中被采用。这里的想法是摆脱将安全性绑定到机器，而是使用基于机器用户访问权限的更传统的安全性。可以使用各种身份验证和加密协议来确保尊重访问权限并保护消息隐私。该方法依靠时间戳、时钟同步和其他技术来抵御某些类型的攻击。

- 基于视图的访问控制模型 (VACM)：VACM 是 SNMPv3 的一部分，它定义了一种方法，可以对设备上的对象的访问进行更精细的控制。视图指定一组特定的 MIB 对象，这些对象可以由特定上下文中的特定组访问。通过控制这些视图，管理员可以管理哪些信息由谁访问。

至少可以说，这些描述被“大大简化”了。安全性可能是网络中最复杂的子主题，详细描述这些方法需要数十个主题。如果您需要更多信息，可以参考相关标准，但除非您通读安全主题，否则您可能无法从其中所写的内容中得出正面或反面。

<u>**SNMP 安全方法的使用**</u>
SNMPv2p 使基于参与方的安全性几乎消失了； USM 和 VACM 是 SNMPv3 的一部分，并为需要它的人提供增强的安全性（尽管再次注意到有多少网络继续使用 SNMPv1，安全缺陷和所有这些都很有趣。）SNMPv3 在重新定义 SNMP 方面采取了另一个与安全相关的重要步骤无缝支持多种安全模型的体系结构。这使不同的实现能够选择最适合它们的安全模型。 USM 是 SNMPv3 中的默认模型。



###### 3.2.3.3 SNMP 协议消息传递和消息格式

正如我们在上一节中广泛看到的那样，管理信息的通信是通过交换包含协议数据单元 (PDU) 的 SNMP 消息来完成的。与大多数 TCP/IP 协议的消息一样，这些 PDU 被设计为使用特定的字段格式，并根据特定的协议规则创建、寻址和传输。 SNMP 消息包括控制协议操作的字段，并以管理信息库 (MIB) 对象的形式携带管理信息的“有效负载”。

在本节中，我将详细描述如何在 SNMP 协议中完成消息传递。我首先对与消息生成、寻址和传输相关的问题进行一般性讨论，并描述必要时如何处理消息的重传。我讨论了在 SNMP 消息中定义字段的方式并描述了它们的一般格式，解释了整个消息和它包含的 PDU 之间的区别。然后我检查了所有重要的 SNMP 版本中使用的消息格式，显示了每种消息类型的结构和使用的字段。

###### 3.2.3.3-1 SNMP 协议消息生成、寻址、传输和重传（部分：1 2 3）

SNMP 协议操作部分描述了使用 SNMP 消息传递网络管理信息的方式。这些讨论主要集中在使用这些消息完成不同任务的逻辑过程。现在让我们仔细看看 SNMP 设备如何创建、寻址和发送这些消息的底层细节。

SNMP 中的消息生成与用于大多数其他协议的典型 TCP/IP 客户端/服务器模型略有不同。 SNMP 中实际上没有任何正式的“客户端”和“服务器”，因为管理信息可以从任何设备获取——它是分布式的。大多数消息交换使用一对匹配的请求和回复消息。网络管理站 (NMS) 通常在这些交换中充当客户端，向 SNMP 代理发送特定的获取或设置请求，SNMP 代理充当其所包含信息的服务器角色。然而，SNMP 代理通常不被视为传统意义上的“服务器”。

SNMP 陷阱完全偏离消息生成的正常请求/回复模型。当陷阱被触发时，SNMP 代理不响应请求而自行向网络管理站发送陷阱消息。由于陷阱消息未经确认，因此没有回复。但是请注意，SNMPv2/v3 InformRequest-PDU 消息是经过确认的，因此会向生成它的 NMS 发送响应消息。

<u>**SNMP 传输映射**</u>
生成消息后，将使用 SNMP 所在的应用层以下级别的协议发送消息。正如我们在 SNMP 协议概述中看到的，当前的 SNMP 标准集将协议操作和 PDU 的描述与实际发送它们的方法分开。从版本 2 开始，SNMP 定义了几个传输映射，描述了 SNMP PDU 如何通过各种网络协议套件发送，包括 TCP/IP、OSI、IPX/SPX (Novell) 和 Appletalk。

SNMP 消息传递的许多具体细节取决于特定实现中使用的传输映射。 SNMP 当然主要用于 TCP/IP 互联网络，而 TCP/IP 是我们在本指南的这一部分中主要关注的地方。因此，我将继续讨论通过 IP 使用 SNMP 时的传输问题。

<u>**使用 UDP 的 SNMP 消息传输**</u>

SNMP 的标准 IP 传输映射要求使用 UDP 传输它。这个决定可以追溯到 SNMPv1 的初始实现（在有不同的传输映射之前）。选择 UDP 可能是因为它对于 SNMP 使用的简单请求/回复消息传递方案更有效；许多 TCP 功能被认为不是必需的，并且增加了 SNMP 设计者想要避免的开销。 TCP 有可能被用来承载 SNMP，定义为不同的传输映射，但我不相信这实际上已经完成了。

为 SNMP 保留了两个众所周知的 UDP 端口号。第一个是端口 161，这是“通用”SNMP 编号。设置为侦听 SNMP 请求的所有设备（代理和管理器）都在端口 161 上侦听。每个设备接收发送的任何消息并回复“客户端”，即发出请求的 SNMP 实体，它使用临时端口标识请求进程的编号。第二个 UDP 端口号是 162，这是为 SNMP 陷阱保留的。拥有两个数字可以将常规消息和陷阱分开。**通常只有 NMS 会侦听端口 162**，因为代理不是陷阱的接收者。

UDP 的使用使 SNMP 信息通信变得“流线型”，因为不需要建立 TCP 连接，并且消息头更短，处理时间略有减少。但是使用 UDP 引入了一些 SNMP 实现必须关注的问题。

<u>**UDP 消息大小问题**</u>
第一个问题是消息长度。 SNMP PDU 可以携带许多 MIB 对象，这意味着它们可能相当大。但是，UDP 在它可以携带的消息大小方面受到限制（而 TCP 则没有）。标准指定 SNMP 实体必须接受大小至少为 484 字节的消息。他们还建议 SNMP 实现能够接受更大的消息，最多 1472 字节，这对应于可以封装在以太网帧中的最大消息大小（1,500 字节，允许 20 字节用于 IP 报头，8 字节用于UDP 标头。）

在 SNMPv2/v3 中使用 GetBulkRequest-PDU 消息类型需要特别小心，因为它允许单个请求导致许多 MIB 对象在响应中被发回。 Max Repetitions 参数必须谨慎选择，这样 SNMP 代理就不会尝试发送不适合的巨大消息。

<u>**处理丢失的传输**</u>

UDP 的第二个问题是我们为它的效率和简单性付出的代价：缺乏传输特性。 UDP 不保证数据交付或处理重传，这意味着理论上请求或回复可能会在传输过程中丢失。只有最初发送请求的设备才能知道传输是否存在问题——它发送请求，如果没有收到回复，则知道请求或响应丢失了。这将重传的责任放在发送请求消息的设备部分。

NMS 向 SNMP 代理发送请求通常使用计时器来跟踪自发送请求以来经过了多长时间。如果响应没有在特定时间间隔内到达，则重新发送请求。由于 SNMP 的工作原理，意外地多次收到请求通常不会导致任何问题（一种称为幂等性的属性）。 NMS 确实需要采用一种算法来确保它不会生成过多的重传和阻塞网络（特别是因为拥塞可能首先导致其消息丢失。）

<u>**处理丢失的陷阱消息**</u>
由于陷阱未经确认，因此陷阱 PDU 的预期接收者无法知道是否未到达，陷阱 PDU 的发送者也无法知道。这只是协议中的一个弱点； TCP/IP（和底层网络）的整体可靠性确保这些消息不会经常丢失。

关键概念：SNMP 设计有一组单独定义的协议操作和传输映射，因此它可以承载在许多不同的互连技术上。其中最常见的传输机制是 TCP/IP，其中 SNMP 使用在 IP 上运行的 UDP，以实现高效和简单的通信。 UDP 中缺乏可靠性功能意味着请求必须由发送它们的设备跟踪，如果没有收到回复则重新传输。 UDP 消息的有限大小限制了可以在任何 SNMP PDU 中发送的信息量。

###### 3.2.3.3-2 SNMP 消息字段定义、通用消息格式和消息部分（部分：1 2 3）

为了构建其消息以供传输，SNMP 使用一种特殊的字段格式，就像大多数协议一样。然而，SNMP 的有趣之处在于它的标准并不像大多数 TCP/IP 标准那样使用简单的字段列表来描述 SNMP 消息格式。相反，SNMP 消息是使用用于描述 MIB 对象的相同数据描述语言（抽象语法符号 1 或 ASN.1）定义的。

这样做的原因是 SNMP 消息实现了各种 SNMP 协议操作，其最终目标是允许 MIB 对象在 SNMP 实体之间传送。这些 MIB 对象成为要发送的消息中的字段。 SNMP 消息中携带的 MIB 对象是使用 ASN.1 定义的，如管理信息结构 (SMI) 标准中所述。因此，使用相同的语法定义 SNMP 消息及其所有字段是有意义的。

由于所有 SNMP 字段都像 MIB 对象一样定义，因此它们就像对象一样具有某些特征。具体来说，每个字段都有一个名称，其内容使用标准 SMI 数据类型之一进行描述。因此，与每个字段只有名称和长度的普通消息格式不同，SNMP 消息格式字段具有名称和语法，例如 Integer、Octet String 或 IpAddress。字段的语法定义了它的长度以及它的格式和使用方式。

正如常规消息格式使用整数来表示特定值（例如，DNS 消息头中的数字 Opcode 字段，它指示 DNS 消息类型），这可以在 SNMP 中使用枚举整数类型来完成。一个例子是错误状态字段，其中一系列整数值表示不同的错误条件。

使用 ASN.1 定义 SNMP 消息的决定允许消息格式描述与格式中的对象描述方式保持一致，这很好。不幸的是，这意味着很难从标准中确定字段格式，因为它们没有在一个地方进行描述。相反，整个消息格式被定义为一组组件；这些组件包含可能在别处定义的子组件，等等。事实上，完整的消息格式甚至没有在一个标准中定义；零件分布在多个标准中。所以你不能在一个地方查看整个消息格式。

好吧，我应该说如果你使用标准你不能，但如果你看这里你可以。为了方便您，我已将这些“分布式”语法描述转换为我在本指南其余部分使用的相同表格字段格式。我将从这里开始描述用于 SNMP 消息的一般格式，并在接下来的三个主题中探讨每个版本的 SNMP 中使用的更具体的格式。

**<u>一般消息格式</u>**

要理解 SNMP 消息，重要的是我们首先要了解 SNMP 消息和 SNMP 协议数据单元 (PDU) 之间的区别。在研究 SNMP 协议操作时，我们已经看到这两个术语经常互换使用。这是因为每条消息携带一个PDU，而PDU是消息中最重要的部分。

但是，严格来说，SNMP PDU 和SNMP 消息并不完全相同。 PDU 是在 SNMP 实体之间传递的实际信息。它与许多标头字段一起在 SNMP 消息中携带，这些标头字段用于携带标识和安全信息。因此，从概念上讲，可以将 SNMP 消息格式视为具有两个整体部分：

- Message Header：包含用于控制如何处理消息的字段，包括用于实现 SNMP 安全性的字段。

- 消息体 (PDU)：包含消息的主要部分。在这种情况下，消息主体是正在传输的协议数据单元 (PDU)。

整个 SNMP 消息有时被称为 PDU 的包装器，因为它封装了 PDU 并在其前面加上附加字段。 PDU 和消息格式之间的区别作为一个整体在 SNMP 版本 1 中开始只是一种形式，但在后来的版本中变得非常重要。原因是它允许用于基本协议操作的字段（在 PDU 中）与用于实现安全功能的字段分开。在 SNMPv2 中，安全的实现确实变得非常重要，正如我们将看到的，因此这种灵活性非常重要。

<u>**通用 PDU 格式**</u>

每个 PDU 中的字段取决于 PDU 类型，但可以再次分为以下通用子结构：

- PDU 控制字段：一组字段，用于描述 PDU 并将信息从一个 SNMP 实体传递到另一个。

- PDU 变量绑定：PDU 中 MIB 对象的一组描述。每个对象都被描述为名称到值的“绑定”。

每个 PDU 都将遵循此通用结构，如图 276 所示，不同之处仅在于控制字段的数量、变量绑定的数量以及它们的使用方式。理论上，每个 PDU 可以使用一组不同的控制字段具有不同的消息格式，但实际上，特定 SNMP 版本中的大多数 PDU 使用相同的控制字段（尽管有例外）。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\images\snmpgenformat.png)

​                                                                                 **图 276：SNMP 通用消息格式**




每个变量绑定描述一个 MIB 对象。绑定由一对子字段组成，一个以标准 SNMP 对象标识符表示法指定对象的名称，一个是其值，其格式与对象的 SMI 语法相匹配。例如，如果对象是 Integer 类型，则 value 字段将为 4 个字节宽并包含一个数字整数值。表 211 描述了每个 PDU 变量绑定的子字段格式。


​                                                                              **表 211：SNMP 变量绑定格式**

| **Subfield Name**   | **Syntax**            | **Size (bytes)** | **Description**                                              |
| ------------------- | --------------------- | ---------------- | ------------------------------------------------------------ |
| ***Object Name\***  | Sequence of *Integer* | Variable         | ***Object Name:\*** 对象名称：MIB 对象的数字对象标识符，指定为整数序列。例如，对象 sysLocation 的对象标识符为 1.3.6.1.2.1.1.6，因此使用 ASN.1 将其指定为“1 3 6 1 2 1 1 6” |
| ***Object Value\*** | Variable              | Variable         | ***Object Value:\*** Object Value：在任何类型的“get”请求中，该子字段都是一个“占位符”；它是使用对象的适当语法构造的，但没有值（因为“get”请求要求该值！）在“设置”请求（SetRequest-PDU）或携带请求数据的回复消息（GetResponse-PDU 或 Response-PDU）中，对象的值被放置在这里。 |

**关键概念：**SNMP 消息的一般格式由消息头和消息体组成。 消息的主体也称为协议数据单元或 PDU，包含一组 PDU 控制字段和一些变量绑定。 每个变量绑定描述一个 MIB 对象并由对象的名称和值组成。



###### 3.2.3.3-3 SNMP 版本 1 (SNMPv1) 消息格式（部分：1 2 3）

当然，SNMP 通用消息格式首先用于定义原始 SNMP 协议 SNMP 版本 1 (SNMPv1) 中的消息格式。 与后续版本相比，SNMP 的第一个版本可能因其相对简单而广为人知。 这反映在它的消息格式中，非常简单。

SNMPv1 中的通用消息格式是一个“包装器”，由一个小报头和一个封装的 PDU 组成。 SNMPv1 中不需要很多报头字段，因为 SNMPv1 中基于社区的安全方法非常初级。 因此，表 212 和图 277 中显示了 SNMPv1 消息的简短整体格式。

​                                                              **表 212：SNMP 版本 1 (SNMPv1) 通用消息格式**

| **Field Name**   | **Syntax**     | **Size (bytes)** | **Description**                                              |
| ---------------- | -------------- | ---------------- | ------------------------------------------------------------ |
| ***Version\***   | *Integer*      | 4                | ***Version Number:\*** Version Number：描述了这条消息的SNMP版本号；用于确保版本之间的兼容性。对于 SNMPv1，这个值实际上是 0，而不是 1。 |
| ***Community\*** | *Octet String* | Variable         | ***Community String:\*** 社区字符串：标识此消息的发送者和接收者所在的 SNMP 社区。这用于实现简单的基于 SNMP 社区的安全机制 |
| ***PDU\***       | —              | Variable         | ***Protocol Data Unit:\*** 协议数据单元：作为消息主体进行通信的 PDU。 |

​                 ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\images\snmpv1format.png)                                                 

​                                                    **图 277：SNMP 版本 1 (SNMPv1) 通用消息格式**

 <u>**SNMPv1 PDU 格式**</u>

SNMPv1 中的所有 PDU 都具有相同的格式，只有一个例外：Trap-PDU。 PDU 中每个字段的确切语义取决于特定消息。 例如，ErrorStatus 字段仅在回复中有意义，在请求中没有意义，对象值在请求和回复中的使用也不同。

<u>**SNMPv1 通用 PDU 格式**</u>
表 213 和图 278 显示了大多数 SNMPv1 PDU 的通用格式：GetRequest-PDU、GetNextRequest-PDU、SetRequest-PDU 和 GetResponse-PDU：


​                                               **表 213：SNMP 版本 1 (SNMPv1) 通用 PDU 格式**

| **Field Name**           | **Syntax**             | **Size (bytes)** | **Description**                                              |
| ------------------------ | ---------------------- | ---------------- | ------------------------------------------------------------ |
| ***PDU Type\***          | *Integer (Enumerated)* | 4                | ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\images\aa20e08c.png) |
| ***Request ID\***        | *Integer*              | 4                | ***Request Identifier:\*** 请求标识符：用于匹配请求和回复的数字。它由发送请求的设备生成，并由响应 SNMP 实体复制到 GetResponse-PDU 中的该字段。 |
| ***Error Status\***      | *Integer (Enumerated)* | 4                | ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\images\aa20e170.png) |
| ***Error Index\***       | *Integer*              | 4                | ***Error Index:\*** 错误索引：当错误状态为非零时，该字段包含一个指针，用于指定哪个对象产生了错误。在请求中始终为零。 |
| ***Variable Bindings\*** | Variable               | Variable         | ***Variable Bindings:\*** 变量绑定：一组名称-值对，标识 PDU 中的 MIB 对象，在 SetRequest-PDU 或 GetResponse-PDU 的情况下，包含它们的值。有关这些绑定的更多信息，请参阅一般消息格式主题。 |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\images\snmpv1pduformat.png)

  

​										      **图 278：SNMP 版本 1 (SNMPv1) 通用 PDU 格式**

<u>**SNMPv1 陷阱-PDU 格式**</u>

表 214 和图 279 显示了 SNMPv1 Trap-PDU 的特殊格式：


​                                                **表 214：SNMP 版本 1 (SNMPv1) Trap-PDU 格式**

| **Field Name**           | **Syntax**             | **Size (bytes)** | **Description**                                              |
| ------------------------ | ---------------------- | ---------------- | ------------------------------------------------------------ |
| ***PDU Type\***          | *Integer (Enumerated)* | 4                | ***PDU Type:\*** PDU Type：一个整数值，表示PDU类型，4表示Trap-PDU消息。 |
| ***Enterprise\***        | Sequence of *Integer*  | Variable         | ***Enterprise:\*** Enterprise：组的对象标识符，指示生成陷阱的对象的类型。 |
| ***Agent Addr\***        | *NetworkAddress*       | 4                | ***Agent Address:\*** 代理地址：生成陷阱的 SNMP 代理的 IP 地址。这当然也在较低级别的 IP 标头中，但包含在 SNMP 消息格式中可以更轻松地在 SNMP 中记录陷阱。此外，在多宿主主机的情况下，这指定了首选地址。 |
| ***Generic Trap\***      | *Integer (Enumerated)* | 4                | ***Generic Trap Code:\*** 通用陷阱代码：指定多个预定义“通用”陷阱类型之一的代码值。 |
| ***Specific Trap\***     | *Integer*              | 4                | ***Specific Trap Code:\*** Specific Trap Code：一个代码值，指示特定于实现的陷阱类型。 |
| ***Time Stamp\***        | *TimeTicks*            | 4                | ***Time Stamp:\*** 时间戳：自发送此消息的 SNMP 实体上次初始化或重新初始化以来的时间量。用于为记录目的的陷阱添加时间戳。 |
| ***Variable Bindings\*** | Variable               | Variable         | ***Variable Bindings:\*** 变量绑定：一组标识 PDU 中的 MIB 对象的名称-值对。有关这些绑定的更多信息，请参阅一般消息格式主题。 |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\images\snmpv1trappduformat.png)



​                                                     **图 279：SNMP 版本 1 (SNMPv1) Trap-PDU 格式**



###### 3.2.3.3-4 SNMP 版本 2 (SNMPv2) 消息格式（部分：1 2 3 4 5 6 ）

在 SMNP 版本 1 使用了几年之后，人们注意到了它的某些问题并确定了需要改进的地方。这导致了最初的 SNMP 版本 2 的开发，该版本旨在在许多领域增强 SNMPv1，包括 MIB 对象定义、协议操作和安全性。最后一个领域，即安全性，导致了我在 SNMP 版本主题中描述的 SNMPv2 版本“变体”的激增。

由于实际上有几种不同的“SNMPv2”，因此 SNMPv2 也有多种消息格式，而不仅仅是一种。这已经够令人困惑了，但如果没有 SNMP 消息的模块化特性“来拯救”，情况会更糟。 SNMPv2 中的协议操作不同于 SNMPv1，这需要对 SNMPv2 PDU 的格式进行一些修改。但是，所有 SNMPv2 变体的协议操作都是相同的。 SNMPv2 变体之间的区别在于安全实现方面。因此，这样做的结果是所有 SNMPv2 类型的 PDU 格式都相同，而每个变体的整体消息格式不同。 （这就是为什么 PDU 和消息之间的区别不仅仅是学术上的区别！）

在 SNMPv2“分歧”期间，定义了四种变体：原始的 SNMPv2 (SNMPv2p)；基于社区的 SNMPv2 (SNMPv2c)、基于用户的 SNMPv2 (SNMPv2u) 和“SNMPv2 之星”(SNMPv2*)。其中，前三个记录在 SNMP RFC 标准集中，第四个没有。每个变体的整体消息格式的结构在有关变体的管理或安全标准中进行了讨论，该标准参考了 PDU 格式的共享 SNMPv2 标准 (RFC 1905)。

SNMPv2p、SNMPv2c、SNMPv2u的整体报文格式如下：

<u>**SNMP 版本 2 (SNMPv2p) 消息格式**</u>

基于方的安全模型相当复杂，但此版本中的基本消息传递是通过管理通信的定义来描述的，它描述了源方和目标方并引用了通信的上下文。 RFC 1445 中详细描述了总体消息格式。此信息在表 215 中进行了总结，并以图形方式显示在图 280 中。


​                                                                  **表 215：SNMP 版本 2 (SNMPv2p) 通用消息格式**

| **Field Name**   | **Syntax**            | **Size (bytes)** | **Description**                                              |
| ---------------- | --------------------- | ---------------- | ------------------------------------------------------------ |
| ***Version\***   | *Integer*             | 4                | ***Version Number:\*** Version Number：描述了这条消息的SNMP版本号；用于确保版本之间的兼容性。对于 SNMPv2p，此值为 2。 |
| ***Dst Party\*** | Sequence of *Integer* | Variable         | ***Destination Party:\*** Destination Party：一个对象标识符，指定作为消息的预期接收方的一方。 |
| ***Src Party\*** | Sequence of *Integer* | Variable         | ***Source Party:\*** 源方：一个对象标识符，指定作为消息发送方的一方。 |
| ***Context\***   | Sequence of *Integer* | Variable         | ***Context:\*** 上下文：定义一组可由特定实体访问的 MIB 对象资源。 |
| ***PDU\***       | —                     | Variable         | ***PDU:\*** PDU：报文的协议数据单元。                        |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\images\snmpv2pformat.png)

​                                                      **图 280：SNMP 版本 2 (SNMPv2p) 通用消息格式**



 <u>**基于社区的 SNMP 版本 2 (SNMPv2c) 消息格式**</u>

此版本的 SNMPv2 旨在保留 SNMPv2p 引入的新协议增强功能，但返回到简单的 SNMPv1 安全模型。 因此，SNMPv2c 的定义文档 RFC 1901 指定其整体消息格式与 SNMPv1 的相同，只是版本号有所更改。 这显示在表 216 和图 281 中。


​                                                  **表 216：基于社区的 SNMP 版本 2 (SNMPv2c) 通用消息格式**

| **Field Name**   | **Syntax**     | **Size (bytes)** | **Description**                                              |
| ---------------- | -------------- | ---------------- | ------------------------------------------------------------ |
| ***Version\***   | *Integer*      | 4                | ***Version Number:\*** Version Number：描述了这条消息的SNMP版本号；用于确保版本之间的兼容性。对于 SNMPv2c，此值为 1。 |
| ***Community\*** | *Octet String* | Variable         | ***Community String:\*** 社区字符串：标识此消息的发送者和接收者所在的 SNMP 社区。 |
| ***PDU\***       | —              | Variable         | ***Protocol Data Unit:\*** 协议数据单元：作为消息主体进行通信的 PDU。 |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\images\snmpv2cformat.png)

​                                                     **图 281：基于社区的 SNMP 版本 2 (SNMPv2c) 通用消息格式**

<u>**基于用户的 SNMP 版本 2 (SNMPv2u) 消息格式**</u>

SNMPv2u 在 SNMPv2c 标准化时被定义为可选的安全模型。 RFC 1910 定义了表 217 和图 282 中描述的基于用户的安全模型和消息格式。


​                                                      **表 217：基于用户的 SNMP 版本 2 (SNMPv2u) 通用消息格式**

| **Field Name**    | **Syntax**     | **Size (bytes)** | **Description**                                              |
| ----------------- | -------------- | ---------------- | ------------------------------------------------------------ |
| ***Version\***    | *Integer*      | 4                | ***Version Number:\*** Version Number：描述了这条消息的SNMP版本号；用于确保版本之间的兼容性。对于 SNMPv2u，此值为 2。请注意，这与用于 SNMPv2p 的值相同。 |
| ***Parameters\*** | *Octet String* | Variable         | ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\images\aa20e5c5.png) |
| ***PDU\***        | —              | Variable         | ***Protocol Data Unit:\*** 协议数据单元：作为消息主体进行通信的 PDU。这可以是加密或未加密的形式。 |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\images\snmpv2uformat.png)

​                                               **图 282：基于用户的 SNMP 版本 2 (SNMPv2u) 通用消息格式**

<u>**SNMPv2 PDU 格式**</u>

SNMPv2协议数据单元的格式在RFC 1905中有描述，与SNMPv1类似。 SNMPv2 中所有 PDU 的格式都是相同的，除了 GetBulkRequest-PDU 消息。 （奇怪的是，这包括 Trapv2-PDU 消息，尽管 SNMPv1 中的 Trap-PDU 消息使用了不同的格式）。

<u>**SNMPv2 通用 PDU 格式**</u>
表 218 和图 283 显示了这种常见的 PDU 格式。 表 219 包含错误状态字段的不同值及其解释方式的列表。


​                                                         **表 218：SNMP 版本 2 (SNMPv2) 通用 PDU 格式**

| **Field Name**           | **Syntax**             | **Size (bytes)** | **Description**                                              |
| ------------------------ | ---------------------- | ---------------- | ------------------------------------------------------------ |
| ***PDU Type\***          | *Integer* (Enumerated) | 4                | ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\aa2107c5.png) |
| ***Request ID\***        | *Integer*              | 4                | ***Request Identifier:\*** 请求标识符：用于匹配请求和回复的数字。它由发送请求的设备生成，并由响应 SNMP 实体复制到 Response-PDU 中的该字段。 |
| ***Error Status\***      | *Integer* (Enumerated) | 4                | ***Error Status:\***错误状态：一个整数值，在 Response-PDU 中用于告知请求 SNMP 实体其请求结果。零值表示没有发生错误；其他值表示发生了什么类型的错误。 请注意，前六个值（0 到 5）保留为 SNMPv1 中使用的兼容性，但 SNMPv2 添加了许多新的错误代码，这些代码提供了请求中错误的确切性质的更具体指示。仅当没有特定错误类型（旧代码或新代码）适用时，genErr 代码仍然使用。 由于有许多不同的错误状态代码，我在表 219 中分别列出了它们。 |
| ***Error Index\***       | *Integer*              | 4                | ***Error Index:\*** 错误索引：当错误状态为非零时，该字段包含一个指针，用于指定哪个对象产生了错误。在请求中始终为零。 |
| ***Variable Bindings\*** | Variable               | Variable         | ***Variable Bindings:\*** 变量绑定：一组名称-值对，标识 PDU 中的 MIB 对象，在消息而非请求的情况下，包含它们的值。有关这些绑定的更多信息，请参阅一般消息格式主题。 |

​                                                

​                                            **表 219：SNMP 版本 2 (SNMPv2) PDU 错误状态字段值**

| **Error Status Value** | **Error Code**      | **Description**                                              |
| ---------------------- | ------------------- | ------------------------------------------------------------ |
| **0**                  | noError             | 没有错误发生。此代码也用于所有请求 PDU，因为它们没有要报告的错误状态。 |
| **1**                  | tooBig              | Response-PDU 的大小太大而无法传输。                          |
| **2**                  | noSuchName          | 找不到请求的对象的名称。                                     |
| **3**                  | badValue            | 请求中的值与请求的接收者对对象的结构不匹配。例如，请求中指定的对象的长度或类型不正确。 |
| **4**                  | readOnly            | 试图设置一个变量，该变量的访问值表明它是只读的。             |
| **5**                  | genErr              | 发生了一个错误，而不是由该表中更具体的错误代码指示的错误。   |
| **6**                  | noAccess            | 出于安全原因，拒绝访问该对象。                               |
| **7**                  | wrongType           | 变量绑定中的对象类型不正确。                                 |
| **8**                  | wrongLength         | 变量绑定指定的对象长度不正确。                               |
| **9**                  | wrongEncoding       | 变量绑定为对象指定了不正确的编码。                           |
| **10**                 | wrongValue          | 变量绑定中给定的值对于对象来说是不可能的。                   |
| **11**                 | noCreation          | 指定的变量不存在，无法创建。                                 |
| **12**                 | inconsistentValue   | 变量绑定指定一个值，该值可以由变量持有但此时不能分配给它。   |
| **13**                 | resourceUnavailable | 尝试设置变量需要不可用的资源。                               |
| **14**                 | commitFailed        | 尝试设置特定变量失败。                                       |
| **15**                 | undoFailed          | 将特定变量设置为一组变量的一部分的尝试失败，然后撤消其他变量设置的尝试也不成功。 |
| **16**                 | authorizationError  | 授权出现问题。                                               |
| **17**                 | notWritable         | 无法写入或创建变量。                                         |
| **18**                 | inconsistentName    | 变量绑定中的名称指定了一个不存在的变量。                     |

​                                       

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\snmpv2pduformat.png)

​												  **图 283：SNMP 版本 2 (SNMPv2) 通用 PDU 格式**



<u>**SNMPv2 GetBulkRequest-PDU 格式**</u>

SNMPv2 GetBulkRequest-PDU消息的特殊格式如表220和图284所示。


​                                        **表 220：SNMP 版本 2 (SNMPv2) GetBulkRequest-PDU 格式**

| **Field Name**           | **Syntax**             | **Size (bytes)** | **Description**                                              |
| ------------------------ | ---------------------- | ---------------- | ------------------------------------------------------------ |
| ***PDU Type\***          | *Integer (Enumerated)* | 4                | ***PDU Type:\*** PDU Type：一个整数值，表示 PDU 类型，对于 GetBulkRequest-PDU 消息为 5。 |
| ***Request ID\***        | *Integer*              | 4                | ***Request Identifier:\*** 请求标识符：用于匹配请求和回复的数字。它由发送请求的设备生成，并由响应 SNMP 实体复制到 Response-PDU 中的该字段。 |
| ***Non Repeaters\***     | *Integer*              | 4                | ***Non Repeaters:\*** Non Repeaters：指定请求中变量列表开头的非重复、常规对象的数量。 |
| ***Max Repetitions\***   | *Integer*              | 4                | ***Max Repetitions:\*** Max Repetitions：非重复对象之后的重复对象在表中要读取的迭代次数。 |
| ***Variable Bindings\*** | Variable               | Variable         | ***Variable Bindings:\*** 变量绑定：一组标识 PDU 中的 MIB 对象的名称-值对。有关这些绑定的更多信息，请参阅一般消息格式主题。 |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\snmpv2getbulkpduformat.png)

​                                                    **图 284：SNMP 版本 2 (SNMPv2) GetBulkRequest-PDU 格式**



**注意：**有关 SNMP 表遍历的主题包含有关如何使用 Non Repeaters 和 Max Repetitions 的完整详细信息。



###### 3.2.3.3-5 SNMP 版本 3 (SNMPv3) 消息格式

在 1990 年代后期，创建了 SNMP 版本 3 以解决 SNMPv2 的许多不同变体出现的问题。 SNMPv3 框架采用了许多在 SNMPv2 中创建的组件，包括 SNMPv2 协议操作、PDU 类型和 PDU 格式。在 SNMPv3 中所做的重大更改包括以更灵活的方式定义安全方法和参数，以允许多种安全技术共存。

SNMPv3 的通用消息格式仍然遵循相同的整体消息“包装器”思想，其中包含一个报头和一个封装的 PDU。然而，在版本 3 中，这个概念得到了进一步完善。标头中的字段本身已分为处理安全问题的字段和不处理安全问题的字段。 “非安全”字段对所有 SNMPv3 实现都是通用的，而安全字段的使用可以由每个 SNMPv3 安全模型定制，并由处理安全的 SNMP 实体中的模块处理。该解决方案提供了相当大的灵活性，同时避免了困扰 SNMPv2 的问题。

RFC 3412 描述了整个 SNMPv3 消息格式，它描述了版本 3 的消息处理和调度。如表 221 和图 285 所示。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\snmpv3format.png)



​                                                             **图 285：SNMP 版本 3 (SNMPv3) 通用消息格式**



​                                                            **表 221：SNMP 版本 3 (SNMPv3) 通用消息格式**

| **Field Name**                 | **Syntax**     | **Size (bytes)** | **Description**                                              |
| ------------------------------ | -------------- | ---------------- | ------------------------------------------------------------ |
| ***Msg Version\***             | *Integer*      | 4                | ***Message Version Number:\*** Message Version Number：描述这条消息的SNMP版本号；用于确保版本之间的兼容性。对于 SNMPv3，此值为 3。 |
| ***Msg ID\***                  | *Integer*      | 4                | ***Message Identifier:\*** 消息标识符：用于标识 SNMPv3 消息并将响应消息与请求消息相匹配的数字。该字段的使用类似于 PDU 格式中的请求 ID 字段（见表 218），但它们并不相同。创建此字段是为了允许在消息处理级别进行匹配，而不管 PDU 的内容如何，以防止某些安全攻击。因此，Msg ID 和 Request ID 是独立使用的。 |
| ***Msg Max Size\***            | *Integer*      | 4                | ***Maximum Message Size:\***最大消息大小：此消息的发件人可以接收的最大消息大小。该字段的最小值为 484。 |
| ***Msg Flags\***               | *Octet String* | 1                | ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\aa20f302.png) |
| ***Msg Security Model\***      | *Integer*      | 4                | ***Message Security Model:\*** 消息安全模型：一个整数值，指示哪个安全模型用于此消息。对于基于用户的安全模型（SNMPv3 中的默认值），该值为 3。 |
| ***Msg Security Parameters\*** | —              | Variable         | ***Message Security Parameters:\*** 消息安全参数：一组字段，其中包含实现用于此消息的特定安全模型所需的参数。该字段的内容在每个描述 SNMPv3 安全模型的文档中指定。例如，基于用户的模型的参数在 RFC 3414 中。 |
| ***Scoped PDU\***              | —              | Variable         | ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\aa20f3c4.png) |

现在，让我们看看 SNMPv3 的 PDU 格式。 啊哈！ 我们幸免于此，因为 SNMPv3 使用 SNMPv2 的协议操作； 这在 RFC 3416 中有所描述，它只是 RFC 1904 的更新。因此，PDU 格式与上一主题中的相同。 呸！



###### 3.2.4 TCP/IP 远程网络监控 (RMON)（部分：1 2 3）

简单网络管理协议 (SNMP) 定义了用于在 TCP/IP 互联网络上交换网络信息的框架和特定协议。 SNMP 使用的一般模型是网络管理站 (NMS)，它向在受管设备上运行的 SNMP 代理发送请求。 SNMP 代理还可以通过发送陷阱消息来启动某些类型的通信，以在特定事件发生时通知 NMS。

该模型运行良好，这就是 SNMP 变得如此流行的原因。然而，该协议及其使用的模型的一个基本限制是它面向来自 SNMP 代理的网络信息通信，这些代理通常是常规 TCP/IP 设备的一部分，例如主机和路由器。这些设备收集的信息量通常是有限的，因为显然主机和路由器有“真正的工作要做”——即做主机和路由器的工作。他们不能全身心地投入到网络管理任务中。

因此，在需要比传统设备收集的更多网络信息的情况下，管理员通常会使用称为网络分析器、监视器或探测器的特殊硬件单元。这些是连接到网络的专用设备，严格用于收集统计数据和监视管理员感兴趣或关注的事件。如果这些设备可以使用 SNMP 来允许检索它们收集的信息，并让它们在发现重要事件时生成陷阱，那显然会非常有用。

为此，创建了远程网络监控 (RMON) 规范。 RMON 通常被称为协议，您有时会看到 SNMP 和 RMON 被称为“TCP/IP 网络管理协议”。然而，RMON 实际上根本不是一个单独的协议——它没有定义任何协议操作。 RMON 实际上是 SNMP 的一部分，RMON 规范只是一个管理信息库 (MIB) 模块，它定义了一组特定的 MIB 对象，供网络监控探测器使用。在架构上，它只是构成 SNMP 框架的众多 MIB 模块之一。

**关键概念**：创建 SNMP 远程网络监控 (RMON) 是为了使用网络分析仪、监视器或探测器等专用管理设备实现网络的高效管理。 RMON 通常被称为“协议”，但实际上并没有定义任何新的协议操作；它是 SNMP 的 MIB 模块，描述了允许高级网络管理功能的对象。

<u>**RMON 标准**</u>
记录 RMON 的第一个标准是 RFC 1271，即远程网络监控管理信息库，于 1991 年发布。RFC 1271 于 1995 年被 RFC 1757 取代，RFC 1757 对规范进行了一些更改。 RFC 2819，2000 年 5 月，更新 RMON 以使用新的管理信息结构版本 2 (SMIv2) 规范，该规范是 SNMPv2 的一部分，但在功能上与 RFC 1757 相同。

<u>**RMON MIB 层次结构和对象组**</u>

由于 RMON 是一个 MIB 模块，它几乎完全由 MIB 对象的描述组成，每个对象都具有属于所有此类对象的标准特征。 RMON 中的所有对象都被安排到 rmon 组内的 SNMP 对象名称层次结构中，它是 SNMP mib (mib-2) 对象树中的组号 16，1.3.6.1.2.1。所以，所有 RMON 对象都有以 1.3.6.1.2.1.16 开头的标识符。这个单一的 RMON 组被分解成几个较低级别的组，这些组为规范定义的 RMON 对象提供更多结构。图 286 显示了此结构。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\rmontree.png)


​                                                     **图 286：SNMP 远程网络监控 (RMON) MIB 层次结构**

RMON 使用一个特殊的 MIB 模块，rmon(16)，它适合在 mgmt(2) 中的 mib/mib-2(1) 下的整个 SNMP 对象层次结构树——就像其他 MIB 对象组，如 sys(1) 和如果(2);参见图 273。在这个具有组标识符 1.3.6.1.2.1.16 的组中，有 9 个 RMON 对象子组。


表 222 描述了每个 RMON 组，显示了每个组的名称、组代码（用作组中对象描述符的前缀）、RMON 组号和 SNMP 对象层次标识符：


​                                                         **表 222：SNMP RMON MIB 对象组**

| **RMON Group Name** | **RMON Group Code**          | **RMON Group Number** | **Full Group Identifier** | **Description**                                              |
| ------------------- | ---------------------------- | --------------------- | ------------------------- | ------------------------------------------------------------ |
| ***statistics\***   | ***etherStats\***            | 1                     | 1.3.6.1.2.1.16.1          | 跟踪设备测量的网络统计信息的对象。示例统计信息包括网络流量负载、平均数据包大小、观察到的广播数量、发生的错误计数、各种大小范围内的数据包数量等等。 |
| ***history\***      | ***history, etherHistory\*** | 2                     | 1.3.6.1.2.1.16.2          | 历史组包含一个表对象，该对象控制探针对统计数据进行采样的频率。额外的 etherHistory 组是可选的，包含额外的以太网特定信息；它在逻辑上包含在 history 组中。 |
| ***alarm\***        | ***alarm\***                 | 3                     | 1.3.6.1.2.1.16.3          | 该组定义了可以生成警报以通知管理员导入发生的参数。警报组包含一个表，该表描述了将触发事件的阈值（请参阅下面的事件组）。 |
| ***hosts\***        | ***host\***                  | 4                     | 1.3.6.1.2.1.16.4          | 包含跟踪网络上每台主机信息的对象。                           |
| ***hostsTopN\***    | ***hostTopN\***              | 5                     | 1.3.6.1.2.1.16.5          | 该组包含有助于报告以特定方式排序的主机的对象。管理员决定如何跟踪这些有序的统计信息。例如，管理员可以生成一份报告，列出按传输的数据包数量排序的主机，显示最活跃的设备。 |
| ***matrix\***       | ***matrix\***                | 6                     | 1.3.6.1.2.1.16.6          | 该组跟踪特定主机对之间数据交换的统计数据。因此，可以在此处跟踪网络上任意两个设备之间发送的数据量。由于大型网络可能有数千个这样的设备对，为了节省探测资源，管理信息库中通常只保留设备对之间最近的“对话”。 |
| ***filter\***       | ***filter\***                | 7                     | 1.3.6.1.2.1.16.7          | 这个 RMON 组允许管理员设置过滤器来控制探测器将捕获的网络数据包种类。 |
| ***capture\***      | ***buffer, capture\***       | 8                     | 1.3.6.1.2.1.16.8          | 该组用于允许探测器根据过滤器组中设置的特定参数捕获数据包。   |
| ***event\***        | ***event\***                 | 9                     | 1.3.6.1.2.1.16.9          | 当根据报警组中对象中的参数触发特定报警时，会生成一个事件。该组控制如何处理这些事件，包括创建 SNMP 陷阱消息并将其发送到网络监控站。 |



最初的 RMON 标准主要围绕以太网 LAN，您可以在上表中看到其中的一些内容。 通过使用为此目的创建的其他 RMON 组，探测器还可以收集和报告与其他网络技术相关的信息。 最好的例子就是专门为令牌环定义了一组组，这是在 1993 年的 RFC 1513 中定义的。

<u>**RMON 告警、事件和统计**</u>

告警和事件是 RMON 中特别有用的结构，因为它们允许将重要信息立即传送到网络管理站。管理员可以完全控制什么条件会导致“响起”警报以及如何生成事件。这包括指定要监控的变量或统计数据、检查它们的频率以及触发警报的值。当事件发生时，也可以记录日志条目。如果事件导致陷阱消息的传输，管理员将因此收到通知，并可以根据事件的严重性决定如何响应。

与所有 MIB 模块和组一样，特定制造商可以决定实施哪些 RMON 组。但是，某些组是相关的，例如警报和事件，而某些组（例如统计信息）几乎总是在所有 RMON 探测器中实现。显然，当使用 RMON 时，网络管理站必须知道 RMON 组，并且必须允许运行将利用 RMON MIB 对象功能的网络管理应用程序。



### 第四章、TCP/IP关键应用和应用协议

几个世纪以来，哲学家们一直在为这个问题而苦苦挣扎：“这到底是怎么回事？”不用说，生命的意义有点超出了本指南的范围。 😄 然而，我们可以在网络本身的范围内审视这个困境。网络有什么用？我们为什么还要费心创建网络？这是怎么回事？

简单的答案是，本指南中检查的所有硬件设备、软件模块和分层协议都是实现一个真正目的的手段：使人们能够使用网络应用程序。分层的真正威力在于，它允许创建自动使用较低级别技术进行通信的应用程序，而不必担心通信如何完成的细节。这使应用程序程序员可以自由地创建各种各样的应用程序，这些应用程序可以找到许多不同的方式来促进信息交换。

TCP/IP 协议族是现代互联网络的基础，因此，已被用作开发和实施网络应用程序的主要平台。在过去的几十年中，随着全球 TCP/IP Internet 的发展，已经创建了数百个新应用程序。这些程序使可能在同一个房间或不同大陆的用户能够完成无数不同的任务和功能，从执行基本的业务任务到纯粹的娱乐。

试图描述每个可能的 TCP/IP 应用程序是不可能的，甚至尝试也毫无意义。然而，在所有的TCP/IP应用中，有一小部分被广泛认为是TCP/IP的“关键应用”。大多数已经存在了很长时间——在某些情况下，甚至比现代互联网协议本身还要长。它们通常作为 TCP/IP 应用程序协议实现，并使用与其他 TCP/IP 协议套件组件相同的 RFC 流程和标准进行定义。

本节描述了其中一些权威的 TCP/IP 应用程序和应用程序层协议。在进入应用程序本身之前，我解释了为 TCP/IP 应用程序设置的用于寻址 Internet 资源的通用系统：统一资源标识符 (URI)，它可以是统一资源定位符 (URL) 或统一资源名称 (URN) .这些以在万维网上的使用而闻名，但实际上可以被各种应用程序使用。

然后我提供几个小节来讨论应用程序组本身。第一个描述文件和消息传输应用程序；这个组是最大的，因为它包含许多我们认为是 TCP/IP 网络核心的应用程序，例如电子邮件、文件传输和万维网。第二部分描述了交互式和远程应用程序协议，这些协议传统上用于允许一台计算机的用户访问另一台计算机，或者允许实时交换信息。第三部分讨论了 TCP/IP 管理和故障排除实用程序，管理员和最终用户都可以使用它们。



### 4.1 TCP/IP 应用层寻址：统一资源标识符、定位符和名称（URI、URL 和 URN）

Internet 由数百万个相互连接的服务器组成，每个服务器都能够向请求它的 Internet 用户提供有用的信息。一个网络拥有的信息越多，它就越丰富，但也就越难定位。为了使用信息，我们需要能够找到它，而这至少需要我们采用某种方式来标记每个文件或对象。

为此，TCP/IP 定义了一个统一资源标识符 (URI) 系统，可以在 Internet 和专用 TCP/IP 网络上使用。每个 URI 都唯一地指定了客户端如何找到特定资源并访问它以便使用它。 URI 细分为统一资源定位符 (URL) 和统一资源名称 (URN)，它们的用途相似，但工作方式不同。

在本节中，我将描述在 Internet 上用于识别文件、对象和资源的寻址系统。我从概述开始，介绍了统一资源标识符 (URI) 的概念，并解释了 URI、URL 和 URN 之间的区别。目前，URL 的使用频率比 URN 高得多。因此，我包含了一个完整的小节，其中包含几个主题，详细介绍了 URL 的语法，以及与它们的使用方式相关的重要问题。我还有一个摘要主题，它对 URN 及其在 Internet 寻址中的作用进行了概述。



#### 4.1.1 统一资源标识符、定位符和名称（URI、URL 和 URN）：概述、历史、意义和标准（部分：1 2 3）

如果您在阅读本指南的过程中一直在“逐步提高”OSI 参考模型层，那么您可能已经预料到此时您已经完成了寻址。毕竟，我们已经讨论了第二层的 MAC 地址和第三层的 IP 地址，以及它们之间的转换机制。我们甚至拥有提供传输层寻址功能的端口和套接字，让每个设备运行多个软件应用程序。考虑到这一切，“应用层寻址”的想法可能看起来有点奇怪，而且我知道用这个术语来指代本节的主题可能有点不合常理。

<u>**应用层寻址的基本原理**</u>
然而，为应用程序寻址的概念并不像乍看起来那么奇怪。的确，通过 IP 地址和端口号，理论上我们可以访问 TCP/IP 互联网上的任何资源——问题在于找到它。应用层寻址不是计算机软件所要求的；它使人类更容易识别和定位资源。

事实上，这与用于证明创建名称系统（如域名系统 (DNS)）合理性的基本原理非常相似。 DNS 是一种高级寻址形式，允许使用名称而不是 IP 地址。它同样重要的不是计算机，而是人们，他们更了解“www.intel.com”的含义，而不是“198.175.96.33”。

综合应用层寻址方案背后的想法是将 DNS 已经完成的工作扩展到下一个级别。 DNS 名称提供基本的高级抽象寻址，但仅限于整个设备（无论是真实的还是虚拟的）。这些名称可用作更完整的标签方案的基础，该方案不仅指向站点或设备，还指向特定文件、对象或其他资源。在 TCP/IP 中，这些标签称为统一资源标识符 (URI)。

URI 是作为万维网 (WWW) 的一部分开发的关键技术之一，并且仍然最常与 WWW 和实现它的协议 HTTP 相关联。您过去可能使用过 URI 数千次；每当您在 Web 浏览器中输入“http://www.myfavoritewebsite.com”之类的内容时，您就是在使用 URI。 （URI？这不是一个 URL 吗？我保证，我到了那里。）

URI 对 Web 如此重要的原因是它们将引用资源所需的所有信息组合到一个字符串中。这种表达的紧凑性对于超文本资源链接的整个概念是必不可少的。如果我们希望能够让一个文档中的对象指向另一个文档，我们需要有一种简单的方法来描述该对象，而不需要一整套指令。 URI 使我们能够做到这一点。

事实上，URI 与 Web 的关联如此之大，以至于它们通常被描述为特定的 Web 技术的一部分。然而，它们并不是 Web 独有的，这就是为什么本节与讨论 WWW/HTTP 的部分分开的原因。

<u>**URI 类别**</u>

URI 实际上是一种用于引用多种 TCP/IP 资源的通用方法。它们目前根据描述资源的方式分为两个主要类别：

- 统一资源定位符 (URLs)：URL 是统一资源标识符，它通过协议或访问机制与特定资源位置的组合来引用资源。 URL 以用于访问资源的协议名称开头，然后包含足够的信息以指出如何获取它。

- 统一资源名称 (URN)：URN 是一种统一资源标识符，它提供了一种唯一命名资源的方法，无需指定访问协议或机制，也无需指定特定位置。

URL 和 URN 之间的区别在于，前者更具体并且以如何访问资源为导向，而后者更抽象并且更多地设计用于识别资源是什么而不是描述如何获取资源。给某人一个 URL 就像给他们指明找书的方向，如下所示：“乘坐火车到阿尔伯克基，然后乘坐 11 号巴士到艾伯特街 41 号，这是乔安妮·约翰逊拥有的一座红砖房。你要的书在二楼书架底下右数第三本。” URN 更像是使用国际标准书号 (ISBN) 来指代一本书；它唯一地标识了这本书，而不管这本书位于何处，并且不会告诉您如何访问它。 （事实上，ISBN 是与 URN 一起使用的识别系统之一。）

虽然 URL 和 URN 在理论上是对等的，但在实践中，URL 的使用远远超过 URN。事实上，URL 如此占主导地位，以至于大多数人甚至从未听说过 URI 或 URN。原因在于，尽管上面的示例表明 URN 比 URL 更“自然”，但 URL 在实践中更易于使用——它们提供访问资源所需的信息，并且无需访问资源，只需知道如何识别它的价值有限。 URN 是一个有吸引力的概念，因为它们标识资源而不将其绑定到特定的访问机制或位置。然而，URN 的实现需要一些方法将资源的永久标识符绑定到它在任何给定时刻的位置，这不是一项简单的任务。出于这个原因，URN 和使用它们的方法已经开发了很多年，而 URL 一直在积极使用。

虽然 URL 以 Web 开头，并且大多数 URL 仍在与 HTTP 一起使用，但它们可以而且确实指代使用许多其他协议（例如 FTP 和 Telnet）访问的资源。同样，URI 的紧凑性使它们非常强大；通过 URL，我们可以使用一个字符串来告诉程序使用 FTP 检索文件。这取代了启动 FTP 客户端、建立会话、登录和发出命令的完整 FTP 过程。

**关键概念：**任何互联网络都需要某种机制来允许识别和访问文件、目录和程序等资源。在 TCP/IP 中，统一资源标识符 (URI) 用于这种“应用层寻址”。两种类型的 URI 是统一资源定位符 (URL)，它指定如何使用访问方法和位置的组合访问对象，以及统一资源名称 (URN)，它按名称标识对象但不指示如何访问访问它。

<u>**URI 标准**</u>

1990 年代发布的许多 Internet 标准描述了 URI、URL 和 URN 的语法和基本用法。第一个是 RFC 1630，WWW 中的通用资源标识符，它于 1994 年发布，至今仍是对该主题的一个很好的概述。 1994 年 12 月，一对文档 RFC 1737 和 1738 分别提供了关于 URN 和 URL 的更具体的信息。 RFC 1808 描述了如何定义和使用相对 URL，而 RFC 2141 提供了有关 URN 语法的更多信息。

RFC 2396，Uniform Resource Identifiers (URI): Generic Syntax，于 1998 年 8 月发布，用于修改和替换刚才提到的许多先前 RFC 中的一些信息。它可能是目前关于 URI 的权威标准，尽管 RFC 继续发布讨论与 URI 相关的问题。对于 URN 尤其如此，正如我之前所说，它仍在积极开发中。

诸如 RFC 2396 之类的基础文档描述了如何为许多通用协议指定 URL（在 URL 中称为方案，我们将在更仔细地研究 URL 时看到这一点）。为了提供灵活性，还定义了一种机制来允许注册新的 URL 方案。这在 RFC 2717“URL 方案名称的注册程序”和 RFC 2718“新 URL 方案指南”中进行了描述。还有一些 RFC 描述了不同协议的特定 URL 方案，包括 RFC 2192 (IMAP)、2224 (NFS)、2368 (电子邮件) 和 2384 (POP)。

**是不是迷糊了:URL是一种URI，它标识一个互联网资源，并指定对其进行操作或获取该资源的方法。可能通过对主要访问手段的描述，也可能通过网络“位置”进行标识。URI可被视为定位符（URL），名称（URN）或两者兼备。统一资源名（URN）如同一个人的名称，而统一资源定位符（URL）代表一个人的住址。换言之，URN定义某事物的身份，而URL提供查找该事物的方法。URN仅用于命名，而不指定地址。**

#### 4.1.2 统一资源定位符 (URL)

统一资源定位符 (URL) 是文本字符串，允许根据资源在互联网上的位置以及访问它的主要方法或协议来标记文件或其他对象等资源。由于其简单性，URL 已成为 TCP/IP 中用于应用程序层寻址的最常见的统一资源标识符 (URI) 类型。

在本节中，我将详细解释统一资源定位符及其使用方法。我首先概述用于标准 URL 的一般语法，有时称为“绝对”URL 以将它们与相对 URL 区分开来。然后，我将描述用于最常见应用程序和访问方法的 URL 方案，以及每种方案使用的特定语法。然后我将讨论相对 URL 的工作原理以及它们的重要性。最后，我讨论了一些与使用 URL 相关的现实问题；这包括与长而复杂的 URL 相关的问题，以及一些不法分子故意混淆“游戏”的问题。

**背景信息：**在阅读本节之前，请确保您已经阅读了关于 URI、URL 和 URN 的概述主题，因为该主题包含对什么是 URL 的基本全面介绍。

##### 4.1.2.1 URL 通用语法（部分：1 2 3 4）

统一资源定位符 (URL) 是统一资源标识符 (URI) 的子集，由两个组件组成，这两个组件标识如何访问 TCP/IP 互联网络上的资源。这两个组成部分是资源的位置，以及用于访问它的方法。将这两条信息放在一起，允许使用适当软件的用户获取、读取或以其他方式使用许多不同类型的资源，例如文件、对象、程序等等。

URL 的最一般语法形式仅包含两个元素，它们对应于刚刚描述的两条信息：

​			<scheme>:<scheme-specific-part>
术语方案是指一种访问方法，它描述了资源的使用方式；它通常指的是应用程序协议，如“http”或“ftp”，或资源类型，如“文件”。方案名称必须仅包含字母、加号（“+”）、句点（“.”）和连字符（“-”）。实际上，它们通常只包含字母。方案不区分大小写，但通常以小写字母表示。

方案后的其余 URL（以及所需的冒号分隔符）是特定于方案的。这是必要的，因为各种协议和访问方法需要不同类型和数量的信息来标识特定资源。读取 URL 时，方案名称会告诉解析它的程序如何解释 URL 其余部分的语法。

**关键概念：**统一资源定位符 (URL) 是使用最广泛的 URI 类型。在其最基本的形式中，URL 由两个元素组成：一个定义协议或其他访问资源机制的方案，以及一个特定于方案的部分，该部分包含标识特定资源并指示应如何使用它的信息。一些方案对其特定于方案的部分使用通用语法，而其他方案则使用该方案独有的语法。

<u>**通用互联网方案语法**</u>

理论上，每个方案都可能对“<scheme-specific-part>”使用完全不同的语法。然而，由于它们在如何引用互联网络设备和这些设备上的资源方面的相似性，许多这些方案在这部分共享一个通用语法。例如，HTTP和FTP都用于使用DNS名称或IP地址指向特定的TCP/IP设备，然后访问存储在分层目录结构中的资源。他们的 URL 至少有些相似是有道理的。

这种常见的 Internet 方案语法的最一般形式如下：

​			<scheme>://<user>:<password>@<host>:<port>/<url-path>;<params>?<query>#<fragment>
此语法的元素如下：

- <scheme>：URL 方案，如上所述。
- <user>和<password>：需要登录的方案的认证信息，形式为用户名和密码。

- <host>：Internet 主机，通常指定为完全限定的 DNS 域名或点分十进制表示法的 IP 地址。

- <port>：调用适合该方案的协议时使用的 TCP 或 UDP 端口号。

- <url-path>：资源位置路径。这通常是一个完整的目录路径，表示从根目录到资源所在位置要遍历的目录顺序，然后是资源名称。例如，如果设备上有一个名为“project1”的目录，其中有一个名为“memos”的子目录，其中包含一个名为“June11th-minutes.txt”的文本文件，URL 路径为“project1/memos/June11th-minutes.txt” ” 将引用该资源。
- 请注意，<url-path> 之前的斜线是必需的，虽然从技术上讲它不被视为路径的一部分，但它的作用类似于在许多文件系统中表示根目录的斜线。此外，<url-path> 可能以斜杠结尾，这意味着该路径专门指代一个目录。然而，这通常不是必需的，因为服务器会在需要时将 URL 视为上下文引用的目录。路径还可以指虚拟文件、程序或资源而不是“普通”文件。

- <params>：包含特定于方案的参数，用于控制方案如何用于访问资源。每个参数通常采用“<parameter>=<value>”的形式，每个参数规范与下一个参数规范使用分号分隔。

- <query>：访问资源时传递给服务器的可选查询或其他信息。

- <fragment>：标识 URL 用户感兴趣的资源中的特定位置。
  图 287 使用示例 HTTP URL 说明了这种通用语法及其元素。



![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\urlsyntax.png)


​                                                                   **图 287：示例统一资源定位符 (URL)**

此图显示了一个示例 URL，其中包含通用方案语法中几乎所有可能的元素，每个元素都使用时髦的彩虹色框突出显示。 J 此 URL 标识 Web (HTTP) 资源，必须使用端口 8080 在站点“www.mysite.org”上使用特定密码访问该资源。本例中的资源是站点“cgi-bin”目录中的 PHP 程序这会导致显示特定页面的照片。 “<fragment>”说明符将使检索到的婚礼照片页面上的图片“Reception07”显示给用户。

<u>**省略 URL 语法元素**</u>

完整的 URL 语法可能看起来非常复杂，但请记住，这是一个正式定义，一次显示了 URL 中所有可能的元素。大多数方案并不使用这些元素中的每一个，而且，即使它们在特定方案中有效，其中许多也是可选的。例如，HTTP URL 正式支持 <login> 和 <password>，但很少使用。同样，端口号通常被省略，告诉客户端软件只使用方案的默认端口号。下一个主题描述了一些最常见的 URL 方案和用于它们的特定语法，包括讨论如何以及何时使用这些元素。

尽管不经常需要丰富的 URL 语法，但在特殊情况下它可用于提供各种信息。 URL 在表达方式方面也非常灵活。例如，虽然“<host>”通常是一个 DNS 名称，但它也可以是以多种形式表示的 IP 地址，包括点分十进制、常规十进制、十六进制、八进制甚至这些的组合。不幸的是，大多数人对其中一些“深奥的知识”缺乏熟悉，导致 URL 通过故意混淆而被滥用，让人们访问他们通常想要避免的“资源”。

***URL Fragments\***
从技术上讲，描述资源命名的标准不认为“<片段>”是 URL 的正式部分。原因是它只标识了资源的一部分，而不是标识资源本身所需的信息的一部分。它不发送给服务器，而是由客户端软件保留，以指导其如何显示或使用资源。然而，有些人会提出一个有效的论点，即这种区分有些武断；例如，考虑方案本身也仅由客户端使用，主机本身也是如此。

最常见的 URL 片段示例是在显示网页时指定要“滚动”到的特定书签。实际上，片段标识符通常被视为 URL 的一部分，因为它是指定 URL 的字符串的一部分。



<u>**“不安全”字符和特殊编码**</u>

URL 通常以标准的美国 ASCII 字符集表示，这是大多数 TCP/IP 应用程序协议使用的默认字符集。该集合中的某些字符被称为不安全字符，因为它们在不同的上下文中具有特殊含义，并且将它们包含在 URL 中会导致歧义或解释它们的方式出现问题。 “空格”字符是经典的“不安全”字符，因为空格通常用于分隔 URL，因此在 URL 中包含一个字符会将 URL 分成“片段”。其他字符是“不安全的”，因为它们在 URL 中具有特殊意义，例如冒号（“:”）。

URL 中的“安全”字符是字母数字（A 到 Z、a 到 z 和 0 到 9）和以下特殊字符：美元符号（“$”）、连字符（“-”）、下划线（“_”） )、句点（“.”）、加号（“+”）、感叹号（“!”）、星号（“*”）、撇号（“'”）、左括号（“(”）和右括号（“）”）。所有其他“不安全”字符都可以使用由百分号（“%”）后跟字符的十六进制 ASCII 值组成的编码方案在 URL 中表示。表 223 中给出了最常见的示例。


​                                                                             **表 223：URL 特殊字符编码**

| **Character** | **Encoding** | **Character** | **Encoding** | **Character** | **Encoding** |
| ------------- | ------------ | ------------- | ------------ | ------------- | ------------ |
| <space>       | %20          | <             | %3C          | >             | %3E          |
| #             | %23          | %             | %25          | {             | %7B          |
| }             | %7D          | \|            | %7C          | \             | %5C          |
| ^             | %5E          | ~             | %7E          | [             | %5B          |
| ]             | %5D          |               | `%60         | ;             | %3B          |
| /             | %2F          | ?             | %3F          | :             | %3A          |
| @             | %40          | =             | %3D          | %             | %26          |



当遇到这些序列时，它们被解释为它们所代表的文字字符，没有任何“意义”。 因此，URL“http://www.myfavesite.com/are%20you%20there%3F”指向一个名为“are you there?”的文件。 在“www.myfavesite.com”上。 “%20”代码防止空格打断 URL，“3F”防止文件名中的问号被解释为特殊的 URL 字符。

注意：由于百分号用于这种编码机制，所以它本身就是“特殊的”； 任何时候看到下一个值都被解释为字符编码，因此要嵌入文字百分号，它必须编码为“%25”。


同样，不幸的是，这些编码有时会被滥用于恶意目的，例如将它们用于常规 ASCII 字符以**隐藏 URL**。



##### 4.1.2.2 URL 方案（应用程序/访问方法）和特定于方案的语法（部分：1 2 3 4 5）

统一资源定位器 (URL) 使用描述访问 TCP/IP 资源的位置和方法的通用语法。 每种访问方法（称为方案）都有自己特定的 URL 语法，包括该方法识别资源所需的各种信息。 RFC 1738 包含对几种流行的 URL 方案所使用的特定语法的描述。 使用为 URL 方案注册建立的过程，在后续的 RFC 中定义了其他的。

一些 URL 方案使用我在 URL 语法概述中给出的常见 Internet 模式。 其他方案根据需要使用完全不同（通常更简单）的结构。 作为参考，我将在这里再次重复一般语法，因为它将帮助您理解主题的其余部分：

​		

```
<scheme>://<user>:<password>@<host>:<port>/<url-path>;<params>?<query>#<fragment>
```

以下是最常见的 URL 方案和它们使用的特定于方案的语法。

<u>**万维网/超文本传输协议 URL 语法 (http)**</u>

Web 可能会使用常见 Internet 方案语法的大部分元素，如下所示：

​	

```
http://<user>:<password>@<host>:<port>/<url-path>?<query>#<bookmark>
```

正如概述中所讨论的，Web 是当今使用 URL 的主要应用程序。一个 URL 理论上可以包含大部分常见的 URL 语法元素，但实际上大部分都被省略了。大多数 URL 仅包含主机和资源路径。端口号通常被省略，暗示应该使用默认值 80。 “<query>”构造通常用于将参数或信息从客户端传递到 Web 服务器。

我在 HTTP 部分的单独主题中提供了有关如何使用 Web URL 的完整详细信息。

<u>**文件传输协议 URL 语法 (ftp)**</u>
FTP URL 的语法是：

```
ftp://<user>:<password>@<host>:<port>/<url-path>;type=<typecode>
```

FTP 是一种基于命令的交互式协议，因此为 FTP 使用 URL 似乎很奇怪。然而，FTP 最常见的用途之一是访问和读取单个特定文件，这就是 FTP URL 允许客户端执行的操作。 <user> 和 <password> 用于登录，匿名 FTP 访问可以省略。端口号通常被省略，默认为标准 FTP 控制通道端口 21。

“<url-path>”被解释为目录结构和文件名。发出适当的“CWD”（“更改工作目录”）命令以转到指定目录，然后为指定文件发出“RETR”（“检索”）命令。可选的“type”参数可用于指示文件类型：“a”指定 ASCII 文件检索或“i”指定图像（二进制）文件。 “类型”参数通常从 URL 中省略，客户端会根据文件名自动设置正确的模式。

例如，考虑这个 URL：

```
ftp://ftp.hardwarecompanyx.com/drivers/widgetdriver.zip
```

这相当于启动一个 FTP 客户端，建立一个匿名 FTP 连接到“ftp.hardwarecompanyx.com”，然后切换到“drivers”目录并检索文件“widgetdriver.zip”。客户端将以二进制模式检索文件，因为它是一个压缩的“zip”文件。

也可以使用 FTP URL 获取特定目录中的文件列表。这允许用户使用 URL 链接浏览 FTP 服务器的目录结构，以找到他或她想要的文件，然后检索它。这是通过为 <url-path> 指定目录名称并使用带有“d”的“<typecode>”的“type”参数来请求目录列表来完成的。同样，“type”参数通常被省略，当 URL 中给出目录名称时，软件会计算出向服务器发送“LIST”命令。

<u>**发送电子邮件的 URL 语法 (mailto)**</u>

定义了一种特殊的语法以允许 URL 表示向用户发送邮件的命令：

```
mailto:<电子邮件地址>
```

电子邮件地址采用标准 Internet 格式：“<用户名>@<域名>”。 这确实是一种不寻常的 URL 类型，因为它根本不代表一个对象，尽管一个人可以被认为是一种“资源”。

注意：请注意，可选参数（例如电子邮件的主题）也可以包含在 mailto URL 中。 然而，这个设施并不经常使用。

<u>**Gopher 协议 URL 语法 (gopher)**</u>
Gopher 协议的语法类似于 HTTP 和 FTP：

```
gopher://<host>:<port>/<gopher-path>
```

有关 Gopher 路径和协议如何运行的更多信息，请参阅有关 Gopher 协议的主题。

<u>**Network News/ Usenet URL 语法 (news)**</u>

Usenet (NetNews) 的 URL 规范定义了两种语法：

```
news://<newsgroup-name>
news://<message-id>
```

这两个 URL 都用于访问 Usenet 新闻组或特定消息，由消息 ID 引用。与“mailto”方案一样，这是一种特殊类型的 URL，因为它定义了一种访问方法，但没有提供描述如何定位新闻组或消息的详细信息。

根据定义，此 URL 的第一种形式被解释为“本地”。因此，例如，“news://alt.food.sushi”表示“使用默认新闻协议访问本地新闻服务器上的新闻组 alt.food.sushi”。默认的新闻协议通常是 NNTP（见下文）。第二种 URL 形式是全局的，因为消息 ID 在 Usenet 上是唯一的（或者至少应该是！）

***Network News Transfer Protocol URL Syntax (nttp)\***
This is a different URL type for news access:

```
nntp://<host>:<port>/<newsgroup-name>/<article-number>
```

与“news”不同，这种 URL 形式专门请求使用 NNTP 并标识特定的 NNTP 服务器。然后它告诉服务器要访问哪个新闻组以及该新闻组中的文章编号。请注意，每个服务器使用不同的顺序对文章进行编号，因此这仍然是一种“本地”形式的新闻寻址。端口号默认为 119。

尽管“nntp”形式似乎提供了更完整的资源规范，但“news”URL 更常用，因为它更简单。只在客户端软件中设置一次合适的 NNTP 服务器比每次都指定它更容易，因为客户端通常只使用一个 NNTP 服务器。

<u>**Telnet URL 语法 (telnet)**</u>

该方案用于打开到服务器的 Telnet 连接。这是语法：

```
telnet://<user>:<password>@<host>:<port>
```

实际上，用户名和密码经常被省略，这会导致 Telnet 服务器提示输入此信息。或者，可以提供“<user>”并省略密码（以防止被看到），服务器将仅提示输入密码。端口号默认为 Telnet 的标准端口 23，并且通常也被省略。

这种类型的 URL 很有趣，因为它标识的资源不是对象而是服务。

<u>**本地文件 URL 语法 (file)**</u>
这是一种特殊的 URL 类型，用于引用特定主机上的文件。标准语法是：

```
file://<host>:<url-path>
```

这种类型的 URL 也有些有趣，因为它描述了对象的位置而不是访问方法。允许访问互联网上任何地方的文件还不够通用，但通常用于引用已将名称分配给不同设备的局域网上的计算机上的文件。

还定义了一种特殊的语法来专门引用本地计算机上的文件：

```
file:///<url-path>
```

在这里，整个“//<host>:”元素已被一组三个斜杠所取代，具体意思是“查看本地主机”。

<u>**其他 URL 语法规则**</u>
浏览器经常使用额外的语法规则来支持微软操作系统的怪癖，尤其是“文件”方案。首先，Microsoft Windows 使用的反斜杠按照 TCP/IP 的要求表示为正斜杠。其次，由于在 Microsoft 操作系统的驱动器号规范中使用了冒号，因此冒号被“竖线”字符“|”取代，“有点像冒号”（请一起玩。J）

因此，要引用文件“C:\WINDOWS\SYSTEM32\DRIVERS\ETC\HOSTS”，可以使用以下 URL：

```
file:///C|/WINDOWS/SYSTEM32/DRIVERS/ETC/HOSTS
```

但是请注意，某些浏览器实际上允许在驱动器规范中使用冒号。

NNTP？ https://en.wikipedia.org/wiki/Network_News_Transfer_Protocol

![image-20221119204839080](C:\Users\zy\AppData\Roaming\Typora\typora-user-images\image-20221119204839080.png)



##### 4.1.2.3 URL 相对语法和基本 URL（部分：1 2 3 4）

本节第一个主题中描述的统一资源定位器语法有时被称为指定绝对 URL。这是因为 URL 中的信息足以完全识别资源。因此，绝对 URL 具有与上下文无关的属性，这意味着可以使用 URL 访问和检索资源，而无需任何其他信息。

由于 URL 的全部意义在于提供定位和访问资源所需的信息，因此我们希望它们在大多数情况下在定义上是绝对的是有道理的。绝对 URL 的问题在于它们可能又长又麻烦。在某些情况下，需要识别许多彼此有关系的不同资源；这些资源的 URL 通常有许多共同的元素。在这种情况下使用绝对 URL 会导致大量多余和多余的“废话”。

<u>**相对 URL 的动机**</u>
在我对 URI 的概述中，我以描述“访问方法”和检索书籍的位置的形式对 URL 进行了“现实世界”类比：“乘火车去阿尔伯克基，然后乘坐 11 路公交车到 41 路公交车艾伯特街，乔安妮约翰逊拥有的红砖房。你要的书在二楼书架底下右数第三本。”

如果我还想让同一个人在拿到第一本书后在同一栋房子的一楼拿到第二本书怎么办？我是否应该再次开始说“坐火车到阿尔伯克基，然后乘坐 11 路巴士到艾伯特街 41 号，乔安妮·约翰逊拥有的红砖房”？当他们已经在那所房子里时，为什么还要打扰呢？不，我会给出第二个相对的指令：“回到楼下，把木桌上的蓝皮书拿来”。该指令仅在原始指令的上下文中才有意义。

同样的需求也出现在 URL 中。考虑位于“http://www.longdomainnamesareirritating.com/index.htm”的网页，其中有 37 个嵌入的图形图像。坚持维护这个网站的可怜人不想在每张图片的 URL 前面加上“http://www.longdomainnamesareirritating.com/”。

类似地，如果我们刚刚在“ftp://ftp.somesitesomewhere.org/very/deep/directory/structures/also/stink/”获取目录列表并且我们想要探索父目录，我们只想说“上一层”而不必说“ftp://ftp.somesitesomewhere.org/very/deep/directory/structures/also/”。

<u>**创建和解释相对 URL**</u>

出于这些原因，URL 语法被扩展为包含相对形式。用最简单的术语来说，相对 URL 与绝对 URL 相同，只是省略了上下文暗示的信息片段。就像我们的“下楼”指令一样，相对 URL 本身并不包含足够的信息来指定资源。必须在提供缺失信息的上下文中解释相对 URL。

从相对 URL 查找资源所需的上下文以提供缺失信息的基本 URL 的形式提供。基本 URL 必须是特定的绝对 URL，或者本身是引用其他绝对基础的相对 URL。基本 URL 可以是明确说明的，也可以是从使用中推断出来的。处理 URL 的 RFC 定义了三种用于确定基本 URL 的方法，它们按以下优先顺序排列：

1. 文档中的基本 URL：一些文档允许明确说明基本 URL。如果存在，此规范将用于文档中的任何相对 URL。

2. 来自封装实体的基本 URL：如果文档中没有明确指定基本 URL，但文档是包含它的更高级别实体的一部分，则基本 URL 是“父”文档的 URL。例如，MIME 多部分消息正文部分中的文档可以将消息的 URL 作为一个整体用作相对引用的基本 URL。

3. 来自检索 URL 的基本 URL：如果这两种方法都不可行，则从用于检索包含相对 URL 的文档的 URL 推断出基本 URL。
   在这三种方法中，#1 和#3 是最常见的。 HTML 是用于 Web 的语言，它允许明确说明基本 URL，这消除了对如何解释相对 URL 的任何疑问。如果做不到这一点，方法 #3 通常用于 HTML 文档中以相对术语指定的图像和其他链接。



例如，让我们回到维护“http://www.longdomainnamesareirritating.com/index.htm”的可怜懒汉。默认情况下，从该“index.htm”HTML 文档引用的任何图像都可以使用相对 URL——基本 URL 将从文档本身的名称中假定。所以他可以只说“companylogo.gif”而不是“http://www.longdomainnamesareirritating.com/companylogo.gif”，只要该文件与“index.htm”位于同一服务器上的同一目录中即可。

如果这三种方法出于某种原因都失败了，则无法确定基本 URL。此类文档中的相对 URL 将被解释为绝对 URL，并且由于它们不包含完整的信息，因此它们将无法正常工作。

此外，相对 URL 仅对某些 URL 方案有意义。对于其他人来说，它们没有任何意义，也无法使用。特别是，相对 URL 从不用于“telnet”、“mailto”和“news”方案。它们非常常用于 HTTP 文档，也可用于 FTP 和文件 URL。

**关键概念**：常规 URL 是绝对的，这意味着它们包含完全指定如何访问资源所需的所有信息。在需要访问许多大致位于同一位置或以某种方式相关的资源的情况下，完全指定 URL 可能效率低下。相反，可以使用相对 URL，它指定如何访问相对于另一个资源位置的资源。相对 URL 只能在提供相对引用中缺少的任何信息的基本 URL 的上下文中进行解释。

<u>**相对URL的实用解读**</u>

上面的描述可能看起来很混乱，但相对 URL 实际上很容易理解，因为它们是以一种相当“常识”的方式解释的。您只需获取基本 URL 和相对 URL，然后用相对 URL 中的任何信息替换基本 URL 中的适当信息即可获得等效的绝对引用。这样做时，您必须“删除”任何比被替换的元素更具体的元素。

“更具体”是什么意思？好吧，大多数 URL 可以被认为在它们指定的位置方面从“最一般”移动到“最具体”。从左到右，依次是主机名、高级目录、子目录、文件名，以及可选的应用于文件名的参数/查询/片段。如果相对 URL 指定了一个新的文件名，它会替换基本 URL 中的文件名，并且任何参数/查询/片段都会被删除，因为鉴于文件名已更改，它们不再具有意义。如果相对 URL 更改了主机名，则整个目录结构、文件名和主机名“右侧”的所有其他内容“消失”，取而代之的是可能已包含在新主机名规范中的任何内容。

这很难用语言解释，但通过几个例子就很容易理解。假设我们从以下显式基本 URL 开始：

```
http://site.net/dir1/subdir1/file1?query1#bookmark1
```

表 224 显示了一些相对 URL 的示例以及它们将如何被解释。


​                                                                    **表 224：相对 URL 规范和绝对等价物**

| **Relative URL**                     | **Equivalent Absolute URL**                         | **Explanation**                                              |
| ------------------------------------ | --------------------------------------------------- | ------------------------------------------------------------ |
| **#bookmark2**                       | http://site.net/dir1/subdir1/file1?query1#bookmark2 | URL 相同，只是书签不同。这可用于在 HTML 中引用同一文档中的不同位置。（从技术上讲，这里的 URL 没有改变，因为“片段”（书签）不是实际 URL 的一部分。给定新书签名称的 Web 浏览器通常不会尝试重新访问该资源。） |
| **?query2**                          | http://site.net/dir1/subdir1/file1?query2           | 相同的文件，但具有不同的查询字符串。请注意，来自基本 URL 的书签引用已“剥离”。 |
| **file2**                            | http://site.net/dir1/subdir1/file2                  | 这里我们引用了一个名为“file2”的文件，它替换了基本 URL 中的“file1”。这里查询和书签都被删除了。 |
| **/file2**                           | http://site.net/file2                               | 由于包含一个斜杠，这意味着“file2”在根目录中；此相对 URL 替换基本 URL 的整个 <url-path>。 |
| **..**                               | http://site.net/dir1/                               | 这对点指的是基本 URL 中那个点的父目录。由于基本 URL 中的目录是“dir1/subdir1”，因此它指的是“dir1/”。 |
| **../file2**                         | http://site.net/dir1/file2                          | 指定我们应该转到父目录以在“dir1”中找到文件“file2”。          |
| **../subdir2/file2**                 | http://site.net/dir1/subdir2/file2                  | 上一级目录“..”，然后进入子目录“subdir2”找到“file2”。         |
| **../../dir2/subdir2/file2**         | http://site.net/dir2/subdir2/file2                  | 与上面相同，但向上两个目录级别，然后向下通过“dir2”和“subdir2”找到“file2”。 |
| **//file2**                          | http://file2                                        | 两个斜杠表示“file2”替换了主机名，导致主机名右侧的所有内容都被删除。这可能不是预期的，并且显示了观看这些斜线的重要性。杰 |
| **//www.newsite.net/otherfile.htm**  | http://www.newsite.net/otherfile.htm                | 这里除了方案之外的所有东西都被替换了。 （在实践中，这种形式的相对 URL 并不常见——如果指定站点名称，通常会包含该方案，以确保完整性。） |
| **file2?query2#bookmark2**           | http://site.net/dir1/subdir1/file2?query2#bookmark2 | 这里我们替换文件名、查询名和书签名。                         |
| **ftp://differentsite.net/whatever** | ftp://differentsite.net/whatever                    | 使用新方案会强制将 URL 解释为绝对 URL。                      |

<u>**使用相对 URL 提高文档的可移植性**</u>

使用相对 URL 的另一个非常重要的好处是：避免在文档中使用绝对 URL 可以通过消除对可能更改的名称的“硬编码”引用来提高可移植性。 回到我们之前的例子，如果维护网站“http://www.longdomainnamesareirritating.com/”的人只使用相对链接来引用图形和其他嵌入对象，那么如果网站迁移到“www.muchshortername. com”，他将不必编辑所有指向新名称的链接。 在有关 HTTP URL 的详细主题中进一步探讨了此在 Web URL 中的重要性。

**关键概念：**除了比绝对 URL 更有效之外，相对 URL 的优势在于它们允许资源设计者避免具体提及名称。 这增加了站点内不同位置之间或站点之间文档的可移植性。

概念类似Linux 的绝对路径和相对路径，但是再html 种很有用，随便打开一个 html 页面找到a 标签 或者资源路径你会发现是为什么

![image-20221119210329349](C:\Users\zy\AppData\Roaming\Typora\typora-user-images\image-20221119210329349.png)



##### 4.1.2.4 URL 长度和复杂性问题（部分：1 2 3 4）

统一资源定位符 (URL) 是最普遍的资源寻址形式，原因非常充分：它们代表了一种简单、方便且易于理解的文档查找方式。由于在万维网上的使用而得到普及，现在可以在从电子文档列表到电视广告的任何事物中看到 URL，这证明了它们的普遍性和易用性。

至少，大多数时候是这样！

当 URL 工作时，它们工作得很好。遗憾的是，对于 URL 的使用方式也存在一些担忧。意外和故意滥用 URL 经常发生。我花这么多精力来描述 URL 的部分原因是大多数人并不真正理解它们是如何工作的，这也是问题出现的部分原因。

URL 的许多问题直接归因于长度和复杂性的相关问题。当 URL 简短时，它们的效果最好，因此它们的内容一目了然，因此易于操作。例如，几乎每个人都可以将“http://www.ibm.com”识别为国际商业机器公司 (IBM) 的万维网 (WWW) 站点。同样，您可能无需任何解释就可以弄清楚这个 URL 的作用：“ftp://www.somecomputercompany.com/drivers/videodrivers.zip”。

但是，正如我们在本节前面看到的那样，URL 可能要复杂得多。特别是，HTTP 和 FTP 等协议使用的通用 Internet 语法非常灵活，包含大量可选元素，可以在需要时使用这些元素来提供特定资源访问所需的信息。

<u>**长 URL 很常见的原因**</u>

URL 语法中的许多元素都是可选的这一点很重要。大多数时候，这些可选部分中的大部分都被省略了，这使得 URL 在实际使用中比“纸上谈兵”简单得多。例如，尽管理论上 HTTP URL 包含用户名、密码、主机、端口、路径、查询和书签，但大多数 URL 仅使用主机名和路径。这有助于保持 URL 简短且易于使用。

尽管如此，您仍然会发现一些在 Internet 上使用的相当长的 URL。以下是一些最常见的原因。

<u>**长 DNS 域名和主机名**</u>
有些人没有意识到长主机名很难记住。如果您经营“Super Auto Body Shop & Pizza Parlour”，拥有一个名为“www.superauto.com”的网站将使您的客户比尝试注册“www.superautobodyshopandpizza.com”更容易找到您。然而，15、20 甚至更多字符的 DNS 名称却出奇地普遍。

**长文档或目录名称**
同样，短文件名比长文件名好，同样，许多人在将文件放到 Internet 上之前没有考虑这一点，这给那些必须访问它们的人带来了更多困难。

<u>**使用“不安全”字符**</u>
URL 具有处理“不安全”字符的机制，但这会使它们变得更长且更难破译。假设您有一个名为：

```
“{ABC Corp} budget; draft #3; third quarter 2004.htm”
```

此 URL 必须是：

```
“%7BABC%20Corp%7D%20budget%3B%20draft%20%233%3B%20third%20quarter%202004.htm”
```

原来的长文件名是可读的，但是由于特殊的字符编码，URL 是一团糟。

将文件命名为“ABC budget draft 3, 3Q2004.htm”将是一个更好的选择，并且仍然包含足够的信息以便于理解。更好的是，您可以用下划线替换空格，以避免完全需要“%20”：“ABC_budget_draft 3,_3Q2004.htm”。

<u>**参数字符串**</u>
在 HTTP URL 中，指定查询的语法（在问号字符后）通常用于允许 Web 浏览器向 Web 服务器发送各种类型的信息，尤其是交互式查询的参数。这些参数字符串可能会变得很长。例如，我向伟大的网络搜索引擎百度输入了一个《如何成为有钱人》。这是查询 URL：

```
https://www.baidu.com/s?wd=%E5%A6%82%E4%BD%95%E5%8F%98%E6%88%90%E6%9C%89%E9%92%B1%E4%BA%BA&rsv_spt=1&rsv_iqid=0x9de4f2ef00190821&issp=1&f=8&rsv_bp=1&rsv_idx=2&ie=utf-8&tn=baiduhome_pg&rsv_enter=1&rsv_dl=tb&rsv_sug3=33&rsv_sug1=27&rsv_sug7=100&rsv_sug2=0&rsv_btype=i&prefixsug=%25E5%25A6%2582%25E4%25BD%2595%25E5%258F%2598%25E6%2588%2590%25E6%259C%2589%25E9%2592%25B1%25E4%25BA%25BA&rsp=5&inputT=6818&rsv_sug4=7661
```

几乎所有这些都由参数组成，这些参数根据我的查询告诉谷歌服务器我想要什么文档。这是必要的，但仍然很麻烦。

<u>**URL 包装和定界问题**</u>

对于人类来说，又长又复杂的 URL 很难记住和使用。除了记住所有这些字符的绝对困难之外，还有 URL 换行的问题，当它们以特定形式呈现时会发生这种情况。大多数程序只能在一行中显示 78 或 80 个字符。如果 URL 比这个长，URL 的字符将“换行”到多行；当您阅读上面的 Google 示例时，您可能会注意到这一点。

将 URL 从一种形式复制到另一种形式时，URL 环绕可能会导致错误，例如，如果您将它从本文档复制到您的 Web 浏览器中。如果一个 URL 有 81 个字符长，80 个字符在第一行，最后一个字符在第二行，许多用户可能根本没有意识到该 URL 已经“换行”了。我见过数百个字符长的 URL，需要多次手动“复制和粘贴”操作才能使 URL 生效。

也许令人惊讶的是，某些软件可能也无法正确处理这种“包装”。虽然在诸如 HTML 文档之类的内容中使用超链接时这不是问题，但是当链接包含在电子邮件消息或 Usenet 文章中时，这可能会很麻烦。

另一个问题是分隔 URL 出现时的开始和结束位置。 URL 以方案名称开头，理论上可以在非 URL 的其他上下文中使用。如果没有明确的方式将 URL 标记为 URL，软件程序可能无法识别它。考虑在这样的文档中讨论 URL；如果我说“请访问 http://www.thissite.com；你会在那里看到你需要的信息”，那么我们都知道分号是句子的一部分而不是 URL 的一部分，但计算机程序可能不会那么确定。而且，当 URL 又长又复杂并且包含多行文本时，这个问题会更加严重——程序如何识别 URL 的结尾？

<u>**显式 URL 定界和 URL 重定向器**</u>

为了同时解决换行和定界问题，有时会使用特殊的 URL“超级语法”，尤其是在其他文本中使用 URL 时。这是通过将 URL 括在尖括号中来完成的，可能包括标签“URL:”。在方案名称之前。例如，以下所有内容都是等效的：

```
http://www.networkingistoodarnedcomplicated.com
<http://www.networkingistoodarnedcomplicated.com>
<URL:http://www.networkingistoodarnedcomplicated.com>
```

尖括号清楚地指示了 URL 的开始和结束位置，使程序和人类更容易处理长 URLs 。

有时用于长 URL 的另一种解决方案是许多网站提供的重定向服务。例如，http://www.tinyurl.com 是一项免费服务，它允许某人创建一个短 URL，该 URL 会自动加载长得多的 URL 上的资源。

<u>**URL 缩写**</u>
我要讨论的最后一个问题与长或复杂的 URL 没有直接关系，但与长度问题有间接关系：URL 缩写。许多人经常使用 URL，以至于在指定 URL 时他们变得懒惰了。他们倾向于省略部分完整的 URL 语法以节省时间和精力。我的意思并不是说它们指定了相对 URL，而是它们指定了带有“缺失部分”的绝对 URL。

例如，他们可能不输入“http://www.sitename.com”，而是输入“http:www.sitename.com”，去掉两个斜杠。更常见的是，人们完全省略方案名称，只输入“www.sitename.com”。从技术上讲，这不是 URL，它只是一个域名。然而，大多数 Web 浏览器都可以处理这个问题，如果没有提供，则默认情况下假定该方案是“http://”。 （别心疼，我也是！😄）



##### 4.1.2.5 URL 混淆、混淆和一般欺骗（部分：1 2 3 4）

大多数时候，资源所有者希望引用资源的 URL 简短、简单且易于理解。因此，长而复杂的 URL 通常是必然、意外或无知的结果。某些资源出于某种原因需要具有长名称，例如在 Google 示例中使用长查询字符串；有时，URL 变长是因为资源所有者没有意识到使用长 DNS 主机名或文件名会导致 URL 又长又笨重。

无论这些情况的原因是什么，它们都不是故意的。然而，近年来，故意使用冗长、复杂、令人困惑和故意欺骗的 URL 的情况急剧增加。这些 URL 要么是结构化的，以至于无法分辨它们是什么，要么更糟的是，当它们真正指向另一个资源时，它们看起来好像指向一个资源。

人们为什么要这样做？很简单：因为他们害怕公开和诚实地谈论他们的“资源”。这些人会是谁？为什么，他们会是垃圾邮件发送者和骗子，他们用各种可以想象的优惠信息让我们的互联网电子邮箱超载，从让您变得超乎您最疯狂的梦想，到将某些身体部位的尺寸膨胀到不自然的尺寸……

他们担心，如果 URL 清楚地表明“资源”是什么，您可能不会点击该链接；或者，如果您将他们识别为垃圾邮件发送者，您可能会过滤掉他们的电子邮件。他们还认为，如果他们可以使 URL 看起来很有趣，您就会加载它。即使结果出乎你的意料，也许你还是会注意的。

（你的意思是你太聪明了，不会被诱骗通过欺骗性 URL 购买产品？而且你永远不会支持垃圾邮件发送者？多么巧合，我也一样！然而垃圾邮件不断涌现；它必须有效，否则他们不会继续这样做……他们会吗？J） 

<u>**常见的欺骗和混淆技术**</u>

具有讽刺意味的是，内置于 URL 中以使其如此灵活的复杂语法已被令人讨厌的人利用来欺骗人们。他们知道大多数人习惯于看到像“http://www.myfavoritesite.com”这样的简单 URL，而没有意识到完整的 URL 语法允许以数百万种不同的方式指定相同的资源。

因此，这些人不惜一切代价渴望访问他们的网站，不断想出新的技巧来操纵 URL。这些都集中在 HTTP 方案 URL 上，尽管理论上这些技巧也可以应用于其他几种类型（尽管显然它们不适用于某些方案）。以下是过去和现在使用过的一些更常见的技巧（请注意，如果您在阅读时尝试使用这些技巧，某些示例可能不适用于某些浏览器）：

<u>**过长**</u>
在某些情况下，URL 只是通过添加大量乱码作为“查询字符串”而变得非常长，以至于用户只是看着它就会眼睛呆滞。然而，这是一种相对“简单”的技术，因为可以通过查看 URL 的开头轻松判断真实主机名是什么。今天，大多数优秀的诈骗者已经超越了这些简单的技巧。

<u>**常规 IP 地址主机**</u>
互联网用户习惯于使用 DNS 名称，以至于他们根本没有意识到可以使用 IP 地址访问 URL。所以大多数人没有意识到使用 <http://209.68.14.80> 和 <http://www.PCGuide.com> 一样可以轻松访问 PC 指南。 （请注意，并非所有 Internet 主机都是如此；那些使用虚拟名称的主机无法仅使用 IP 地址访问。）

这本身并不是真正的诡计。这是非常合法的，在某些方面甚至是必要的——例如，访问有 DNS 问题的站点。这里的问题是，通常人们无法仅从 IP 地址来判断一个站点是什么，许多人只会点击一个 IP 地址链接而不会费心去找出它是什么。

<u>**数字域名**</u>
可以注册仅包含一个数字的 DNS 域名。例如，可以注册“114.com”。然后可以在其中创建子域，例如“42.12.205.114.com”。乍一看，这似乎是一个 IP 地址规范，因此有人可能认为它会解析为地址 42.12.205.114——但实际上，它是其他地址。

我相信 DNS 名称注册商一直在打击这种欺骗行为，因此它现在可能不像以前那样普遍。



<u>**伪造认证信息**</u>

HTTP URL 理论上支持包含身份验证信息，方法是在 URL 中的主机前包含“<user>:<password>@”。然而，绝大多数网站都是“开放的”，既不需要也不使用它。如果您指定了一个身份验证字符串但不需要它，它将被忽略。

这是目前最流行的技术之一。它的一种使用方法是包含看起来像“良性”主机的“身份验证信息”，让用户认为该 URL 是针对该主机的。例如，如果我想诱骗您访问 The PC Guide，我可能会使用此 URL 使其看起来像是点击它会转到 CNN：

```
<http://www.cnn.com@www.PCGuide.com>
```

然而，这仍然太明显了，因此这种“方法”通常与下面的一些技术结合使用。

<u>**欺骗性字符编码**</u>
使用百分号对空格和标点符号等特殊字符进行编码也可能被滥用来掩盖域名。例如，以下是 The PC Guide 的 DNS 名称的另一种表达方式：

```
<http://%57%57%57.%50%43%47%55%49%44%45.%43%4F%4D>
```

试试看。

<u>**IP 地址数学技巧**</u>
好的，这就是事情变得非常奇怪的地方。大多数时候，我们将 IP 地址表示为点分十进制数。但是请记住，对于计算机而言，IP 地址只是一个 32 位二进制数。大多数浏览器支持相当多的方法来表示这些数字。这很不幸，因为实际上不需要这种灵活性，而且几乎从未用于合法目的。它可能会导致一些无法识别的非常奇怪的 URL，或者看起来像常规 IP 地址但实际上不是。

下面是一些例子，都和电脑指南的IP地址形式一样（<http://209.68.14.80>）：

点分八进制的 IP 地址：前导零表示 IP 地址，其中每个字节都是八进制的：

```
<http://0321.0104.016.0120>
```

点分十六进制 IP 地址：前导零后跟“x”表示 IP 地址，其中每个字节均为十六进制：

```
<http://0xD1.0x44.0x0E.0x50>
```

IP 地址作为单个数字：我们甚至可以将整个 32 位数字表示为一个数字，这也行得通。十进制：

```
<http://3510898256/>
In octal:
<http://032121007120/>
And, in hexadecimal:
<http://0xd1440e50/>.
```

<u>**让事情变得更糟：结合欺骗性技巧**</u>

好像这些技巧单独使用还不够糟糕，我们可以通过组合它们来获得真正的乐趣！例如，从常规 PC 指南 URL 开始：

```
<http://www.PCGuide.com>
```

并将其转换为 IP：

```
<http://209.68.14.80>
```

然后添加一些伪造的身份验证乱码：

```
<http://www.cnn.com@209.68.14.80>
```

并将真实 URL 转换为单个数字，使其看起来像 CNN 网站上的文档：

```
<http://www.cnn.com@3510898256>
```

或者，我们可以使用八进制形式，甚至包括许多额外的前导零只是为了好玩：

```
<http://www.cnn.com@0000000000000321.00000000104.00000000000016.00000120>
```

信不信由你，这只是冰山一角。在某些浏览器中，甚至 IP 地址数字也可以使用“百分号”ASCII 编码来表示！

虽然很烦人，但我必须至少给这些人的创造力加分——有些技巧非常巧妙。同时，他们的创造力具有潜在的危险性。虽然这些虚假 URL 通常比任何有害的东西更浪费时间，但有时人们会竭尽全力隐藏资源的身份是有充分理由的。欺骗性 URL 只是当今网络管理员必须处理的另一种危险。

**关键概念：**Internet URL 的语法包含许多元素，这些元素在如何构建 URL 方面提供了极大的灵活性。不幸的是，这些表达能力现在经常被故意创建模糊 URL 的人滥用，以诱使用户访问他们的网站和其他资源。其中一些可能具有潜在危险，这意味着在单击未知链接或访问陌生 URL 之前需要小心。

简单有效最重要铁子

#### 4.1.3 统一资源名称 (URN)（部分：1 2 3）

“HTTP 404 - NOT FOUND”

您是否曾尝试访问网站或其他 Internet 资源，却只看到那些令人生畏的字眼？您可能遇到过，并且在看到它们时，您亲身体验了统一资源定位器 (URL) 最常见的问题之一。

URL 使用两个关键信息来指定资源：资源的位置，以及可以访问或检索资源的方法。这种对资源访问方式的关注使得 URL 非常实用，因为 URL 通常包含我们使用资源所需的所有数据。这就是 URL 在今天被如此广泛使用的原因。然而，这种“访问导向”也意味着 URL 有许多严重的局限性。

<u>**URL 的问题**</u>
URL 的主要困难在于，由于它们根据资源的位置描述资源，因此它们将资源及其位置紧密地联系在一起。虽然这看起来可能没什么大不了的，但实际上在很多方面都是一个相当严重的问题，因为资源和它的位置不是一回事。只是因为大多数 Internet 资源很少改变位置，所以我们不会更频繁地注意到 URL 的这个问题。

假设您的名字是 Joe Xavier Zachariah，住在澳大利亚悉尼的 44 Glendale Crescent。如果有人问你是谁，你会说“Joe Xavier Zachariah”，还是“住在澳大利亚悉尼格伦代尔弯 44 号的那个人”？几乎可以肯定，前者；但是 URL 就像使用后一种描述将您自己描述为“资源”一样。

由于我们意识到 Zachariah 先生显然不会总是在 44 Glendale Crescent，因此我们知道仅使用位置来描述他是不够的。当仅使用位置来识别 Internet 资源时，也会发生同样的事情。

然而，Internet 资源和 URL 的问题不仅仅是移动问题。考虑一种特定资源非常受欢迎的情况；我们可能想在多个位置复制相同的资源。使用 URL，我们需要为资源的每个副本使用不同的标识符，即使每个副本都是相同的。同样，问题在于我们不是在识别资源本身，而是在识别资源所在的位置。

<u>**URN 概述**</u>

认识到这个问题，开发了一种替代的 Internet 资源标识机制，称为统一资源名称 (URN)。描述URNs的基本标准是1994年发布的RFC 1737，Functional Requirements for Uniform Resource Names。1997年发布的RFC 2141，规定了URNs的语法。

正如您可能从该术语中看出的那样，URN 旨在根据资源的实际标识而不是可以找到的位置来标记资源。因此，如果 URL 类似于 Joe Zachariah 的地址，则 URN 就是他的名字。或者，正如我在 URI 概述中举的例子，URN 将根据书的 ISBN 编号来识别一本书，而不是指定它在建筑物中的哪个书架上。

为了在识别特定资源时有用，URN 必须是全局唯一的，这并不总是像乍看起来那么简单。例如，考虑人名。即使全世界可能只有一个 Charles Marlin Kozierok，但如果您的名字是 John Paul Smith 或 José Garcia，您很可能与其他数千人共享这个名字。这意味着使用通用名称可能不足以识别人类“资源”，可能需要设计一些其他方法。

<u>**URN 命名空间和语法**</u>
URN 旨在在 Internet 上标识多种类型的资源，每种资源可能需要不同的命名形式。为了允许 URN 表示多种资源，定义了许多 URN 命名空间。名称空间是使用唯一字符串引用的，该字符串告诉解释 URN 的人或计算机 URN 标识的资源类型。当一个特定的标识符可能存在于多个上下文中时，名称空间还确保了 URN 的唯一性。例如，北美电话号码和 ISBN 号码均由十位数字组成，因此“4167819249”等特定号码既可以表示电话号码，也可以表示书号；名称空间标识符告诉我们在 URN 中遇到该数字时的含义。

URN 的一般语法是：

```
URN:<namespace-ID>:<resource-identifier>
```

例如，一本 ISBN 号为 0-679-73669-7 的书可以表示为：

```
URN:isbn:0-679-73669-7
```

该字符串唯一地标识该特定书籍，无论它可能在世界上的任何地方。还定义了许多其他名称空间来指定其他类型资源的 URN，例如 Internet 上的文档。

**关键概念**：统一资源定位符 (URL) 根据访问方法和位置指定资源，而统一资源名称 (URN) 按名称标识资源。 URN 由一个命名空间标识符和一个资源标识符组成，前者指示它包含的名称类型，后者指定该命名空间上下文中的单个资源。

<u>**URN 解决方案和实施困难**</u>

URN 是一种更“自然”的识别资源的方式，这赋予了它们直观的吸引力。尽管如此，URN 仍然没有得到广泛使用，尽管它们已经开发了十多年。这样做的主要原因有点讽刺：实际上是因为 URN 与位置无关。为 URN 提供优于 URL 的识别优势的这一特性也使 URN 在实际中更难使用，这导致了可工作的 URN 系统的长期延迟。

要理解这个问题，请考虑示例字符串“URN:isbn:0-679-73669-7”。与 URL 不同，这唯一地标识了一本特定的书，并且无论书在哪里都将始终引用它。问题在于，虽然 URL 等价物告诉我们如何实际找到这本书，但 URN 却没有。同样的事情也适用于我们之前的人类示例：通过他的名字识别 Joe Xavier Zachariah 比将他识别为“住在澳大利亚悉尼格伦代尔弯 44 号的人”更“明智”，但至少对于后者，我们知道在哪里乔是！

为了使 URN 在互联网上发挥作用，它们需要一种额外的机制来将简单的 URN 标识字符串转换为特定的位置和/或访问方法。换句话说，我们需要能够将 URN 转换为 URL 的等价物，以便可以找到资源。这个需求类似于将 Internet DNS 域名解析为 IP 地址的问题，用同一个术语来描述它：URN 解析。

理想情况下，我们希望能够使用某种技术来指定名称“Joe Xavier Zachariah”，并告知我们 Joe 在哪里，以便我们找到他。或者，我们提供字符串“URN:isbn:0-679-73669-7”，并提供一份图书馆列表或其他可以找到该书的地方。 URN 的力量也可以在这样的系统中被利用，通过让解析系统指定最接近（根据网络距离、成本或其他测量）提出请求的实体的资源副本的位置。

然而，建立 URN 解析机制是一项非常重要的任务。在过去十年中，URN 解析问题一直是 URN 的大部分工作的主题。 RFC 2483，URI Resolution Services Necessary for URN Resolution，于 1999 年发布，讨论了 URN 解析中的一些重要问题。 2002 年 10 月，一系列 RFC，3401 到 3405，定义了一个称为动态委派发现系统 (DDDS) 的新系统，其设计不仅用于解析 URN，而且用于处理给定标识符和输出是有关从何处获取有关该标识符的更多信息的信息。 RFC 3406 同时发布，提供了更多关于 URN 命名空间的信息。

**关键概念：**由于 URN 通过名称而不是位置来标识资源，因此它们是一种比使用 URL 更自然的标识资源的方式。不幸的是，这个优势也是一个劣势，因为 URN 本身并不能为用户提供必要的信息来找到可以使用的资源。必须执行 URN 解析过程，将 URN 转换为一组允许访问资源的信息。


尽管 URN 的进展缓慢，但一直很稳定。虽然 URN 被广泛使用可能还需要几年时间，但我相信它们很可能在将来在识别 Internet 上的资源方面发挥越来越重要的作用。

额 good

### 4.2 TCP/IP 文件和消息传输应用程序和协议（FTP、TFTP、电子邮件、USENET、HTTP/WWW、Gopher）

互联网应用程序的目的是允许在联网设备之间发送不同类型的信息。在计算机世界中，信息通常被安排到称为文件的离散单元中。当这些文件是专门为通信目的而创建的时，它们通常被称为消息。最重要的一组 TCP/IP 应用程序是描述在互连设备之间移动这些文件的基本机制的应用程序：文件和消息传输应用程序。

在本节中，我详细描述了 TCP/IP 中用于文件和消息传输的最重要的应用程序，以及实现它们的协议。我首先概述了这些应用程序，并描述了它们之间的差异。然后我包括四个小节，描述四个最重要的文件/消息传输应用程序系列：显式文件传输、电子邮件、网络新闻 (Usenet) 和超文本（万维网）。我还简要介绍了 Gopher 协议，该协议已失宠但值得一提，特别是因为它作为 Web 历史先驱的作用。

**相关信息：**我已决定区分通常由用户显式用于移动消息和文件的应用程序协议和隐式用于共享文件的应用程序协议。前者通常使用特定的命令来传输数据，在本节中进行描述。后者通过在网络上自动传输命令和数据，为用户创建远程设备上的文件实际上是本地文件的外观，并且在网络文件和资源共享协议的单独部分中进行了描述。在 TCP/IP 中，这种共享功能通常由网络文件系统 (NFS) 执行。



#### 4.2.1 文件和消息传输概述和应用程序类别（部分：1 2）

我在本节的介绍中说过，文件和消息传输应用程序是 TCP/IP 中使用的最重要的类型之一。在联网的计算机之间传输文件是最基本的网络通信类型。事实上，可以毫不夸张地说，这可能是最重要的一类互联网应用程序。这个组的一些成员非常普通，以至于很多人每天都在使用他们，甚至想都没想。

要了解这些应用程序，让我们先快速回顾一下“文件”的基本概念。简而言之，文件只是信息的集合，被计算机系统视为一个整体。文件存储在文件系统中的目录或文件夹中。在现代计算机中，文件通常表示为字节或字符序列，每个文件都作为一个独立的对象进行读取、写入、复制或其他操作。除了它包含的数据之外，每个文件还具有与其相关联的描述它的文件属性。

就我们的目的而言，文件的关键特征是它是一个包含任意信息的自包含对象。由于文件是计算机系统中信息的组成部分，因此网络中的信息传输最初是根据这些文件的移动来定义的，这并不奇怪。一些描述如何传输文件的协议早于 TCP/IP 较低级别的所有现代协议，包括 IP 版本 4、TCP 和 UDP。文件传输并不是互联网的早期应用，而是互联网的发明在很大程度上是为了允许文件传输！

现代计算系统中的文件本质上被设计为通用的；它们可以包含任何类型的信息。文件内容的重要性完全取决于检查它的用户或软件程序。 TCP/IP 文件和消息传输协议的共同点是将文件从一台计算机移动到另一台计算机。它们的不同之处在于文件的处理和处理方式。有两种基本方法：一般文件传输和消息传输。

<u>**一般文件传输**</u>
一般传输应用程序通常将文件视为“黑匣子”，将它们从一个地方移动到另一个地方并且很少或根本不关注文件包含的内容。 TCP/IP 文件传输协议 (FTP) 和普通文件传输协议 (TFTP) 属于此类。 FTP 已经以一种或另一种形式存在了 30 多年，并且仍在广泛使用。

<u>**消息传输**</u>

其他 TCP/IP 应用程序处理特定类型的文件，以各种方式处理和解释它们。这些文件通常是为特定的通信目的而设计的，因此称为消息；这些应用程序允许用户构建、发送和接收适合特定消息格式的消息。我们将在本指南中研究几个著名的 TCP/IP 消息传递应用程序：

- 电子邮件 (E-Mail)：允许用户以与传统邮政系统相同的方式交换“信件”（实际上是任何类型的文件）的系统，但具有速度快和简单的优点。电子邮件并没有完全取代普通邮件，但现在许多人在绝大多数信件中都使用它。

- 网络新闻 (Usenet)：一种类似于电子邮件的应用程序，允许用户发送消息。然而，虽然电子邮件通常用于允许将消息发送给一个用户或少数收件人，但网络新闻是成千上万的用户共享各种主题消息的一种方式。任何用户都可以贡献其他人可以看到的消息，任何人都可以回复。与电子邮件的情况不同，收件人不需要明确标识，这使得网络新闻更适合在甚至可能彼此不认识的大群人之间进行交流。这是第一个创建类似于“电子公告板”的东西的 TCP/IP 应用程序：一个在线社区。

- 超文本（万维网）：您可能甚至不需要我解释什么是万维网，这就是它在现代互联网中的重要意义。超文本将消息传递的概念从简单的文本消息或普通文件交换转变为可以包含各种类型信息的丰富消息的概念。这包括文本、图形、多媒体和嵌入式文件。最重要的是，超文本允许一个文档链接到另一个文档，形成相关文档的“网络”，这导致了“万维网”的名称。 Web 几乎可以肯定是最重要的 TCP/IP 应用程序，每天都有数百万人使用。

这些应用程序中的每一个在某一点上都有些不同，但近年来的一些发展使它们之间的界限变得非常模糊。电子邮件不再局限于简单的文本消息；现在可以通过特殊方法将普通文件编码成文本形式来承载普通文件，甚至可以承载超文本文档。万维网客户端（浏览器）不断得到增强，可以让它们访问其他类型的服务器和文件，也可以用于一般的文件传输。这些发展对 TCP/IP 用户来说意味着更多的功能和灵活性——并且 TCP/IP 学习者需要更多的关注。

**关键概念：**最重要的一组 TCP/IP 应用程序是使文件能够在互联网络的设备之间移动的应用程序：文件和消息传输应用程序。该组包含 TCP/IP 用户每天用于通信的许多常见应用程序。它可以分为两大类：用于在设备之间移动任何类型文件的通用文件传输应用程序，以及允许使用特殊文件类型（例如电子邮件消息或超文本文件）进行不同类型通信的消息传输应用程序.



#### 4.2.2 TCP/IP 通用文件传输协议（FTP 和 TFTP）

正如我在前面的文件和消息传输协议概述中提到的，它们代表了最基本的网络通信类型：数据块的简单移动。在许多文件和消息传输方法中，最基本的应用是我所说的通用文件传输。通用文件传输协议执行一个主要功能：允许将文件从一台计算机复制到另一台计算机。

由于文件传输协议在不考虑文件内容的情况下将文件从一个地方移动到另一个地方，因此与某些消息处理应用程序相比，它们相对“简单”。然而，能够四处移动文件的想法非常重要，以至于通用文件传输协议成为了互联网络中最早的应用程序之一。虽然现在许多人使用电子邮件或 Web 浏览器来执行以前仅使用一般文件传输才能执行的功能，但这些较旧的协议仍然非常重要且被广泛使用，理解这些协议也很重要。

在本节中，我将了解两种 TCP/IP 通用文件传输协议。第一个简称为文件传输协议 (FTP)。第二种称为普通文件传输协议 (TFTP)。每个都在其自己的小节中进行了描述。

FTP 和 TFTP 之间的关系类似于第四层的传输控制协议 (TCP) 和用户数据报协议 (UDP) 的关系。 FTP 是全功能的、面向会话的并且有些复杂。它是两种协议中更常用的一种，提供完整的命令接口并利用其运行的 TCP 的可靠性和流传输功能。 TFTP 与它在传输层使用的 UDP 一样，是 FTP 的“精简版”。它的命令和功能比 FTP 少得多，但非常适合重视简单性和小软件程序的情况，例如设备中的嵌入式软件。

##### 4.2.2.1 文件传输协议 (FTP)

TCP/IP 套件中的主要通用文件传输协议直接通过其不合格的名称显示其“通用性”：文件传输协议 (FTP)。 FTP是世界上使用最广泛的应用协议之一。它旨在允许在 TCP/IP 互联网络上的任何两个设备之间高效地传输文件。它自动处理文件移动方式的细节，提供丰富的命令语法以允许执行各种支持文件操作（例如导航目录结构和删除文件）并使用 TCP 传输服务进行操作以确保可靠性。

在本节中，我描述了文件传输协议的操作。我首先概述了 FTP，讨论了它的悠久历史和定义它的标准。然后，我将在两个小节中描述 FTP 的工作原理。第一部分讨论了 FTP 功能背后的关键概念，并概括性地讨论了它的操作。第二个提供了 FTP 命令和回复代码的具体细节。最后，我提供了一个用户 FTP 会话的示例说明，其中显示了用于每个操作的内部命令。

###### 4.2.2.1.1 FTP 概述、历史和标准（部分：1 2）

我们今天所知道的 TCP/IP 协议族是在 70 年代末和 80 年代初开发的，其分水岭事件可能是 1980 年 Internet 协议和传输控制协议第 4 版标准的发布。现代 TCP/IP 是自 1960 年代以来一直在进行的实验和开发工作的结果。这项工作包括实现互联网络的协议的设计和实现，以及第一个允许用户执行不同任务的网络应用程序的创建。

<u>**FTP开发和标准化**</u>
早期应用程序的开发人员在概念上将网络使用方法分为两类：直接和间接。直接网络应用程序允许用户访问远程主机并像在本地一样使用它，从而产生网络甚至不存在的错觉（或者至少，最小化距离的重要性）。间接网络使用意味着从远程主机获取资源并在本地系统上使用它们，然后将它们传回。这两种使用方法成为前两个正式的 TCP/IP 网络应用程序的模型：用于直接访问的 Telnet 和用于间接网络使用的文件传输协议 (FTP)。

第一个 FTP 标准是 1971 年 4 月发布的 RFC 114，当时 TCP 和 IP 甚至还不存在。该标准定义了协议的基本命令以及设备使用它进行通信的正式方式。此时，TCP 的前身（简称为网络控制协议或 NCP）用于传输网络流量。那时候还没有互联网。它的前身 ARPAnet 很小，仅由一小部分开发计算机组成。

许多后续的 RFC 改进了这个早期版本的 FTP 的操作，修订版于 1971 年 6 月发布为 RFC 172，1971 年 11 月发布为 RFC 265。第一个主要修订版是 1972 年 7 月的 RFC 354，它首次包含了描述介绍了现代 TCP 使用的整体通信模型，并详细介绍了该协议的许多当前功能。在随后的几个月里，许多额外的 RFC 被发布，定义了 FTP 的特性或提出了它的问题。 RFC 542，1973 年 8 月，FTP 规范看起来与我们今天使用的规范非常相似，三十多年后，除了它仍然被定义为在 NCP 上运行。

在一系列后续的 RFC 定义和讨论更改之后，现代 FTP 的正式标准在 RFC 765 中发布，文件传输协议规范，1980 年 6 月。这是第一个定义现代 TCP/IP 上的 FTP 操作的标准，并被创建大约与 TCP/IP 的其他主要定义标准同时出现。

RFC 959，文件传输协议 (FTP)，于 1985 年 10 月发布，对 RFC 765 进行了一些修改，包括添加了几个新命令，现在是 FTP 的基本规范。从那时起，已经发布了许多其他标准，这些标准定义了 FTP 的扩展、更好的安全措施和其他功能。 （其中一些在一般操作部分的适当位置进行了讨论。）

<u>**FTP操作概述**</u>

创建 FTP 的总体目标是允许间接使用网络上的计算机，使用户可以轻松地将文件从一个地方移动到另一个地方。与大多数 TCP/IP 协议一样，它基于客户端/服务器模型，用户计算机上的 FTP 客户端创建到 FTP 服务器的连接，以向服务器发送文件和从服务器检索文件。 FTP 的主要目标是使文件传输变得简单，并使用户免受文件实际如何从一个地方移动到另一个地方的实现细节的影响。为此，FTP 旨在自动处理由于存储在不同系统上的文件的格式差异而可能出现的许多问题。

为确保发送和接收文件时不会丢失可能损坏文件的数据，FTP 在传输层使用可靠的传输控制协议 (TCP)。身份验证系统用于确保只有授权的客户端才能访问服务器。同时，有时称为匿名 FTP 的功能允许希望它建立通用信息服务器的组织向可能想要检索文件的任何人提供文件。

TCP 连接建立后，将创建 FTP 控制连接。内部 FTP 命令根据 Telnet 协议建立的格式规则通过此逻辑连接传递。客户端发送的每个命令都会收到服务器的回复，以指示它是成功还是失败。为要执行的每个单独的数据传输建立数据连接。 FTP 支持普通或被动数据连接，允许服务器或客户端发起数据连接。支持多种数据类型和文件类型，以便灵活地进行各种类型的传输。

FTP 用户和协议之间的接口以一组交互式用户命令的形式提供。建立连接并完成身份验证后，可以使用两个基本命令来发送或接收文件。提供了额外的支持命令来管理 FTP 连接，以及执行支持功能，例如列出目录的内容或删除或重命名文件。近年来，已经创建了 FTP 的图形实现，以允许用户使用鼠标单击而不是记住命令来传输文件。其他应用程序也可以直接使用 FTP 将文件从一个地方移动到另一个地方。

**关键概念：**TCP/IP 中最重要的通用文件传输协议是简单命名的文件传输协议 (FTP)。能够在机器之间移动任何类型的文件的需求是如此基本，以至于 FTP 的历史可以追溯到 30 多年前。 FTP 在 TCP 上运行，以确保文件可靠传输而不会丢失数据。该协议使用一组从 FTP 客户端发送到 FTP 服务器的 FTP 命令来执行文件传输操作； FTP 服务器向客户端发送表明命令成功或失败的 FTP 回复。



###### 4.2.2.1.2 FTP 概念和一般操作

文件传输协议 (FTP) 的开发人员必须在对丰富功能的需求与对协议尽可能简单易用的需求之间取得平衡。因此，FTP 远不如它的“小弟”简单文件传输协议 (TFTP) 那么简单，但考虑到该协议的功能，它远没有人们想象的那么复杂。该协议的操作实际上可以分解为许多相当简单的元素，它们一起工作以建立连接并传递命令和数据。

在本节中，我将描述文件传输协议背后最重要的概念，并以一般术语解释其操作。我首先讨论 FTP 通信和操作模型，它显示了协议的内部组件以及它们如何通过互联网进行通信。我描述了建立 FTP 控制连接的过程，以及如何执行用户身份验证。我解释了创建数据连接的两种主要方法（正常和被动），并讨论了与每种方法的使用时间有关的问题。然后我将描述 FTP 通信的一般工作原理和各种传输模式。最后，我将讨论用于通过 FTP 发送的文件的不同数据表示选项。

**相关信息：**在本节中，我将有限地提及用于在 FTP 客户端和服务器之间进行通信的命令。 FTP 命令的详细信息可以在单独的部分中找到。




###### 4.2.2.1.2-1 FTP 操作模型、协议组件和关键术语（部分：1 2 3 4）

定义文件传输协议 (FTP) 的标准使用称为 FTP 模型的简单概念工具来描述其整体操作。该模型定义了参与文件传输的设备的角色，以及在它们之间建立的两个通信通道。它还描述了管理这些通道的 FTP 组件，并定义了用于这些组件的术语。这使它成为我们从广义上了解 FTP 工作原理的理想场所。

<u>**Server-FTP进程和User-FTP进程**</u>
正如我在概述中提到的，FTP 是一种经典的客户端/服务器协议。但是，客户端不使用该名称来调用，而是称为用户。这个名字来源于这样一个事实，即发出 FTP 命令的人类用户在客户端机器上工作。在一台设备上运行的全套FTP软件称为一个进程。服务器上的FTP软件称为Server-FTP Process，而客户端上的软件称为User-FTP Process。

**关键概念：**FTP 客户端有时称为用户设备，因为人类用户直接与客户端交互。 FTP客户端软件称为User-FTP Process； FTP 服务器软件，Server-FTP Process。

<u>**FTP控制连接和数据连接**</u>
理解 FTP 的一个关键概念是，虽然它像许多其他应用程序一样使用 TCP，但它不像大多数协议那样只使用一个 TCP 连接进行所有通信。 FTP 模型是围绕服务器和用户 FTP 进程之间的两个逻辑通信通道设计的：

- 控制连接：这是建立 FTP 会话时创建的主要逻辑 TCP 连接。它在整个 FTP 会话期间保持不变，仅用于传递控制信息，例如 FTP 命令和回复。它不用于发送文件。

- 数据连接：每次数据从服务器发送到客户端时，反之亦然，它们之间会建立一个不同的 TCP 数据连接。数据通过此连接传输。文件传输完成后，连接将终止。

拥有这些单独通道的原因是它提供了协议使用方式的灵活性，正如我们将在本节后面看到的那样。但是，它确实增加了 FTP 的复杂性。

**关键概念：**与大多数协议不同，FTP 不使用单个 TCP 连接。建立会话后，将使用 TCP 建立永久控制连接，以传递命令和回复。当要发送文件或其他数据时，它们通过单独的 TCP 数据连接传递，这些连接被创建，然后根据需要被拆除。



###### 4.2.2.1.2-2 FTP 控制连接建立、用户认证和匿名 FTP 访问（部分：1 2 3）

<u>**FTP 进程组件和术语**</u>

由于控制和数据功能使用不同的通道进行通信，因此 FTP 模型将每个设备上的软件划分为两个负责每个通道的逻辑协议组件。协议解释器 (PI) 是一种软件，负责管理控制连接、发出和接收命令以及回复。数据传输进程 (DTP) 负责在客户端和服务器之间实际发送和接收数据。除了这两个元素之外，用户 FTP 进程还包括第三个组件，即与人类 FTP 用户交互的用户界面；它不存在于服务器端。

因此，FTP 中有两个服务器进程组件和三个客户端（用户）进程组件。这些组件在 FTP 模型中通过特定名称引用，这些名称在标准中用于描述协议的详细操作。我打算在本节中做同样的事情，所以我现在将更全面地描述该模型的每个设备中的组件，如图 288 所示。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ftpmodel.png)

​                                                                          **图 288：文件传输协议 (FTP) 操作模型**

FTP 是一种客户端/服务器协议，通信发生在客户端上的用户-FTP 进程和服务器上的服务器-FTP 进程之间。命令、回复和状态信息通过控制连接在 User-PI 和 Server-PI 之间传递，该连接建立一次并为会话维护。数据通过为每次传输设置的数据连接在设备之间移动。

<u>**服务器-FTP 进程组件**</u>

服务器-FTP 进程包含以下两个协议元素：

- 服务器协议解释器（Server-PI）：负责管理服务器上的控制连接的协议解释器。它在主保留 FTP 端口上侦听来自用户（客户端）的传入连接请求。建立连接后，它会从 User-PI 接收命令，发回回复，并管理服务器数据传输过程。

- Server Data Transfer Process (Server-DTP)：服务器端的DTP，用于向User-DTP发送数据或从User-DTP接收数据。 Server-DTP 可以建立数据连接或监听来自用户的数据连接。它与服务器的本地文件系统交互以读写文件。

<u>**用户 FTP 进程组件**</u>
User-FTP Process 包含以下三个协议元素：

- 用户协议解释器（User-PI）：负责管理客户端控制连接的协议解释器。它通过向 Server-PI 发出请求来启动 FTP 会话。建立连接后，它会处理从用户界面收到的命令，将它们发送到 Server-PI，然后接收回复。它还管理用户数据传输过程。

- User Data Transfer Process (User-DTP)：用户端的DTP，它向Server-DTP发送数据或从Server-DTP接收数据。 User-DTP 可以建立数据连接或侦听来自服务器的数据连接。它与客户端设备的本地文件系统交互。

- 用户界面：用户界面为人类用户提供了更“友好”的 FTP 界面。它允许将更简单的面向用户的命令用于 FTP 功能而不是有些神秘的内部 FTP 命令，并且还允许将结果和信息传回给操作 FTP 会话的人。

**关键概念：**服务器-FTP 进程和用户-FTP 进程都包含协议解释器 (PI) 元素和数据传输进程 (DTP) 元素。 Server-PI和User-PI通过FTP控制连接进行逻辑链接； Server-DTP 和 User-DTP 通过数据连接。 User-FTP Process 包括第三个组件，即用户界面，它为人类用户提供了发出命令和查看来自 FTP 软件的响应的方法。

<u>**第三方文件传输（代理 FTP）**</u>

FTP 标准实际上为使用协议的替代方式定义了一个单独的模型。 在这种技术中，一台主机上的用户执行从一台服务器到另一台服务器的文件传输。 这是通过打开两个控制连接来完成的：一个从用户机器上的 User-PI 到两个服务器上的两个 Server-PI。 然后，在每个服务器上调用一个Server-DTP发送数据； 不使用用户 DTP。

这种方法有时称为第三方文件传输或代理 FTP，如今并未广泛使用。 这样做的一个主要原因是它引起了安全问题，并且在过去曾被利用过。 因此，虽然我觉得它值得一提，但我不会在我的 FTP 报道中进一步讨论它。



###### 4.2.2.1.2-3 FTP 数据连接管理、正常（主动）和被动数据连接以及端口使用（部分：1 2 3 4）

FTP 操作模型描述了在 FTP 客户端（用户）和 FTP 服务器之间建立的不同逻辑数据和控制通道。在数据连接可用于发送实际文件之前，必须建立控制连接。遵循特定过程来建立此连接，从而在可用于传输文件的设备之间创建永久 FTP 会话。

与其他客户端/服务器协议一样，FTP 服务器在控制连接过程中扮演被动角色。服务器协议解释器（Server-PI）“侦听”为 FTP 控制连接保留的特殊众所周知的 TCP 端口：端口 21。User-PI 通过打开从用户设备到此服务器的 TCP 连接来启动连接港口。它使用临时端口号作为 TCP 连接中的源端口。

一旦建立了 TCP，就建立了设备之间的控制连接，允许从 User-PI 向 Server-PI 发送命令，并返回响应代码作为响应。通道运行后的第一个业务顺序是用户认证，FTP 标准称之为登录顺序。这个过程有两个目的：

- 访问控制：身份验证过程允许将对服务器的访问限制为仅授权用户。它还允许服务器控制每个用户拥有的访问类型。

- 资源选择：通过识别建立连接的用户，FTP 服务器可以决定向用户提供哪些资源。

<u>**FTP 登录序列和身份验证**</u>

FTP 的常规身份验证方案非常基本：它是一个简单的“用户名/密码”登录方案，如图 289 所示。我们大多数人都熟悉这种用于 Internet 和其他地方的各种访问类型的身份验证。首先，通过使用 USER 命令将用户名从 User-PI 发送到 Server-PI 来识别用户。然后，使用 PASS 命令发送用户密码。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ftpconnection.png)


​                                                                            **图 289：FTP 连接建立和用户验证**

FTP 会话从客户端和服务器之间建立 TCP 连接开始。客户端 hen 发送用户名和密码以向服务器进行身份验证。假设服务器接受了信息，它向客户端发送一个问候回复，会话打开。


服务器根据其用户数据库检查用户名和密码，以验证连接用户是否具有访问服务器的有效权限。如果信息有效，则服务器向客户端发回问候语以指示会话已打开。如果用户不正确地验证（通过指定不正确的用户名或密码），服务器将请求用户再次尝试授权。在多次尝试无效授权后，服务器可能会超时并终止连接。

假设身份验证成功，服务器然后建立连接以允许用户被授权的访问类型。某些用户可能只能访问某些文件或某些类型的文件。一些服务器可能允许特定用户在服务器上读取和写入文件，而其他用户可能只检索文件。因此，管理员可以根据需要定制 FTP 访问。

一旦建立连接，服务器还可以根据用户的身份做出资源选择决策。例如，在有多个用户的系统上，管理员可以设置 FTP，这样当任何用户连接时，他或她会自动进入他或她自己的“主目录”。可选的 ACCT（帐户）命令还允许用户选择一个特定的帐户（如果他或她有多个帐户）。

<u>**FTP 安全扩展**</u>
与大多数旧协议一样，FTP 使用的简单登录方案是早期 Internet 相对“封闭”性质的遗产。当今的全球 Internet 标准认为它不安全，因为用户名和密码以明文形式通过控制连接发送。这使得登录信息相对容易被中间系统截获，并且帐户受到损害。 RFC 2228，FTP 安全扩展，为那些需要在其 FTP 软件中增加安全性的人定义了更复杂的身份验证和加密选项。

**关键概念：**FTP 会话始于在 FTP 客户端和服务器之间建立控制连接。建立 TCP 连接后，用户必须使用客户端和服务器之间的简单用户/密码交换向服务器进行身份验证。这仅提供基本的安全性，因此如果需要更多，则必须使用 FTP 安全扩展或通过其他方式来实现。

<u>**匿名FTP**</u>

然而，也许令人惊讶的是，许多组织并不认为需要这种增强的安全级别。他们实际上走向了相反的方向：使用 FTP，根本没有任何身份验证。这似乎令人惊讶；为什么会有人想要只允许任何人访问他们的 FTP 服务器？然而，答案非常简单：任何想要使用服务器向公众提供信息的人。

今天，大多数组织使用万维网向客户和其他想要获取它们的人分发文档、软件和其他文件。但在 1980 年代，在 Web 流行之前，FTP 是经常使用的方式。例如，今天，如果您有一个 3Com 网络接口卡并需要它的驱动程序，您会访问 Web 服务器 www.3com.com，但几年前，您可能访问过 3Com FTP 服务器 (ftp.3com .com) 为其下载驱动程序。

显然，要求每个客户在这样的服务器上都有用户名和密码是荒谬的。为此，1994 年的 RFC 1635 定义了一种称为匿名 FTP 的协议用途。在这种技术中，客户端连接到服务器并提供默认用户名以访客身份登录。通常支持名称“anonymous”或“ftp”。看到这个名字，服务器会回复一条特殊的消息，比如“来宾登录成功，请发送您的完整电子邮件地址作为密码。”。这种情况下的密码当然不是真正的密码，它只是用来让服务器记录谁在访问它。

来宾随后可以访问该站点，尽管服务器通常会严格限制来宾在系统上的访问权限。许多 FTP 服务器同时支持身份访问和匿名访问，授权用户拥有更多权限（例如能够遍历完整目录路径，并有权删除或重命名文件），而匿名用户可能只能从为公共访问设置的特定目录。

**关键概念：**许多 FTP 服务器支持匿名 FTP，这允许在服务器上没有帐户的来宾对服务器资源具有有限的访问权限。出于技术支持、客户支持或分发等目的，希望向公众提供文件的组织经常使用此方法。



使用 FTP 连接建立和身份验证过程在 Server-PI 和 User-PI 之间创建的控制通道在整个 FTP 会话期间保持不变。命令和回复通过此通道在协议解释器之间交换，但不交换数据。

每次需要在服务器和用户 FTP 进程之间发送文件或其他数据时，都必须创建数据连接。数据连接将 User-DTP 与 Server-DTP 链接起来。显式文件传输操作（获取或接收文件）和隐式数据传输都需要此连接，例如从服务器上的目录请求文件列表。

FTP 标准指定了两种不同的创建数据连接的方式，尽管它并没有以非常容易理解的方式真正解释它们。那是我的工作。这两种方法的主要区别在于哪个设备（客户端或服务器）发起连接。乍一看这似乎是一件微不足道的事情，但正如我们很快就会看到的那样，它实际上非常重要。

<u>**正常（活动）数据连接**</u>

第一种方法有时称为创建普通数据连接（因为它是默认方法），有时称为主动数据连接（与我们稍后将看到的被动方法形成对比）。在这种类型的连接中，Server-DTP 通过打开到 User-DTP 的 TCP 连接来启动数据通道。服务器使用特殊保留端口号 20（比众所周知的控制 FTP 端口号 21 少一个）进行数据连接。在客户端机器上，使用的默认端口号与用于控制连接的临时端口号相同，但我们很快就会看到，客户端通常会为每次传输选择不同的端口。

让我们举个例子看看这是如何工作的。假设 User-PI 建立了从其临时端口号 1678 到服务器的 FTP 控制端口 21 的控制连接。然后，要创建用于数据传输的数据连接，Server-PI 将指示 Server-DTP 启动 TCP 连接从服务器的端口 20 到客户端的端口 1678。客户端将确认这一点，然后可以传输数据（在任一方向 — 请记住 TCP 是双向的）。

实际上，在同一个端口上进行客户端的控制和数据连接并不是一个好主意；它使 FTP 的操作复杂化，并可能导致一些棘手的问题。因此，强烈建议客户端在数据传输之前使用 PORT 命令指定不同的端口号。例如，假设客户端使用 PORT 指定端口 1742。 Server-DTP 然后会创建从其端口 20 到客户端端口 1742 而不是 1678 的连接。此过程如图 290 所示。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ftpactive.png)




​                                                                                **图 290：FTP 活动数据连接**

在传统的或主动的 FTP 数据连接中，服务器通过打开与客户端的数据连接来启动数据传输。在这种情况下，客户端首先发送 PORT 命令告诉服务器使用端口 1742。然后服务器打开从其默认端口号 20 到客户端端口 1742 的数据连接。然后使用这些端口在设备之间交换数据。对比图 291。

<u>**被动数据连接**</u>

第二种方法称为被动数据连接。客户端告诉服务器“被动”，即接受客户端发起的传入数据连接。服务器回复给客户端它应该使用的服务器 IP 地址和端口号。 Server-DTP 然后在此端口上侦听来自 User-DTP 的传入 TCP 连接。默认情况下，用户机器使用它用于控制连接的相同端口号，就像在活动情况下一样。但是，在这里，如果需要，客户端可以选择使用不同的端口号进行数据连接（通常是临时端口号）。

让我们再次考虑我们的示例，控制连接从客户端的端口 1678 到服务器的端口 21，但这次考虑使用被动连接的数据传输，如图 291 所示。客户端将发出 PASV 命令告诉服务器它想使用被动数据控制。 Server-PI 将回复一个客户端使用的端口号，比如端口 2223。然后 Server-PI 将指示 Server-DTP 侦听此端口 2223。User-PI 将指示 User-DTP 以创建从客户端端口 1742 到服务器端口 2223 的连接。服务器将确认这一点，然后可以再次在任一方向发送和接收数据。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ftppassive.png)

​                                                                                      **图 291：FTP 被动数据连接**

在被动的FTP数据连接中，客户端使用PASV命令告诉服务器等待客户端建立数据连接。服务器响应，告诉客户端应该使用服务器上的哪个端口进行数据传输，在本例中为端口 2223。然后客户端使用服务器上的该端口号和它自己选择的客户端端口号打开数据连接，在本例中为 1742。对比图 291。

<u>**选择连接方法时的效率和安全问题**</u>

当然，这留下了一个挥之不去的问题：谁在乎呢？ J 我已经说过，在任何一种情况下，数据传输都可以双向进行。那么谁发起数据连接有什么关系呢？这不就像争论谁打本地电话一样吗？

答案与可怕的“S 词”有关：安全。 FTP 使用多个 TCP 连接这一事实会给人们用来确保系统安全的硬件和软件带来问题。

考虑在上例中描述的活动数据连接情况下发生的情况。从客户端的角度来看，已经建立了从客户端的1678端口到服务器的21端口的控制连接。但是数据连接是由服务器发起的。因此，客户端会看到对端口 1678（或其他某个端口）的传入连接请求。许多客户端对接收此类传入连接持怀疑态度，因为在正常情况下，客户端会建立连接，但不会对其做出响应。由于传入的 TCP 连接可能存在安全风险，因此许多客户端配置为使用防火墙硬件或软件阻止它们。

为什么不直接让客户端始终接受到比用于控制连接的临时端口号大一的端口号的连接？这里的问题是客户端经常使用 PORT 命令为每次传输使用不同的端口号。为什么这样做？因为TCP的规则。正如我在 TCP 部分中描述的那样，连接关闭后，必须经过一段时间才能再次使用该端口，以防止混淆连续的会话。这会在一个接一个地发送多个文件时造成延迟，因此为避免这种情况，客户端通常在每次传输时使用不同的端口号。这更有效，但意味着保护客户端的防火墙将被要求接受似乎去往许多不可预测端口号的传入连接。

被动连接的使用在很大程度上消除了这个问题。与传出连接相比，大多数防火墙在处理奇数端口的传入连接时要困难得多。 RFC 1579，Firewall-Friendly FTP，详细讨论了这个问题。它建议客户端默认使用被动数据连接，而不是通过 PORT 命令使用普通连接，以避免端口阻塞问题。

当然，被动数据连接并不能真正消除问题，它们只是将问题推到服务器上。这些服务器现在必须面对各种端口的传入连接问题。尽管如此，一般来说，与大量客户端相比，在数量相对较少的服务器上处理安全问题更容易。无论如何，FTP 服务器必须能够接受来自客户端的被动模式传输，因此通常的方法是为此目的预留一个端口块，服务器的安全规定允许接受传入连接，同时阻止其他端口上的传入连接请求。

**注意：**顺便说一句，在PORT、PASV等FTP命令及其回复中传递IP地址和端口号是严重违反网络分层原则的。这不仅仅是一个哲学问题：应用程序不应该处理端口号，这在使用某些较低层技术时会产生问题。例如，考虑修改 IP 地址和可能的端口号的网络地址转换的使用。为了防止 NAT 在使用 FTP 时“中断”，必须对协议进行特殊规定。

**关键概念：**FTP 支持两种不同的模型来建立客户端和服务器之间的数据连接。**在正常或活动的数据连接中，服务器在客户端请求传输时发起连接，客户端响应；在被动数据连接中，客户端告诉服务器它将启动连接，然后服务器响应。由于 TCP 是双向的，因此两种情况下数据都可以双向流动；两种模式之间的主要区别与安全性有关。特别是，经常使用被动模式，因为当今的许多客户端设备无法接受来自服务器的传入连接。**





###### 4.2.2.1.2-4 FTP 通用数据通信和传输模式（部分：1 2）

一旦在 Server-DTP 和 User-DTP 之间建立了数据连接，数据就会直接从客户端发送到服务器，或从服务器发送到客户端，这取决于发出的特定命令。由于控制信息是使用不同的控制通道发送的，因此整个数据通道都可以用于数据通信。 （当然，这两个逻辑通道在较低层与两个设备上的所有其他 TCP 和 UDP 连接组合在一起，所以这并不代表单个通道的性能改进。只是想说清楚。）

FTP 定义了三种不同的传输模式（也称为传输模式），它们准确地指定了数据如何通过打开的数据通道从一个设备发送到另一个设备：流模式、块模式和压缩模式。

<u>**流模式**</u>
在这种模式下，数据只是作为连续的非结构化字节流发送。发送设备只是开始通过 TCP 数据连接将数据推送到接收方。没有使用具有不同标头字段的消息格式，这使得该方法与许多其他协议以离散块发送信息的方式截然不同。它强烈依赖于 TCP 的数据流和可靠的传输服务。由于没有标头结构，文件结束仅由发送设备在完成时关闭数据连接来指示。

在这三种方法中，流模式是迄今为止在实际 FTP 实现中使用最广泛的一种。这可能有三个原因。首先，它是默认方法，也是最简单的方法，因此最容易实现，也是兼容性所必需的方法。其次，它是最通用的，因为它将所有文件都视为简单的字节流，而不关心它们的内容。第三，它是最有效的方法，因为没有字节浪费在“开销”上，例如标头。

<u>**块模式**</u>

这是一种更“常规”的数据传输模式，其中数据被分成数据块并封装到单独的 FTP 块或记录中。每条记录都有一个三字节的标头，指示其长度并包含有关正在发送的数据块的信息。一种特殊的算法用于跟踪传输的数据并检测并重新启动中断的传输。

<u>**压缩模式**</u>

一种传输模式，其中使用称为游程编码的相对简单的压缩技术来检测正在发送的数据中的重复模式，然后以整个消息占用更少字节的方式表示它们。然后以类似于块模式的方式发送压缩信息，使用标头+有效负载记录格式。

压缩模式从表面上看似乎很有用。然而，在实践中，压缩通常在典型网络软件堆栈的其他地方实现，因此在 FTP 中没有必要。例如，如果您使用模拟调制解调器通过 Internet 传输文件，您的调制解调器通常会在第一层向下执行压缩。 FTP 服务器上的大文件通常也已经使用 ZIP 格式进行了压缩，这意味着进一步压缩将无济于事。

**核心概念：**FTP包括三种不同的传输方式：流式、块式和压缩式。在流模式下，数据作为连续的字节序列发送；在块模式下，数据被格式化为带有标题的块；在压缩模式下，字节使用游程编码进行压缩。流模式是最常用的一种。



###### 4.2.2.1.2-5 FTP 数据表示：数据类型、数据结构和格式控制（部分：1 2 3）

设计文件传输协议的最通用方法是让它将所有文件视为“黑匣子”。该文件将表示为一组字节。 FTP 不会注意文件包含的内容，而只会将文件从一个地方移动到另一个地方，一次一个字节。在这方面，它似乎与大多数文件系统上实现的“复制”命令非常相似，它同样会创建一个副本，而无需查看文件以查看其包含的内容。

那么，您可能想知道，这会有什么问题？好吧，对于某些类型的文件，这正是我们想要的，但对于其他类型的文件，它引入了一个问题。原因是某些类型的文件在不同的系统上使用不同的表示。如果您使用“复制”命令将文件从同一台计算机上的一个位置复制到另一个位置，则没有问题：该计算机内的所有文件都使用相同的表示形式。但是，当您将它复制到使用不同表示法的计算机时，您可能会遇到困难。

最常见的例子是一种可能会让您感到惊讶的文件类型：简单的文本文件。所有 ASCII 文本文件都使用 ASCII 字符集，但它们在用于标记文本行结尾的控制字符方面有所不同。在 UNIX 上，使用换行 (LF) 字符；在 Apple 计算机上，回车符 (CR)； Windows 机器同时使用 (CR+LF)。

如果您使用常规 FTP 将文本文件从一种类型的系统移动到另一种系统，则数据将完全按照原样移动。将一个文本文件从 UNIX 系统移动到 PC 上只是一组字节意味着程序无法正确识别行尾标记。避免这种困境需要 FTP 摆脱“所有文件都只是字节”的想法，并结合一些智能来处理不同类型的文件。 FTP 标准通过允许在传输之前指定有关文件内部表示的某些详细信息来识别这一点。

<u>**FTP 数据类型**</u>
可以给出的关于文件的第一条信息是它的数据类型，它决定了文件的整体表示。 FTP 标准中指定了四种不同的数据类型：

- ASCII：定义一个 ASCII 文本文件，其中的行由某种行尾标记标记，如上所述。

- EBCDIC：概念上与 ASCII 类型相同，但适用于使用 IBM 的 EBCDIC 字符集的文件。

- 图像：文件没有正式的内部结构，一次发送一个字节，不做任何处理；这就是我上面提到的“黑匣子”模式。

- 本地：此数据类型用于处理可能将数据存储在逻辑字节中的文件，其中包含 8 位以外的位数。指定此类型以及数据的结构方式允许数据以某种方式存储在目标系统上与其当地代表一致。

**注意：**术语“字节”通常指的是 8 位，但严格来说，8 位的术语是“八位字节”。在某些系统上，一个字节实际上可能包含 8 个以外的多个位。有关详细信息，请参阅有关位和字节的背景主题。

实际上，最常用的两种数据类型是 ASCII 和图像。 ASCII 类型用于文本文件，并允许它们在具有自动转换的行尾代码的系统之间移动。 Image 类型用于通用二进制文件，例如图形图像、ZIP 文件和其他以通用方式表示的数据。由于这个原因，它也经常被称为二进制类型。



<u>**ASCII 数据类型行定界问题**</u>

当使用 ASCII 数据类型时，系统之间内部表示的差异通过使用充当“通用语言”的通用外部表示来处理。正在传输的文件的行通过发送 FTP 进程从发送方的内部表示转换为 Telnet 协议（“NETASCII”）使用的中性 ASCII 表示，每行以“CR+LF”结尾。接收设备然后将此中性表示转换为接收方文件系统使用的内部格式。

例如，当使用 FTP 将文本文件从 Macintosh 移动到 UNIX 系统时，每一行都会将“CR”更改为“CR+LF”，以便通过 FTP 数据通道传输。接收 UNIX 系统会将每个“CR+LF”更改为“LF”，以便 UNIX 程序可以正确读取它。

请注意，如果使用 ASCII 模式在系统之间传输，这实际上意味着生成的文件可能比原始文件更大或更小。此外，由于 FTP 通过转换为通用的中性表示来工作，将 ASCII 文件从 UNIX 系统发送到 UNIX 系统意味着每个“LF”都更改为“CR+LF”以进行传输，然后再更改回“LF”由收件人。效率有点低，但没什么大不了的。

使用 FTP 时，使用适当的用户命令指定正确的数据类型非常重要。在不设置 ASCII 模式的情况下在不同系统之间发送文本文件将导致目标文件无法正确读取，或者文件中包含杂散字符。相反，二进制文件必须以二进制方式发送。如果您以 ASCII 模式发送 ZIP 文件或 JPG 图形之类的内容，FTP 软件会认为它是文本文件。它会将文件视为文本，每次遇到文件中看起来像“CR”、“LF”或“CR+LF”的字节时，它都会转换它们，这是你不想要的。 （当使用 FTP 在 PC 和 UNIX 系统之间移动文件时，设置错误的数据类型是文件损坏的主要原因。我从经验中知道！）

**关键概念：**FTP 定义了四种数据类型：ASCII、EBCDIC、图像和本地。 ASCII和EBCDIC分别用于ASCII和EBCDIC字符集中的文本文件；图像类型用于没有特定结构的文件，本地类型用于本地表示。 ASCII 类型很重要，因为它允许文本文件在可能使用不同方法指示文本行结尾的文件系统之间成功传输。图像类型，也称为二进制，用于必须逐字节发送和接收且不进行任何转换的文件，例如可执行文件、图形和任意格式的文件。

<u>**FTP格式控制**</u>

对于 ASCII 和 EBCDIC 类型，FTP 定义了一个称为格式控制的可选参数。这允许用户指定垂直格式如何用于描述文件的特定表示。三个选项是：

- Non Print：默认，表示没有垂直格式。

- Telnet 格式：表示在该文件中使用 Telnet 协议中指定的垂直格式控制字符。

- Carriage Control / FORTRAN：该文件使用格式控制字符作为每行的第一个字符，如 FORTRAN 编程语言所指定的那样。
  格式控制选项是为正确处理从主机设备传输到打印机的文件的特定目的而创建的。据我所知，它今天没有被使用（或者即使被使用，也只是在特殊应用中。）

<u>**FTP数据结构**</u>
除了指定文件的数据类型外，还可以指定文件的数据结构。存在三种可能性：

- 文件结构：文件是连续的字节流，没有内部结构。

- 记录结构：文件由一组顺序记录组成，每个记录都由记录结束标记分隔。

- 页面结构：该文件包含一组特殊的索引数据页面。

文件结构是默认的，用于大多数类型的文件。记录结构可用于 ASCII 文本文件，但这些文件更常与使用 ASCII 数据类型的常规文件结构一起发送。页面结构不常用；我相信它最初是为早期 ARPAnet 中使用的一种现在已经过时的计算机创建的。



###### 4.2.2.1.3 FTP 命令和回复 

在上一节中，我讨论了文件传输协议的一般操作。作为此描述的一部分，我解释了如何执行数据传输、如何建立和管理连接以及 FTP 支持的各种传输模式和数据类型。所有这些功能都是使用一组特殊的 FTP 命令实现的，这些命令由 User-FTP 进程发送到 Server-FTP 进程。服务器设备通过使用特殊代码发回回复来确认命令。了解 FTP 命令和回复代码将使我们能够全面了解该协议的工作原理。

我通过讨论 FTP 命令及其分组方式开始本节。然后我展示了用于 FTP 回复代码的特殊编码格式，并列出了一些更常见和重要的代码。我还讨论了 FTP 用户界面和典型 FTP 实现所使用的命令，以允许用户与 FTP 软件进行通信。这些命令通常不同于内部 FTP 命令，以允许用户以对人类更友好的方式操作协议。

###### 4.2.2.1.3-1 FTP 内部协议命令和命令组（部分：1 2）

FTP 会话始于从 FTP 客户端（用户设备）到 FTP 服务器的 TCP 连接的建立。一旦建立，控制通道逻辑上就位于服务器-PI 和用户-PI 之间。管理协议操作的所有通信都通过此通道进行。 User-PI 向 Server-PI 发送协议命令，Server-PI 对其进行处理并采取适当的措施。 Server-PI 使用回复代码进行响应，以告知 User-PI 它发出的命令的结果并传达其他重要信息。

<u>**FTP 命令组**</u>
为方便起见，每个命令都由一个简短的三字母或四字母命令代码标识，并在 FTP 的整体功能中执行特定任务。这些协议命令有几十个，为了帮助组织它们，FTP 标准根据整体功能类型将它们分为三组：

- 访问控制命令：作为用户登录和身份验证过程的一部分的命令，用于资源访问，或者是一般会话控制的一部分。

- 传输参数命令：指定数据传输方式参数的命令。例如，该组中的命令指定要发送的文件的数据类型，指示将使用被动数据连接还是主动数据连接，等等。

- FTP 服务命令：这是最大的一组，包含所有实际执行文件操作的命令，例如发送和接收文件。实现支持功能的命令，例如删除或重命名文件，也在这里。

有趣的是，FTP 命令在控制通道上的实际传输是使用基于 Telnet 协议的规范完成的。您可能还记得 FTP 概述，Telnet 和 FTP 是两个最古老的 TCP/IP 应用程序，前者用于“直接”网络使用，后者用于“间接”资源访问。它们大约是同时开发的，设置 FTP 控制通道作为一种 Telnet 连接是 Internet 标准如何避免“重新发明轮子”的一个很好的例子。

**关键概念：**FTP 操作是通过从 FTP 客户端向 FTP 服务器发出协议命令来控制的。每个命令都有一个由三个或四个字母组成的命令代码来指示其功能。命令分为三组：用于登录和一般会话控制的访问控制命令；控制传输如何执行的传输参数命令；和 FTP 服务命令，用于执行实际的文件操作。

<u>**FTP 协议命令**</u>

由于这些命令基于 Telnet 规范，因此它们只是按照 Telnet 的网络虚拟终端 (NVT) 约定以纯文本形式发送。 我在下面提供了三个表格，按照它们在 FTP 标准 (RFC 959) 中出现的顺序描述了 FTP 内部协议命令。 表 225 涵盖了 FTP 访问控制命令，表 226 列出了传输参数命令，表 227 列出了服务命令。


​                                                                             **表 225：FTP 访问控制命令**

| **Command Code** | **Command**                                          | **Description**                                              |
| ---------------- | ---------------------------------------------------- | ------------------------------------------------------------ |
| ***USER\***      | *User Name*                                          | 标识尝试建立 FTP 会话的用户。                                |
| ***PASS\***      | *Password*                                           | 指定在登录验证期间先前由 USER 命令提供的用户的密码。         |
| ***ACCT\***      | *Account*                                            | 在 FTP 会话期间为经过身份验证的用户指定一个帐户。仅用于需要单独标识的系统；大多数会根据在 USER 命令中输入的名称自动选择一个帐户。 |
| ***CWD\***       | *Change Working Directory*                           | 允许用户在 FTP 会话期间为文件传输指定不同的目录。            |
| ***CDUP\***      | *Change To Parent Directory (“Change Directory Up”)* | CWD 命令的一种特殊情况，它转到服务器目录结构中的上一级目录。它是单独实现的，以抽象出文件系统之间目录结构的差异；用户可以只使用 CDUP 而不是知道在服务器上向上导航目录树的特定语法。 |
| ***SMNT\***      | *Structure Mount*                                    | 允许用户挂载特定的文件系统以访问不同的资源。                 |
| ***REIN\***      | *Reinitialize*                                       | 重新初始化 FTP 会话，刷新所有设置的参数和用户信息。这会将会话返回到刚刚建立控制连接时的状态。本质上，它与 USER 命令相反。发出的下一个命令通常是 USER，用于登录不同的用户。 |
| ***QUIT\***      | *Logout*                                             | 终止 FTP 会话并关闭控制连接。                   请注意，这个命令“注销”的命名很不幸； REIN 命令实际上与传统的“注销”命令最相似，因为它会终止已登录的用户并允许另一个用户登录。相反，QUIT 命令会关闭整个会话。 |
|                  |                                                      |                                                              |

​                                                                              **表 226：FTP 传输参数命令**

| **Command Code** | **Command**           | **Description**                                              |
| ---------------- | --------------------- | ------------------------------------------------------------ |
| ***PORT\***      | *Data Port*           | 用于告诉 FTP 服务器客户端想要接受特定端口号上的活动数据连接。 |
| ***PASV\***      | *Passive*             | 请求 FTP 服务器允许 User-DTP 启动被动数据连接。              |
| ***TYPE\***      | *Representation Type* | 为要传输的文件指定数据类型（ASCII、EBCDIC、图像或本地），以及可选的格式控制（非打印、Telnet 或 Carriage Control）。 |
| ***STRU\***      | *File Structure*      | 指定文件的数据结构（文件、记录或页面）。                     |
| ***MODE\***      | *Transfer Mode*       | 指定要使用的传输模式（流、块或压缩）。                       |

​                                                                           **表 227：FTP 服务命令**

| **Command Code** | **Command**               | **Description**                                              |
| ---------------- | ------------------------- | ------------------------------------------------------------ |
| ***RETR\***      | *Retrieve*                | 告诉服务器向用户发送文件。                                   |
| ***STOR\***      | *Store*                   | 向服务器发送文件。                                           |
| ***STOU\***      | *Store Unique*            | 与 STOR 类似，但指示服务器确保文件在当前目录中具有唯一名称。这用于防止覆盖可能已经存在的同名文件。服务器用文件使用的名称回复。 |
| ***APPE\***      | *Append (with Create)*    | 与 STOR 一样，但如果具有指定名称的文件已经存在，则发送的数据将附加到它而不是替换它。 |
| ***ALLO\***      | *Allocate*                | 一个可选命令，用于在发送文件之前在服务器上保留存储空间。     |
| ***REST\***      | *Restart*                 | 在特定服务器标记处重新启动文件传输。仅用于块或压缩传输模式。 |
| ***RNFR\***      | *Rename From*             | 指定要重命名的文件的旧名称。请参阅下面的 RNTO 命令。         |
| ***RNTO\***      | *Rename To*               | 指定要重命名的文件的新名称。与 RNFR 命令一起使用。           |
| ***ABOR\***      | *Abort*                   | 告诉服务器中止最后的 FTP 命令和/或当前的数据传输。           |
| ***DELE\***      | *Delete*                  | 删除服务器上的指定文件。                                     |
| ***RMD\***       | *Remove Directory*        | 删除服务器上的目录。                                         |
| ***MKD\***       | *Make Directory*          | 创建一个目录。                                               |
| ***PWD\***       | *Print Working Directory* | 显示 FTP 会话的当前服务器工作目录；向用户显示服务器文件系统中的“位置”。 |
| ***LIST\***      | *List*                    | 从服务器请求当前目录的内容列表，包括名称和其他信息。在概念上类似于 DOS/Windows 中的“DIR”命令或 UNIX 中的“ls”命令。 |
| ***NLST\***      | *Name List*               | 类似于 LIST，但只返回目录中的名称。                          |
| ***SITE\***      | *Site Parameters*         | 用于实现站点特定的功能。                                     |
| ***SYST\***      | *System*                  | 请求服务器向客户端发送有关服务器操作系统的信息。             |
| ***STAT\***      | *Status*                  | 提示服务器发送文件状态或当前正在进行的传输的指示。           |
| ***HELP\***      | *Help*                    | 向服务器询问任何可能有助于用户确定应如何使用服务器的帮助信息。 |
| ***NOOP\***      | *No Operation*            | 除了提示服务器发送“OK”响应以验证控制通道是否处于活动状态之外，什么都不做。 |



**注意：**FTP 命令不区分大小写，但为清楚起见已显示为大写。


FTP 命令都是在 FTP 协议元素之间发送的； 它们通常不是由用户直接发布的。 相反，为此目的采用了一组特殊的用户命令。 FTP用户界面实现了用户和User-FTP进程之间的链接，包括将用户命令翻译成FTP协议命令。



###### 4.2.2.1.3-2 FTP 回复、回复代码格式和重要回复代码（部分：1 2 3 4 5）

每次 User-PI 通过控制连接向 Server-PI 发送命令时，服务器都会发回回复。 FTP 回复服务于三个主要目的。首先，它们用作服务器收到命令的确认。其次，它们告诉用户设备命令是否被接受，如果发生错误，是什么错误。第三，他们向会话用户传达各种类型的信息，例如传输状态。

<u>**同时使用文本和数字回复的优势**</u>
对于人类用户，一串回复文本就足以满足上述要求，并且 FTP 回复确实包含描述性文本。但是只有一个文本字符串会使客户端的 FTP 软件难以或不可能解释来自服务器的结果。 FTP 的设计还允许软件应用程序通过 FTP 命令链接相互交互。为此，协议围绕回复代码的使用设计了回复系统。

FTP 回复代码是计算机程序可以轻松解读的三位数字回复。它们对于熟悉 FTP 的人类用户也很有用，因为它们一眼就能传达各种操作的结果。虽然每个 FTP 服务器实现在为每种类型的回复发送的文本方面可能有所不同，但根据 FTP 标准的规范以一致的方式使用回复代码。因此，检查代码以确定命令的结果；文字只是描述性的。

<u>**回复代码结构和数字解释**</u>

为了使回复代码更有用，代码不仅以线性或随机顺序分配，而且使用了特殊的编码方案。每个代码都有三个数字，每个数字都传达一种特定类型的信息并对回复进行分类。可以将代码视为“xyz”形式，其中“x”是第一个数字，“y”是第二个数字，“z”是第三个数字。

**关键概念：**FTP 客户端发送的每个命令都会导致 FTP 服务器发送回复。 FTP 回复由一个三位数的数字回复代码和一行描述性文本组成。回复代码用于标准化 FTP 回复，以便它们可以被客户端软件解释，因此有经验的用户可以一眼看出命令的结果。回复代码的结构使得前两位数字指示回复的类型及其所属的类别。

<u>**第一个回复代码数字（“x”）**</u>
回复码的第一位一般表示命令的成功或失败，成功的命令是完整的还是不完整的，不成功的命令是否应该重试。表 228 显示了可能的值。


​                                                                   **表 228：FTP 回复代码格式：首位解释**

| **Reply Code Format** | **Meaning**                             | **Description**                                              |
| --------------------- | --------------------------------------- | ------------------------------------------------------------ |
| **1yz**               | **Positive Preliminary Reply**          | 初始响应表明命令已被接受并且处理仍在进行中。在发送新命令之前，用户应该期待另一个回复。 |
| **2yz**               | **Positive Completion Reply**           | 该命令已成功处理并完成。                                     |
| **3yz**               | **Positive Intermediate Reply**         | 该命令已被接受，但它的处理已被延迟，等待收到更多信息。这种类型的回复用于命令序列的中间。例如，它在收到 USER 命令之后但在发送匹配的 PASS 命令之前用作身份验证序列的一部分。 |
| **4yz**               | **Transient Negative Completion Reply** | 该命令未被接受且未采取任何操作，但该错误是暂时的，可以再次尝试该命令。这用于可能由于临时故障或可能发生变化的条件而导致的错误；例如，一个文件由于在请求它时另一个资源正在访问它而“忙”。 |
| **5yz**               | **Permanent Negative Completion Reply** | 命令未被接受且未采取任何操作。再次尝试相同的命令可能会导致另一个错误。例如，对服务器上找不到的文件的请求将属于此类，或者发送无效命令，如“BUGU”。杰 |

<u>**第二个回复代码数字（“y”）**</u>
第二个数字用于将消息分类到功能组中。 这些组显示在表 229 中。


​                                                            **表 229：FTP 回复代码格式：第二位数字解释**

| **Reply Code Format** | **Meaning**                       | **Description**                  |
| --------------------- | --------------------------------- | -------------------------------- |
| **x0z**               | **Syntax**                        | 语法错误或杂项消息。             |
| **x1z**               | **Information**                   | 回复信息请求，例如状态请求。     |
| **x2z**               | **Connections**                   | 与控制连接或数据连接相关的回复。 |
| **x3z**               | **Authentication and Accounting** | 与登录程序和会计相关的回复。     |
| **x4z**               | **Unspecified**                   | Not defined.                     |
| **x5z**               | **File System**                   | 与服务器文件系统相关的回复。     |



<u>**第三个回复代码数字（“z”）**</u>
最后一个回复代码数字表示第二个数字描述的每个功能组中的特定类型的消息。 第三位允许每个功能组针对第一位代码给出的每种回复类型（初步成功、暂时失败等）有 10 个不同的回复代码。

<u>**组合数字值以生成特定的回复代码**</u>

这些“x”、“y”和“z”数字的含义组合在一起，形成特定的回复代码。例如，考虑回复代码“530”，如图 292 所示。第一个数字告诉您这是一个永久的否定回复；第二个表示它与登录或计费有关。 （这实际上是登录失败时收到的错误消息。）

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\ftpreplycode.png)


​                                                                                     **图 292：FTP 回复代码格式**

此图显示了如何解释三位数的 FTP 回复代码格式。在此示例中，回复代码 530，“5”表示永久性错误，“3”表示错误与身份验证或计费有关，“0”是特定错误类型。类似的方法用于许多其他 TCP/IP 应用程序协议（包括 SMTP 和 HTTP）中的回复代码。


使用“编码”回复代码允许代码本身立即传达信息，并提供一种保持不同类型的回复有条理的方法。上述想法适用于其他几个应用程序协议，包括用于电子邮件的 SMTP、用于网络新闻的 NNTP 和用于万维网的 HTTP。

<u>**常见的 FTP 回复代码**</u>

表 230 包含一些取自 RFC 959 的更常见的 FTP 回复代码的列表。它们按数字顺序显示，以及该文档中作为典型给出的回复文本，以及我自己在需要时提供的其他描述信息：

​                                                                                       表 230：FTP 回复代码

| **Reply Code** | **Typical Reply Text**                                       | **Description**                                              |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **110**        | Restart marker reply.                                        | 在块模式下传输时用作标记重新启动功能的一部分。               |
| **120**        | Service ready in “nnn” minutes.                              | “nnn”表示距离服务可用的分钟数。                              |
| **125**        | Data connection already open; transfer starting.             |                                                              |
| **150**        | File status okay; about to open data connection.             |                                                              |
| **200**        | Command okay.                                                | 有时，文本会指示成功命令的名称。                             |
| **202**        | Command not implemented, or superfluous at this site.        |                                                              |
| **211**        | System status, or system help reply.                         | 将包含系统特定的状态或帮助信息。                             |
| **212**        | Directory status.                                            |                                                              |
| **213**        | File status.                                                 |                                                              |
| **214**        | Help message.                                                | 包括此服务器的人类用户使用的帮助信息。                       |
| **215**        | “NAME” system type.                                          | “NAME”是一种操作系统的名称。通常作为对 SYST 命令的回复发送。 |
| **220**        | Service ready for new user.                                  | 在发送 USER 命令之前建立命令通道时发送。                     |
| **221**        | Service closing control connection.                          | 会话关闭时发送的“再见”消息。                                 |
| **225**        | Data connection open; no transfer in progress.               |                                                              |
| **226**        | Closing data connection.                                     | 在文件传输成功或文件中止后发送。                             |
| **227**        | Entering Passive Mode (h1,h2,h3,h4,p1,p2).                   | 作为对 PASV 命令的回复发送，指示用于数据连接的 IP 地址和端口。 |
| **230**        | User logged in, proceed.                                     | USER 和 PASS 身份验证成功后发送。登录后，系统通常会在此代码中包含额外的“问候语”或其他信息。 |
| **250**        | Requested file action okay, completed.                       | 文本描述将提供有关成功完成的更多详细信息，例如确认目录更改或删除文件。 |
| **257**        | “PATHNAME” created.                                          | “PATHNAME”替换为创建的路径。                                 |
| **331**        | User name okay, need password.                               | 发送 USER 之后但发送 PASS 之前的中间结果。                   |
| **332**        | Need account for login.                                      |                                                              |
| **350**        | Requested file action pending further information.           |                                                              |
| **421**        | Service not available, closing control connection.           | 如果 FTP 服务器正在关闭，有时会发送。                        |
| **425**        | Can't open data connection.                                  |                                                              |
| **426**        | Connection closed; transfer aborted.                         |                                                              |
| **450**        | Requested file action not taken. File unavailable.           | 该文件不可用；例如，它可能被另一个用户锁定。与回复代码 550 对比。 |
| **451**        | Requested action aborted: local error in processing.         |                                                              |
| **452**        | Requested action not taken. Insufficient storage space in system. | 文件系统已满。                                               |
| **500**        | Syntax error, command unrecognized.                          | 发送了错误或过长的命令行。                                   |
| **501**        | Syntax error in parameters or arguments.                     |                                                              |
| **502**        | Command not implemented.                                     |                                                              |
| **503**        | Bad sequence of commands.                                    |                                                              |
| **504**        | Command not implemented for that parameter.                  |                                                              |
| **530**        | Not logged in.                                               | 如果由于错误的用户名或不正确的密码导致身份验证失败，则发送。 |
| **550**        | Requested action not taken. File unavailable.                | 找不到文件或用户无权访问它。如果用户尚未成功登录，则可能会发送此错误代码以回复任何文件传输命令。与回复代码 450 对比。 |
| **551**        | Requested action aborted: page type unknown.                 |                                                              |
| **552**        | Requested file action aborted. Exceeded storage allocation.  |                                                              |
| **553**        | Requested action not taken. File name not allowed.           |                                                              |

<u>**FTP 多行文本回复**</u>

回复可能包含多行文本。 在这种情况下，每一行都以回复代码开头，除最后一行之外的所有行在回复代码和回复文本之间都有一个连字符，以指示回复继续。 最后一行在回复代码和回复文本之间有一个空格，就像单行回复一样。 此工具通常用于在用户登录后通过 230 回复代码提供额外的响应信息。 表 231 包含一个示例。

​                                                                                    **表 231：FTP 多行文本回复示例**

```
230-Welcome user to FTP server jabberwockynocky.
230-
230-You are user #17 of 100 simultaneous users allowed.
230-
230-
230-Please see the file "faq.txt" for help using this server.
230-
230 Logged in.
```

如前所述，每个回复代码的实际文本字符串是特定于实现的。 有时您会发现一些与这些错误消息相关联的相当幽默的文本字符串。 例如，我在我的一个 Internet 帐户上使用 FreeBSD FTP 客户端尝试了一些命令。 如果您在登录前尝试发送或接收文件，它不会返回类似“请求的操作未执行。 文件不可用”。 它告诉我“先登录，然后我可能会让你这样做。”。 笑……这些计算机今天的态度是怎样的！ 



###### 4.2.2.1.3-3 FTP 用户界面和用户命令（部分：1 2 3）

FTP 协议命令集为实现文件传输协议提供了丰富、完整的指令集。人类用户可以使用这些命令直接与 FTP 服务器执行文件传输功能。但要做到这一点，需要用户对 FTP 的工作原理有深入的了解。用户必须确切地知道在什么时间以什么顺序发送哪些命令。

<u>**FTP 用户界面的优点**</u>
记住内部 FTP 命令对于网际网络专家来说可能是一项合理的任务，但对于典型的 TCP/IP 应用程序用户来说则不然。为此，FTP 协议定义了一个附加的协议组件作为 User-FTP Process 的一部分：FTP 用户界面。它为 FTP 用户提供了三个主要好处：

- 用户友好性：FTP 用户界面以一种比发出协议命令更容易使用的方式向人类用户展示 FTP。用户界面不需要了解所有这些四字母代码，而是允许使用更直观的人类语言命令来执行功能。例如，我们可以说“获取”一个文件而不用知道使用命令 RETR。

- 自定义：用于执行特定功能的命令可以根据网络行业的通用说法进行自定义，而不需要对 FTP 协议本身进行更改。例如，“图像”传输模式现在通常也称为“二进制”模式，因此创建了一个名为“二进制”的用户命令来设置此模式。

- 细节抽象和命令序列简化：单个用户命令可以发出多个 FTP 协议命令，隐藏内部 FTP 细节并使协议更易于使用。特别是，与维护连接和用户不想处理的其他“开销”问题相关的命令可以自动化。例如，FTP 客户端通常在每次数据传输之前发出 PASV 或 PORT 命令。当用户告诉 FTP 获取或发送文件时，用户界面可以在 RETR 或 STOR 命令之前自动发出此命令。

<u>**命令行和图形 FTP 界面**</u>

传统上，FTP 客户端使用命令行界面。在这种熟悉的安排中，将调用 FTP 客户端并自动要求用户输入用户名和密码以建立 FTP 会话。然后，用户会看到一个命令提示符，他们可以在其中键入各种 FTP 命令来执行不同的功能。来自服务器的文本响应显示给用户以指示各种命令的结果。通常，客户端发送的内部协议命令（如 PASV 和 STOR）被抑制以避免“屏幕混乱”，但可以在调试模式下启用。

命令行实用程序很高效，但有些人并不关心它们。在现代图形操作系统和应用程序的背景下，它们相当“老派”。因此，现在也有许多本质上是图形化的 FTP 客户端。通过单击按钮而不是键入命令，它们可以更快地执行操作。有些允许通过“拖放”将文件从本地文件系统显示传输到远程服务器上的文件。这些使 FTP 更易于使用。

**关键概念：**FTP 用户界面是 FTP 客户端上的组件，充当人类用户和 FTP 软件之间的中介。用户界面的存在允许以友好的方式使用 FTP，而无需了解 FTP 的内部协议命令。大多数 FTP 软件要么使用理解类似英语的用户命令的命令行界面，要么使用图形界面，在该界面中鼠标单击和其他图形操作被转换为 FTP 命令。

<u>**典型的 FTP 用户命令**</u>

要了解 FTP 客户端支持的特定命令，请查阅其文档。 在命令行客户端中，您可以输入命令“？” 获取支持的命令列表。 表 232 显示了典型 FTP 命令行客户端中遇到的一些常见命令，以及它们所需的典型参数。


​                                                                                      **表 232：FTP 用户命令**

| **User Command**                              | **Description**                                              |
| --------------------------------------------- | ------------------------------------------------------------ |
| ***account\* <account-name>**                 | Sends the *ACCT* command to access a particular account on the server. |
| ***append\* <file-name>**                     | Appends data to a file using *APPE*.                         |
| ***ascii\***                                  | Sets the *ASCII* data type for subsequent transfers.         |
| ***binary\***                                 | Sets the *Image* data type for subsequent transfers. Same as the *image* command. |
| ***bye\***                                    | Terminates FTP session and exits the FTP client (same as *exit* and *quit*). |
| ***cd\* <directory-path>**                    | Change remote server working directory (using *CWD* protocol command.) |
| ***cdup\***                                   | Go to parent of current working directory.                   |
| ***chmod\* <file-name>**                      | On UNIX systems, change file permissions of a file.          |
| ***close\***                                  | Closes a particular FTP session but user stays at FTP command line. |
| ***debug\***                                  | Sets debug mode.                                             |
| ***delete\* <file-name>**                     | Deletes a file on the FTP server.                            |
| ***dir\* [<optional-file-specification>]**    | Lists contents of current working directory (or files matching the specification). |
| ***exit\***                                   | Another synonym for *bye* and *quit*.                        |
| ***form\* <format>**                          | Set transfer format.                                         |
| ***ftp\* <ftp-server>**                       | Open session to FTP server.                                  |
| ***get\* <file-name> [<dest-file-name>]**     | Get a file. If the “<dest-file-name>” parameter is specified, it is used for the name of the file retrieved; otherwise, the source file name is used. |
| ***help\* [<optional-command-name>]**         | Displays FTP client help information. Same as “?”.           |
| ***image\***                                  | Set Image data type, like the *binary* command.              |
| ***ls\* [<optional-file-specification>]**     | Lists contents of current working directory (or files matching the specification). Same as *dir*. |
| ***mget\* <file-specification>**              | Gets multiple files from the server.                         |
| ***mkdir\* <directory-name>**                 | Create directory on remote server.                           |
| ***mode\* <transfer-mode>**                   | Set file transfer mode.                                      |
| ***mput\* <file-specification>**              | Sends (“puts”) multiple files to the server.                 |
| ***msend\* <file-specification>**             | Same as *mput*.                                              |
| ***open\* <ftp-server>**                      | Open session to FTP server (same as ftp).                    |
| ***passive\***                                | Turns passive transfer mode on and off.                      |
| ***put\* <file-name> [<dest-file-name>]**     | Sends a file to the server. If the “<dest-file-name>” parameter is specified, it is used as the name for the file on the destination host; otherwise, the source file name is used. |
| ***pwd\***                                    | Prints current working directory.                            |
| ***quit\***                                   | Terminates FTP session and exits FTP client (same as *bye* and *exit*.) |
| ***recv\* <file-name> [<dest-file-name>]**    | Receives file (same as *get*). If the “<dest-file-name>” parameter is specified, it is used for the name of the file retrieved; otherwise, the source file name is used. |
| ***rename\* <old-file-name> <new-file-name>** | Renames a file.                                              |
| ***rhelp\***                                  | Displays remote help information, obtained using FTP *HELP* command. |
| ***rmdir\* <directory-name>**                 | Removes a directory.                                         |
| ***send\* <file-name> [<dest-file-name>]**    | Sends a file (same as *put*). If the “<dest-file-name>” parameter is specified, it is used as the name for the file on the destination host; otherwise, the source file name is used. |
| ***site\***                                   | Sends a site-specific command to the server.                 |
| ***size\* <file-name>**                       | Show size of remote file.                                    |
| ***status\***                                 | Displays current session status.                             |
| ***struct\* <structure-type>**                | Sets file structure.                                         |
| ***system\***                                 | Shows the server's operating system type.                    |
| ***type\* <data-type>**                       | Sets data type for transfers.                                |
| ***user\* <user-name>**                       | Log in to server as a new user. Server will prompt for password. |
| **? [<optional-command-name>]**               | Displays FTP client help information. Same as *help*.        |

请注意这些命令中有多少实际上是同义词，例如 bye、exit 和 quit。 同样，可以使用命令“type ascii”来设置 ASCII 数据类型，或者只使用 ascii 命令。 这一切都是为了方便用户而完成的，并且是拥有与 FTP 协议命令集不同的灵活用户界面的好处之一。

最后，使用 FTP 的另一种方法是通过 FTP 统一资源定位器 (URL) 的规范。 虽然 FTP 的核心是一个交互式系统，但 FTP URL 允许快速轻松地完成简单的功能，例如检索单个文件。 它们还允许将 FTP 文件引用与超文本（万维网）文档集成在一起。 有关 FTP 如何使用 URL 的更多信息，请参阅 URL 方案的讨论。



###### 4.2.2.1.4 FTP 示例用户和内部命令对话框

前两节描述了FTP 的工作原理，并展示了用于实现FTP 用户和FTP 服务器之间通信的命令和应答代码。现在已经了解了 FTP 如何工作的所有细节，让我们通过查看 FTP 客户端和服务器之间的示例 FTP 会话将所有内容联系在一起，以查看 FTP 命令和“实际操作”的回复。

在此示例中，我将从客户端调用 FTP 以从 FTP 服务器检索文本文件，然后从服务器和包含该文件的目录中删除该文件。在此过程中，我将发出一些额外的命令来说明更多 FTP 的工作原理。我将在 FTP 客户端中启用“调试”模式，以便对于每个用户命令，我们都可以看到生成的实际 FTP 协议命令。

表 233 显示了示例 FTP 对话框，略有简化。第一列包含用户（也就是我）在 FTP 客户端上输入的命令。第二个以突出显示的文本显示发送到 FTP 服务器的实际协议命令，并以纯文本显示从服务器返回到客户端的回复。第三个包含描述性评论。


​                                                                                  **表 233：示例 FTP 会话**

| **User Command**       | **FTP Protocol Command / FTP Server Reply**                  | **Comments**                                                 |
| ---------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **ftp -d pcguide.com** | `Connected to pcguide.com.<br/>220 ftp199.pair.com NcFTPd Server (licensed copy) ready.<br/>Name (pcguide.com:ixl):` | 这是启动 FTP 的命令。 “-d”启用调试模式。在此初始步骤中，建立了 TCP 控制连接，服务器回复 220 回复代码，表明它已准备好进行用户识别。 FTP 客户端会自动提示输入用户名。 |
| **ixl**                | **USER ixl  **331 User ixl okay, need password.              | 我通常使用“ixl”作为用户名。在这里，FTP 客户端发送用户名，服务器响应请求密码。 |
| ***\**\***             | **PASS XXXX  **230-You are user #1 of 300 simultaneous users allowed. 230- 230- 230-Welcome to (<system name>) 230- 230 Logged in.  **SYST  **215 UNIX Type: L8 Remote system type is UNIX. Using binary mode to transfer files. | 我输入我的密码，它被发送到 FTP 服务器，然后发生了一堆事情。 J 服务器对我进行身份验证并发回 230 消息。这告诉我登录成功。它还为我提供了额外的信息。 然后 FTP 客户端自动发送一个 SYST 命令来告诉我服务器使用的是什么类型的系统，在本例中是 UNIX。客户端还告诉我默认选择了二进制模式；这通常是从 UNIX 到 UNIX 进行 FTP 时的默认设置（就像我在这里所做的那样），因为在类似系统之间移动文本文件时不需要 ASCII 模式。 |
| **pwd**                | **PWD  **257 “/usr/home/ixl” is cwd.                         | 我检查了当前工作目录（“cwd”），服务器告诉我这是我自己在这个系统上的主目录。 |
| **cd ftptest**         | **CWD ftptest  **550 No such directory.                      | 我尝试转到一个名为“ftptest”的目录，但那是错误的名称，因此我遇到了一个 550 错误。 （我并没有尝试这样做，我忘记了目录名称，但我想我还是把它展示给你看吧！J） |
| **cd ftpdemo**         | **CWD ftpdemo  **250 “/usr/home/ixl/ftpdemo” is new cwd.     | 这次我得到了正确的名称，服务器确认了新的工作目录。           |
| **dir**                | **PASV  **227 Entering Passive Mode (ip1,ip2,ip3,ip4,193,224)  **LIST **150 Data connection accepted from ip5.ip6.ip7.ip8:4279; transfer starting. -rw-r—r— 1 ixl users 16 May 22 17:47 testfile.txt 226 Listing completed. | 我从服务器请求文件列表。 FTP 客户端自动发出一个 PASV 命令，服务器响应一个端口号和 IP 地址供其使用（出于安全原因，我没有在此处显示 IP。）然后目录列表从服务器传输到客户端。 |
| **asc**                | **TYPE A  **200 Type okay.                                   | 我设置了 ASCII 模式。正如我上面所说，真的不需要，但管他呢。请注意，此客户端允许我将 ascii 命令缩写为“asc”。 |
| **get testfile.txt**   | **PASV  **227 Entering Passive Mode (ip1,ip2,ip3,ip4,193,226)  **RETR testfile.txt  **150 Data connection accepted from ip5.ip6.ip7.ip8:4283; transfer starting for testfile.txt (16 bytes).  226 Transfer completed. 17 bytes received in 0.10 seconds (0.17 KB/s) | 我使用 get 命令获取此演示目录中的文件。服务器接受 PASV 命令并发送文件。它最初在传输开始时发送 150 回复（初始肯定回复），然后在传输完成时发送 226。请注意，此处使用的端口号（对于服务器和客户端）与我之前使用的目录列表不同。 |
| **del testfile.txt**   | **DELE testfile.txt  **250 Deleted.                          | 我删除了服务器上的原始文件。                                 |
| **cdup**               | **CDUP  **250 "/usr/home/ixl" is new cwd.                    | 我转到父目录。                                               |
| **rmdir ftpdemo**      | **RMD ftpdemo  **250 Directory removed.                      | 我删除了文件所在的目录。                                     |
| **quit**               | **QUIT  **221 Goodbye.                                       | 我结束 FTP 会话。 quit 命令还会自动关闭 FTP 客户端并将我返回到 UNIX shell。 |



##### 4.2.2.2 普通文件传输协议 (TFTP)

文件传输协议 (FTP) 实现了一套完整的命令和回复功能，使用户能够在两台 TCP/IP 机器之间执行范围广泛的文件移动和操作任务。它是计算机之间文件传输的通用协议的理想选择，但在某些类型的硬件上，它过于复杂而不易实现，并且提供的功能比实际需要的要多。在仅需要最基本的文件传输功能并且简单性和小程序大小至关重要的情况下，创建了 FTP 的配套协议，称为普通文件传输协议 (TFTP)。

在本节中，我提供了对 TFTP 操作的描述。我首先概述协议的描述、它的历史和动机，以及描述它的相关标准。我一般性地讨论了它的操作以及 TFTP 客户端和服务器如何通信，并详细解释了 TFTP 消息传递。然后我将讨论 TFTP 选项和 TFTP 选项协商机制，最后展示各种 TFTP 消息格式。

**背景信息：**虽然 TFTP 是与 FTP 不同的协议，但当读者熟悉后者时，解释前者会更容易。我假设读者对 FTP 有一定的了解，因为它是更常用的协议。如果您在阅读有关 FTP 的部分之前已阅读本部分，我建议您在继续之前至少阅读 FTP 概述主题。



###### 4.2.2.2-1 TFTP 概述、历史和标准（部分：1 2 3） 

文件传输协议 (FTP) 是用于 TCP/IP 互联网络中大多数常规文件传输的主要协议。 FTP 设计者的目标之一是保持协议相对简单，但这实际上只能在有限的范围内实现。为了使该协议能够在各种情况下以及在多种设备之间发挥作用，FTP 需要相当大的特性和功能集。因此，虽然 FTP 不像某些其他协议那样复杂，但它在许多方面仍然相当复杂。

<u>**TFTP 的必要性**</u>
FTP 的复杂性部分是由于协议本身及其数十个命令和回复代码，部分是由于需要使用传输控制协议 (TCP) 进行连接和数据传输。对 TCP 的依赖意味着任何想要使用 FTP 的设备不仅需要 FTP 程序，还需要完整的 TCP 实现。它必须处理 FTP 对同步数据和控制通道连接的需要以及其他要求。

对于传统计算机，如普通 PC、Macintosh 或 UNIX 工作站，这些都不是真正的问题，尤其是在当今的大硬盘和快速廉价内存的情况下。但请记住，FTP 是在三十多年前开发的，当时硬件速度很慢，内存也很昂贵。此外，即使在今天，普通计算机也不是网络上使用的唯一设备。有些联网设备不具备“真正”计算机的功能，但仍需要能够进行文件传输。对于这些设备，完整的 FTP 和 TCP 实现是一件非常重要的事情。

存在此问题的最著名的设备示例之一是无盘工作站。这些计算机没有永久存储，因此当它们启动时，它们无法像大多数计算机那样轻松地从硬盘读取整个 TCP/IP 实现。他们从只有少量内置软件开始，必须从服务器获取配置信息，然后从另一个网络设备下载其余软件。某些其他没有硬盘的硬件设备也会出现同样的问题。

启动这些设备的过程通常称为引导，分两个阶段进行。首先，通过使用主机配置协议（例如 BOOTP 或 DHCP）为工作站提供 IP 地址和其他参数。其次，客户端下载操作系统和驱动程序等软件，使其像任何其他设备一样在网络上运行。这需要能够快速轻松地传输文件。执行此引导的指令必须适合只读存储器 (ROM) 芯片，这使得软件的大小成为一个重要问题——再次强调，尤其是在许多年前。

解决这一需求的方法是创建一个“轻型”版本的 FTP，该版本将强调小程序大小和简单性而不是功能。这个称为简单文件传输协议 (TFTP) 的新协议最初于 70 年代后期开发，并于 1980 年首次标准化。现代版本称为 TFTP 版本 2，于 1981 年记录在 RFC 783 中，并经过修订和发布如 RFC 1350，TFTP 协议（修订版 2），1992 年。这是该标准的当前版本。

<u>**比较 FTP 和 TFTP**</u>

理解 TFTP 和 FTP 之间关系的最好方法可能是将其与传输层的 TCP 和 UDP 之间的关系进行比较。 UDP 是 TCP 的简化、“精简”替代方案，在简单性比丰富功能更重要的情况下使用。类似地，TFTP 是 FTP 的一个大大简化的版本，它只允许基本操作并且缺少 FTP 的一些奇特功能，以保持其实现简单（甚至“微不足道”！）和程序大小小。

FTP 和 TFTP 之间一些更重要的特定差异：

- 传输：与 TCP 和 UDP 的比较是恰当的，不仅基于功能/简单性权衡，而且因为 FTP 使用 TCP 进行传输，而 TFTP 使用 UDP。与 TFTP 一样，UDP 也很简单，这使得两者非常适合作为网络设备中的硬件程序集一起嵌入。

- 有限的命令集：FTP 包括一组丰富的命令，允许发送、接收、重命名、删除等文件。 TFTP 只允许发送和接收文件。

- 有限的数据表示：TFTP 不包括一些 FTP 的奇特数据表示选项；它只允许简单的 ASCII 或二进制文件传输。

- 缺少身份验证：UDP 不使用登录机制或其他身份验证方式。这又是一种简化，尽管这意味着 TFTP 服务器的运营商必须严格限制他们提供的可供访问的文件。 （这也是 TFTP 明确不允许客户端执行删除等“危险”文件操作的部分原因。）

由于其局限性，TFTP 是对常规文件传输协议的补充，而不是替代。只有当它的简单性很重要而不是缺少功能时才使用它。如上所述，它最常见的应用是自举，但它也可以用于其他目的。 TFTP 标准为该协议描述的一种特定应用是电子邮件的传输。虽然该协议明确支持这一点，但目前 TFTP 并不普遍用于此目的。

<u>**TFTP 操作概述**</u>

TFTP 中的通信和消息传递与 FTP 中的非常不同，因为它们使用的传输层协议不同。 FTP 利用 TCP 的丰富功能，包括它的流数据方向，允许它直接通过 FTP 数据连接发送字节数据。 TCP 还负责为 FTP 可靠地传送数据，确保正确接收文件。相反，由于 TFTP 使用 UDP，它必须将数据打包成单独的消息以用于协议控制和数据通信。 TFTP 还必须负责定时传输以检测丢失的数据报，然后根据需要重新传输。

TFTP 服务器允许来自 TFTP 客户端的连接执行文件发送和接收操作。许多运行 FTP 服务器的主机也将运行一个单独的 TFTP 服务器模块。 TFTP 用户通过启动TFTP 客户端程序来发起连接，该程序通常使用类似于许多FTP 客户端的命令行界面；主要区别在于 TFTP 中的命令数量要少得多。

**关键概念：**对于完整文件传输协议 (FTP) 不必要或不切实际的情况，开发了更简单的普通文件传输协议 (TFTP)。 TFTP 类似于 FTP，因为它用于客户端和服务器设备之间的一般文件传输，但它的功能被剥离了。 TFTP 不像 FTP 那样包含完整的命令集并使用 TCP 进行通信，它只能用于读取或写入单个文件，并使用快速但不可靠的 UDP 进行传输。在必须快速简单地传输小文件的情况下，例如引导无盘工作站，它通常是首选。

**TFTP 选项扩展和 TFTP 选项**
自 RFC 1350 发布以来，TFTP 的基本操作没有改变，但在 1995 年向该协议添加了一个新功能。RFC 1782，TFTP 选项扩展，定义了一种机制，TFTP 客户端和 TFTP 服务器可以通过该机制协商某些参数，这些参数将在传输开始之前控制文件传输。这使得 TFTP 的使用方式更加灵活，稍微增加了 TFTP 的复杂性，但不是很大。

选项扩展与常规 TFTP 向后兼容，并且仅在服务器和客户端都支持时才使用。两个后续的 RFC 定义了可以协商的实际选项：RFC 1783，TFTP 块大小选项和 RFC 1784，TFTP 超时间隔和传输大小选项。这组三个 RFC（1782、1783 和 1784）在 1998 年被 RFC 2347、2348 和 2349 中的更新版本所取代。



###### 4.2.2.2-2 TFTP 一般操作、连接建立和客户端/服务器通信（部分：1 2 3）

由于“TFTP”中的“T”代表“trivial”，并且该协议专门设计为简单，您会认为描述它的工作原理实际上很简单，不是吗？好吧，实际上，它几乎是。对不起，我忍不住把你安排在那里。

如概述中所述，TFTP 通信是基于客户端/服务器的。传输文件的过程包括三个主要阶段。用高度概括的术语来说，这些是：

1. 初始连接：TFTP 客户端通过向服务器发送初始请求来建立连接。服务器响应客户端并有效打开连接。

2. 数据传输：建立连接后，客户端和服务器交换 TFTP 消息。一个设备发送数据，另一个发送确认。

3. 连接终止：当包含数据的最后一个 TFTP 消息已发送并得到确认时，连接将终止。

<u>**连接建立和识别**</u>
TFTP 中的“连接”概念与使用 TCP 的 FTP 等协议有所不同。 FTP 必须先在 TCP 级别建立连接，然后才能由 FTP 本身完成任何操作。但是，TFTP 使用无连接的 UDP 进行传输，因此在 TCP 中不存在连接。在 TFTP 中，连接更多是在“逻辑意义上”，意味着客户端和服务器参与协议并交换 TFTP 消息。

TFTP 服务器持续侦听众所周知的 UDP 端口号 69 上的请求，该端口号为 TFTP 保留。客户端为其初始通信选择一个临时端口号，这在 TCP/IP 中通常是这种情况。该端口号实际上标识了数据传输，称为传输标识符 (TID)。

然而，TFTP 的不同之处在于，服务器还会选择一个伪随机 TID，用于将响应发送回客户端；它不会从端口号 69 发送它们。这样做的原因是通过使用唯一的客户端端口号和源端口号，服务器可以同时进行多个 TFTP 交换。每个传输都由源端口号和目标端口号自动标识，因此无需在数据消息中标识每个块数据所属的传输。这使 TFTP 标头大小减小，允许每个 UDP 消息中包含更多实际数据。

例如，假设 TFTP 客户端为其初始消息选择了 3,145 的 TID。它将从其端口 3,145 向服务器的端口 69 发送 UDP 传输。假设服务器选择了 1,114 的 TID。它将从其端口 1,114 将其回复发送到客户端的端口 3,145。从那时起，客户端将消息发送回服务器端口 1,114，直到 TFTP 会话完成。

<u>**锁步”客户端/服务器消息传递**</u>

初始交换后，客户端和服务器以“锁步”方式交换数据和确认消息。每个设备针对它收到的每条消息发送一条消息：一个设备发送数据消息并等待确认，另一个发送确认并等待数据消息。这种形式的严格通信比允许发送器“发射”一个接一个数据消息的效率低，但它很重要，因为它在涉及一个重要问题时保持 TFTP 简单：重传。

与所有使用不可靠 UDP 的协议一样，TFTP 无法保证发送的任何消息实际上都会到达目的地，因此它必须使用计时器来检测丢失的传输并重新发送它们。 TFTP 的不同之处在于客户端和服务器都执行重传。正在发送数据消息的设备如果在合理的时间内没有收到确认，将重新发送数据消息；发送确认的设备如果没有及时收到下一条数据消息，将重新发送确认。上面讨论的“锁步”通信大大简化了这个过程，因为每个设备一次只需要跟踪一个“未完成”的消息。它还消除了处理复杂情况的需要，例如重组乱序接收的块（FTP 等协议依赖 TCP 来管理。）

**关键概念：**由于 TFTP 使用 UDP 而不是 TCP，因此没有像 FTP 中那样明确的连接概念。 TFTP 会话改为使用“逻辑连接”的概念，当客户端向服务器发送读取或写入文件的请求时打开该连接。客户端和服务器之间的通信以“锁步”方式执行：一个设备发送数据消息并接收确认，因此它知道数据消息已收到；另一个发送确认并接收数据消息，因此它知道已收到确认。

<u>**TFTP 的简化消息传递机制的困难**</u>

这种技术最重要的缺点之一是，虽然它简化了通信，但它是以牺牲性能为代价的。由于一次只能传输一条消息，因此这将吞吐量限制为最大 512 字节，用于客户端和服务器之间的消息交换。相比之下，当使用 FTP 时，可以流水线传输大量数据；在发送第二个数据之前无需等待对第一个数据的确认。

另一个复杂情况是，如果重新发送数据或确认消息并且原始消息没有丢失而只是延迟了，则会出现两个副本。原始的 TFTP 协议规则规定，在收到重复数据报后，接收它的设备可能会再次重新发送当前数据报。因此，执行读取操作的客户端接收到重复的块 #2 将导致客户端发送对块 #2 的重复确认。这意味着服务器收到了两个确认，这将依次发送块 #3 两次。然后将有两个块 #3 的确认，依此类推。

这样做的最终结果是，一旦发生初始复制，此后的每条消息都会发送两次。这被亲切地称为 Sorcerer's Apprentice Bug，因为这个故事被用作迪士尼幻想曲中著名场景的基础，在该场景中，米老鼠将动画扫帚切成两半，然后发现每一半都活了过来。通过更改规则修复了此问题，以便只有接收重复数据消息的设备可以发送重复确认。收到重复的确认不会导致发送重复的数据消息。由于两个设备中只有一个可以发送重复项，因此这解决了问题。

还值得强调的是，TFTP 绝对不包含安全性，因此没有登录或身份验证过程。如概述中所述，管理员在决定通过 TFTP 提供哪些文件以及允许对 TFTP 服务器进行写访问时必须谨慎。



###### 4.2.2.2-3 TFTP 详细操作和消息传递（部分：1 2 3）

TFTP 操作包括三个一般步骤：初始连接、数据传输和连接终止。所有操作都是通过特定 TFTP 消息的交换来执行的。现在让我们更详细地了解这三个操作阶段以及 TFTP 消息传递功能的细节。

<u>**初始消息交换**</u>
客户端发送的启动 TFTP 的第一条消息是读取请求 (RRQ) 消息或写入请求 (WRQ) 消息。此消息用于隐式建立逻辑 TFTP 连接，并指示文件是从服务器发送到客户端（读取请求）还是客户端发送到服务器（写入请求）。该消息还指定要执行的文件传输类型。 TFTP 支持两种传输模式：netascii 模式（Telnet 协议使用的 ASCII 文本文件）和八位字节模式（二进制文件）。

**注意：**最初有第三种文件类型选项——邮件模式——但 TFTP 从来就不是真正为传输邮件而设计的，这个选项现在已经过时了。


假设请求没有问题（例如服务器问题，无法找到文件等），服务器将以肯定的答复进行响应。在读取请求的情况下，服务器会立即将第一条数据消息发送回客户端。在写入请求的情况下，服务器将向客户端发送确认消息，告诉它可以继续发送第一条数据消息。

初始交换后，客户端和服务器以“锁步”方式交换数据和确认消息，如上一主题所述。对于读取，服务器发送一个数据消息并等待客户端的确认，然后再发送下一个。对于写操作，客户端发送一条数据消息，服务器在客户端发送下一条数据消息之前为其发送确认。

如果在连接建立或传输过程的任何阶段出现问题，设备可能会根据情况使用错误消息而不是数据或确认消息进行回复。错误消息通常会导致数据传输失败；这是为 TFTP 的简单性付出的代价之一。

每个 TFTP 文件传输都使用下述过程之一进行，该过程读取或写入单个文件。如果需要发送或接收另一个文件，则建立新的逻辑通信，其方式类似于 FTP 创建数据连接的方式。主要区别在于 TFTP 没有像 FTP 那样的持续控制连接。

<u>**数据块编号**</u>
每个数据消息包含一个 0 到 512 字节的数据块。这些块按顺序编号，从 1 开始。每个块的编号放在携带该块的数据消息的标头中，然后用于该块的确认中，以便原始发送者知道它已收到。发送数据的设备将始终一次发送 512 字节的数据，只要它有足够的数据来填充消息。当它到达文件末尾并且要发送的字节数少于 512 时，它将只发送剩余的字节数。有趣的是，这意味着如果文件大小正好是 512 的倍数，最后发送的消息将有零字节数据！

收到包含 0 到 511 字节数据的数据消息表明这是最后一条数据消息。一旦确认，这将自动发出数据传输结束的信号。没有必要明确终止“连接”，就像没有必要明确建立它一样。

<u>**TFTP 读取过程步骤**</u>

让我们使用一个示例来了解 TFTP 消息传递的工作原理。假设客户端想要读取一个 1,200 字节长的特定文件。以下是简化形式的步骤（也显示在图 293 中）：

1. 客户端向服务器发送读取请求，指定文件名。

2. 服务器发回包含块#1 的数据消息，携带 512 字节的数据。

3. 客户端接收数据，并发回对块#1 的确认。

4. 服务器发送包含 512 字节数据的块#2。

5. 客户端收到块#2，并发回确认。

6. 服务器发送块 #3，包含 176 字节的数据。它在终止逻辑连接之前等待确认。

7. 客户端接收数据，发送块#3 的确认。由于此数据消息少于 512 字节，因此它知道文件是完整的。

8. 服务器收到确认，并知道文件已成功接收。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\tftpread.png)

​                                                                                        **图 293：TFTP 读取过程**

在此示例中，客户端通过向服务器发送文件请求来启动读取文件的过程。服务器通过立即发送携带块#1 的数据消息来确认此请求，该块包含文件的前 512 个字节。客户端通过块#1 的 ACK 消息确认这一点。服务器然后发送块#2，包含字节 513 到 1,024，客户端确认。当客户端收到块 #3 时，它意识到它只有 176 字节，这将它标记为文件的最后一个块。

<u>**TFTP 写入过程步骤**</u>

以下是同一过程中的步骤，但客户端正在写入文件（参见图 294）：

1. 客户端向服务器发送写请求，指定文件名。

2. 服务器发回确认。由于此确认先于任何数据的接收，因此它在确认中使用块号零。

3. 客户端发送包含块#1、512 字节数据的数据消息。

4. 服务器接收数据，发回块#1 的确认。

5. 客户端发送块 #2，512 字节的数据。

6. 服务器接收数据，发回块#2 的确认。

7. 客户端发送块 #3，包含 176 字节的数据。它在终止逻辑连接之前等待确认。

8. 服务器接收块 #3 并为其发送确认。由于此数据消息少于 512 字节，因此传输已完成。

9. 客户端收到块#3 的确认并知道文件写入已成功完成。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\tftpwrite.png)

​                                                                                       **图 294：TFTP 写入过程**

此示例显示客户端将相同的 1,200 字节文件发送到它在图 293 中读取的服务器。客户端向服务器发送写入请求，服务器确认；它使用块 #0 来表示在收到任何数据之前对请求的确认。然后客户端一次发送一个数据块，每个数据块都由服务器确认。当服务器接收到包含少于 512 字节数据的块 #3 时，它知道它已经接收到整个文件。

**关键概念：**TFTP 读取操作始于客户端向 TFTP 服务器发送读取请求消息；服务器然后以 512 字节的数据消息发送文件，在每个消息之后等待客户端确认收到，然后再发送下一个。 TFTP 写操作从客户端发送到服务器的写请求开始，服务器确认该请求。然后客户端以 512 字节的数据块发送文件，等待服务器确认接收。在这两种情况下，都没有明确的方式来标记传输结束；接收文件的设备在收到包含少于 512 字节的数据消息时就知道传输已完成。



###### 4.2.2.2-4 TFTP 选项和选项协商（部分：1 2 3 4）

简单协议和应用程序的设计者似乎遇到的困难之一就是保持简单。许多协议开始时都很小，但随着时间的推移，善意的用户会建议缓慢但肯定会添加的改进。最终，这个曾经“精简”的程序变成了，好吧，我们应该说，“大理石花纹好”。 J 在软件行业，这被称为“功能蠕变”，许多协议和应用程序都发生过这种情况。

当程序或协议的起点很少时，添加功能的诱惑尤其强烈。鉴于此，TFTP 协议的维护者多年来在避免这个陷阱方面做得很好。然而，他们确实允许在 1995 年向协议添加一项新功能：TFTP 选项扩展，它描述了 TFTP 客户端和服务器如何在传输文件之前协商选项。

添加此功能的原因是原始 TFTP 协议根本无法让客户端和服务器在发送文件之前交换重要的控制信息。这限制了协议处理特殊情况的灵活性，例如通过不寻常的网络类型传输数据。 TFTP 选项协商功能允许在客户端和管理数据传输方式的服务器之间交换其他参数。它在没有显着使协议复杂化的情况下执行此操作，并且与普通 TFTP 向后兼容。它仅在客户端和服务器都支持时才使用，如果一台设备尝试使用该功能，而另一台设备不支持，则不会出现问题。

<u>**TFTP 选项协商过程**</u>

客户端通过发送修改后的 TFTP 读取请求或写入请求消息开始协商。除了此消息中出现的常规信息（请参阅下一主题）之外，还可能包含一个选项列表。每个都指定了一个选项代码和一个选项值。名称和值表示为 ASCII 字符串，以空字符（零字节）结尾。请求消息中可以指定多个选项。

服务器接收包含选项的请求，如果它支持选项扩展，则处理它们。然后它向客户端返回一条特殊的选项确认 (OACK) 消息，其中列出了客户端指定的服务器识别和接受的所有选项。客户端请求但服务器拒绝的任何选项，不包括在此选项确认中。客户端只能使用服务器接受的选项。如果客户端拒绝服务器的响应，它可能会在收到不可接受的 OACK 消息后发回错误消息（错误代码为 8）。

服务器可以在其对某些选项的响应中指定一个替代值，如果它识别该选项但不喜欢客户端的建议值。显然，如果服务器根本不支持选项，它将忽略客户端的选项请求，并像普通 TFTP 一样以数据消息（对于读取）或常规确认（对于写入）进行响应。

如果服务器确实发送了 OACK，则客户端将继续使用上一节中描述的常规消息交换来发送消息。在写入的情况下，选项确认会替换消息对话框中的常规确认。在读取的情况下，选项确认是服务器的第一条消息，而不是它通常发送的第一个数据块。 TFTP 不允许同一设备连续发送两个数据报，因此在发送第一个数据块之前需要有来自客户端的回复。客户端通过发送块号为 0 的常规确认来执行此操作——与服务器通常为写入发送的确认形式相同。

**关键概念**：TFTP 应该是一个小而简单的协议，因此它包含很少的“额外”功能。它确实支持选项协商，其中 TFTP 客户端和服务器尝试就它们将在传输文件时使用的其他参数达成一致。 TFTP 客户端在其 Read Request 或 Write Request 消息中包含一个或多个选项；然后 TFTP 服务器发送选项确认 (OACK) 消息，列出服务器同意使用的每个选项。读取文件时使用选项意味着在服务器发送文件的第一个块之前，客户端必须发送额外的确认——以确认 OACK。


呸，这令人困惑。为了便于回顾，让我们看一下四种可能的情况（读和写，有和没有选项）中的每一个。

<u>**有和没有选项协商的 TFTP 读取过程**</u>

正常读取（无选项协商）的初始消息交换，如图 293 所示：

1. 客户端发送读取请求。

2. 服务器发送数据块#1。

3. 客户端确认数据块 #1。

等等…
现在，阅读选项协商（图 295）：

1. 客户端发送带有选项的读取请求。

2. 服务器发送选项确认。

3. 客户端发送“block #0”的定期确认，即它确认 OACK。

4. 服务器发送数据块#1。

5. 客户端确认数据块 #1。

ETC…

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\tftpreadoptions.png)

​                                                                           **图 295：带有选项协商的 TFTP 读取过程**

此图显示了图 293 中所示的相同示例，但添加了一个用于选项协商的消息交换（紫色背景）。此处客户端的初始读取请求包括它希望用于此传输的选项。服务器不会立即响应第一个数据块，而是响应一个 Option Acknowledgement。客户端通过使用块 #0 发送确认来指示收到 OACK。服务器发送数据块#1，其余交换正常进行。

<u>**有和没有选项协商的 TFTP 写入过程**</u>

正常写入的初始消息交换（无选项协商）：

1. 客户端发送写请求。

2. 服务器发送确认。

3. 客户端发送数据块#1。

4. 服务器确认数据块#1。
   ……

并写一个选项协商：

1. 客户端发送带有选项的写请求。

2. 服务器发送选项确认（而不是常规确认）。

3. 客户端发送数据块#1。

4. 服务器确认数据块#1。
   ……

<u>**TFTP 选项**</u>
表 234 包含当前定义的三个 TFTP 选项的摘要。


​                                                                                **表 234：TFTP 选项**

| **TFTP Option Name**    | **TFTP Option Code (Used in \*Request\* Messages)** | **Defining RFC** | **Description**                                              |
| ----------------------- | --------------------------------------------------- | ---------------- | ------------------------------------------------------------ |
| ***Block Size\***       | *blksize*                                           | 2348             | 允许客户端和服务器发送大小不同于 512 字节的数据块，以提高效率或解决特定类型网络的限制。 |
| ***Timeout Interval\*** | *interval*                                          | 2349             | 允许客户端和服务器商定指定的秒数以用于其重传计时器。同样，在具有高延迟或其他特殊要求的某些网络上可能有价值。 |
| ***Transfer Size\***    | *tsize*                                             | 2349             | 让发送文件的设备（写入客户端，读取服务器）在传输开始之前告诉其他设备文件的大小。这允许接收设备提前为其分配空间。 |



###### 4.2.2.2-5 TFTP 消息格式（部分：1 2 3 4 5）

与 FTP 不同，TFTP 中的所有通信都是以遵循特定消息格式的离散消息的形式完成的。 TFTP 和 FTP 在这方面如此不同的原因是它们使用的传输协议不同。 FTP 使用 TCP，它允许一次传输一个字节的数据； FTP 还为命令使用专用通道。 TFTP 在 UDP 上运行，UDP 使用传统的“报头/数据”格式化方案。

最初的 TFTP 标准定义了五种不同类型的消息：读取请求 (RRQ)、写入请求 (WRQ)、数据 (DATA)、确认 (ACK) 和错误 (ERROR)。 TFTP 选项扩展功能定义了第六条消息：选项确认 (OACK)。在这六个消息中，前两个共享相同的消息格式。其他的都有自己独特的格式。每个 TFTP 消息中唯一的公共字段是操作代码 (Opcode)，它告诉消息的接收者它是什么类型。

TFTP 的消息格式与用于某些其他协议的消息格式不同，因为许多字段的长度是可变的。通常，消息中的可变长度字段使用前面的长度字段来表示，该长度字段指定可变大小字段的长度。相反，TFTP 使用 netascii（ASCII 的 Telnet 版本）发送 ASCII 字符串等字段。字符串的结尾用零字节标记。例外情况是数据消息中的数据字段，其内容取决于传输模式。

您将在下面找到每种 TFTP 消息类型的详细信息。

<u>**读取请求和写入请求消息**</u>

这些消息使用一种通用的消息格式，如表 235 中所述，并在图 296 中以图形方式显示。


​                                                             **表 235：TFTP 读请求/写请求消息格式**

| **Field Name**  | **Size (bytes)** | **Description**                                              |
| --------------- | ---------------- | ------------------------------------------------------------ |
| ***Opcode\***   | 2                | ***Operation Code:\*** 操作代码：指定 TFTP 消息类型。值 1 表示读取请求消息，而值 2 表示写入请求消息。 |
| ***Filename\*** | Variable         | ***Filename:\*** 文件名：要读取或写入的文件的名称。          |
| ***Mode\***     | Variable         | ***Transfer Mode:\*** 传输模式：字符串“netascii”或“octet”，以零结尾。 （为什么不只使用一个字节设置为 0 用于 netascii 和 1 用于八位字节？别问我！J） |
| ***Options\***  | Variable         | ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\aa36652b.png) |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\tftpreadwrite.png)

​                                                                    **图 296：TFTP 读请求/写请求消息格式**

<u>**数据信息**</u>

使用表 236 和图 297 中所示的简化格式发送数据块。

​                                                                          **表 236：TFTP 数据消息格式**

| **Field Name** | **Size (bytes)** | **Description**                                              |
| -------------- | ---------------- | ------------------------------------------------------------ |
| ***Opcode\***  | 2                | ***Operation Code:\*** Specifies the TFTP message type. A value of 3 indicates a *Data* message. |
| ***Block #\*** | 2                | ***Block Number:\*** The number of the data block being sent. |
| ***Data\***    | Variable         | ***Data:\*** 0 to 512 bytes of data.                         |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\tftpdata.png)

​                                                                                  **图 297：TFTP 数据报文格式**



<u>**确认消息**</u>
确认具有所有 TFTP 消息中最简单的格式，如表 237 和图 298 所示。


​                                                                                 **表 237：TFTP 确认消息格式**

| **Field Name** | **Size (bytes)** | **Description**                                              |
| -------------- | ---------------- | ------------------------------------------------------------ |
| ***Opcode\***  | 2                | ***Operation Code:\*** 操作代码：指定 TFTP 消息类型。值为 4 表示确认消息。 |
| ***Block #\*** | 2                | ***Block Number:\*** Block Number：被确认的数据块的编号；值 0 用于确认收到不带选项的写请求，或确认收到选项确认。 |

​                             ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\tftpack.png)

​                                                                                       **图 298：TFTP 确认消息格式**

<u>**错误信息**</u>

在通信中检测到问题的情况下，客户端或服务器可以发送错误消息。 它们的格式如表 238 和图 299 所示。


​                                                                                 **表 238：TFTP 错误消息格式**

| **Field Name**    | **Size (bytes)** | **Description**                                              |
| ----------------- | ---------------- | ------------------------------------------------------------ |
| ***Opcode\***     | 2                | ***Operation Code:\*** 操作代码：指定 TFTP 消息类型。值 5 表示一条错误消息。 |
| ***Error Code\*** | 2                | ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\aa366624.png) |
| ***Error Msg\***  | Variable         | ***Error Message:\*** 错误消息：描述性文本错误消息字符串，正如标准所说，用于“人类消费”。 |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\tftperror.png)

​                                                                               **图 299：TFTP 错误消息格式**

<u>**选项确认消息**</u>

OACK 消息用于确认收到 TFTP 选项。 它们的结构如表 239 和图 300 所示。


​                                                                         **表 239：TFTP 选项确认消息格式**

| **Field Name** | **Size (bytes)** | **Description**                                              |
| -------------- | ---------------- | ------------------------------------------------------------ |
| ***Opcode\***  | 2                | Operation Code: 操作代码：指定 TFTP 消息类型。值 6 表示选项确认消息。 |
| ***Options\*** | Variable         | ![img](http://www.tcpipguide.com/free/aa212558.png)          |

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\tftpoack.png)

​                                                                             **图 300：TFTP 选项确认消息格式**



#### 4.2.3 TCP/IP 电子邮件系统：概念和协议（RFC 822、MIME、SMTP、POP3、IMAP）

人类通常会创建让人想起他们已经习惯的系统。我们都习惯于使用常规邮件系统将信件和其他文件从我们所在的位置发送到邮政系统服务的任何地方的收件人。自然地，互联网络的首批应用之一是创建这种传统邮件系统的电子版本，允许以类似的方式发送消息，但更快速、更容易。在多年的过程中，创建并改进了 TCP/IP 的电子邮件系统。它现在是世界上使用最广泛的电子消息传递方式。

在本节中，我将在五个部分中详细描述 TCP/IP 电子邮件，讨论电子邮件概念以及构成整个 TCP/IP 电子邮件系统的各种组件和协议。第一部分概述了 TCP/IP 电子邮件，并讨论了它的使用方式以及构成该系统的不同协议和方法。第二部分讨论电子邮件消息的寻址方式，第三部分讨论电子邮件消息的标准格式和特殊格式。第四和第五小节描述了实现电子邮件功能的 TCP/IP 协议。这包括对负责电子邮件传递的简单邮件传输协议 (SMTP) 的检查，以及用于邮箱访问和邮件检索的几种协议和方法，包括 POP3 和 IMAP。

注意：本次讨论主要集中在现代互联网中用于电子邮件撰写、传递和访问的机制。在电子邮件概述主题中，我提到了过去用于 TCP/IP 电子邮件的一些技术，但只是为了历史的完整性而简要介绍，并将这些方法与目前使用的方法进行对比。



##### 4.2.3.1 TCP/IP 电子邮件系统概述和概念

TCP/IP 协议族中的电子邮件并不是作为单一的协议或技术实现的。相反，它是一个完整的系统，包含许多协同工作的相关组件。其中包括定义寻址和消息格式化方法的标准，以及在实现电子邮件消息传送过程中发挥不同功能的许多协议。在继续检查每个部分之前，从整体系统概述开始是有意义的。

在本节中，我将介绍 TCP/IP 电子邮件，以帮助您了解该系统、它的工作原理以及不同的组件如何融入其中。我从电子邮件的概述和历史及其在 TCP/IP 中的实现开始。我提供了电子邮件通信过程中涉及的步骤的一般概述。最后，我将更具体地讨论 TCP/IP 中使用的通信模型以及各种 TCP/IP 设备和协议在电子邮件发送和接收中所扮演的角色。



###### 4.2.3.1.1 TCP/IP 电子邮件系统概述和历史（部分：1 2 3）

交流的需求与人类本身一样古老。几千年前，通信几乎完全是本地的。信息主要是口头的，即使是书面的，也很少能传递很远的距离。大多数人从不远离家乡，也很少与远离自己的人交流。但即使在古代，领导者也会使用信使从一个地方到另一个地方发送简短的重要信息。它速度慢且不可靠，但有些消息非常重要，因此尽管困难重重，但仍必须努力进行沟通。

交通运输的进步导致了通信能力的进步，最终导致了物理邮件系统的创建。如今，这些系统已经发展到发达国家中的任何人都可以向几乎任何其他人发送信件的程度。尽管人们对邮政服务开了许多玩笑，但可靠性已大大提高。  Speed 也比过去好得多，现在消息需要几天才能到达目的地，而不是几周或几个月。

以我们现代世界的标准来看，消息从一个地方传到另一个地方甚至要等上几天的时间是相当慢的。出于这个原因，网络最自然的应用之一就是用它们来替代从一个地方到另一个地方的消息物理传输。将邮件从物理过程转变为电子过程会产生巨大的好处，其中最主要的是大大提高了通信速度，能够立即将一条消息发送给多个收件人，以及能够在收到消息后获得近乎即时的反馈。

<u>**电子邮件的早期**</u>
电子邮件（电子邮件或电子邮件）背后的概念不仅与计算机网络一样古老，而且实际上早于互联网。第一个电子邮件系统是在传统的大型计算机上实现的。这些是许多用户通过连接的终端同时访问的单一大型计算机。大型机上的电子邮件系统由一组运行在大型机上的软件组成，这些软件实现了整个电子邮件系统。每个用户在这台机器上都有一个邮箱，邮件通过将邮件从一个邮箱移到另一个邮箱来“投递”。用户通过用户界面程序发送和接收邮件。

这种早期的电子邮件系统对本地通信很有用，但对向另一个组织的人发送消息却没有用。大型机电子邮件有点类似于城镇的一位居民向另一位居民发送的“本地邮件”。如果没有更多的投递基础设施，就无法向远方城镇的人发送邮件。

互联网的力量真正使电子邮件成为一种普遍的通信方式。互联网将系统连接在一起，就像邮政服务的机队和车辆将邮局连接在一起一样。邮件通过互联网的底层技术从一个用户发送到另一个用户。 TCP/IP 当然是最常用的网络互连协议组，现代互联网使用 TCP/IP 将全球系统连接在一起。因此，它是发送电子邮件的“载体”。

<u>**TCP/IP 电子邮件的历史**</u>

与其他一些文件和消息传输协议一样，基于 TCP/IP 的电子邮件实际上可以追溯到 TCP/IP 和 Internet 正式存在之前。第一个电子邮件协议是在 ARPAnet 时代开发的。在创建电子邮件之前，一些 Internet RFC，例如 RFC 95（是的 95，两位数，我们在这里要倒退很久了！）和 RFC 155 描述了早期用于分发文档的物理邮寄列表70 年代。正是这种发送文档的需求可能使 TCP/IP 的先驱们意识到使用他们自己创建的技术的电子消息系统将是多么有用。

第一个描述电子邮件的 Internet 文档可能是 1971 年发布的 RFC 196。它描述了一种称为“邮箱协议”的东西，这是一种使用 TCP/IP 的前身的非常基本的消息传输方法。该协议专为发送文档以进行远程打印的特定目的而设计。在那些日子里，人们在交互式终端上使用计算机并不像今天这样普遍，但电子邮寄文件的想法是一样的。邮箱协议在 1971 年进行了多次修订。

在 20 世纪 70 年代中期，人们开始着手开发一种在刚刚起步的互联网上实施电子邮件的更全面的方法。该技术最初是使用许多当时存在的应用层传输协议来描述的，包括文件传输协议 (FTP)。 1980 年，邮件传输协议 (MTP) 在 RFC 772 中发布。这是当今 TCP/IP 电子邮件的第一个前身，它是使用 Telnet 远程访问协议和 FTP 的原理定义的。

在 20 世纪 70 年代开发电子邮件协议期间，使用各种不同的技术在主机系统之间交换邮件。最常用的一种是 Unix 到 Unix 复制协议 (UUCP)，该协议旨在允许文件在 UNIX 系统之间传输，将它们从一个连接的系统移动到另一个连接的系统。 UUCP 还用于传送 Usenet 新闻组文章和其他文件。

1981年，随着简单邮件传输协议（SMTP）的定义，现代TCP/IP电子邮件时代应运而生。 SMTP 详细描述了如何在不需要使用 FTP 或其他文件传输方法的情况下将邮件直接或间接地从一台 TCP/IP 主机移动到另一台。它在本指南中有自己的详细历史和讨论。大约在同一时间创建了其他补充规范，这些规范规范或定义了系统的其他组件和元素。我们将在接下来的两个主题中探讨这些难题。

<u>**TCP/IP 电子邮件系统概述**</u>

现代电子邮件系统中最重要的一般概念之一是，在互联网上的 SMTP 主机之间传递电子邮件的协议与允许用户访问其本地主机上收到的邮件的协议之间存在区别。继续我们的类比，不同的协议用于在邮局之间发送邮件和“送货上门”。正如我们将看到的，这是有意为之的，即使用户在发送邮件时未连接到 Internet，也可以向用户发送邮件。这种解耦非常重要，因为它可以实现延迟通信，即可以在发件人想要发送邮件时发送邮件，并在收件人想要阅读邮件时接收邮件。

多年来，1980 年代初定义的基本组件没有发生实质性变化，但它们的使用方式却发生了演变和改进。早期的电子邮件传递涉及由一个 SMTP 主机使用路由规范来指示邮件如何通过中间系统传递；今天，域名系统使大部分内容都过时了，在大多数情况下促进了近乎即时的直邮投递。早期的电子邮件只支持简单的文本，现在我们可以在电子邮件中发送图形图像、程序和其他文件。现代高速 Internet 连接和更新的访问协议使现代电子邮件成为实现甚至跨越大陆的几乎即时通信的最终目标。

**关键概念：**最重要的 TCP/IP 应用程序之一是与现实世界的邮政投递系统等效的互联网络，通常称为电子邮件或电子邮件。电子邮件的历史可以追溯到 TCP/IP 发展的最早时期；今天，每天有数百万人使用它在世界各地发送简单和复杂的消息。 TCP/IP 电子邮件不是一个单一的应用程序，而是一个包括多个协议、软件元素和组件的完整系统。



###### 4.2.3.1.2 TCP/IP 电子邮件通信概述：消息组合、提交、传递、接收、处理和访问

TCP/IP 电子邮件作为一个完整的系统来实现，具有许多不同的元素，它们执行电子邮件通信的完整工作的不同部分。其中包括标准消息格式、收件人寻址的特定语法以及用于传递邮件和允许从间歇性连接的 TCP/IP 客户端访问邮箱的协议。

为了帮助奠定检查这些组件的基础，我想概述电子邮件通信的完整端到端过程，以便您了解一切是如何工作的。我将简化形式展示基本步骤，并继续类比常规邮件系统进行比较。

<u>**电子邮件通信过程步骤**</u>
现代 TCP/IP 电子邮件通信过程包括以下五个基本步骤。

1. 邮件撰写
用户通过创建电子邮件消息开始电子邮件之旅。消息包含两部分：标题和正文。消息的主体是要传达的实际信息；标头包含描述消息并控制消息传递和处理方式的数据。必须创建消息，使其与电子邮件系统的标准消息格式相匹配，以便对其进行处理。它还必须指定消息的预期收件人的电子邮件地址。

类比真实的邮件，邮件的正文就像一封信，而标题就像是信封。

2. 邮件提交
正如我们将在下一个主题中更详细地看到的那样，电子邮件不同于许多其他网络应用程序，因为消息的发送者和接收者不一定需要同时连接到网络，甚至不需要连续连接到网络才能使用它.该系统的设计使用户在撰写消息后决定何时将其提交给电子邮件系统以便可以发送。这是使用简单邮件传输协议 (SMTP) 完成的。

这类似于在邮局投递信封，或者邮政工作人员从邮箱中拿起信封并将其带到当地邮局以插入邮件投递流。

3. 邮寄
电子邮件消息被发件人的本地 SMTP 系统接受，以通过邮件系统传送到目标用户。今天，这是通过对预期收件人的主机系统执行域名系统 (DNS) 查找并与该系统建立 SMTP 连接来实现的。 SMTP 还支持指定一系列 SMTP 服务器的功能，消息必须通过这些服务器才能到达目的地。无论哪种方式，最终邮件都会到达收件人的本地 SMTP 系统

这就像通过邮政系统的卡车、飞机和其他设备的内部“网络”将信封运送到预期收件人的当地邮局。

4. 邮件接收和处理
本地 SMTP 服务器接受电子邮件消息并对其进行处理。它将邮件放入预期收件人的邮箱中，等待用户取回邮件。

在我们的物理类比中，这是收件人的当地邮局对来自邮政投递系统的邮件进行分类并将邮件放入单独的邮政信箱或箱子中以进行投递的步骤。

5.邮件访问和检索
预期的收件人定期检查其本地 SMTP 服务器以查看是否有邮件到达。如果是，收件人检索邮件，打开它并阅读其内容。这不是使用 SMTP 而是使用特殊的邮件访问协议或方法来完成的。为了节省时间，访问协议和客户端电子邮件软件可能允许用户扫描收到邮件的标题（例如主题和发件人身份）以决定下载哪些邮件消息。

这是在邮局实际领取邮件或将邮件递送到家中的步骤。

<u>**通用通信流程的修改**</u>
在某些情况下，并非执行所有这些步骤。如果用户从已经是 SMTP 服务器的设备发送电子邮件，则可以省略步骤 #2；如果收件人登录的设备也是 SMTP 服务器，则将跳过第 5 步，因为用户可以直接在服务器上阅读邮件。因此，在最简单的情况下，所发生的只是组合、交付和接收；当拨号 UNIX 主机的一个用户向另一个用户发送邮件时，就会发生这种情况。然而，在今天的大多数情况下，所有五个步骤都会发生。

<u>**关键概念：**</u>TCP/IP 电子邮件通信通常包括五个步骤的序列，每个步骤都类似于普通信件通过邮政系统所经历的旅程的一部分。首先，撰写（撰写）电子邮件；第二，提交到电子邮件系统；第三，投递到收件人的服务器；第四，接收和处理；最后，第五，它由接收者访问和检索。


同样，这被简化了。 例如，我省略了收件人注意到邮件实际上是垃圾邮件发送者的广告，宣传他如何“快速赚钱”、消除债务或一夜之间减肥，然后低声嘀咕并删除邮件的步骤 . 嘿，我从未说过电子邮件速度快且几乎免费没有任何缺点。 



###### 4.2.3.1.3 TCP/IP 电子邮件消息通信模型以及设备和协议角色（部分：1 2 3）

电子邮件系统作为一个整体的目的是完成电子邮件消息从 TCP/IP 互联网络的用户到一个或多个接收者的传输。为了实现这一点，需要一种特殊的通信方法，使电子邮件系统与大多数其他协议所使用的系统截然不同。要理解我的意思，您只需要了解发送信件和打电话之间的通信区别即可。

大多数 TCP/IP 协议在这方面类似于拨打电话：发送方和接收方必须同时在网络上。如果他们不在身边接电话，您就不能打电话给他们并与他们交谈。 （是的，是的，答录机和语音邮件。别再打扰了，好吗？J）大多数 TCP/IP 协议都是这样的：例如，要使用 FTP 发送文件，您必须从发件人的机器直接连接到收件人的机器。如果收件人的机器在发件人的准确时间不在网络上，则无法进行通信。

对于电子邮件，这种类型的通信是完全不能接受的。电子邮件就像它在现实世界中的对应物一样。 Joe 希望能够在他方便的时间将消息放入系统，而 Ellen 希望能够在适合她的时间接收 Joe 的邮件。为此，电子邮件必须使用“发送后忘记”模式，就像真正的邮件一样，Joe 将“信封”放入电子邮件系统，最终到达目的地。

发件人和收件人的这种解耦对于电子邮件系统的设计至关重要。尤其如此，因为 Internet 电子邮件的许多用户并非一直都在 Internet 上。正如您不希望收到的真实邮件在您不在家时被拒收一样，如果电子邮件到达时您不在 Internet 上，您也不希望它不被投递。同样，您可能不希望在编写消息的整个过程中都连接到 Internet，尤其是如果您每天访问 Internet 的时间有限。

对于整个电子邮件系统来说，同样重要的是通信是在特定用户之间进行的，而不是在特定机器之间进行的。这使得电子邮件在本质上不同于 TCP/IP 互联网络上的许多其他类型的通信。当我们查看电子邮件寻址时，我们会更多地了解为什么这很重要。

<u>**延迟交付模型和设备角色**</u>

为了允许电子邮件所需的通信类型，整个系统被设计成促进电子邮件消息从一个用户到另一个用户的延迟传递。为了解这是如何工作的，让我们再次看一下我们在上一个主题中讨论的示例通信，但这一次，考虑交换中不同设备的角色（如图 301 所示）：

- 发件人的客户端主机：邮件的发件人撰写电子邮件消息，通常使用他或她的本地计算机上的邮件客户端程序。邮件一旦写好，不会立即通过 Internet 发送出去；它保存在称为线轴的缓冲区中。这允许用户在创建多个传出消息的整个时间内“分离”。用户完成后，可以立即发送所有消息。

- 发件人的本地 SMTP 服务器：当用户的邮件准备好发送时，他或她连接到互联网。然后将消息传送到用户指定的本地 SMTP 服务器，该服务器通常由用户的 Internet 服务提供商 (ISP) 运行。邮件使用 SMTP 从客户机发送到本地 SMTP 服务器。 （在某些情况下，发件人可能会直接在具有本地 SMTP 服务器的设备上工作，在这种情况下发送会被简化。）

- 收件人的本地 SMTP 服务器：发件人的 SMTP 服务器使用 SMTP 通过互联网将电子邮件发送到收件人的本地 SMTP 服务器。在那里，电子邮件被放入收件人的传入邮箱（收件箱）。这相当于发件人客户端机器上存在的传出假脱机。它允许收件人在一段时间内积累来自多个来源的邮件，并在方便时检索它们。

- 收件人的客户端主机：在某些情况下，收件人可以直接在本地 SMTP 服务器上访问他或她的邮箱。然而，更常见的是，邮件访问和检索协议（例如 POP3 或 IMAP）用于从 SMTP 服务器读取邮件并将其显示在收件人的本地计算机上。在那里，它使用电子邮件客户端程序显示，类似于发件人最初用来撰写邮件的程序。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\emailmodel.png)



​                                                                        **图 301：电子邮件（E-Mail）通信模型**

此图显示了两个用户之间典型的电子邮件通信中涉及的四个设备。 （是的，他们是同卵双胞胎，想象一下！J）每个设备都由许多不同的元素组成，它们按照黑色箭头所示进行通信。请注意固有的不对称性，因为用于从用户发送电子邮件的方法与用于从服务器检索电子邮件的方法不同。大的绿色箭头显示了一个典型的交易：发件人撰写邮件并将其发送到她的本地电子邮件池。它使用 SMTP 发送到发件人的本地 SMTP 服务器，然后发送到收件人的 SMTP 服务器，然后进入该用户的收件箱。然后检索它，通常使用 POP 或 IMAP 等协议。

<u>**电子邮件通信中的协议角色**</u>

您可能已经注意到 SMTP 用于此通信过程的大部分。事实上，如果收件人使用运行 SMTP 软件的机器（这对于使用拨号 UNIX shell 上网的人来说很常见），则发送电子邮件的过程将专门使用 SMTP。但是，SMTP 服务器必须始终在 Internet 上可用并准备好接收邮件。大多数人使用不总是在线或不运行 SMTP 软件的设备访问互联网。这就是为什么通常需要最后一步，即邮件访问和检索。

或许可以定义电子邮件系统，使通信的最后一步也使用 SMTP 执行，这意味着整个系统使用相同的协议。但是，SMTP 是为传输和传递电子邮件的特定目的而定制的，而不是为远程邮箱访问而设计的。将邮箱访问功能留给专用的、单独的协议更有意义。这不仅允许这些协议根据电子邮件收件人的需要进行定制，而且通过为用户提供多种检索电子邮件的选项来提供灵活性。我在指南的单独部分讨论了邮件访问协议和方法，重点介绍了两种最常用的协议：邮局协议 (POP) 和 Internet 消息访问协议 (IMAP)。

上面讨论的三种协议——SMTP、POP3 和 IMAP——在 TCP/IP 电子邮件阶段占据了“主导地位”，但它们依赖于另外两个元素来扮演“配角”。第一种是一种寻址电子邮件消息以确保它们到达目的地的方法。第二个是用于对消息进行编码并控制它们的传递和使用方式的一组消息格式。这些通常不会得到应有的关注，但它们在这里确实如此，因为我在接下来的两节中专门介绍了它们。

**关键概念：**电子邮件系统的关键要求之一是在发送邮件时不需要消息的发送者和接收者都在系统上。因此，TCP/IP 使用具有多个设备的通信模型，允许发送方和接收方分离。发件人的客户端设备假脱机邮件，并在准备好传输时将其移动到发件人的本地 SMTP 服务器；然后使用 SMTP 将电子邮件传输到接收方的 SMTP 服务器。电子邮件可以无限期地保留在收件人的服务器上。当收件人准备好阅读它时，他或她使用一组邮件访问协议和方法中的一个或多个来检索它，其中最流行的两种是 POP 和 IMAP。

##### 4.2.3.2 TCP/IP 电子邮件地址和寻址

电子邮件的整个概念基于一个类比：发送电子消息与发送纸质消息的比较。这个类比很管用，因为电子邮件确实打算像普通邮件一样，只是具有电子时代的优势：速度和灵活性。

电子邮件和普通邮件之间的许多相似之处之一是需要寻址。为了传递消息，发件人必须指定收件人是谁，并提供合理数量的信息以指示如何联系到收件人。在 TCP/IP 电子邮件中，为此使用了标准的电子邮件地址格式，并且还提供了对可在特殊情况下使用的替代寻址方案的支持。

在本节中，我将描述如何处理电子邮件消息。我首先讨论 TCP/IP 中的标准电子邮件寻址，以及如何使用这些地址来确定应将电子邮件发送到哪里。然后，我将简要讨论您可能不时遇到的历史和特殊电子邮件地址。我还讨论了电子邮件地址簿（别名）的使用以及如何处理多个收件人，以及提供电子邮件列表的概述，这是实现电子群组通信的最早方式之一。



###### 4.2.3.2.1 TCP/IP 电子邮件寻址和地址解析（部分：1 2 3）

互联网络上的所有通信都需要某种方式来指定通信的预期接收者的身份。大多数应用程序协议（例如 FTP 和 HTTP）使用传统的 TCP/IP 结构（IP 地址和端口号）来指定要发送的信息的目的地。 IP 地址通常标识特定的主机，端口号标识在该计算机上运行的软件进程或应用程序。

然而，电子邮件使用与大多数应用程序截然不同的通信模型。正如我们在讨论电子邮件模型时看到的那样，将电子邮件与许多其他系统区分开来的一个要素是通信是面向用户的。电子邮件不会像使用 FTP 传输文件那样从一台机器发送到另一台机器。它从一个用户发送到另一个用户。这对整个系统的运行至关重要；一方面，它允许某人检索从任意数量的不同客户端计算机发送的电子邮件。这使得即使在旅行时也可以接收电子邮件。

由于电子邮件消息是基于用户的，因此寻址方案也必须是基于用户的。我们不能使用传统的 IP 地址和端口，而是需要一个明确的系统来指定两个主要信息：用户是谁，以及用户所在的位置。当然，这些类似于普通邮件信封上的姓名和地址。

用户名的想法相对简单，但识别用户的位置则不然。在普通邮件中，地址是指实际位置。用同样的方式定义电子邮件地址是可能的：让它指向用户的客户端机器。然而，回想一下电子邮件传递的另一个重要特征：它是间接的，并且基于用户本地 SMTP 服务器保存收到的消息直到可以检索的概念。用户用来访问他或她的电子邮件的机器可能甚至经常不在 Internet 上，因此可能不容易识别它。同样，我们希望用户能够从多台机器访问邮件。

由于所有这些原因，我们希望地址标识的不是用户在任何特定时间的具体位置，而是用户永久邮箱所在的位置。这是在用户的 SMTP 服务器上，该服务器永久连接到 Internet。

<u>**基于标准 DNS 的电子邮件地址**</u>

在 TCP/IP 中，用于识别服务器（和其他机器）的系统是域名系统 (DNS)。 DNS 是一个大系统，在本指南的大章节中进行了描述；如果您想了解更多，我会推荐给您。就我们的目的而言，重要的是在 DNS 中，Internet 上的所有设备都排列成一个设备命名层次结构，任何设备都可以使用由一系列由点分隔的文本标签组成的域名来识别。

因此，完整的 TCP/IP 地址由两部分组成：用户名规范和域名规范。两者使用特殊的“at”符号（“@”）连接在一起，形成我们今天几乎所有人都熟悉的 TCP/IP 电子邮件地址语法：

```
<username>@<domainname>
```

<domainname>的格式遵循DNS的语法规则，每个标签只包含数字和数字，标签之间用句点分隔。 <username> 的格式限制稍微少一些，允许使用下划线（“_”）等特殊字符。如果其他特殊字符和空格被引号括起来（或以其他方式标记为名称的一部分，例如通过使用转义字符），则 <username> 中也允许使用其他特殊字符和空格。域名不区分大小写；用户名可能区分大小写，具体取决于系统。

因此，一个有效的电子邮件地址示例可能是我多年前在学校使用的以下地址：

```
cmk@athena.mit.edu
```

其中“cmk”是我的用户名（我的姓名首字母），“athena.mit.edu”是我接收邮件的主机名。 “athena”是麻省理工学院（“mit”）的一个特殊系统，这是一个教育机构，因此使用“.edu”顶级域。

<u>**URL 电子邮件地址规范**</u>
也可以使用 Internet 标准统一资源定位器 (URL) 指定电子邮件地址。这允许将链接嵌入到超文本 (Web) 文档中，当单击该文档时，会调用电子邮件客户端向用户发送邮件。电子邮件 URL 是通过在地址前面加上特殊的 URL 方案字符串“mailto:”来创建的，如下所示：

```
mailto:cmk@athena.mit.edu
```

<u>**电子邮件地址的特殊要求**</u>

与让地址提及特定客户端计算机相比，让电子邮件地址指向用户的本地 SMTP 服务器提供了很大的灵活性。但它没有提供足够的灵活性来处理各种情况：

- 组织可能希望使用未指定 SMTP 服务器名称的“通用”地址来处理邮件。原因是这需要发送邮件的人知道该服务器的名称。例如，如果有人知道我的真实姓名并且知道我在麻省理工学院工作，那么他们会更容易记住我的旧电子邮件地址是“cmk@mit.edu”而不是“cmk@athena.mit.edu”。

- 管理员可以在一段时间内更改哪些机器处理邮件。这意味着所有用户的电子邮件地址都必须更改——我们大多数人都知道这是多么痛苦。例如，如果我从“athena”机器转移到“jabberwocky”机器，我的旧地址就需要更改为“cmk@jabberwocky.mit.edu”。但如果只是“cmk@mit.edu”，则更改不会影响我。

- 在较大的组织中，可能希望有多个服务器分担处理传入邮件的负载。

<u>**邮件交换 (MX) DNS 记录**</u>
为满足所有这些要求，DNS 系统包含一项专门设计用于支持电子邮件寻址的功能。可以设置一个特殊的邮件交换 (MX) 记录，指定哪个 SMTP 服务器应该用于进入特定域名的邮件。如果配置得当，这将允许相当大的灵活性来处理我上面描述的情况以及更多情况。更多详细信息，请参见MX记录和DNS电子邮件支持的描述。

例如，我是“pcguide.com”域名的所有者。可以通过“pcguide.com”向我发送电子邮件，但它实际上并未以该名称存储在任何服务器上。它被重定向到我的收件箱所在的真实服务器。这使我能够处理所有发往“pcguide.com”的邮件，而不管我的邮箱实际位于何处。

DNS 也很重要，因为它的“MX”资源记录消除了将电子邮件从一个 SMTP 服务器“中继”到下一个服务器以传递它的需要。在现代 TCP/IP 中，可以将电子邮件直接从发件人的 SMTP 服务器发送到收件人的服务器，从而使通信更快、更高效。有关详细信息，请参阅专门介绍 SMTP 的部分。

**关键概念：**所有网络通信都需要某种形式的寻址；因为电子邮件是面向用户的，所以电子邮件地址也是基于用户的。在现代 TCP/IP 电子邮件中，标准地址由用户名和域名组成，用户名指定收件人是谁，域名指定用户所在的 DNS 域。为接受电子邮件的每个域设置一个特殊的 DNS 邮件交换 (MX) 记录，因此发送 SMTP 服务器可以确定它应该使用哪个 SMTP 服务器将邮件发送给特定的收件人。



###### 4.2.3.2.2 TCP/IP 历史和特殊电子邮件寻址（部分：1 2）

TCP/IP 电子邮件非常成功，可以说是最重要的全球电子消息传递标准。电子邮件的广泛接受与 TCP/IP 和整个 Internet 密不可分。由于大多数组织都希望成为 Internet 的一部分，因此他们连接到 Internet 并使用其技术，包括作为 TCP/IP 电子邮件地址基础的域名系统。反过来，使用简单的 DNS 式电子邮件地址（“user@domain”）会鼓励进一步使用电子邮件，因为人们发现从概念上来说很容易决定如何发送消息。

然而，TCP/IP 并不是唯一的电子邮件系统。多年来，其他几个网络也开发了电子邮件系统。由于 Internet 是世界上最大的互联网络，TCP/IP 电子邮件经常被用作各种“信息交换所”，将这些不同的电子邮件机制连接在一起。这称为网关，允许使用非 SMTP 电子邮件系统的人与使用 TCP/IP 的人进行交互，反之亦然。网关很复杂，原因之一是电子邮件系统使用不同的方式来处理邮件。让我们看一下其中的几个系统以及它们如何与 TCP/IP 交互。

<u>**FidoNet 寻址**</u>
最早的独立电子邮件系统之一是 FidoNet，它已经存在了很长时间并且今天仍在使用。 FidoNet 是一个使用调制解调器和专有协议连接的全球网络；它本质上是全球 TCP/IP 互联网的“竞争对手”。我把“竞争对手”放在引号中是因为两者在用户数量和它们支持的应用程序种类方面并没有真正的可比性，但它们在总体目标上是相似的：全球电子通信。

FidoNet 用户使用指定 FidoNet 区域、网络、节点和点（连接点）的四个数字来识别。这些寻址元素用于在此系统上发送邮件，这又完全不同于 TCP/IP。然而，为了允许 TCP/IP 和 FidoNet 之间的通信，FidoNet 管理员设置了一个网关系统，允许使用 TCP/IP 样式域名将邮件发送到 FidoNet。这种映射方式也被其他具有专有邮件地址格式的系统使用，以允许它们与 Internet 接口。

例如，如果用户在机器 4、节点 205、网络 141、区域 1（北美）上，则 FidoNet 地址将为 1:141/205:4。等效域名为 p4.f205.n141.z1.fidonet.org，可用于 TCP/IP 样式的“user@domain”寻址。



<u>**UUCP 式寻址**</u>

通常与电子邮件相关联的旧地址样式是“UUCP 样式”地址。 Unix 到 Unix 复制协议 (UUCP) 多年前在 SMTP 得到广泛部署之前通常用于路由邮件（同样，它仍在使用，只是不像以前那么多了）。该系统中的地址指定为由感叹号（“！”）分隔的主机路径。该路径指示邮件到达特定用户所采用的路由，通过一系列运行 UUCP 的中间机器。例如，如果在主机“joesplace”上给“joe”的邮件必须经过三个主机“host1”、“host2”和“host3”，地址将是：

```
host1!host2!host3!joesplace!joe
```

由于感叹号的俚语是“bang”，因此被称为 bang path notation。

当 DNS 开始使用时，UUCP 风格的表示法有时会与 TCP/IP 风格的域名地址表示法混合使用。所以你可能见过类似“host1!user@domain”的东西。对于如何准确解释这样的地址存在一些困惑：这是否意味着先将邮件发送到“host1”，然后再发送到“user@domain”？或者它是否意味着首先将它发送到“域”，然后再发送到“host1”的“用户”？对此没有普遍的答案。通过减少 UUCP 的使用和部分 UUCP 系统转向 TCP/IP 样式的域名寻址，问题基本上得到了解决。

<u>**网关寻址**</u>
最后，您可能会遇到看起来像使用不寻常的标点符号嵌套的多个 TCP/IP 地址的电子邮件地址。例如，您可能会看到如下所示的内容：

```
user%domain1.com@subdomain.domain2.edu
```

这是使用电子邮件网关时有时会看到的一种寻址方式；它将导致邮件被发送到位于“subdomain.domain2.edu”的“user%domain1.com”。该地址然后被解释为“user@domain1.com”。但是，同样，并非所有系统都保证以相同的方式解释这一点。

电子邮件网关通常不是一件简单的事情，如您所见，原因之一是使用不同的电子邮件地址样式以及解释复杂“混合”地址的一致性问题，如上文所述。然而，随着 Internet 的扩展和 TCP/IP 变得越来越普遍，使用这些旧的、特殊的地址格式变得越来越少。它们越来越成为一种“历史好奇心”（除非你碰巧使用其中之一！）

###### 4.2.3.2.3 TCP/IP 电子邮件别名/地址簿、多个收件人寻址和电子邮件列表（部分：1 2）

电子邮件类似于普通邮件，但由于数字和电子通信的两个主要优点而优于普通邮件。其中之一就是速度，这就是现代互联网用户想出俚语“snail mail”来指代常规邮政服务的原因。 J 但是另一个也很重要：灵活性。电子邮件使您能够轻松地以普通邮件发送方式繁琐的方式发送消息。可以看到这种灵活性的方式之一是解决问题。

电子邮件寻址灵活的第一种方式是大多数电子邮件客户端支持高级功能，允许用户以方便的方式指定收件人的身份。虽然 TCP/IP 寻址确实相当简单，但记住您认识的每个人的地址却很困难。在现实世界中，我们使用地址簿来帮助我们记住地址。对于电子邮件，我们也可以这样做，方法是允许电子邮件软件将姓名与电子邮件地址相关联。这通常以两种方式之一完成。

<u>**电子邮件地址别名**</u>
在许多 UNIX 系统上使用的“老式”基于文本的电子邮件中，名称和地址关联是使用别名执行的。这些是电子邮件地址的缩写形式，可以节省键入时间。例如，我妻子的名字叫 Robyn，我经常给她发电子邮件，但我懒得一直输入她的地址。所以我在我的电子邮件程序中为她定义了一个别名，简称为“r”。我输入邮件命令并将别名“r”指定为预期收件人，它会为我展开它。 （是的，我本可以使用“robyn”，但是嘿，我真的很懒。J）

<u>**电子地址簿**</u>
在现代图形电子邮件系统中，不使用别名。相反，通常实施电子地址簿，这当然等同于纸质地址簿。不同的是没有手动复制；您只需使用鼠标从列表中选择名称；除非系统能够以某种方式读懂您的想法，否则没有比这更简单的了。

指定多个收件人
电子邮件寻址的另一个优点是它允许轻松指定多个收件人。对于纸质邮件，向十个人发送一条消息意味着您需要十份消息副本、十个信封和十张邮票。对于电子邮件，您只需在收件人列表中列出以逗号分隔的收件人地址：

<user1@domain1>,<user2@domain2>,<user3@domain3>...
将单独的副本邮寄给每个收件人，尽可能简单。当然，在这里也可以使用别名和/或地址簿来指定每个收件人，从而使这变得更加简单。

由于电子邮件使一个人可以很容易地向一组其他人发送信息，即所谓的一对多消息传递，因此它也是最早实现电子群组通信的方式之一。在使用电子邮件之前，在群组设置中共享信息需要面对面的会议或电话会议。在这两种情况下，各方都必须同时在场，并且涉及成本，尤其是当各方相距遥远时。

有了电子邮件，一群人就可以共享信息，而无需见面，甚至无需同时在线。假设有一个小组有四个人：A、B、C 和 D。A 有一个他想讨论的提议。他将它发送给 B、C 和 D。每个收件人将在他或她方便的时候阅读它。然后每个人都可以回复该组。例如，D 可能对提案有意见，因此她将其发送给 A、B 和 C。为此，大多数电子邮件客户端都包含群回复功能。

<u>**邮件列表**</u>

在较大的群体中，通过简单地写出每个收件人的地址来进行交流会变得很麻烦。相反，使用邮件列表。该列表由称为列表所有者的个人创建，并包含该组所有成员的电子邮件地址。然后，创建一个特殊的列表地址。这个地址的外观和功能就像一个普通的电子邮件地址。然而，当任何人向这个特殊地址发送邮件时，它并不是简单地存入邮箱。相反，它会被处理消息的特殊软件截获，并自动将其发送给列表中的所有收件人。任何收件人都可以回复列表地址，所有成员都会收到回复。

Internet 上有成千上万的邮件列表，涵盖了所有可以想象到的主题。每个列表在许多方面都不同，包括以下内容：

- 实施：通常使用某种特殊软件来允许列表所有者对其进行管理、添加和删除用户以及设置控制列表运行方式的参数。这些程序通常称为机器人或列表服务器（列表服务器）。其中一个比较常见的名字叫做 Majordomo。现在还有使用万维网实际实施和管理的邮件列表。 （互联网应用程序之间的界限越来越模糊……）

- 订阅规则和技巧：一些邮件列表对任何希望加入的人开放，而其他邮件列表则“仅限受邀者”。大多数允许新订阅者使用软件自动加入，其他则需要列表所有者添加新成员。

- 管理方法和风格：列表所有者决定列表中可接受的讨论内容。有些列表是经过审核的，这意味着所有提交到列表的内容在发送给列表成员之前必须得到列表所有者的批准。有些列表允许非成员向列表发送邮件，有些则不允许。

- “文化”：与所有群体一样，邮件列表中的群体也有自己的“文化”、有趣的“个性”等等。通常鼓励列表的新成员阅读列表，并且在他们习惯它及其工作方式之前暂时不要发送给它。这类似于 Usenet“新手”的适应过程。

- 特殊功能：一些列表支持特殊功能，例如能够以摘要模式订阅（消息被收集到大摘要中以减少发送的单个消息的数量）或访问 Web 上的消息。

**关键概念：**电子邮件的众多好处之一是，只需指定多个收件人地址，即可轻松地同时向多人发送消息。这允许轻松简单的群组通信，因为每个收件人然后可以进行群组回复以向发送原始消息的每个人发送回复。电子邮件列表为团体交流想法和信息提供了一种更正式的方式； Internet 上有成千上万个这样的列表。

现在还有许多其他方式可以让群组共享信息，例如万维网公告板、Usenet 新闻组、Internet 中继聊天等等。相比之下，其中一些具有许多使邮件列表显得“简单”的功能。尽管如此，电子邮件列表仍然很受欢迎，主要是因为电子邮件是最普遍的 Internet 通信方式，也是最容易使用的方式之一。

 

##### 4.2.3.3 TCP/IP 电子邮件消息格式和消息处理：RFC 822 和 MIME

使用计算机进行通信的优势是显而易见的，但使用计算机技术也存在一些局限性。当我将电子邮件与普通邮件进行比较时，我总是指出电子邮件在传递方式上更快、更灵活，这是事实。一封电子邮件可以在几秒钟内到达目的地，而传统的信件需要几天时间。

但是计算机的一个缺点是它们在弄清楚如何理解消息方面不是很适应。想一想任何人都可以将任何类型的信件、备忘录或其他通信内容放入信封中并发送给您，并且假设您知道它所用的语言，您可以打开信封并理解它。您可以自动弄清楚如何处理日期在信件中不寻常的位置，或者您的名字出现在顶部而不是底部，或者邮件正文以不同的方式构建。您可以阅读打字或手写的笔记；用钢笔、铅笔或蜡笔；只要字母是可辨认的，你就可以理解所说的内容。

计算机根本不擅长这个。正是出于这个原因，电子邮件系统必须依赖标准的消息格式来确保所有消息都具有相同的格式和结构。这使得电子邮件系统中的所有设备都能够阅读和理解彼此的消息成为可能，从而使 TCP/IP 电子邮件能够在许多不同类型的计算机上工作。

在本节中，我分两个小节描述了用于 TCP/IP 电子邮件消息的两种格式。第一部分描述了主要的 TCP/IP 电子邮件标准，在定义它的标准之后称为 RFC 822 格式。第二部分描述了多用途 Internet 邮件扩展 (MIME) 标准，它通过定义将各种媒体和非英语语言文本编码为标准 RFC 822 格式的方法，极大地扩展了电子邮件支持不同类型信息通信的能力.



###### 4.2.3.3.1 TCP/IP 电子邮件标准消息格式：RFC 822

我读到的关于互联网应用程序的最敏锐的观察之一是它们的有用性与使用它们的人数成正比。 TCP/IP 电子邮件就是一个很好的例子：它是一种强大的通信方法，很大程度上是因为今天几乎每个拥有计算机的人都参与了该系统。注册使用电子邮件的人越多，它就变得越强大。

TCP/IP 电子邮件的创建者意识到使用该系统的人会使用许多不同类型的硬件和软件。为了确保每个人都能理解所有电子邮件消息，无论是谁发送的，他们为电子邮件消息指定了一种通用消息格式。这种格式没有正式的花哨名称；它只是通过定义它的标准的名称而为人所知：RFC 822 消息格式。

在本节中，我将介绍 RFC 822 消息格式，它构成了 TCP/IP 中电子邮件消息传输的基础。我首先概述消息的格式和一般结构，以及用于格式化 RFC 822 消息的一些总体规则。然后我描述了 RFC 822 电子邮件消息中使用的许多标头，以及它们是如何分组的。最后，我简要介绍了 RFC 822 消息的处理方式及其内容的解释方式。

**相关信息：**本节可能对有关 SMTP 的部分进行了某些引用，但旨在让您在阅读 SMTP 之前阅读它而不会感到困惑。好吧，不管怎样，我试过了。

###### 4.2.3.3.1-1 TCP/IP 电子邮件 RFC 822 标准消息格式概述、结构和一般格式规则（部分：1 2 3）

传送电子邮件的主要协议是简单邮件传输协议 (SMTP)。出于这个原因，用于 TCP/IP 电子邮件的消息格式可以被认为是 SMTP 的“协议消息格式”，这与针对其他协议（如 IP 和 TCP）讨论的特殊消息格式没有什么不同。然而，TCP/IP 电子邮件消息格式不仅被 SMTP 使用，而且被处理电子邮件的所有协议和应用程序使用。这包括邮件访问协议 POP3 和 IMAP 以及其他协议。它还旨在可能被其他非 TCP/IP 邮件传递协议使用。

可能由于这个原因，TCP/IP 电子邮件格式并未指定为 SMTP 本身的一部分，即 RFC 821，而是在配套文档：RFC 822 中指定。两者均于 1982 年发布。没有为此指定正式的花哨名称消息格式，因此该格式以标准本身的名称为人所知：RFC 822 消息格式。

<u>**RFC 822 消息格式标准的开发**</u>
当然，TCP/IP 中使用的消息格式的历史可以追溯到很久以前的 1982 年。它最初被定义为 1970 年代初期在互联网前身 ARPAnet 上传递文本消息的格式。随着时间的推移，该格式经过多次改进，最终于 1977 年发布了重要的电子邮件标准 RFC 733（ARPA 网络文本消息格式标准）。 RFC 822 后来对 RFC 733 的内容进行了精简，删除了早期标准中描述的一些未能获得认可的特性，并简化了规范。

2001年，对SMTP和RFC 822消息格式进行了修订； SMTP 现在在 RFC 2821 中描述，消息格式在 RFC 2822 中描述。这个较新的标准对 RFC 822 消息格式进行了相对较小的更改，以反映 TCP/IP 电子邮件的现代使用。尽管 RFC 2822 是当前标准，但原始名称仍然是最常用的名称。在本次讨论中，我将尊重该约定，描述基于 RFC 2822 的消息格式，同时仍将其称为“RFC 822”消息格式。

RFC 822 格式描述了 TCP/IP 电子邮件消息的格式、结构和内容。正如我所说，它类似于用于 TCP/IP 中其他协议的消息格式。与其他格式一样，RFC 822 格式在逻辑上可以分为两个主要部分：包含重要控制和描述信息的消息标头，以及承载数据的消息体或负载。

<u>**RFC 822 消息概述**</u>

RFC 822 与其他协议的字段格式不同的地方在于表达方式。大多数 TCP/IP 协议将标头信息编码为一组紧凑的字节，根据它们在消息中的位置和分配给它们的语义来读取和理解这些字节。例如，考虑 Internet 协议。每个 IP 数据报的第 9 个字节是生存时间 (TTL) 字段，它被编码为 0 到 255 之间的值。读取 IP 数据报的设备只知道第 9 个字节包含 TTL 值。如果它在那里看到二进制值“00010011”，它就知道该数据报的 TTL 值是十进制值 19。

相反，RFC 822 消息不使用二进制格式。它们完全由多行常规 ASCII 文本（在美国使用，标准称为 US-ASCII）组成，甚至是标题。每行以 ASCII 回车 (CR) 字符结尾，后跟换行 (LF) 字符；该组合统称为“CRLF”。每行文本不得超过 78 个字符（不包括终止符“CRLF”），并且不得超过 998 个字符（同样，不包括“CRLF”）。此外，字符 CR 和 LF 不得单独出现在文本中。

RFC 822 消息以一组共同构成消息头的文本行开头。每个头字段以以下形式表示，在文本中：

```
<header name>: <header value>
```

因此，例如，如果在 RFC 822 消息中有一个 Time To Live 字段（当然没有，因为该概念对电子邮件没有意义）并且需要表达一个值 19，则标头字段会出现这样的：

```
Time To Live: 19
```

将所有字段表示为简单文本意味着每个标题在每条消息中占用更多空间；字符串“Time To Live: 19”占用 18 个字节，包括终止符“CRLF”，其中 IP 标头中二进制编码的 Time To Live 字段仅占用一个字节。我们从中获得的是两个重要的好处。首先，任何用户都可以轻松检查标头并立即了解标头的内容及其值，这使得 RFC 822 消息非常可读。其次，由于每个标头都被明确标记，因此 RFC 822 消息可以在它们包含的标头数量，甚至它们出现的顺序方面有所不同，从而使它们变得灵活。

<u>**一般结构**</u>

RFC 822 消息总是以一组如上所述的标头字段开头；下一个主题将更详细地描述它们。在所有标题之后，必须出现一个空行。这仅由字符“CRLF”本身组成，紧跟在最终标题字段行末尾的“CRLF”之后。依次看到两个“CRLF”字符对会告诉读取消息的设备已到达标头的末尾。所有剩余的行都被视为消息的正文。与标题行一样，正文行由 ASCII 文本组成，不得超过 998 个字符，建议不超过 78 个字符（以便在标准的 80 字符终端显示器上阅读）。

由于电子邮件的标题和正文都是简单的 ASCII 文本，这意味着整封邮件只是一个文本文件。正如我上面所说，这使得这些消息非常可读，并且也很容易创建。可以使用简单的文本编辑器创建完整的电子邮件消息，包括标题，并可以使用简单的文本显示实用程序阅读它。这有助于电子邮件的普遍吸引力。

缺点是完全使用 ASCII 消息的决定意味着 RFC 822 消息中没有对任何需要更复杂结构或不能使用少量 ASCII 字符表达的消息的本地支持。不能直接使用 ASCII 表示图片、二进制文件、电子表格、声音剪辑等。此外，ASCII 的使用使 RFC 822 非常适合用英语表达消息，但不适用于使用 ASCII 无法表示的字符的许多其他语言。所有这些限制最终促使创建了增强的 MIME 消息格式。

**关键概念：**为确保 TCP/IP 互联网络上的每个设备都可以读取其他设备发送的电子邮件，所有消息都需要遵循特定的结构。最早指定现代 TCP/IP 电子邮件消息格式的标准是 RFC 822，因此，现在称为 RFC 822 消息格式。 RFC 822 消息由一组消息标头和消息正文组成，它们之间用空行分隔。 RFC 822 消息必须仅包含纯 ASCII 文本字符；每行的长度不得超过 1000 个字符，最后两个字符必须是 ASCII 字符“CR”和“LF”以标记行的结束。



###### 4.2.3.3.1-2 TCP/IP 电子邮件 RFC 822 标准消息格式标题字段定义和组（部分：1 2 3）

RFC 822 消息格式描述了 TCP/IP 电子邮件消息的结构和内容。该结构被有意设计为非常简单且易于创建和理解。每条消息都以一组描述消息及其内容的标头开头。一个空行标记标题的结尾，然后是邮件正文。

邮件正文包含发件人试图传达给收件人的实际文本，而邮件标题包含用于各种目的的各种类型的信息。标头通过指定收件人是谁、描述邮件的内容以及向邮件的收件人提供有关在传递邮件时对邮件进行的处理的信息来帮助控制邮件的处理方式。

<u>**标题字段结构**</u>
每个标题字段都遵循我们在上一主题中看到的简单文本结构：

```
<header name>: <header value>
```

"<header name> 当然是标头的名称，<header value> 是与该标头关联的值，这取决于标头类型。与所有 RFC 822 行一样，标题的长度不得超过 998 个字符，建议长度不超过 78 个字符，以便于阅读。 RFC 822 和 2822 标准支持一种特殊语法，如果标题非常长，则允许将标题“折叠”到多行。这是通过简单地将标题值继续到新行来完成的，该行必须至少以一个“空白”字符开头，例如空格或 <Tab> 字符，如下所示："

```
<header name>: <header value part 1>
<white space> <header value part 2>
<white space> <header value part 3>
…
```

<Tab> 字符最常用于此目的。 因此，例如，如果我们想为一条消息指定大量收件人，我们可以按如下方式进行：

```
To: person1@domain1.org, person2@domain2.com,
person3@domain3.net, person4@domain4.edu
```

<u>**标题字段组**</u>

RFC 822 邮件格式指定了可以包含在电子邮件中的许多类型的标头。少量标头是强制性的，这意味着它们必须包含在所有消息中。有些不是强制性的，但通常存在，因为它们是描述消息的基础。其他的是可选的，仅在需要时才包括在内。

为了帮助组织许多标头，RFC 2822 标准将它们分类为标头字段组（与 RFC 822 一样，尽管这些组在旧标准中略有不同）：

- 始发日期字段：指定消息准备好发送的日期和时间；详情见下文。 （由于我不清楚的原因，这个领域在它自己的组中；也许只是因为它很重要。）


- 发起者字段：包含有关消息发送者的信息。

- 目的地地址字段：指定邮件的收件人，可能属于三种不同收件人类别之一。

- 标识字段：包含有助于识别消息的信息。

- 信息字段：包含可选信息，以帮助收件人更清楚消息的内容。

- 重发字段：用于在重发消息时保留原始发件人、目的地和其他字段。

- 跟踪字段：用于显示邮件在传输时所采用的路径。

此外，该格式还允许指定其他用户定义的字段，只要它们符合标准的“<header name>: <header value>”语法即可。这可用于提供各种附加信息。例如，有时电子邮件客户端软件会包含一个标题行，指示用于撰写和发送邮件的软件的名称和版本。我们还将看到 MIME 使用新的标题行来编码有关 MIME 消息的信息。

**关键概念：**每个 RFC 822 消息都以一组标头开头，这些标头携带有关消息的基本信息。这些标头用于管理消息的处理和解释方式，还描述了消息正文的内容。每个标头由一个标头名称和一个标头值组成。有十几种不同的标准 RFC 822 标头，它们被组织成组；也可以定义自定义用户标头。

<u>**通用标题字段组和标题字段**</u>

表 240 描述了 TCP/IP 电子邮件消息中的标头字段及其使用方式：


​                                                              **表 240：RFC 822 电子邮件标题字段组和字段**

![image-20221121171721657](C:\Users\zy\AppData\Roaming\Typora\typora-user-images\image-20221121171721657.png)

![image-20221121171740177](C:\Users\zy\AppData\Roaming\Typora\typora-user-images\image-20221121171740177.png)

![image-20221121171758907](C:\Users\zy\AppData\Roaming\Typora\typora-user-images\image-20221121171758907.png)



###### 4.2.3.3.1-3 TCP/IP 电子邮件 RFC 822 标准消息格式处理和解释（部分：1 2）

定义 SMTP 的标准将协议描述为负责传输邮件对象。邮件对象被描述为由两个部分组成：消息和信封。信封包含完成消息传输所需的所有信息；消息是我们在上两个主题中看到的电子邮件消息中的所有内容，包括消息头和正文。

这些之间的区别在技术上很重要。就像邮政服务在决定如何处理一封信时只看信封而不看里面的内容一样——请不要开玩笑！ J—SMTP 在决定如何发送消息时同样只查看信封。出于基本传输目的，它不依赖于实际消息本身中的信息。

所以从技术上讲，信封与邮件标题不同。但是，正如您通过查看电子邮件标头列表可以看出的那样，每封邮件都包含收件人和邮件传输所需的其他信息。出于这个原因，通常会为电子邮件消息指定足够的标头信息，以至于它本身可以被认为足以完成自己的传递。电子邮件软件可以处理和解释消息以构建必要的“信封”，以便 SMTP 将消息传输到其目标邮箱。在描述 SMTP 邮件传输的主题中更详细地讨论了电子邮件与其信封之间的区别。

<u>**RFC 822 消息处理序列**</u>

由于简单的 RFC 822 消息格式，RFC 822 消息的处理相对简单。完整电子邮件的创建首先由创建邮件的用户创建邮件正文和某些标题。每当软件程序“处理”消息时，都会检查标题，以便程序可以确定如何处理它。还会根据需要添加和更改其他标头。

以下是在邮件标头的“生命周期”中发生的事件序列。

<u>**邮件编辑**</u>
邮件的人类撰写者编写邮件正文，并告知电子邮件客户端程序用于某些重要标题字段的值。这些包括预期的收件人、邮件主题和其他信息字段，以及某些可选的标题，例如回复字段。

<u>**发件人客户端处理**</u>
电子邮件客户端处理消息，将人类提供的信息放入适当的标题表单中，并创建初始电子邮件消息。此时，它会在消息中插入某些标头，例如原始日期。客户端还分析预期的收件人列表以创建用于使用 SMTP 传输邮件的信封。

<u>**SMTP 服务器处理**</u>
SMTP 服务器在转发邮件时不会注意邮件中的大部分字段。但是，它们会在传输消息时添加某些标头，尤其是跟踪标头，例如 Received 和 Return-Path。这些通常放在消息的开头，以确保不会重新排列或修改现有的标头。

但是请注意，当在电子邮件系统之间完成网关时，某些标头实际上必须更改，以确保消息与非 TCP/IP 电子邮件软件兼容。

**收件人客户端处理**
当邮件到达目的地时，收件人的 SMTP 服务器可能会添加标头以指示收到邮件的日期和时间。

<u>**收件人访问**</u>
当消息的接收者使用客户端软件时，可选择通过邮件访问协议（如 POP3 或 IMAP），该软件会分析邮箱中的每条消息。这使软件能够以对人类用户有意义的方式显示消息，并且还可以允许选择要检索的特定消息。

例如，我们大多数人都喜欢看到新收到邮件的摘要列表，显示发件人、邮件主题以及邮件的接收日期和时间，这样我们就可以决定要先阅读哪些邮件，哪些邮件要推迟阅读稍后，以及不阅读就删除的内容（垃圾邮件垃圾邮件……J）

RFC 822 定义邮件得消息格式，不是smtp 协议消息格式。类似定义http 文件协议得结构和规范



###### 4.2.3.3.2 TCP/IP 增强型电子邮件消息格式：多用途 Internet 邮件扩展 (MIME)

RFC 822 电子邮件消息格式是 TCP/IP 互联网络中电子邮件交换的标准。它使用简单的 ASCII 文本使得创建、处理和阅读电子邮件消息变得容易，这对电子邮件作为全球通信方式的成功做出了贡献。

不幸的是，虽然 ASCII 文本非常适合编写简单的备忘录和其他短消息，但它没有提供支持其他类型通信的灵活性。为了允许电子邮件以使用 ASCII 以外的字符集的语言携带多媒体信息、任意文件和消息，创建了多用途 Internet 邮件扩展 (MIME) 标准。

在本节中，我将描述 MIME 以及它如何用于现代电子邮件消息传递。我首先概述 MIME 并讨论它的历史和定义它的标准。我描述了两个总体 MIME 消息结构，并提供了重要的 MIME 特定标头的摘要。然后，我将更详细地解释重要的 MIME Content-Type 标头，并讨论 MIME 离散媒体类型、子类型和参数。我讨论了更复杂的 MIME 多部分和封装消息结构，然后讨论了将数据编码为 MIME 消息体的不同方法。我以特殊的 MIME 扩展结束，以允许在普通电子邮件标题中支持非 ASCII 字符。

**背景信息：**MIME 是一种消息格式，它增强了基本的 RFC 822 消息格式，而不是取代它。本节假定您基本熟悉 RFC 822 格式和更重要的电子邮件消息头。


注意：虽然 MIME 是专门为邮件开发的，但它的编码和数据表示方法已被证明非常有用，以至于它也被其他应用程序协议所采用。其中最著名的协议之一是超文本传输协议 (HTTP)，它使用 MIME 标头来指示正在传输的数据的特征。 MIME 的某些元素实际上不是为电子邮件开发的，而是为 HTTP 或其他协议开发的，我在适当的地方指出了这一点。但是请注意，HTTP 仅使用 MIME 元素；有重要的区别，并且 HTTP 消息不符合 MIME。




###### 4.2.3.3.2-1 MIME 消息格式概述、动机、历史和标准（部分：1 2 3）

我在本指南的“网络基础”一章中描述了通用标准为何重要的原因，并在许多其他地方也再次强调了这一点。大多数协议之所以成功，是因为它们基于被广泛接受的开放标准。 RFC 822 电子邮件消息格式标准就是一个很好的例子；每天有数百万人使用它来发送和接收 TCP/IP 电子邮件。

然而，标准的成功是有代价的：对这些标准的依赖。一旦标准被广泛使用，就很难对其进行修改，即使时代发生变化并且这些标准不再足以满足现代计算的要求也是如此。同样不幸的是，RFC 822 电子邮件消息格式也是一个很好的例子。

<u>**MIME 的动机**</u>
TCP/IP 电子邮件是在 1960 年代和 70 年代开发的。与当今计算机和网络世界的方式相比，当时几乎所有东西都很小。网络很小；用户数量少；联网主机的计算能力很小；网络连接容量小；网络应用数量少。 （当时唯一不小的是计算机本身的大小！）

因此，对电子邮件消息传递的要求也相当……小。当时大多数计算机输入和输出都是基于文本的，因此 SMTP 和 RFC 822 标准的创建者自然会将电子邮件设想为严格的文本媒体。因此，他们指定 RFC 822 来传送文本消息。

初出茅庐的互联网也是在美国境内发展起来的，起初整个互联网都在美国境内。大多数美国人都说英语，您可能知道这种语言使用的字符数量相对较少，但使用 ASCII 字符集可以很好地表示这些字符。定义电子邮件消息格式以支持美国 ASCII (US-ASCII) 在当时也很有意义。

然而，随着计算机的发展，它们从严格的文本模型转向图形操作系统。不出所料，用户开始对发送的不仅仅是文本感兴趣。他们希望能够传输图表、非 ASCII 文本文档（如 Microsoft Word 文件）、二进制程序文件，以及最终的多媒体信息：数码照片、MP3 音频剪辑、幻灯片演示、电影文件等等。此外，随着 Internet 的发展和全球化，其他国家也“上线”了，其中一些使用的语言根本无法用 US-ASCII 字符集表达。

不幸的是，至此，命运已成定局。 RFC 822 被广泛使用，改变它也意味着改变 SMTP、POP 和 IMAP 等协议的工作方式，这些协议在数百万台机器上运行。然而到了 80 年代后期，很明显纯 ASCII 电子邮件的局限性是一个必须解决的大问题。需要一个解决方案，它以多用途 Internet 邮件扩展 (MIME) 的形式出现。

**注意：**MIME 通常以单数形式提及，正如我从这里开始所做的那样，即使它是复数术语的缩写。

<u>**MIME 能力**</u>

MIME 背后的想法既聪明又优雅——这意味着我喜欢它！ RFC 822 将电子邮件消息限制为 ASCII 文本，但这并不意味着我们不能为 ASCII 文本的创建方式定义更具体的结构。我们可以使用 ASCII 文本字符实际编码非文本信息（通常称为附件），而不是让用户键入 ASCII 文本消息。使用这种技术，MIME 允许常规的 RFC 822 电子邮件消息携带以下内容：

- 非文本信息，包括图形文件、多媒体剪辑和我之前列出的所有其他非文本数据示例；

- 任意二进制文件，包括可执行程序和以专有格式存储的文件（例如，AutoCAD 文件、Adobe Acrobat PDF 文件等）；

- 使用 ASCII 以外的字符集的短信。这甚至包括在 RFC 822 电子邮件消息的标头中使用非 ASCII 字符的能力。

MIME 甚至更进一步，它实际上定义了一种结构，允许将多个文件编码到单个电子邮件消息中，包括不同类型的文件。例如，从事预算分析的人员可以发送一封电子邮件，其中包括文本消息、Powerpoint 演示文稿和包含预算数字的电子表格。这种能力极大地扩展了电子邮件在 TCP/IP 中的用途。

所有这些都是通过将非 ASCII 文件和信息转换为 ASCII 形式的特殊编码规则来实现的。标题被添加到消息中以指示信息的编码方式。然后可以像任何其他消息一样通过系统发送编码消息。 SMTP 和其他处理邮件的协议不关注邮件正文，因此它们甚至不知道使用了 MIME。

电子邮件软件所需的唯一更改是在电子邮件客户端程序中添加对 MIME 的支持：发件人和收件人都必须支持 MIME 以对消息进行编码和解码。最初开发 MIME 时，对 MIME 的支持并不广泛，但这项技术的价值如此之大，以至于如今几乎所有电子邮件客户端软件都采用了它。此外，今天的大多数客户端还可以使用 MIME 标头中的信息来解码非文本信息，并将其传递给适当的应用程序以呈现给用户。

**关键概念：**使用 RFC 822 消息格式可确保所有设备都能读取彼此的电子邮件消息，但它有一个关键限制：它仅支持纯 ASCII 文本。这不足以满足现代互联网的需求，但对 RFC 822 标准的依赖会使替换它变得困难。相反，定义了一个称为多用途 Internet 邮件扩展 (MIME) 的新标准。 MIME 指定了几种方法，允许电子邮件消息包含多媒体内容、二进制文件和使用非 ASCII 字符集的文本文件，同时仍然遵循 RFC 822 消息格式。 MIME 还允许在单个邮件中发送多个文件或内容片段，从而进一步扩展了电子邮件的灵活性。

<u>**MIME 标准**</u>

1992 年 6 月发布的一组两个标准 RFC 1341 和 RFC 1342 中首次描述了 MIME。这些标准在 1993 年 9 月由 RFC 1521 和 1522 更新。1994 年 3 月发布了补充标准 RFC 1590，其中规定了 定义新 MIME 媒体类型的过程。

MIME 的工作一直持续到 90 年代中期，1996 年 11 月标准再次修订。 这一次，这些文件被完全重组并作为一组 5 个单独的标准发布。 这样做是为了提高信息的可读性。 这些标准如表 241 所示。


​                                                               **表 241：多用途 Internet 邮件扩展 (MIME) 标准**

| **RFC Number** | **Name**                                                     | **Description**                                              |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **2045**       | *多用途 Internet 邮件扩展 (MIME) 第一部分：Internet 邮件正文的格式* | 描述 MIME 背后的基本概念和 MIME 消息的结构。                 |
| **2046**       | *多用途 Internet 邮件扩展 (MIME) 第二部分：媒体类型*         | 解释 MIME 媒体类型和子类型的概念，并描述其编码在 MIME 标准中定义的一些媒体类型。 |
| **2047**       | *MIME（多用途因特网邮件扩展）第三部分：非 ASCII 文本的消息头扩展* | 描述如何修改 RFC 822 标头以携带非 ASCII 文本。               |
| **2048**       | *多用途 Internet 邮件扩展 (MIME) 第四部分：注册程序*         | 讨论组织如何注册其他媒体类型以用于 MIME。                    |
| **2049**       | *多用途 Internet 邮件扩展 (MIME) 第五部分：一致性标准和示例* | 提供额外的实施信息和如何使用 MIME 的示例。                   |

自从这五个“主要”MIME 标准问世以来，已经发布了许多其他 RFC。 它们定义了对 MIME 本身的各种扩展，包括附加的 MIME 标头类型和新的媒体类型。 值得注意的示例是 RFC 2183 和 2557，它们分别定义了 MIME Content-Disposition 和 Content-Location 标头。 其他一些 MIME 功能实际上被定义为使用 MIME 的其他技术的一部分； 例如，第一个 HTTP 标准 RFC 1945 定义了 Content-Length 标头。 许多其他 RFC 定义了新的媒体类型/子类型，这里无法一一列举。



###### 4.2.3.3.2-2 MIME 基本结构和标题（部分：1 2 3 4）

多用途 Internet 邮件扩展 (MIME) 标准的创建者面临着艰巨的挑战：当 RFC 822 规定它们必须仅由 ASCII 文本组成时，如何为电子邮件中包含的数据类型带来灵活性.为实现这一目标，他们必须利用现有 RFC 822 中已经加入的灵活性领域。

有两个这样的“机会”。首先是 RFC 822 消息体允许包含任何类型的 ASCII 文本，只要行不超过 998 个文本字符并且每行以“CRLF”控制代码组合结尾。尽管 RFC 822 的创建者自然而然地假设此 ASCII 文本是人类可读的，但没有什么能阻止它成为机器可读的代码。第二个是 RFC 822（以及使用它的协议，例如 SMTP）中内置的工具，允许将自定义的“用户定义”标头字段添加到任何电子邮件消息中。

RFC 822 消息体的非特定性质构成了 MIME 本身如何工作的基础。支持 MIME 标准的电子邮件客户端使用特殊的编码算法将非 ASCII 信息转换为 ASCII 形式。然后它将这组编码的 ASCII 字符放入消息正文中，就好像它是由用户使用两种特殊结构之一键入的一样。

向 RFC 822 添加新标头的能力用于将有关 MIME 使用的信息从发件人传递给收件人。传输 MIME 消息的设备不关心是否使用了 MIME，因为它们不关注消息正文的内容。但是，当邮件到达目的地时，收件人的电子邮件客户端程序必须通过某种方式知道使用了 MIME，并且还必须告知邮件中的信息是如何编码的。否则，它可能只是将编码后的非 ASCII 数据作为 ASCII 文本呈现给用户（这看起来像是随机的乱码！）

<u>**基本结构类型**</u>

在邮件正文中对数据进行编码并包含 MIME 标头的确切方法取决于 MIME 邮件的整体结构。有两种基本结构类型，根据消息携带的媒体种类进行描述：

- 简单结构（离散媒体）：携带单个离散媒体类型（如文本消息或图形图像）的 MIME 消息使用简单结构。消息正文中只存在一种信息编码。

- 复杂（复合媒体）结构：一些 MIME 消息带有复合媒体类型，它允许在单个消息中包含多种不同的媒体，例如文本消息和图形图像，或者将另一封电子邮件消息完整地封装起来.其中许多使用更复杂的结构，其中邮件正文包含多个 MIME 正文部分。

<u>**MIME实体**</u>
总的来说，整个 MIME 消息和各个正文部分都称为 MIME 实体。每组 MIME 标头都提供有关任一类型的 MIME 实体的信息：作为一个整体的 MIME 消息，或复合消息中的正文部分。收到 MIME 消息时，收件人首先检查整个消息中的标头（RFC 822 标头）以确定整体消息类型。然后这表明消息使用的是简单结构还是复杂结构。如果是后者，则解析消息正文并单独解释每个单独的正文部分，包括其个性化的标头。有关复合媒体类型的主题包含有关如何格式化这些正文部分的更多详细信息。

<u>**主要 MIME 标头**</u>

五个主要 MIME 标准中的第一个，RFC 2045，描述了一组五个主要 MIME 标头，这些标头传达有关每个 MIME 实体（消息或正文部分）内容的基本信息。

<u>**MIME 版本**</u>
每个 MIME 消息都需要有一个 MIME-Version 标头，它有两个用途。首先，它将电子邮件消息标识为 MIME 编码的。其次，即使到目前为止只定义了一个版本的 MIME，拥有版本号标头可以提供“面向未来”，以防以后创建的新版本可能与当前版本存在一些不兼容。现在，所有 MIME 消息都使用 1.0 版。

这是唯一适用于整个邮件的 MIME 标头；它不用于标记单个 MIME 正文部分。这很容易记住，因为它是唯一一个名称不以“Content-”开头的标头。

<u>**内容类型**</u>
描述在 MIME 实体中编码的数据的性质。此标头指定内容类型和内容子类型，它们由斜杠字符分隔。它也可以选择包含某些参数，这些参数传达有关类型和子类型的附加信息。在邮件正文中，此标头告诉电子邮件的收件人它包含哪种媒体，以及正文是使用简单结构还是复杂结构。在正文部分，它描述了正文部分包含的媒体类型。

例如，包含 HTML 文档的消息可能具有“text/html”的 Content-Type 标头，而包含 JPEG 图形文件的消息可能被指定为“image/jpeg”。对于复合 MIME 类型，整个消息的 Content-Type 标头将包含诸如“multipart/mixed”或“multipart/alternative”之类的内容，并且每个正文部分将包含单独的 Content-Type 标头，例如“text/html”或“图像/jpeg”。这些都将在接下来的两个主题中详细讨论。

此标头是可选的。如果不存在，则假定为常规 US-ASCII 文本消息的默认值（常规 RFC 822 消息的媒体类型）。

<u>**内容传输编码**</u>
对于使用简单结构的消息，指定用于对消息正文中的数据进行编码的特定方法；对于复合消息，标识每个 MIME 正文部分的编码方法。对于已经是ASCII形式的数据，不需要特殊编码，但其他类型的数据必须转换成ASCII形式才能传输。此标头告诉接收者如何将数据解码回其正常表示形式。 MIME 编码方法将在本节后面介绍。

这个标题是可选的；如果不存在，则默认值为“7bit”编码，这也是常规 ASCII 的编码。

<u>**内容ID**</u>
允许为 MIME 内容分配特定的标识代码。此标头类似于 RFC 822 Message-ID 标头字段，但特定于 MIME 内容本身。它是可选的，最常用于多部分 MIME 消息中的正文部分。

<u>**内容描述**</u>
这是一个可选的标头，允许将任意附加文本描述与 MIME 实体相关联。在多部分消息中，每个正文部分都可能被赋予一个描述标题，以向收件人清楚这些部分代表什么。

<u>**额外的 MIME 标头**</u>

除了上述五个基本标头之外，MIME 标准还允许定义其他标头。唯一的限制是它们都必须以单词“Content-”开头，这再次明确地将它们标记为描述 MIME 实体（消息或正文部分）的内容。显然，发件人和收件人都必须支持自定义标头才能发挥作用。

实际上已经在各种 Internet RFC 中创建并记录了几个新的 MIME 标头。有些实际上不是专门为电子邮件消息使用而设计的，而是供其他使用 MIME 技术的协议使用，例如超文本传输协议 (HTTP)。这是三个值得注意的。

<u>**内容处置**</u>
在多部分 MIME 消息中，可以将此标头提供给 MIME 正文部分以控制信息如何呈现给用户。两个最常见的值是“inline”和“attachment”，前者表示内容将与其他正文部分一起自动显示，后者表示内容与主文档分开。此标头在 RFC 2183 中定义。

<u>**内容位置**</u>
允许使用统一资源标识符 (URI) 标识 MIME 正文部分的位置。当使用 MIME 多部分消息将 HTML 和其他支持多媒体的文档格式编码到电子邮件中时，有时会用到它。它在 RFC 2557 中定义。

<u>**内容长度**</u>
以字节为单位指定 MIME 实体的长度。该头部在MIME 的电子邮件应用中不常用，但在HTTP 中是一个重要的头部。它在 HTTP 标准中进行了描述，首次出现在 RFC 1945 中。

**关键概念：**MIME 通过以 ASCII 格式对非 ASCII 数据进行编码，并通过添加描述该数据及其解释方式的特殊标头，为电子邮件消息中携带的信息提供了灵活性。最重要的 MIME 标头是 Content-Type，它描述了消息中的数据类型，以及 Content-Transfer-Encoding，它指定了数据的编码方式。 MIME 支持两种基本的整体格式：简单结构，在消息中编码单一类型的离散媒体；复杂的结构，它编码了一种可以携带多种信息的复合媒体类型。



###### 4.2.3.3.2-3 MIME 内容类型标头和离散媒体：类型、子类型和参数（部分：1 2 3 4 5）

MIME 将 TCP/IP 电子邮件从单调、纯文本的 RFC 822 世界转变为可以承载多种数据类型的丰富通信方法。它通过使用特殊技术将各种信息编码为 ASCII 文本形式来实现这一点，例如图形图像、声音文件、视频剪辑、应用程序、压缩数据文件等等。我们通常将这些称为不同类型的媒体，而 MIME 使用相同的术语来描述它们。

由于 MIME 支持多种媒体，因此每条消息都必须包含描述其内容的信息，以允许对消息内容进行准确解码。这是重要的 MIME Content-Type 标头的功能。

<u>**内容类型标头语法**</u>
标头的语法如下：

```
Content-Type: <type>/<subtype> [; parameter1 ; parameter2 .. ; parameterN ]
```

这些不同元素的目的是以从一般到特定的方式描述 MIME 实体中的媒体。第一个元素“<type>”称为顶级媒体类型，描述了数据的整体形式。例如，它指示 MIME 实体是否包含文本、图像、音频等。第二个元素“<subtype>”提供有关数据形式或格式的特定信息。例如，JPEG 图片和 GIF 图片都是图片，只是格式不同。 “<type>”和“<subtype>”在 Content-Type 标头中都是必需的。

在这些元素之后可能会出现一个或多个参数，这些参数通常是可选的，但对于某些媒体类型可能是必需的。这些在需要时提供了更详细的数据性质规范。每个参数前面都有一个分号，表示为属性/值对，由“=”符号分隔，如下所示：

```
; attribute=value
```

如何使用参数的一个示例是在文本消息中指定字符集。 “常规”RFC 822 ASCII 文本的表示如下：

```
Content-type: text/plain; charset=“us-ascii”
```

顶级媒体类型是“text”，子类型是“plain”，所以这表示纯文本消息。参数“charset”指定消息使用美国 ASCII 字符集。参数的另一个常见用途是指定附件的名称，如下所示：

```
Content-type: image/jpeg; name=“ryanpicture.jpg”
```

<u>**离散媒体类型和子类型**</u>

正如我在前面的主题中提到的，MIME 支持两种基本结构：简单结构或复杂结构。一条简单的消息只携带一种媒体类型，例如一段文本、一张图片或一个可执行文件。这些在 MIME 中称为离散媒体类型。复杂的消息携带复合媒体类型，它可能包含多个正文部分。每个主体部分依次携带与一种离散媒体类型相对应的数据。顶层媒体类型表示整条消息携带的是离散媒体类型还是复合类型；我将在这里描述离散的媒体类型；复合类型将在下一个主题中讨论。

RFC 2046 标准（描述 MIME 的五个标准集的第二部分）定义了五种离散的顶级媒体类型：文本、图像、音频、视频和应用程序；它们各自代表通常通过 TCP/IP 传输的主要数据类别之一。其中每一种都有一个或多个子类型，有些还具有用于提供有关它们的更多信息的参数。

MIME 的创建者认识到该标准无法描述所有媒体类型，并且将来会创建新的媒体类型。 RFC 2048（五个标准 MIME 集的第四部分）描述了可以描述新媒体类型、子类型和参数并向 Internet 编号分配机构 (IANA) 注册的过程。

到目前为止，只创建了一种新的顶级媒体类型；这是模型顶级类型，为 CAD 建模文件和类似用途定义，如 RFC 2077 中所述。然而，多年来已经创建了许多新的子类型，其中一些在 RFC 中指定，而另一些则直接在 IANA 中注册。这包括许多“特定于供应商”的子类型，这些子类型通常由前缀“x-”或“vnd”标识。在子类型名称中。

**internet：**您可以在 IANA 的网站上找到按顶级媒体类型组织的 MIME 媒体的完整列表：http://www.iana.org/assignments/media-types/index.html

**关键概念**：MIME Content-Type 标头指定在 MIME 消息中编码的数据类型。标头通过顶级媒体类型指示消息内容的一般形式，并通过子类型的规范指示数据的更具体性质。它还可能包含提供有关内容的更多信息的可选参数。

<u>**常见的离散媒体类型和子类型**</u>

现在确实有数百种类型/子类型组合，我不会尝试全部列出，但会简要描述六种 MIME 离散顶级媒体类型。 对于每一种，都提供了一个表格，显示一些更常见的 MIME 子类型，让您了解“外面”是什么。 这包括每个子类型的描述和对其定义位置的引用。

<u>**文本媒体类型（文本）**</u>
此类型用于发送主要为文本形式的数据（表 242）。


​                                                                         **表 242：MIME 文本媒体类型子类型**

| **type/subtype**     | **Description**                                              | **Defining Source** |
| -------------------- | ------------------------------------------------------------ | ------------------- |
| ***text/plain\***    | 纯文本，用于常规消息，例如那些对应于初始 RFC 822 标准的消息。 | RFC 2046            |
| ***text/enriched\*** | 包含格式信息或其他使其不再“简单”的“丰富”的文本。             | RFC 1896            |
| ***text/html\***     | 以超文本标记语言 (HTML) 表示的文档，通常用于万维网。         | RFC 2854            |
| ***text/css\***      | 万维网的级联样式表信息。                                     | RFC 2318            |

<u>**图像媒体类型（图像）**</u>
图像类型表示图形图像文件，例如图片。 子类型通常指示允许接收者正确解码和呈现文件的特定格式，表 243 中给出了一些更常见的子类型。


​                                                                            **表 243：MIME 图像媒体类型子类型**

| **type/subtype**                                   | **Description**                | **Defining Source**                      |
| -------------------------------------------------- | ------------------------------ | ---------------------------------------- |
| ***image/jpeg\***                                  | JPEG 格式的图像。              | RFC 2046                                 |
| ***image/gif\***                                   | 图形交换格式 (GIF).image。     | (IANA says RFC 2046 but it’s not there…) |
| ***image/tiff\***                                  | 标记图像文件格式 (TIFF) 图像。 | RFC 2302                                 |
| ***image/vnd.dwg, image/vnd.dxf, image/vnd.svf\*** | AutoCAD 中使用的矢量图像。     | Registration with IANA                   |

<u>**音频媒体类型（音频）**</u>

此媒体类型用于发送音频信息。 子类型通常表示特定格式，表 244 显示了几个常用值。


​                                                                            **表 244：MIME 音频媒体类型子类型**

| **type/subtype**   | **Description**                                              | **Defining Source** |
| ------------------ | ------------------------------------------------------------ | ------------------- |
| ***audio/basic\*** | 主要 MIME 标准中定义的“基本”音频类型。它描述了使用 8000 Hz 的 8 位 ISDN mu-law PCM 编码的单通道音频。 | RFC 2046            |
| ***audio/mpeg\***  | MPEG 标准音频（包括流行的 MP3 文件格式）。                   | RFC 3003            |



<u>**视频媒体类型（视频）**</u>
该类型用于发送视频信息。 同样，子类型通常指示特定格式（表 245）。


​                                                                            **表 245：MIME 视频媒体类型子类型**

| **type/subtype**       | **Description**                                              | **Defining Source**    |
| ---------------------- | ------------------------------------------------------------ | ---------------------- |
| ***video/mpeg\***      | 编码为 MPEG 数字视频标准的视频。                             | RFC 2046               |
| ***video/dv\***        | 数字视频对应于多种流行标准，包括 SD-VCR、HD-VCR 和 DVB，供各种类型的视频设备使用。 | RFC 3189               |
| ***video/quicktime\*** | Apple 的 Quicktime 电影格式。                                | Registration with IANA |

<u>**模型媒体类型（模型）**</u>
此类型描述模型表示，例如二维或三维物理模型（表 246）。


​                                                                           **表 246：MIME 模型媒体类型子类型**

| **type/subtype**  | **Description**                            | **Defining Source**    |
| ----------------- | ------------------------------------------ | ---------------------- |
| ***model/mesh\*** | 用于建模的网格。                           | RFC 2077               |
| ***model/vrml\*** | 虚拟现实建模语言 (VRML) 模型。             | RFC 2077               |
| ***model/iges\*** | 对应于初始图形交换规范 (IGES) 的模型文件。 | Registration with IANA |

<u>**应用媒体类型（应用）**</u>

这种媒体类型“包罗万象”，适用于不属于上述类别之一的任何类型的数据，或者本质上是特定于应用程序的数据。子类型通过指示使用它的应用程序的种类来描述数据。这可用于指导收件人的电子邮件程序选择合适的应用程序来显示它，就像 Windows 中的文件扩展名告诉操作系统如何打开不同类型的文件一样。

例如，如果您的 PC 上安装了 Microsoft Excel，单击以“.XLS”结尾的文件将自动启动 Excel。同样，Excel 电子表格通常使用 MIME 发送，媒体类型为 application/vnd.ms-excel。这会告诉收件人的电子邮件程序启动 Excel 来读取此文件。

由于那里有如此多的应用程序，因此在这个顶级类型中有一百多种不同的子类型。表 247 包含一些代表性样本。


​                                                                   **表 247：MIME 应用媒体类型子类型**

| **type/subtype**                     | **Description**                                              | **Defining Source**    |
| ------------------------------------ | ------------------------------------------------------------ | ---------------------- |
| ***application/octet-stream\***      | 一组任意的二进制数据八位字节。请参阅下面的更多细节。         | RFC 2046               |
| ***application/postscript\***        | Postscript 文件，用于打印和生成 Adobe Acrobat (PDF) 文件。   | RFC 2046               |
| ***application/applefile\***         | 表示 Apple Macintosh 文件的资源文件信息。                    | Registration with IANA |
| ***application/msword\***            | 微软 Word 文档。请注意，它不像大多数其他 Microsoft 文件类型那样具有“vnd”前缀。 | Registration with IANA |
| ***application/pdf\***               | 由 Adobe Acrobat 创建的便携式文档格式 (PDF) 文件。           | Registration with IANA |
| ***application/vnd.framemaker\***    | Adobe FrameMaker 文件。                                      | Registration with IANA |
| ***application/vnd.lotus-1-2-3\***   | Lotus 1-2-3 文件。                                           | Registration with IANA |
| ***application/vnd.lotus-notes\***   | Lotus Notes 文件。                                           | Registration with IANA |
| ***application/vnd.ms-excel\***      | Microsoft Excel 电子表格文件。                               | Registration with IANA |
| ***application/vnd.ms-powerpoint\*** | Microsoft Powerpoint 演示文稿文件。                          | Registration with IANA |
| ***application/vnd.ms-project\***    | 一个微软项目文件。                                           | Registration with IANA |
| ***application/zip\***               | 包含一个或多个其他文件的压缩存档文件，使用 ZIP/PKZIP 压缩格式。 | Registration with IANA |

其中，有一个值得进一步提及的特殊子类型：application/octet-stream 子类型。这是应用程序类型“catch all”中的“catch all”，仅表示文件是任意二进制数据序列。它通常在发送方不确定数据采用何种形式或无法将其识别为属于特定应用程序时使用。使用此类型时，通常会提示收件人将数据保存到文件中。然后，他或她必须弄清楚要使用什么应用程序来阅读它。

application/octet-stream MIME 类型/子类型甚至可以用于未知格式的图像、音频或视频。如果您尝试发送您的发送程序不理解的多媒体文档，它通常会将其编码为 application/octet-stream 进行传输。这是您的电子邮件程序对收件人说“我按原样向您发送此文件，您知道如何处理它”的方式。

这种应用程序/八位字节流类型也经常用于传输可执行文件（程序），尤其是在 Windows 系统上。不幸的是，虽然方便，但这可能是一个严重的安全隐患。近年来，Internet 受到源源不断的病毒和蠕虫的影响，这些病毒和蠕虫通过电子邮件中的可执行文件附件将自己发送给其他用户来传播。这使得打开和运行任何未知的应用程序/八位字节流附件具有潜在危险。



###### 4.2.3.3.2-4 MIME 复合媒体类型：多部分和封装的消息结构（部分：1 2 3 4 5 6）

MIME 离散媒体类型允许 MIME 表示电子邮件中数百种不同类型的数据。仅此一项就可以使 MIME 成为一项非常有用的技术，但 MIME 标准通过定义复合媒体类型更进了一步。这些允许 MIME 执行更多“壮观的壮举”，例如一次发送多种类型的数据，或将其他消息或信息封装到电子邮件中。

MIME 复合媒体类型的使用通过 RFC 822 消息的 Content-Type 标头指示。使用以下两种复合媒体类型之一，而不是六种离散媒体类型（文本、图像、音频、视频、模型和应用程序）中的一种：

- 多部分媒体类型 (multipart)：允许在单个 MIME 消息中发送一组或多组数据。每条数据都表示为单独的离散媒体类型。

- Message Media Type（消息）：允许一条消息封装另一条消息。这可能是之前发送的另一封电子邮件，或其他类型的邮件。这种媒体类型还为发送部分消息和其他特殊类型的通信提供了灵活性。

**关键概念：**有两种 MIME 复合媒体类型：消息，它允许一条消息封装另一条消息；多部分，它允许将多个单独的媒体类型编码到单个电子邮件消息中。

<u>**MIME 多部分消息类型**</u>

多部分媒体类型是两者中更常见的一种，并且有充分的理由：它是一种非常强大的机制。它允许一条消息包含可以以不同方式使用的多种不同类型的信息。每条数据都单独编码为 MIME 正文部分，然后将这些部分组合到一封电子邮件中。如何使用这些部分取决于消息的语义，这由 MIME 子类型指示。 RFC 2046 描述了其中的几个，上一个主题中描述的 IANA 注册方案也定义了一些新的。

<u>**MIME 多部分消息子类型**</u>
以下是最常见的多部分媒体子类型，以及它们的使用方式。前四个在 RFC 2046 中定义，其他的如下所示：

- multipart/mixed：表示正文部分并不真正相关，只是为了方便而被捆绑在单个消息中进行传输。例如，这可能会被某人用来发送办公室备忘录和假期快照，只是为了好玩。当部分相关但关系以某种其他方式传达给接收者时（例如在不同的身体部分中的描述），有时也会使用此子类型。

- multipart/alternative：指定正文部分是相同信息的替代表示。接收者解码部分并选择最适合他或她需要的部分。它的一个常见用途是发送 HTML 编码的电子邮件。一些电子邮件客户端无法显示 HTML，因此发送包含 HTML 和纯文本格式消息的多部分/替代消息是有礼貌的。

- 备选方案应按偏好的递增顺序放置在消息中，这意味着首选格式排在最后。在包含纯文本和富文本替代方案的文档的情况下——例如上面的文档的纯文本和 HTML 版本的示例——最简单的格式应该放在第一位，“最奇特”的放在最后。

- multipart/parallel：告诉接收者身体部位应该同时显示（“平行”）。这可能如何使用的一个例子是，如果有人发送了一个音频剪辑和解释性文本，以便在播放时与它一起显示。

- multipart/digest：这用于允许消息携带摘要，例如其他电子邮件消息的集合。

- multipart/related：具体表示body各部分是相互关联的。特殊参数用于提供有关如何解释它们的更多信息。此子类型在 RFC 2387 中定义。

- multipart/encrypted：用于加密数据。第一个正文部分包含有关如何解密数据的信息，第二个包含数据本身。此子类型在 RFC 1847 中定义。

<u>**大部分消息编码**</u>

您可以从这些不同的子类型中看出多部分类型为 MIME 提供了多少灵活性，还有其他的。在所有情况下，都使用相同的语法将组成的正文部分编码为单个消息。基本流程如下：

1. 每个单独的数据片段都被处理，就好像它是作为离散媒体类型 MIME 消息的主体进行传输一样。这包括根据需要指定适当的标头，例如 Content-Type、Content-ID 和 Content-Transfer-Encoding。

2. 选择一个特殊的边界定界符来分隔正文部分。必须选择它，使其不会出现在身体的任何部位；有时使用随机字符串。当放置在消息中时，它会在前面加上两个破折号（“--”），以减少被误认为数据的机会。

3. 组合多部分消息。它由序言文本区域、边界线和第一正文部分组成。每个后续的身体部位都用另一条边界线与前一个分开。在最后一个正文部分之后，会出现另一条边界线，然后是结语文本区域。

4. 特殊参数 boundary 作为一个整体包含在消息的 Content-Type 头中，以告诉接收者什么模式分隔正文部分。

**关键概念：**MIME 多部分消息是通过首先处理每个单独的数据组件以创建 MIME 正文部分而形成的。每个都可以有不同的编码方法和一组标头，就好像它是一个单独的 MIME 消息一样。然后将这些正文部分组合成一个多部分消息，并用边界定界符分隔。分隔符的身份被插入到 Content-Type 标头的边界参数中，因此收件人可以在收到消息时轻松地将各个正文部分分开。

<u>**大部分消息结构**</u>

这些规则看起来相当复杂，但实际上并没有那么糟糕；一旦您看到了几个多部分消息，该结构就会有意义。为了帮助澄清，我提供了图 302，它以图形方式显示了多部分 MIME 消息的整体结构。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\mimemultipart.png)




​                                                              图 302：MIME 多部分消息结构

与所有邮件一样，MIME 多部分邮件由一组主标题和主体部分组成。在主体中有一个或多个主体部分，每个主体部分都有自己的主体部分特定的标题，后面是主体部分本身；每个身体部位都以蓝色显示。消息整体的Content-Type头（绿色高亮）表示消息类型是multipart，boundary参数指定分隔符的名称，这里就叫“Delimiter”（好无聊）这个分隔符用于将正文部分彼此分开，并与分别开始和结束消息正文的序言和尾声分开。

<u>**示例多部分消息**</u>

表 248 包含一个多部分消息的具体示例（部分被缩写以保持长度），因此您可以看到文本形式的样子。 （如果您想查看更多，您现在可能在自己的电子邮件收件箱中有几个！）


​                                                                 表 248：示例 MIME 多部分消息

```
From: Joe Sender <joe@someplace.org>
To: Jane Receiver <jane@somewhereelse.com>
Date: Sun, 1 Jun 2003 13:28:19 —0800
Subject: Photo and discussion
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="exampledelimtext123"

This is a multipart message in MIME format

—exampledelimtext123
Content-Type: text/plain

Jane, here is the photo you wanted me for the new client.
Here are some notes on how it was processed.
(Blah blah blah…)
Talk to you soon,
Joe.

—exampledelimtext123

Content-Type: image/jpeg; name="clientphoto.jpg"
Content-Transfer-Encoding: base64

SDc9Pjv/2wBDAQoLCw4NDhwQEBw7KCIoOzs7Ozs7Ozs
…
zv/wAARCADIARoDASIAAhEBAxEB/8QAHAAAAQUBA

—exampledelimtext123

(Epilogue)
```

在这个例子中，Joe 正在向 Jane 发送一条包含 JPEG 照片和一些解释性文本的多部分消息。消息的主标头指定了多部分/混合类型和“exampledelimtext123”的边界字符串。消息以前导码开头，收件人电子邮件客户端会忽略前导码，但人类读者可以看到。通常在此处放置一个字符串，例如本例中给出的字符串。这样，如果使用不支持 MIME 的客户端的人收到邮件，收件人将知道它是什么。

然后将第一个定界符字符串放在消息中，然后是第一个正文部分，即 Joe is sending Jane 的文本。这之前是正文部分所需的任何标头，在本例中为 Content-Type：text/plain。 （但是请注意，这是 MIME 中的默认设置，因此此处可以省略。）在文本消息之后是另一个分隔符，然后是第二个正文部分中的编码 JPEG 照片，带有自己的标题。最后，还有一个定界符，然后是结语的空格。如果存在，这将被忽略，并且通常根本不使用。

可以发送只有一个正文部分的“多部分”消息。有时这样做是为了利用前导区提供有关如何解码非文本媒体类型的信息。当然，这也可以通过将这样的文本解码指令作为主体部分来完成。

<u>**MIME 封装消息类型**</u>

另一种复合媒体类型是消息类型，专门用于将现有电子邮件消息封装在新消息正文中的特殊用途，或用于封装其他类型的消息。以下是 RFC 2046 中定义的子类型：

- message/rfc822：表示正文包含封装的电子邮件本身，其格式根据 RFC 822 标准。请注意，这并不一定意味着它是纯文本电子邮件。它可能是一个 MIME 消息（尽管在 MIME 中封装 MIME 必须小心完成......）

- message/partial：用于允许将较大的消息分割成稍后可以重新组合的片段。这在 RFC 2046 中有详细描述。

- message/external-body：表示消息正文实际上并不包含在消息本身中；相反，提供了实际身体所在位置的参考。必须提供足够的信息来定位真正的消息体。同样，这种“灵魂出窍”在 RFC 2046 中有所描述。（抱歉，忍不住！）



###### 4.2.3.3.2-5 MIME 内容传输编码标头和编码方法（部分：1 2 3）

创建 MIME 的主要原因之一是 RFC 822 标准对电子邮件中的数据必须如何格式化设置了重要限制。为遵循规则，消息必须以 US ASCII（一种 7 位数据表示法）进行编码。这意味着即使每个字节理论上可以有 256 个值中的任何一个，但在 ASCII 中只有 128 个值是有效的。此外，行不能超过 1000 个字符，包括末尾的回车符和换行符（“CRLF”），并且这两个字符不能出现在其他地方。

对于某些类型的数据，例如文本文件，这没什么大不了的，但对于其他类型的数据来说，这是一个严重的问题。对于二进制数据尤其如此。如果您查看视频剪辑或 MP3 文件或可执行程序中的数据，它看起来像是“随机乱码”。事实上，此类数据不是随机的，而是使用特定规则表示的，但数据以原始二进制形式表示，其中任何 8 位字节都可以包含 0 到 255 之间的任何值，这就是为什么它看起来像“垃圾”人类。更重要的是，这意味着此数据不遵循 RFC 822 文件的规则，无法以这种形式直接发送。

<u>**MIME 编码方法**</u>

要在 MIME 中发送非 ASCII 数据，必须对其进行编码。 Content-Transfer-Encoding 标头用于指定 MIME 消息或正文部分的编码方式，以便其接收者可以对其进行解码。定义了以下类型的编码：

- 7 位：这表示消息已经采用与 RFC 822 兼容的 ASCII 格式。这是默认设置，如果不存在 Content-Transfer-Encoding 标头，则采用这种格式。

- 8 位/二进制：这些同义值表示消息已直接以 8 位二进制形式编码。是的，我只是说这会违反 RFC 822 的规则。这些选项似乎已包含在内以支持未来直接传输二进制数据的机制。 RFC 1652 描述了一个 SMTP 扩展，部分讨论了这个问题：8 位 MIME 传输的 SMTP 服务扩展（原文如此，“MIME”和“传输”之间没有空格）。然而，标准明确表示这仍然不允许使用 SMTP 和 RFC 822 传输原始二进制数据。
- quoted-printable：这是一种特殊编码，当大部分数据是 ASCII 文本，但包含某些违反 RFC 822 规则的情况时使用。这些非法部分使用特殊编码规则转换，因此数据作为一个整体是与 RFC 822 一致。

- base64：一种用于允许以 ASCII 形式表示任意二进制数据的编码。然后数据以 ASCII 格式发送，并由接收方解码回二进制形式。

quoted-printable 和 base64 编码是最有趣的编码，因为它们允许使用 RFC 822 发送非 RFC-822 数据。

**关键概念：** MIME 支持四种编码方式：7bit、8bit（二进制）、quoted-printable 和base64。 7bit 编码是标准的 ASCII，用于文本； quoted-printable 编码用于主要是文本但有一些必须编码的特殊字符的输出； base64 用于任意二进制文件。 （8 位编码方法在 MIME 中定义，但不用于 RFC 822 消息。）

<u>**引用打印编码**</u>
当消息“大部分”是 ASCII 时使用这种编码方法；只有问题字节被编码。结果是在将大部分数据保持为常规文本的同时实现了 RFC 822 兼容性，因此人们仍然可以轻松理解它。

一个例子是带有波浪号或重音符号的字母，例如法语或西班牙语中使用的字母。另一种是使用在行中间插入回车符的编辑器形成的文本消息。大多数消息仍然是文本。这里可以使用 quoted-printable 编码，回车符表示为“=0D”（字符的十六进制值加上等号）。 RFC 2046 包含有关如何完成此操作的更多详细信息。

<u>**base64编码**</u>

相比之下，base64 编码更常用于无论如何都不是人类可读形式的原始二进制数据，例如图形图像、音频、视频和应用程序文件。 其背后的想法很简单：需要发送的数据对于每个 8 位字节可以有任何值，这是不允许的。 那么，为什么不重新排列位以使数据“适合”RFC 822 的 7 位 ASCII 限制呢？

这是通过一次处理三个字节发送的数据来完成的。 每个三字节块中有 24 位，分为 4 组，每组 6 位。 每个 6 位组都有一个从 0 到 63 的值，并由单个 ASCII 字符表示，如表 249 中所示。

​                                                                             **表 249：MIME Base64 编码组**

| **6-bit Value** | **Encoding** | **6-bit Value** | **Encoding** | **6-bit Value** | **Encoding** | **6-bit Value** | **Encoding** |
| --------------- | ------------ | --------------- | ------------ | --------------- | ------------ | --------------- | ------------ |
| **0**           | A            | **16**          | Q            | **32**          | g            | **48**          | w            |
| **1**           | B            | **17**          | R            | **33**          | h            | **49**          | x            |
| **2**           | C            | **18**          | S            | **34**          | i            | **50**          | y            |
| **3**           | D            | **19**          | T            | **35**          | j            | **51**          | z            |
| **4**           | E            | **20**          | U            | **36**          | k            | **52**          | 0            |
| **5**           | F            | **21**          | V            | **37**          | l            | **53**          | 1            |
| **6**           | G            | **22**          | W            | **38**          | m            | **54**          | 2            |
| **7**           | H            | **23**          | X            | **39**          | n            | **55**          | 3            |
| **8**           | I            | **24**          | Y            | **40**          | o            | **56**          | 4            |
| **9**           | J            | **25**          | Z            | **41**          | p            | **57**          | 5            |
| **10**          | K            | **26**          | a            | **42**          | q            | **58**          | 6            |
| **11**          | L            | **27**          | b            | **43**          | r            | **59**          | 7            |
| **12**          | M            | **28**          | c            | **44**          | s            | **60**          | 8            |
| **13**          | N            | **29**          | d            | **45**          | t            | **61**          | 9            |
| **14**          | O            | **30**          | e            | **46**          | u            | **62**          | +            |
| **15**          | P            | **31**          | f            | **47**          | v            | **63**          | /            |



例如，假设要发送的数据的前三个字节是十进制值212、39和247，这些不能全部用7位ASCII表示。在二进制形式中，它们是：

```
11010100 00100111 11110111
```

我们可以将它们分为四个 6 位组：

```
110101 - 00 0010 - 0111 11 - 110111
```

这会产生四个值 53、2、31 和 55。因此，值 214、39 和 247 将被编码为三个 ASCII 字符“1Cf3”。图 303 显示了该过程的概念性步骤。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\mimebase64.png)




​                                                                      **图 303：MIME Base64 编码**

在这个简化的示例中，三个二进制数据字节使用 MIME base64 编码被编码为四个 ASCII 字符。不是传输这三个字节（其中两个在 RFC 822 中无效），而是发送四个 ASCII 字符“1Cf3”。



**注意**：我在上面提到并在图中显示的编码步骤顺序旨在帮助您理解该过程。计算机本质上直接处理位，因此在将 6 位组编码为 ASCII 字符之前不会费心转换为十进制。


这种 3 到 4 的编码是为所有数据完成的。然后将转换后的 ASCII 字符放入实体主体中，而不是原始二进制数据，每行 76 个字符。我在表 248 的示例的第二个正文部分展示了这是如何完成的（除了我没有每行放置 76 个字符，以保持行的长度较短）。该方案涉及一个最终字符，即等号（“=”），在需要时用作填充字符。

由于 base64 字符是常规的 ASCII，它们对 SMTP 来说就像“常规文本消息”。当然，这些数据对我们来说看起来像是乱码，但这不是问题，因为它会被转换回其常规形式并以图像、电影、音频或其他任何形式显示给接收者。

**关键概念：**MIME 使用 base64 编码将任意 8 位文件转换为电子邮件通信可接受的格式。每组三个 8 位字节被分成四个 6 位组，每个 6 位组由一个 ASCII 字符表示。由于数据是 ASCII，它符合 RFC 822 消息格式标准，即使它不是人类可读的。接收设备反转编码，将每个四字符块变回三个 8 位字节。


base64 方法的主要缺点是什么？与使用 FTP 之类的工具直接发送二进制数据相比，它的效率大约低 33%。原因是三个 8 位字节的二进制数据作为四个 ASCII 字符发送，当然，每个 ASCII 字符本身都使用 8 位来表示。所以使用base64时会有1/3的额外开销。在大多数情况下，这不是什么大问题，但如果通过慢速 Internet 连接下载非常大的电子邮件文件，这可能会很重要。

请注意，RFC 2046 还定义了另外两种编码：ietf-token 和 x-token。包括这些是为了允许在未来定义新的编码类型。



###### 4.2.3.3.2-6 非 ASCII 邮件消息标头的 MIME 扩展（部分：1 2）

到目前为止，本节中讨论的所有 MIME 机制都处理将不同种类的 ASCII 和非 ASCII 数据编码到 RFC 822 消息正文中的方法。除了这些功能之外，MIME 还包括一种方法，可以将非 ASCII 数据编码到 RFC 822 消息的标头中。

<u>**需要 MIME 编码的标头**</u>
此时您可能想知道为什么有人会想要这样做。当然，能够使用 MIME 将图像等二进制数据编码到电子邮件中是有意义的，但为什么要在标题中呢？好吧，如果您看不到这样做的必要性，很可能您的母语是英语。 J ASCII 在表示英语方面做得很好，但在许多其他语言中就不是那么热门了。对于 RFC 822，使用非 ASCII 字符的语言的使用者无法完全使用描述性标头，例如主题和注释标头。有的甚至连自己的名字都说不好！

这个问题的解决方案是 RFC 2047 的主题，它是五个主要 MIME 标准中的第三个。它描述了如何将非 ASCII 文本编码为 ASCII RFC 822 消息标头。这个想法很简单：就像消息体一样，非 ASCII 文本被 ASCII 替换，并提供信息来描述这是如何完成的。

<u>**MIME 编码字语法**</u>

在 MIME 非 ASCII 标头技术中，常规标头的值被具有以下语法的 MIME 编码字替换：

```
=?<charset>?<encoding>?<encoded-text>?=
```

字符串“=?”和“?=”用于括起非 ASCII 标头，将其标记为收件人电子邮件客户端的 MIME 编码标头。以“？”分隔的其他元素表示非 ASCII 文本的编码方式：

- <charset>：使用的字符集，如“iso-8859-1”。
- <encoding>：定义了两种不同的编码类型，为简洁起见，每种都用一个字母表示：
  “B”：这表示 base64 编码，如上一主题所述。

- “Q”：这表示 quoted-printable 编码，与之前的讨论一样。

- <encoded-text>：已使用指示的编码类型编码为 ASCII 的非 ASCII 文本。

如您所见，此方法类似于非 ASCII 消息正文或正文部分的编码方式，但有关编码的信息已被压缩，因此所有内容都可以放在单个标题行中。 “<charset>”参数有点类似于消息正文的 Content-Type 标头，但由于标头只能包含文本，因此它指定了文本的类型。 “<encoding>”参数显然等同于 Content-Transfer-Encoding 标头。

<u>**示例非 ASCII MIME 标头**</u>
下面是一个非 ASCII 标头的示例，使用 GB2312 字符集（用于汉字）和 base64 编码：

```
Subject: =?GB2312?B?u7bTrbLOvNPDwLn61bm74Q==?=
```

我希望这不会说出任何不恰当的话；我从我曾经收到的一封垃圾邮件中取出来的！

**关键概念：**除了在电子邮件正文中对各种数据进行编码的许多功能外，MIME 还提供了一种允许将非 ASCII 信息放入电子邮件标题中的功能。这是通过使用 quoted-printable 或 base64 编码对数据进行编码，然后对标头值使用指定其编码和字符集的特殊格式来完成的。对于使用标准 ASCII 无法轻易表示的语言（如许多亚洲语言）发送的电子邮件，此技术特别有用。



##### 4.2.3.4 TCP/IP 电子邮件传送协议：简单邮件传输协议 (SMTP)

我在对 TCP/IP 电子邮件的总体描述中已经强调，使用电子邮件进行通信需要各种协议和元素的交互。有些人犯的一个错误是将用于发送电子邮件的方法等同于整个系统。然而，这是一个可以理解的错误：正如邮政服务只是整个邮寄系统的一部分一样；它仍然是一个很大的部分。同样，从发件人到收件人的电子邮件传递可以说是整个电子邮件中最重要的部分。在现代 TCP/IP 中，此任务由简单邮件传输协议 (SMTP) 负责。

在本节中，我将详细描述简单邮件传输协议 (SMTP) 的操作。我将从 SMTP 的概述和历史以及定义它的标准的讨论开始。然后我检查 SMTP 客户端/服务器通信和消息传输的工作方式。我解释了 SMTP 服务器建立连接和事务会话的方式，然后是邮件从一个服务器传输到另一个服务器的过程。我描述了一些在 SMTP 中实现的特殊功能，并讨论了 SMTP 安全问题。我以 SMTP 命令和回复的参考摘要作为结尾。

**背景信息：**我对 SMTP 的讨论假设您已经对 TCP/IP 电子邮件的一般概念有基本的了解，并且熟悉 TCP/IP 电子邮件寻址和消息格式。

###### 4.2.3.4.1 SMTP 概述、历史和标准（部分：1 2）

TCP/IP 电子邮件系统的概述和历史描述了 TCP/IP 如何从早期发展到现在的形式。由于用于传递电子邮件的机制是整个系统的重要组成部分，因此对系统的任何概述都必须讨论传递机制是如何发生变化的。以 TCP/IP 为例，我解释了在 1970 年代，随着开发人员试图找到在系统之间传递电子邮件消息的有效方式，邮件的传递如何演变为多种形式。这些努力中的大多数都涉及尝试使用现有协议来传输邮件；这是有道理的，因为采用一项技术比从头开始设计一项技术更容易。

<u>**早期的 SMTP 历史**</u>
一项重要成就是邮件传输协议 (MTP) 的发布，该协议于 1980 年 9 月在 RFC 772 中首次定义，然后在 1981 年 5 月在 RFC 780 中更新。MTP 描述了一组命令和过程，两个设备可以通过这些命令和过程使用TCP 交换电子邮件消息。它的操作主要是使用从当时已经在使用的两个早期 TCP/IP 应用程序借用的元素来描述的：Telnet 和 FTP。 MTP 的命令实际上直接基于 FTP 的命令。

将电子邮件传送基于诸如 FTP 之类的东西本质上没有任何错误，但是以这种方式定义它使 MTP 有点像“黑客”。它还受限于 FTP（一种通用文件传输协议）定义的功能，因此不可能在该协议中包含特定于发送和接收邮件的功能。由于电子邮件的重要性，为传送电子邮件而设计的特定协议是有必要的。该协议最初定义于 1981 年 11 月发布的 RFC 788：简单邮件传输协议 (SMTP)。

顾名思义，SMTP 比它所取代的“非简单”MTP 更“简单”。这是否属实有点见仁见智。我确实注意到 RFC 788 有 61 页长，而早期的 RFC 780 只有 43 页。 SMTP 绝对优于 MTP 的是优雅；该协议专为传输电子邮件而设计。虽然它保留了与 FTP 的某些相似之处，但它是一个运行在 TCP 上的“独立”协议。因此，从概念的角度来看，它可以被认为比 MTP 更简单。就机制而言，SMTP 用于传输电子邮件的过程确实相当简单，尤其是与其他一些协议相比。

RFC 788 描述了承载电子邮件消息的 SMTP 操作，符合 RFC 733 中描述的 ARPAnet 文本消息标准。当然，电子邮件消息和 SMTP 协议的开发仍在继续。 1982 年 8 月，当 RFC 821 和 822 发布时，TCP/IP 电子邮件实现了一个里程碑。 RFC 821 修订了 SMTP，并成为未来二十年协议的定义标准。它的配套标准 RFC 822 成为 SMTP 承载的 TCP/IP 电子邮件消息的标准。

**关键概念**：TCP/IP 电子邮件系统最重要的组成部分是简单邮件传输协议 (SMTP)。 SMTP 源自早期的邮件传输协议 (MTP)，是用于在 TCP/IP 系统和用户之间传递邮件的机制。电子邮件系统中唯一没有使用 SMTP 的部分是电子邮件收件人的最后检索步骤。

<u>**SMTP 扩展和修订**</u>

随着 20 世纪 80 年代的进步，TCP/IP 和 Internet 都越来越流行，SMTP 逐渐取代其他方法成为电子邮件消息传递的主要方法。多年来，该协议主要“按原样”使用，没有发布新的 RFC 来定义新版本或正式更改其行为。

这在 1993 年 2 月发生了变化，当时发布了 RFC 1425，即 SMTP 服务扩展。顾名思义，该标准描述了一个过程，用于添加新功能以扩展 SMTP 的工作方式，同时保持与现有系统的向后兼容性。具有这些扩展的 SMTP 有时被称为扩展 SMTP 或 ESMTP（尽管这个术语的使用似乎并不完全通用）。随着 SMTP 的继续发展，RFC 1425 在 1994 年 7 月在 RFC 1651 中进行了修订，然后在 1995 年 11 月在 RFC 1869 中进行了修订。除此之外，还定义了许多其他 RFC，这些 RFC 定义了特定的 SMTP 扩展，例如管道和消息大小声明。

2001 年 4 月，当 RFC 821 和 RFC 822 的修订版本分别作为 RFC 2821 和 2822 发布时，TCP/IP 电子邮件达到了另一个重要的里程碑。这两个文档都是 1982 年至 2001 年间对 RFC 821 和 822 所做的更新和更改的“合并”。不，我认为新旧 RFC 编号恰好相差“2000”并不是巧合。 RFC 2820 和 2823 都是在 2000 年 5 月发布的，所以看起来 2821 和 2822 是为电子邮件标准保留的。我认为这是一个好主意，因为它更清楚地表明新的 RFC 是对旧的 RFC 的修订。

RFC 2821 是 SMTP 的当前基本标准。它结合了 RFC 821 的基本协议描述和 RFC 1869 中定义的最新 SMTP 扩展。也许更重要的是，它更新了电子邮件通信模型的描述以反映现代 TCP/IP 网络的现实，尤其是 e - 内置于域名系统 (DNS) 中的邮件功能。我们将在下一个主题中更详细地研究这一点。



###### 4.2.3.4.2 SMTP 通信和消息传输方法、客户端/服务器角色和术语（部分：1 2 3）

TCP/IP 电子邮件通信模型描述了电子邮件消息从发件人传送到收件人的方式。在大多数情况下，这涉及发件人的客户机将电子邮件发送到其本地 SMTP 服务器，该服务器又将其发送到收件人的本地 SMTP 服务器，最后发送到收件人的本地主机。除最后一个步骤外，所有这些步骤均由 SMTP 执行。事实上，整个电子邮件通信模型主要由 RFC 821 和 2821 SMTP 标准描述。

初始通信发生在发件人的客户端计算机和允许发件人访问的本地 SMTP 服务器之间。提交电子邮件消息后，该 SMTP 服务器负责将消息传递到负责收件人邮箱的 SMTP 服务器。有两种不同的方式可以发生这种情况。

<u>**使用中继的早期电子邮件通信**</u>
在电子邮件出现的最初几年，当最初定义 RFC 821 及其前身时，Internet 与今天大不相同。没有域名系统，这使得电子邮件传递变得复杂，因为无法将邮箱地址映射到管理该邮箱的 SMTP 服务器的 IP 地址。此外，有许多专有网络连接到 Internet，这意味着任何给定系统并不总是能够与任何其他系统进行通信。

鉴于此，如何发送电子邮件？ SMTP 早期最常见的方式是通过称为中继的过程。 SMTP 路由信息与电子邮件地址一起包含在内，以指定一系列 SMTP 服务器，邮件应通过这些服务器进行中继以到达其目的地。例如，如果使用 SMTP 服务器 A 的发件人想向其邮箱位于 SMTP 服务器 Z 上的某人发送电子邮件，他们可能需要指定邮件通过站点 D、P 和 U 的中间 SMTP 服务器发送，以获取那里。将建立从 A 到 D 的 SMTP 连接，以在其旅程的一段中发送消息；然后它将从 D 到 P，P 到 U，然后 U 到 Z。这个过程类似于 IP 路由的工作方式，但是在应用层（当然，实际上是在较低级别使用 IP 路由。）

您可能很容易看出这样做的问题：它很麻烦，需要很多设备来“处理”邮件，导致通信延迟，还需要 SMTP 服务器之间的源路由通信。它当然是实用的，但远非理想。

<u>**使用 DNS 和直接投递的现代电子邮件通信**</u>

DNS 的创建从根本上改变了电子邮件传递的方式。 DNS 包括对特殊邮件交换器 (MX) 记录的支持，该记录允许从电子邮件地址中的域名轻松映射到处理该域邮件的 SMTP 服务器的 IP 地址。我在有关常规电子邮件地址格式的主题以及有关 DNS 电子邮件支持的专门主题中对此进行了解释。

在新系统中，SMTP 通信更加简单和直接。发送 SMTP 服务器使用 DNS 来查找电子邮件地址所在域的 MX 记录。这会向发件人提供收件人的 SMTP 服务器的 DNS 名称。这被解析为一个 IP 地址，并且可以直接从发件人的 SMTP 服务器建立连接到收件人的以发送电子邮件。虽然 SMTP 仍然支持中继，但使用 MX 记录的直接电子邮件传递速度更快、效率更高，并且 RFC 2821 明确表示这是现在的首选方法。

在这个新系统中，SMTP 一般只用于两次传输：首先，从发件人的客户端机器到发件人本地的 SMTP 服务器，然后从该服务器到收件人的本地 SMTP 服务器，如图 301 所示。（一个不同的邮件访问协议或方法由收件人在旅程的最后一段使用。）在 SMTP 服务器之间的每次电子邮件消息传输都涉及建立 TCP 连接，然后使用SMTP 邮件传输过程。接下来的两个主题详细描述了这是如何发生的。

**关键概念：**在 SMTP 的早期，邮件是使用相对低效的跨互联网从服务器到服务器中继的过程来传递的。今天，当 SMTP 服务器有邮件要传递给用户时，它会使用域名系统 (DNS) 确定处理用户邮件的服务器，并将邮件直接发送到该服务器。

<u>**SMTP 术语：客户端/服务器和发件人/接收方**</u>

最初的 RFC 821 标准将发起 SMTP 电子邮件传输的设备称为发件人，将响应它的设备称为接收者。这些术语在 RFC 2821 中更改为客户端和服务器，以“反映当前的行业术语”。严格来说，这是正确的，但在某些方面，更流行的术语显然不太清楚。

正如我在 TCP/IP 客户端/服务器操作的一般性讨论中所解释的，术语“客户端”和“服务器”在网络中有多种不同的含义，这常常会导致混淆。通俗地说，Internet 上处理电子邮件的计算机通常都称为 SMTP 服务器。这是出于两个原因。首先，他们运行 SMTP 服务器软件来为客户端机器（例如最终用户 PC）提供 SMTP 服务。其次，这些设备通常是在网络中心运行的专用硬件服务器，通常由互联网服务提供商管理。

但是，术语“客户端”和“服务器”现在也用于指代特定 SMTP 通信中的角色。由于所有 SMTP 服务器都发送和接收电子邮件，因此它们在不同时间都充当事务性的客户端和服务器。中继电子邮件的 SMTP 服务器将同时充当该消息的角色，作为服务器接收它，然后作为客户端将其发送到下一个服务器。

增加这种潜在混淆的是，发送电子邮件的初始阶段是从发件人的客户端机器到发件人的本地 SMTP 服务器。因此，SMTP 事务中的客户端角色可能不是实际的 SMTP 服务器，但服务器角色始终是服务器。

困惑了吗？我也是。出于所有这些原因，旧术语“发送方”和“接收方”仍在 RFC 2821 中的某些地方使用，需要澄清的地方。我认为它们更直接，并在随后的主题中使用它们。

**关键概念**：SMTP 服务器同时发送和接收电子邮件；发送邮件的设备充当该交易的客户端；接收它的人充当服务器。为避免混淆，将发送电子邮件的设备称为 SMTP 发送器，将接收电子邮件的设备称为 SMTP 接收器更容易；这些是最初创建 SMTP 时使用的术语。



###### 4.2.3.4.3 SMTP 连接和会话建立和终止（部分：1 2 3 4）

使用简单邮件传输协议 (SMTP) 传送电子邮件涉及在 SMTP 服务器之间定期交换电子邮件消息。 SMTP 服务器负责发送服务器用户提交的电子邮件。他们还接收用于本地收件人的电子邮件，或者在某些情况下用于转发或中继到其他服务器的电子邮件。

<u>**连接建立和终止概述**</u>
所有 SMTP 通信都是使用 TCP 完成的。这允许 SMTP 服务器利用 TCP 的许多功能来确保高效和可靠的通信。 SMTP 服务器一般必须每周 7 天、每天 24 小时保持运行并连接到 Internet，以确保邮件可以随时送达。 （这是为什么大多数最终用户使用 POP3 等访问协议来访问他们收到的电子邮件而不是运行他们自己的 SMTP 服务器的一个重要原因。）服务器连续侦听 SMTP 服务器端口，众所周知的端口号 25，对于来自其他 SMTP 服务器的任何 TCP 连接请求。

如前一主题所述，希望发送电子邮件的 SMTP 服务器通常首先对与目标收件人电子邮件地址的域名对应的 MX 记录进行 DNS 查找，以获取适当的 SMTP 服务器的名称.然后将此名称解析为 IP 地址；为了提高效率，此 IP 地址通常作为附加记录包含在对 MX 请求的响应中，以避免发送服务器需要执行两次显式 DNS 解析。

然后，SMTP 发送方与 SMTP 接收方建立 SMTP 会话。一旦建立了会话，就可以执行邮件事务，以允许在设备之间发送邮件。当 SMTP 发件人完成后，它会终止连接。所有这些过程都涉及特定的命令和回复交换，如图 304 所示。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\smtpconnection.png)


​                                                                             **图 304：SMTP 事务会话的建立和终止**

SMTP 会话始于 SMTP 发送方与 SMTP 接收方建立 TCP 连接。接收方发送就绪消息；发送方发送 HELO 或 EHLO 命令，接收方对此作出响应。假设没有困难，会话建立并且邮件交易发生。当发送方完成后，它发送一个 QUIT 命令；接收方以 221 回复响应并关闭会话。

<u>**连接建立和*Greeting\*交换**</u>

让我们更详细地了解这些过程，当然是从 SMTP 会话建立开始。 SMTP 发送方首先启动与 SMTP 接收方的 TCP 连接。发送 SMTP 服务器使用临时端口号，因为它在事务中扮演客户端的角色。假设服务器愿意接受一个连接，它将通过发送回复代码 220 来表示它已准备好接收来自客户端的指令。这称为“问候”或“服务就绪”响应。它通常包括服务器机器的完整域名、它运行的 SMTP 服务器软件的版本以及可能的其他信息。

现在，作为客户端的服务器不先打招呼就开始向响应服务器发送命令是不礼貌的，不是吗？所以接下来就是这样：客户说“你好”。在最初的 SMTP 协议中，这是通过发出 HELO 命令来完成的，其中包含发送（客户端）SMTP 服务器的域名作为礼貌。然后，接收设备使用 SMTP 回复代码 250 返回“hello”消息进行响应。

例如，如果 SMTP 服务器“smtp.sendersite.org”正在连接到 SMTP 服务器“mail.receiversplace.com”，它会说：

```
HELO smtp.sendersite.org
```

收到此消息后，“mail.receiversplace.com”会回复一条自己的“hello”消息，如下所示：

```
250 mail.receiversplace.com Hello smtp.sendersite.org, nice to meet you.
```

“喋喋不休”的文字当然是可选的；大多数时候 SMTP 通信是在软件程序之间进行的，所以所有的玩笑大多只是有幽默感的程序员。不过，在我们这个有时很困难的世界里，看到这样的礼貌难道不是一件令人愉快的事情吗？😄

<u>**使用 SMTP 扩展建立连接**</u>

SMTP 扩展首先在 RFC 1425 中定义，然后在 RFC 2821 之前的后续标准中定义了供客户端使用的替代“问候”消息：EHLO（扩展问候）。支持 SMTP 扩展的 SMTP 发件人（大多数支持）使用 EHLO 而不是 HELO 来响应 220 问候语。这既可以向 SMTP 接收方说“你好”，也可以告诉它发送方支持 SMTP 扩展。

如果 SMTP 接收方支持扩展，它会回复通常的 250 回复，以及一系列额外的 250 回复。其中每一个都列出了一个 EHLO 关键字，指示接收方支持的特定 SMTP 扩展。如果接收服务器不支持扩展，它将拒绝 EHLO 命令并返回 500 回复代码（“语法错误，命令无法识别”）。这告诉 SMTP 发件人它不能使用扩展；然后它将发出一个传统的 HELO 命令，或者如果它需要 SMTP 扩展存在则退出连接。 （实际上，服务器很少需要使用 SMTP 扩展。）

这是与上面相同的示例，但使用 EHLO。发件人说：

```
EHLO smtp.sendersite.org
```

假设“mail.receiversplace.com”支持 SMTP 扩展，典型的回复可能是：

```
250-mail.receiversplace.com Hello smtp.sendersite.org, nice to meet you.
250-SIZE
250-DSN
250 PIPELINING
```

这些附加回复中的每一个都标识了“mail.receiversplace.com”支持的特定 SMTP 扩展；在这种情况下，消息大小声明（“SIZE”）、传递状态通知（“DSN”）和命令流水线。 （“250”后的破折号表示对命令的多行响应。）

一旦发送了 HELO 或 EHLO 命令并且接收设备已响应，会话就会启动。发送 SMTP 服务器可以向响应服务器发送更多命令。这些通常采用电子邮件消息传输事务的形式，使用以下主题中描述的过程，以及其他需要的命令/回复交换。

<u>**连接终止**</u>

当发送设备发送完所有它必须传输到接收设备的电子邮件，并完成所有其他活动时，它通过发出 QUIT 命令终止会话。这通常会导致来自 SMTP 接收方的 221“再见”消息，类似于“关闭传输通道”之类的内容。然后终止 TCP 连接。

在特殊情况下，服务器也可能提前终止。如果它收到本地命令关闭（例如，由于运行它的硬件服务器即将重启），它可能会以 421 响应（“服务不可用，关闭传输通道”）响应任何例行命令).服务器不应该仅仅因为收到无效命令而终止会话，但是，只有在无法避免会话终止的特殊情况下才会终止。

关键概念：SMTP 会话由三个基本阶段组成。会话首先通过创建 TCP 连接和使用 HELO 命令在 SMTP 发送方和接收方之间交换身份信息来建立。一旦建立，就可以进行邮件交易。当 SMTP 发件人完成会话时，它使用 QUIT 命令终止会话。如果支持 SMTP 扩展，则 SMTP 发送方使用 EHLO（扩展问候）命令而不是 HELO，并且 SMTP 接收方回复一个允许 SMTP 发送方使用的扩展列表。



###### 4.2.3.4.4 SMTP邮件交易流程（部分：1 2 3）

电子邮件消息的传递始于在发送和接收消息的设备之间建立 SMTP 会话。 SMTP 发送方启动到 SMTP 接收方的 TCP 连接，然后发送 HELO 或 EHLO 命令，接收方对此作出响应。假设没有问题，会话就建立起来并准备好进行实际的电子邮件消息事务处理。

<u>**SMTP 邮件事务概述**</u>
SMTP 邮件事务处理过程本身包括三个步骤：

- 事务启动和发件人标识：SMTP 发件人告诉 SMTP 收件人它要开始发送消息，并向收件人提供消息发件人的电子邮件地址。

- 收件人身份识别：发件人告诉收件人邮件预期收件人的电子邮件地址。

- 邮件传输：发件人将电子邮件消息传输给收件人。这是符合 RFC 822 规范的完整电子邮件（也可能是 MIME 格式）。

而已！所以你可以看到“简单邮件传输协议”中的“简单”一词肯定至少有一些优点。特别是与其他声称简单的协议（如 SNMP）相比时。

<u>**单独的电子邮件和信封的基本原理**</u>

事实上，在检查 SMTP 时有时会出现的一个问题是为什么这个过程不能更简单？前两个步骤确定电子邮件的发件人和预期的收件人。但是所有这些信息都已经包含在邮件本身的标题中。为什么 SMTP 不直接从邮件中读取该信息，这实际上会使邮件事务成为一步过程？

对此的解释在 SMTP 标准中没有具体说明，但我相信有几个原因：

- 分别指定发件人和收件人效率更高，因为它会在邮件本身传输之前“预先”向 SMTP 收件人提供所需的信息。事实上，SMTP 接收方可以根据源和目标电子邮件地址来决定是否接受邮件。

- 单独指定此信息可以更好地控制电子邮件的分发方式。例如，一封电子邮件可能发送给两个收件人，但他们可能在完全不同的系统上； SMTP 发件人可能希望使用两个单独的 SMTP 会话将邮件传递给两个不同的 SMTP 收件人。

- 与此类似，还有提供盲目副本的问题。在消息中被“密件抄送”的人必须在没有在消息本身中提及的情况下收到它。

- 将这些信息分开使得在 SMTP 上实现安全性变得更加容易。

由于这些原因，SMTP 区分了消息本身（它称为内容）和发件人和收件人标识（它称为信封）。这当然与我们在普通邮件和电子邮件之间进行的类比是一致的。正如邮政服务仅使用写在信封上的信息来投递邮件一样，SMTP 使用信封信息而不是邮件内容来投递电子邮件。并不是说 SMTP 服务器不查看消息本身，只是这不是它用来管理传递的信息。

**注意：**邮件的发件人可以根据邮件的内容生成信封信息，但这对 SMTP 本身来说有点“外部”。它在标准中有描述，但在具体如何实施时要谨慎。

<u>**SMTP 邮件交互详情**</u>

让我们使用图 305 中的流程图和表 250 中的示例事务（命令以粗体突出显示，回复以斜体显示）来更详细地了解 SMTP 邮件事务处理过程。邮件事务的前两个步骤负责向接收方 SMTP 服务器提供刚才讨论的信封信息。事务由 SMTP 发件人发出 MAIL 命令开始。这用于通知接收方新交易正在开始，并告诉它“信封”上的“发件人”信息。一个例子：

邮件发件人：<joe@someplace.org>

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\smtpmail.png)

​                                                                    **图 305：SMTP 邮件交易流程**

一旦在发件人和收件人之间建立了 SMTP 会话，每个邮件事务都由一组三个命令/回复序列组成。首先使用 MAIL 命令识别发件人，然后使用一个或多个 RCPT 命令指定收件人。然后使用 DATA 命令传输实际的邮件消息，这包括在发送实际消息之前的初步答复，以及在完全接收后的完成答复。

 




发件人的电子邮件地址始终包含在尖括号（“<”和“>”）中。 SMTP 接收方使用 250（“OK”）回复消息确认命令，有时发回地址作为确认。例如：

```
250 <joe@someplace.org>… Sender ok
```

接下来，SMTP 发件人使用 RCPT 命令指定要发送的电子邮件的预期收件人。每个 RCPT 行只能包含一个收件人，因此如果指示多个收件人，则必须发出两个或更多 RCPT 命令。每个命令通常指定一个电子邮件地址，但如果使用中继，该命令也可能包含路由信息。 （如 SMTP 通信主题中所述，这不像过去那样普遍。）例如：

```
RCPT TO:<jane@somewhereelse.com>
```

假设服务器接受了电子邮件，它会再次给出 250 “OK” 回复，例如：

```
250 <jane@somewhereelse.com>… Recipient ok
```

SMTP 发送方然后发出 DATA 命令，告诉 SMTP 接收方消息即将到来：

```
DATA
```

SMTP 接收方使用 354“中间”回复消息进行响应，例如：

```
354 Enter mail, end with “.” on a line by itself
```

SMTP 发件人然后发送电子邮件，一次一行，带有一个“.”。在一条线上终止它。服务器通过另一个 250“OK”回复确认收到消息，交易完成。

​                                               **Table 250: Example SMTP Mail Transaction**



```
MAIL FROM:<joe@someplace.org>
250 <joe@someplace.org>… Sender ok
RCPT TO:<jane@somewhereelse.com>
250 <jane@somewhereelse.com>… Recipient ok
DATA
354 Enter mail, end with "." on a line by itself
From: Joe Sender <joe@someplace.org>
To: Jane Receiver <jane@somewhereelse.com>
Date: Sun, 1 Jun 2003 14:17:31 —0800
Subject: Lunch tomorrow

Hey Jane,

It's my turn for lunch tomorrow. I was thinking we could
[rest of message]
Hope you are free. Send me a reply back when you get a chance.
Joe.
.
250 OK
```

**关键概念：**建立 SMTP 会话后，将使用 SMTP 邮件事务处理发送电子邮件消息。 SMTP 发件人通过识别电子邮件的发件人，然后指定一个或多个收件人来启动事务。 然后电子邮件消息本身被传输到 SMTP 接收方。 每封要发送的电子邮件都是一个单独的交易。

<u>**潜在的邮件交易并发症**</u>
虽然这确实很简单，但我应该指出，我只展示了一封从发件人到收件人的电子邮件，以及交易中没有问题或复杂情况的情况。 由于命令语法或服务器问题，在流程的不同阶段可能会出现各种类型的错误，这可能导致交易失败。 还有一些安全问题可能会发挥作用，这可能会导致服务器允许的交易受到限制。



###### 4.2.3.4.5 SMTP 特殊特性、功能和扩展（部分：1 2）

简单邮件传输协议的主要工作当然是实现TCP/IP 电子邮件传送系统。每当 SMTP 服务器的用户向其发送一封地址为非本地邮箱的电子邮件时，服务器将尝试使用 SMTP 邮件事务处理将其传输到适当的目标服务器。每天在 Internet 上执行数十亿次此类传输，从而使电子邮件能够快速到达世界各地的目的地。

<u>**SMTP 特殊功能**</u>
除了基本的邮件传输机制之外，SMTP 还包括许多其他特性和功能。这些允许 SMTP 支持邮件系统的特殊要求和辅助需求，并在 RFC 2821 中有详细描述。要详细描述它们需要很多主题，所以我在这里只提供较重要的快速摘要所以你对他们有所了解：

- 邮件中继：如 SMTP 通信概述中所述，该协议曾经广泛用于“中继模式”，其中电子邮件从一个 SMTP 服务器路由到另一个服务器以到达其目的地。如今，Internet 上正常的电子邮件传输方法是直接从发件人的 SMTP 服务器到收件人的，使用 DNS MX 记录来确定收件人的 SMTP 服务器地址。如果满足某些条件，SMTP 仍然包括将邮件从一台服务器中继到另一台服务器的能力。请注意，除了中继效率低下之外，许多服务器不会中继邮件，因为此功能已被滥用于垃圾邮件和黑客攻击。

- 邮件转发：在某些情况下，SMTP 服务器可能同意接受非本地邮箱的电子邮件并将其转发到适当的目的地。这听起来与中继类似，但使用方式不同。一个常见的例子是当用户更改他或她的电子邮件地址时。如果我在 XYZ Industries 工作多年然后退休，公司可能不再希望我在公司的 SMTP 服务器上接收电子邮件。不过，出于礼貌，他们可能会将发给我的电子邮件转发到那里，这样我仍然可以在我的新公司收到它。

- 邮件网关：某些 SMTP 服务器可以配置为电子邮件网关。这些设备将 TCP/IP 电子邮件“翻译”为适合另一个电子邮件系统的格式，反之亦然。网关是一个复杂的话题，因为电子邮件系统可能千差万别；更重要的问题之一是不同电子邮件系统的寻址方法不一致。

- 地址调试：SMTP 包含一个 VRFY（验证）命令，可用于检查电子邮件地址的有效性，而无需实际向其发送邮件。

- 邮件列表扩展：SMTP 命令 EXPN（扩展）可用于确定与邮件列表关联的各个电子邮件地址。 （但是请注意，这与像 Majordomo 这样的邮件列表软件没有直接关系。）

- “Turning”：最初的SMTP协议包含一个允许SMTP发送者和SMTP接收者改变角色的命令。这可用于允许 SMTP 服务器 A 向服务器 B 发送电子邮件，然后让 B 发送它在同一会话中为 A 排队的电子邮件。实际上，出于各种原因（包括安全考虑），此功能并未得到广泛使用。它现在正式“不推荐”，但可能仍会在某些 SMTP 软件中实现。

<u>**b**</u>
上面的列表仅代表了 SMTP 标准中提到的一些功能。除了这些之外，给定类型的 SMTP 服务器软件还可以由其开发人员提供其他功能。 HELP 命令是确定给定 SMTP 服务器支持哪些命令的一种方法。

SMTP 服务器还必须执行大量未引起大量关注的“后台处理”。这包括管理连接、检查命令和电子邮件消息中的错误以及相应地做出反应。他们还必须注意问题情况，例如可能导致电子邮件在两个 SMTP 服务器之间来回传递的“循环”，每个服务器都认为另一个是预期的收件人。在最初发送邮件失败的情况下，SMTP 服务器还需要定期重试与目标设备的通信，如果在一定时间后无法发送邮件，则向发件人返回失败消息。同样，RFC 2821 包含更多详细信息。

<u>**SMTP 扩展**</u>

正如本节前面所讨论的，在 1990 年代定义了许多对 SMTP 基本操作的扩展。 当支持扩展的两个 SMTP 服务器使用 EHLO 命令和适当的扩展响应代码设置会话时，将启用这些。 表 251 总结了一些已定义的更有趣的 SMTP 扩展，并给出了每个描述的 RFC 编号。


​                                                                                 **表 251：SMTP 扩展**

| **Extension Keyword**      | **Extension**                                                | **Defining Document** | **Description**                                              |
| -------------------------- | ------------------------------------------------------------ | --------------------- | ------------------------------------------------------------ |
| ***8BITMIME\***            | 8-bit MIME support.                                          | RFC 1652              | 理论上定义了对MIME中8位内容传输类型的支持，但是与此相关的并发症。请参阅“ MIME”部分中的内容编码的讨论。 |
| ***AUTH\***                | Authorization                                                | RFC 2554              | 用于实施需要增强安全性的服务器的授权机制。                   |
| ***DSN\***                 | Delivery status notification                                 | RFC 1891              | 允许SMTP发件人请求SMTP接收器通知IT在传递发件人给它的消息时发生问题。 |
| ***ENHANCEDSTATUSCODES\*** | Enhanced status codes. (They should have abbreviated the keyword. J) | RFC 2034, RFC 1893    | 扩展了传统的3位SMTP回复代码格式，并提供提供更多信息的额外代码。有关更多信息，请参见SMTP上的主题结尾。 |
| ***PIPELINING\***          | Command pipelining                                           | RFC 2920              | 允许将多个命令从SMTP发件人批处理到接收器，而不是一次发送一个命令并等待响应代码。 |
| ***SIZE\***                | Message size declaration                                     | RFC 1870              | 允许在传输之前由SMTP发送者声明消息大小的信息，因此SMTP接收器可以决定是否需要该消息。 |

internet：完整的最新 SMTP 扩展集可在此处找到：http://www.iana.org/assignments/mail-parameters

**注意**：在基本 SMTP 协议描述中被认为是可选的某些命令有时也被认为是扩展，例如 EXPN 和 HELP 命令； 我没有在这里列出这些，因为它们不是真正的 SMTP 扩展。



###### 4.2.3.4.6 SMTP 安全问题（部分：1 2）

如果您已经阅读了描述其他 TCP/IP 协议（如 DHCP、FTP 等）的部分，您可能已经知道我将如何开始本节。这个主题在 TCP/IP 中很常见：协议的实现方式缺乏安全性。这一切都可以追溯到一个共同的根本原因：大多数这些协议是在“互联网”还只是一小部分机器的时候开发的，这些机器由大多数人相互了解和信任，或者能够使用物理安全手段的人控制。开发人员从未想过 TCP/IP 会被全世界数百万匿名的“普通 Joe”用户使用，这需要对安全性的关注远远超过像 ARPAnet 这样的小型研究互联网。

对于 SMTP，安全问题比我上面提到的其他协议更糟糕。 SMTP 不仅没有任何真正的安全机制，SMTP 通信的原始中继模型完全是围绕服务器之间的“合作”和“信任”思想设计的。由于大多数 SMTP 服务器会被要求处理一定数量的中间传输，因此每个服务器都需要接受来自任何发件人的邮件，以便将其传送到任何目的地。

该模型的基本假设是 SMTP 服务器都将“表现良好”，不会通过向中间服务器发送大量待发送邮件或发送虚假消息来造成问题来滥用系统。随着互联网在 1990 年代的爆炸式普及，这一切都发生了变化。骗子、黑客和声名狼藉的销售人员都发现，只需将电子邮件提交到 SMTP 服务器进行传递，即可使用电子邮件“免费”传递消息。结果导致服务器超载，这主要是由于发送了大量不需要的电子邮件，互联网用户通常称之为垃圾邮件。

**注意：**在这种情况下，术语“垃圾邮件”与荷美尔加工肉类产品没有任何直接关系。它用于指代大量电子邮件，来自 Monty Python 喜剧小品，其中一遍又一遍地重复这个词。


“冒充”SMTP 服务器实际上非常容易。您可以使用 Telnet 协议直接连接到端口 25 上的 SMTP 服务器。SMTP 命令都以文本形式发送，SMTP 回复也是如此，因此您可以与服务器进行“对话”，甚至可以手动执行邮件事务。这对于调试很有用，但也使得滥用开放的 SMTP 服务器变得非常容易。由于垃圾邮件发送者通常不想被识别，因此他们采用欺骗技术来增加识别他们的难度，这使事情变得更加困难。

<u>**常见的 SMTP 服务器安全技术**</u>

尽管存在这个明显的问题，但由于两个主要原因，在 SMTP 中实现通用安全机制的努力遭到了抵制。首先，没有万无一失的方法可以在不造成新旧系统之间不兼容的情况下将新的安全机制改造到像 SMTP 这样广泛使用的东西上。其次，许多管理员不愿意完全取消帮助互联网如此成功的站点之间合作的一般概念，仅仅是因为一些“坏苹果”。

尽管如此，还是得做点什么。折衷方案是让系统管理员通过强加技术和策略更改来“加强”他们的 SMTP 服务器。当然，这些因组织而异。一些更常见的 SMTP 安全规定包括：

- 检查尝试连接的设备的 IP 地址，甚至拒绝启动 SMTP 会话，除非它在授权客户端设备列表中。

- 将某些命令或功能（例如电子邮件中继）限制为授权用户或客户端服务器。这有时是通过在接受命令之前要求通过 SMTP 扩展 AUTH 进行身份验证来完成的。

- 限制诸如 EXPN 之类的命令的使用，以防止未经授权的用户确定邮件列表中用户的电子邮件地址。

- 在接受要投递的消息之前检查信封信息的有效性。一些服务器在同意接受 MAIL 命令之前会首先验证发件人的电子邮件地址是否有效。许多人会检查收件人的地址，如果邮件没有投递到本地邮箱，就会拒收。其他人使用更先进的技术。

- 限制可以发送的电子邮件的大小或在给定时间段内可以发送的数量。

- 记录对服务器的所有访问以保留服务器使用记录并检查滥用情况。

由于近年来的所有滥用行为，您会发现大多数 SMTP 服务器都实现了这些或其他功能，即使这些功能中的大多数并未由 SMTP 标准正式定义。它们是内置于单个 SMTP 服务器软件包中的增强功能。

其中一些措施实际上可以变得相当复杂。例如，由我多年使用的伟大的 Web 托管公司 pair Networks 运行的 SMTP 服务器使用“POP-before-SMTP 身份验证”。这意味着在服务器通过 SMTP 接收来自用户的外发邮件之前，用户必须首先使用邮局协议登录以检查传入邮件。由于 POP 包括身份验证，成功的 POP 登录告诉服务器用户已获得授权。这会在服务器中“触发一个开关”，允许用户在登录后的一段有限时间内访问 SMTP 服务。如果这看起来很费解，那么，您就会开始了解垃圾邮件发送者和黑客今天为 Internet 服务提供商造成的麻烦。

还值得注意的是，SMTP 不包含任何加密机制来确保电子邮件传输的隐私。需要确保谁能看到他们消息的用户必须在提交之前使用单独的加密方案对消息正文进行编码。

**关键概念**：SMTP 是在互联网安全不是什么大问题的时代设计的；因此，基本协议根本不包含任何安全机制。由于当今电子邮件经常被滥用，大多数现代 SMTP 服务器都包含一项或多项安全功能以避免出现问题。



###### 4.2.3.4.7 SMTP 命令（部分：1 2 3）

我在 SMTP 的概述和历史中提到过，早期的 TCP/IP 电子邮件机制是通过借鉴现有应用程序协议（尤其是 Telnet 和 FTP）的技术和元素而开发的。 SMTP 是一个独立的协议，但在一些方面仍然可以清楚地看到它的遗产。其中最明显的一个是 SMTP 发送方发出命令和 SMTP 接收方返回回复的方法。

与 FTP 一样，所有 SMTP 命令都以纯 ASCII 文本的形式通过 SMTP 连接中客户端和服务器之间建立的 TCP 连接发送。这些命令必须以两个字符的“CRLF”序列结束，该序列通常根据 Telnet 网络虚拟终端 (NVT) 的要求终止 ASCII 文本。事实上，您可以检查 SMTP 服务器的功能，甚至可以自己向它发出命令，只需使用 Telnet 在端口 25 上连接到它即可。

<u>**SMTP 命令语法**</u>
所有 SMTP 命令均使用四个字母的命令代码指定。一些命令还允许或要求指定参数。命令的基本语法是：

```
<command-code> <parameters>
```

使用参数时，它们跟在命令代码之后，并由一个或多个空格字符分隔。例如，HELO 和 EHLO 命令由命令代码、空格字符和 SMTP 发件人的域名指定，正如我们在查看 SMTP 连接建立时看到的那样。

<u>**当前 SMTP 命令**</u>

表 252 列出了当前在现代 SMTP 中使用的命令，按照它们在 RFC 2821 中描述的顺序排列，并对每个命令进行了简短描述。


​                                                                            **表 252：SMTP 命令**

| **Command Code** | **Command**               | **Parameters**                                               | **Description**                                              |
| ---------------- | ------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| ***HELO\***      | Hello                     | The domain name of the sender.                               | SMTP 发送方发送给 SMTP 接收方以启动 SMTP 会话的常规指令。    |
| ***EHLO\***      | Extended Hello            | The domain name of the sender.                               | 由支持 SMTP 扩展的 SMTP 发送方发送，以问候 SMTP 接收方并要求它返回接收方支持的 SMTP 扩展列表。发件人的域名作为参数提供。 |
| ***MAIL\***      | Initiate Mail Transaction | Must include a “FROM:” parameter specifying the originator of the message, and may contain other parameters as well. | 开始从发件人到收件人的邮件交易。                             |
| ***RCPT\***      | Recipient                 | Must include a “TO:” parameter specifying the recipient mailbox, and may also incorporate other optional parameters. | 指定当前事务中传送的电子邮件消息的一个收件人。               |
| ***DATA\***      | Mail Message Data         | None                                                         | 告诉 SMTP 接收方 SMTP 发件人已准备好传输电子邮件。接收方通常会回复一个中间的“继续”消息，然后发送方一次一行地发送消息，在一行中用一个句点表示消息的结束。 |
| ***RSET\***      | Reset                     | None                                                         | 中止正在进行的邮件事务。如果在发出 MAIL 或 RCPT 命令时收到错误，如果 SMTP 发件人因此无法继续传输，则可以使用此方法。 |
| ***VRFY\***      | Verify                    | E-mail address of mailbox to be verified.                    | 要求 SMTP 接收方验证邮箱的有效性。                           |
| ***EXPN\***      | Expand                    | E-mail address of mailing list.                              | 请求 SMTP 服务器确认该地址指定了邮件列表，并返回列表中的地址列表。 |
| ***HELP\***      | Help                      | Optional command name.                                       | 请求帮助信息：如果未提供参数，则为一般帮助，否则为提供的命令代码的特定信息。 |
| ***NOOP\***      | No Operation              | None                                                         | 除了验证与 SMTP 接收方的通信外，不执行任何操作。             |
| ***QUIT\***      | Quit                      | None                                                         | 终止 SMTP 会话。                                             |

与 FTP 命令一样，SMTP 命令不区分大小写。

某些 SMTP 扩展对基本 SMTP 命令集进行了更改。 例如，AUTH 扩展指定了一个新命令（也称为 AUTH），该命令指定 SMTP 客户端想要使用的身份验证方法。 其他扩展为现有命令定义新参数。 例如，SIZE 扩展定义了一个 SIZE 参数，可以将其添加到 MAIL 命令中，以告知 SMTP 接收方要传输的邮件的大小。

**关键概念：**SMTP 发送方使用一组 SMTP 命令执行操作。 每个命令都使用四字母代码进行标识。 由于 SMTP 仅支持有限的功能，因此它的命令集很小。



<u>**过时的 SMTP 命令**</u>

上表中的命令是当今 SMTP 中最常用的命令。 除此之外，还有一些最初在 RFC 821 中定义但后来已过时的命令。 其中包括：

- SEND、SAML（“发送和邮寄”）和 SOML（“发送或邮寄”）：RFC 821 定义了一种独特的机制，用于将邮件直接传送到用户终端而不是邮箱，可选择与传统电子邮件传送相结合。 这些很少在 RFC 2821 中实现和废弃。

- TURN：颠倒 SMTP 发送方和接收方的角色，如 SMTP 特殊功能主题中所述。 这有许多实施和安全问题，并已从 RFC 2821 中的标准中删除。



###### 4.2.3.4.8 SMTP 回复和回复代码（部分：1 2 3 4）

SMTP 通信始于在 SMTP 发送方（作为客户端的设备）和 SMTP 接收方（作为服务器的设备）之间建立 SMTP 会话。然后，所有协议操作都由发送方向接收方发出的纯 ASCII 文本 SMTP 命令组成。接收方分析每个命令，如果可能执行发送方请求的指令，然后回复发送方。回复有几个功能：确认命令接收；指示命令是否被接受；并传达处理命令的结果。

正如 SMTP 命令的发送方式让人想起 FTP 内部命令的工作方式一样，SMTP 回复的格式和解释方式几乎与 FTP 回复相同。与 FTP 一样，回复不仅包含一串回复文本，还包含回复文本和数字回复代码的组合。与 FTP 一样，这些回复代码使用三位数字来编码有关回复的各种信息，每个数字都有特定的意义。回复代码实际上是回复的关键部分，回复文本只是描述性的。

**注意：**有关 FTP 回复代码的主题包含对使用这些结构数字回复代码的好处的详尽解释。由于 SMTP 系统非常相似，因此我不会在本主题中重复该讨论。但是，我将在此处完整描述 SMTP 回复代码的语法和语义，以便使本节关于 SMTP 的内容自成一体，并指出 FTP 和 SMTP 回复代码之间的差异所在。

<u>**回复代码结构和数字解释**</u>

SMTP 回复代码可以被认为是“xyz”形式，其中“x”是第一个数字，“y”是第二个数字，“z”是第三个数字。 以下是这些数字的使用方式。

<u>**第一个回复代码数字（“x”）**</u>
前导的回复码数字一般表示命令的成功或失败，成功的命令是完整的还是不完整的，不成功的命令是否应该重试。 这个特定数字的解释方式与 FTP 中的解释方式完全相同，如表 253 所示。


​                                                             **表 253：SMTP 回复代码格式：第一位数字解释**

| **Reply Code Format** | **Meaning**                             | **Description**                                              |
| --------------------- | --------------------------------------- | ------------------------------------------------------------ |
| **1yz**               | **Positive Preliminary Reply**          | 初始响应表明命令已被接受并且处理仍在进行中。在发送新命令之前，SMTP 发件人应该等待另一个答复。请注意，虽然为了完整性在 SMTP 规范中正式定义了第一个数字类型，但它目前并未被任何 SMTP 命令实际使用。也就是说，SMTP中没有100到199之间的回复码。 |
| **2yz**               | **Positive Completion Reply**           | 该命令已成功处理并完成。                                     |
| **3yz**               | **Positive Intermediate Reply**         | 该命令已被接受，但它的处理已被延迟，等待收到更多信息。经常进行此类回复的一个示例是在收到 DATA 命令后，提示 SMTP 发件人然后发送要传输的实际电子邮件消息。 |
| **4yz**               | **Transient Negative Completion Reply** | 该命令未被接受且未采取任何操作，但该错误是暂时的，可以再次尝试该命令。这用于可能由于临时故障或可能更改的条件而导致的错误，例如 SMTP 服务器上的资源暂时繁忙。 |
| **5yz**               | **Permanent Negative Completion Reply** | 命令未被接受且未采取任何操作。再次尝试相同的命令可能会导致另一个错误。一个例子是发送一个无效的命令。 |

<u>**第二个回复代码数字（“y”）**</u>
中间数字将消息分类为功能组。 该数字的使用方式与 FTP 中的一般方式相同，但某些功能组在 SMTP 中有所不同，如表 254 所示。


​                                                   **表 254：SMTP 回复代码格式：第二位数字解释**

| **Reply Code Format** | **Meaning**     | **Description**                                    |
| --------------------- | --------------- | -------------------------------------------------- |
| **x0z**               | **Syntax**      | 语法错误或杂项消息。                               |
| **x1z**               | **Information** | 回复信息请求，例如状态请求。                       |
| **x2z**               | **Connections** | 与 SMTP 发送方和 SMTP 接收方之间的连接相关的回复。 |
| **x3z**               | **Unspecified** | 没有定义的。                                       |
| **x4z**               | **Unspecified** | 没有定义的。                                       |
| **x5z**               | **Mail System** | 与 SMTP 邮件服务本身相关的回复。                   |

<u>**第三个回复代码数字（“z”）**</u>
最后一位表示第二位描述的每个功能组中的特定类型的消息。 第三位允许每个功能组针对第一位代码给出的每种回复类型（初步成功、暂时失败等）有 10 个不同的回复代码。

<u>**组合数字值以生成特定的回复代码**</u>
同样，与在 FTP 中一样，这些“x”、“y”和“z”数字的含义组合起来构成特定的回复代码。 例如，回复码“250”是一个肯定的回复，表示命令完成，与邮件系统有关。 它通常用于指示请求的邮件命令已成功完成。

<u>**常用 SMTP 回复代码**</u>

表 255 包含从 RFC 2821 中提取的一些更常见的 SMTP 回复代码的列表，按数字顺序排列。 对于每一个，我都展示了标准中指定的“典型”回复文本，并在我认为需要的地方提供了额外的描述信息。


​                                                                                   **表 255：SMTP 回复代码**

| **Reply Code** | **Reply Text**                                               | **Description**                                              |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **211**        | System status or system help reply.                          |                                                              |
| **214**        | <Help message…>                                              | 用于回复 HELP 命令时发送的文本。                             |
| **220**        | <servername> Service ready.                                  | 首次与 SMTP 服务器建立 TCP 连接时发送的问候消息。            |
| **221**        | <servername> closing transmission channel.                   | 为响应 QUIT 消息而发送的再见消息。                           |
| **250**        | Requested mail action okay, completed                        | 表示成功执行了各种命令。                                     |
| **251**        | User not local; will forward to <forward-path>               | 当 SMTP 接收方同意将消息转发给非本地用户时使用。             |
| **252**        | Cannot VRFY user, but will accept message and attempt delivery | 表示服务器尝试验证电子邮件地址，但无法完全验证。通常意味着该地址似乎是有效的，但无法肯定地确定这是真的。 |
| **354**        | Start mail input; end with <CRLF>.<CRLF>                     | 对 DATA 命令的中间回复。                                     |
| **421**        | <servername> Service not available, closing transmission channel | 当 SMTP 接收方过早终止连接时发送以响应任何命令。一个常见的原因是收到本地关机命令，例如由于硬件重启。 |
| **450**        | Requested mail action not taken: mailbox unavailable         | 当邮箱由于另一个进程访问它而忙时发送。                       |
| **451**        | Requested action aborted: local error in processing          | 服务器上的本地处理问题。                                     |
| **452**        | Requested action not taken: insufficient system storage.     | 是时候清理服务器的硬盘了！                                   |
| **500**        | Syntax error, command unrecognized                           | 对一个错误的命令或一个太长的命令的响应。                     |
| **501**        | Syntax error in parameters or arguments                      |                                                              |
| **502**        | Command not implemented                                      | 命令通常对 SMTP 有效，但不受此特定服务器支持。               |
| **503**        | Bad sequence of commands                                     | 命令未按正确顺序发送，例如在 MAIL 命令之前发送 DATA 命令。   |
| **504**        | Command parameter not implemented.                           |                                                              |
| **550**        | Requested action not taken: mailbox unavailable              | 由于指定邮箱出现问题而给出的一般响应。这包括尝试将邮件发送到无效地址、拒绝中继到非本地邮箱等。 |
| **551**        | User not local; please try <forward-path>                    | 告诉 SMTP 发件人尝试不同的路径；可用于支持邮箱转发。         |
| **552**        | Requested mail action aborted: exceeded storage allocation   | 用户邮箱已满。                                               |
| **553**        | Requested action not taken: mailbox name not allowed         | 指定的邮箱地址无效。                                         |
| **554**        | Transaction failed.                                          | 事务的一般失败。                                             |

如前所述，每个回复代码的实际文本字符串是特定于实现的。 虽然标准为 250 消息指定了“干”响应文本，例如“请求的操作已完成”，但一些服务器自定义此代码，甚至根据上下文对不同的 250 消息给出不同的回复。 同样，在其他主题中也有这样的例子。

<u>**SMTP 多行文本回复**</u>

同样，与在 FTP 中一样，回复可能包含多行文本。在这种情况下，每一行都以回复代码开头，除最后一行之外的所有行在回复代码和回复文本之间都有一个连字符，以指示回复继续。最后一行在回复代码和文本之间有一个空格，就像单行回复一样。关于 SMTP 连接的主题中给出了这方面的示例，我在其中显示了对 EHLO 命令的多行响应。

<u>**增强状态代码回复**</u>
当启用 ENHANCEDSTATUSCODES SMTP 扩展时，这会导致 SMTP 接收方发出补充回复代码以响应每个命令。这些代码在某些方面类似于标准回复代码；他们也使用三位数字，但数字之间用句点分隔。这些增强的代码提供了有关操作结果的更多信息，尤其是错误。

例如，如果您尝试在不支持此功能的服务器上发出指定非本地邮箱的 RCPT 命令，它将发回“550”回复，这是一个一般错误（“未采取请求的操作：邮箱不可用” ).当增强状态代码处于活动状态时，响应将是“550 5.7.1”，更具体的消息是“交付未授权，请求被拒绝”。在 RFC 1893 中可以找到这些增强代码的完整描述。

**关键概念：**每次 SMTP 发送方发出命令时，它都会收到来自 SMTP 接收方的回复。 SMTP 回复类似于 FTP 回复，使用三位数回复代码和描述性文本行。还定义了一个特殊的增强状态代码 SMTP 扩展；启用后，这会导致 SMTP 接收方在处理命令后返回更详细的结果信息。



##### 4.2.3.5 TCP/IP 电子邮件访问和检索协议和方法

 简单邮件传输协议 (SMTP) 负责将电子邮件消息从发件人发送到收件人的大部分过程。当邮件已成功存放到收件人本地 SMTP 服务器上的邮箱中时，SMTP 的工作就结束了。

在某些情况下，这个邮箱是信息在网络空间中传播的终点。然而，更多时候，它只是一个“休息站”——旅程的最后一步是让接收消息的用户实际访问和阅读消息。这可能需要从邮箱中检索它并将其传输到另一台客户机。由于各种原因，SMTP 并不用于访问邮箱的过程，而是一组专门为电子邮件访问和检索而设计的特殊协议和方法。

在本节中，我将介绍一些用于 TCP/IP 电子邮件访问和检索的更常用的技术。我从主题概述开始，概括描述了用于电子邮件访问的不同范例，并给出了协议的概述。然后我有几个小节涵盖了两种邮件 TCP/IP 电子邮件访问和检索协议：邮局协议 (POP) 和 Internet 消息访问协议 (IMAP)。我还有第三个较小的小节，讨论其他电子邮件访问方法。

请注意，本节假定您已经熟悉 SMTP 和整个 TCP/IP 电子邮件系统的操作。

###### 4.2.3.5.1 TCP/IP 电子邮件邮箱访问模型、方法和协议概述（部分：1 2 3）

在一个理想的世界里……我们都会生来就知道关于计算机和网络的一切知识，我会成为一位著名的小说家，而不是写下数千页这些东西。 J 好吧，这可能有点过分了，但是如果互联网上的每台设备都运行 SMTP 服务器软件不是很好吗？如果是这样，那么一个协议就足以实现整个 TCP/IP 电子邮件系统。您只需在您的机器上撰写电子邮件，然后您的 SMTP 软件会将它发送给您的收件人，然后他或她会阅读它。漂亮而简单。

然而，回到现实世界，这在一般情况下确实是不可能的。正如我在关于电子邮件的概述部分和 SMTP 的讨论中所解释的，SMTP 服务器必须连接到 Internet 并且全天候可用，以接收来自世界上数百万台其他计算机的任何时间发送的电子邮件。世界。我们中的大多数人不能或不想运行持续连接到 Internet 的机器，我们也不想配置和维护可能很复杂的 SMTP 软件。这就是为什么完整的电子邮件交换通常不涉及两台设备而是四台设备的原因：邮件在发件人的客户端计算机上编写，传输到发件人的 SMTP 服务器，然后传输到收件人的 SMTP 服务器，最后传输到收件人的计算机.

<u>**专用邮件访问和检索协议的优势**</u>
SMTP服务器之间的通信当然是用SMTP来完成的。将电子邮件从发件人的机器发送到发件人的 SMTP 服务器的初始步骤也是如此。但是，SMTP 不用于该过程的最后一部分，即访问收件人的邮箱。相反，设计了一组邮箱访问和检索协议和方法。

一个公平的问题是……为什么这样做？为什么不简单地让邮件“待定”在收件人的 SMTP 服务器上，然后让它在收件人客户端设备联机时使用 SMTP 将邮件发送到收件人客户端设备？这有两个主要原因。第一个是 SMTP 是专为传输电子邮件的特定目的而设计的。让它负责客户端邮箱访问需要添加更多功能，从而难以保持 SMTP 的“简单性”。此外，SMTP 以“推”模式工作，事务由发件人发起。它需要进行更改以允许它响应来自仅间歇性在线的客户端设备的请求。

但第二个原因可能更重要：电子邮件访问方式的灵活性。如果我们使用 SMTP，我们所能做的就是将电子邮件传输到收件人的客户端机器。这将是有用的，但会极大地限制电子邮件的使用能力。例如，某些用户可能希望直接在服务器上访问邮件并在那里进行操作。还要考虑有特殊要求的人的问题，例如那些出差并且可能需要从许多不同的客户端设备访问电子邮件的人。

<u>**电子邮件访问和检索模型**</u>

由于刚才检查的原因，提供不止一种访问邮箱的方法是有好处的。 RFC 1733，IMAP4 中的分布式电子邮件模型，描述了三种不同的邮件访问和检索范例或模型：

- 在线访问模型：这是我们在我的“理想世界”场景中都会使用的访问模式，其中每台机器始终连接到运行 SMTP 服务器的 Internet。您可以持续、直接地在线访问您的邮箱。在现实世界中，这种模式仍然被一些 Internet 用户使用，尤其是那些拥有 UNIX 帐户或运行自己的 SMTP 服务器的用户。我称之为直接服务器访问。

- 离线访问模型：在此范例中，用户与他或她的邮箱所在的服务器建立连接。用户将收到的消息下载到客户端设备，然后从服务器邮箱中删除它们。一旦邮件被取回，对邮件执行的所有阅读和其他活动都可以“离线”完成。

- 断开连接的访问模型：这是在线和离线访问的混合体。用户从服务器下载消息，这样他或她就可以阅读或以其他方式操作它们，而无需持续连接到服务器。然而，邮件并没有从服务器中删除，就像在离线模型中一样。在未来的某个时间，用户重新连接到服务器并将在本地设备上所做的任何更改与服务器上的邮箱同步。

什么样的变化？示例包括标记消息是否已读、跟踪未读邮件以及标记用户已回复的消息。这些是帮助那些邮箱繁忙的人跟踪他们需要做什么的重要工具。

<u>**比较电子邮件访问和检索模型**</u>

三者，哪个最好？你应该知道最好不要问我那个问题。 J 每个都有优点和缺点，这就是为什么我们有这些选项而不是用于邮件访问的单一 SMTP 协议是好的。

直接服务器访问的主要优点是即时速度和从任何位置的普遍访问。它的缺点是您必须在线才能阅读邮件，而且通常需要您使用大多数人不熟悉的 UNIX 电子邮件客户端。但是，Internet 消息访问协议 (IMAP) 也可用于在线访问。

离线访问的主要优点是简单，连接时间要求短；您可以轻松连接到邮箱，下载邮件，然后在本地阅读。但这使得这种方法有些不灵活，并且不适合从不同的机器访问。尽管如此，它仍然是目前最流行的访问方法，因为简单很重要；流行的邮局协议 (POP) 是最好的代表。

断开连接尝试结合离线和在线访问的优点而不结合它们的缺点，并且做得很好。优势很明显：能够快速访问邮件并脱机使用，同时在服务器上保留和更新邮箱以允许从不同的客户端计算机访问。 IMAP 是广泛用于离线访问的协议。在 IMAP 概述中，我探讨了它相对于离线访问的优势，以及它的主要缺点：复杂性和远不如 POP 的普遍支持（尽管 IMAP 的接受度正在缓慢增加）。

最后，近年来，一种有点新的邮箱访问方法开始流行：使用万维网访问电子邮件。此技术允许用户从任何具有 Internet 连接和 Web 浏览器的计算机访问他或她的邮箱。这是“界限模糊”的一个很好的例子，不仅在此处讨论的访问模型之间，而且在 TCP/IP 应用程序之间，在本例中为 Web 和电子邮件。

关键概念：为了灵活性，TCP/IP 使用多种邮箱访问和检索协议和方法来允许用户阅读电子邮件。三种不同的模型描述了这些不同方法的工作原理：在线模型，在服务器上访问和阅读电子邮件；离线模型，其中邮件被传输到客户端设备并在那里使用；和断开连接的模型，在该模型中，邮件被离线检索和阅读，但仍保留在服务器上，更改同步以保持一致性。



###### 4.2.3.5.2 TCP/IP 邮局协议 (POP/POP3)

用于 TCP/IP 电子邮件的整体通信模型为电子邮件用户提供了许多选项来访问他或她的电子邮箱。当今最流行的访问方法是简单的离线访问模型，其中客户端设备访问服务器、检索邮件并将其从服务器中删除。邮局协议 (POP) 旨在实现快速、简单和高效的邮件访问；每天有数百万人使用它访问数十亿封电子邮件。

在本节中，我描述了邮局协议的操作，重点是版本 3 (POP3)。我首先从总体上看协议，讨论它的历史、协议的各种版本和定义它们的标准。我描述了 POP3 的一般操作以及客户端和服务器之间的通信，重点介绍了会话转换的三种主要状态。然后我按顺序描述这些状态中的每一个：授权状态、交易状态和更新状态。对于每一个，我都解释了发生的通信过程以及实现它们的命令和回复。

###### 4.2.3.5.2-1 POP 概述、历史、版本和标准

 在在线、离线和断开连接这三种邮箱访问范例中，离线模型在功能方面可能是最没有能力的。而且也是最受欢迎的！这似乎有悖常理，但它实际上是一种在计算和网络世界中反复出现的模式：一个很好的例子就是以太网在 LAN 市场上击败令牌环。原因在于简单性和易于实施是任何技术成功的关键，而离线邮件访问模型在这些方面击败了其他两个模型。

离线电子邮件访问的历史可以追溯到 20 世纪 80 年代初期。二十年前，几乎每个人和他的兄弟都没有像今天这样上网查收电子邮件。事实上，只有相对较少的机器使用 TCP/IP 连接，并且这些机器的大多数用户都能够使用在线访问模型在服务器上访问他们的电子邮件。

然而，即使在那时，开发人员也认识到能够从服务器直接检索电子邮件到客户端计算机的优势，而不是使用 Telnet 或 NFS 访问服务器上的邮箱。 1984 年，RFC 918 发布，定义了邮局协议 (POP)。 POP 背后的想法是为客户端计算机提供一种从 SMTP 服务器上的邮箱检索电子邮件的简单方法，以便可以在本地使用。

重点是简单； POP 的第一个版本的 RFC 只有 5 页长，它定义的标准非常简陋。它只描述了一个简单的操作序列，用户输入名称和密码进行身份验证，然后下载邮箱的全部内容。简单是好的，但也有限制。

1985 年 2 月，RFC 937 发布：邮局协议 - 版本 2。POP2 通过定义一组更丰富的命令和回复来扩展 POP 的功能。这包括能够只读取某些消息而不是转储整个邮箱的重要能力。当然，这是以协议复杂性略有增加为代价的，但 POP2 协议仍然非常简单。

POP 的这两个早期版本在 20 世纪 80 年代中期使用，但不是很广泛。同样，这仅仅是因为当时对离线电子邮件访问协议的需求有限。大多数人在 1990 年代之前不上网。

1988 年，RFC 1081 发布，描述了邮局协议 (POP3) 的版本 3。到那时，个人计算机 (PC) 已从奇葩转变为计算和网络世界中的重要场所。 POP3 以 POP2 为基础，但经过改进和增强，其理念是为 PC 和其他通常不连接到 Internet 的客户端访问和检索电子邮件提供一种简单有效的方式。

POP3 的开发一直持续到 1990 年代，每隔几年就会发布几个新的 RFC。 RFC 1081 依次被 RFC 1225、1460、1725 和 1939 淘汰。尽管进行了大量修订，但协议本身自 1988 年以来并没有太大变化；这些 RFC 仅包含对协议原始描述的相对较小的调整。 RFC 1939 于 1996 年发布，POP3 从那时起就没有进行过修订，尽管一些后续的 RFC 定义了基本协议的可选扩展和补充，例如替代身份验证机制。

虽然 POP3 得到了增强和改进，但其开发人员仍然坚持使用非常简单的协议来快速高效地传输电子邮件的基本理念。 POP3 是一种直接基于状态的协议，客户端和服务器在会话期间经历三个阶段。定义了极少数命令来执行简单任务，即使在进行了上述所有更改和修订之后，该协议也有最少的“绒毛”。

由于我不清楚的原因，几乎每个人都用版本号来指代邮局协议；也就是说，他们说“POP3”而不是“POP”。这是事实，尽管大多数人不使用许多其他协议的版本号，而且几乎没有人使用任何其他版本的 POP。但这是惯例，我将在本节的其余部分遵循它。

**关键概念：**邮局协议 (POP) 是目前最流行的 TCP/IP 电子邮件访问和检索协议。它实现了离线访问模型，允许用户从他们的 SMTP 服务器检索邮件并在他们的本地客户端计算机上使用它。它被专门设计成一个非常简单的协议，只有少量的命令。 POP 的当前修订版是第 3 版，因此该协议通常缩写为 POP3。

**注意：**有一些 POP 实现试图实现断开连接的访问模型，但收效有限。然而，IMAP 通常用于此目的，因为它更适合该访问模型。有关详细信息，请参阅 IMAP 概述。





###### 4.2.3.5.2-2 POP3 一般操作、客户端/服务器通信和会话状态（部分：1 2）

正如我在上一个主题中提到的，邮局协议旨在仅执行一个主要功能，并且可以快速而简单地执行此功能：允许客户端计算机从服务器访问和检索电子邮件。该协议的操作简单明了，这对您来说是个好消息，您是想了解其工作原理的人。

<u>**客户端/服务器通信**</u>
POP3 是一种常规的 TCP/IP 客户端/服务器协议。要提供对邮箱的访问，必须在邮箱所在的服务器上安装并持续运行 POP3 服务器软件。这不一定是运行为这些邮箱接收邮件的 SMTP 服务器软件的同一物理硬件设备——可以使用 NFS 等机制来允许 POP3 和 SMTP 服务器都在本地“查看”邮箱。 POP3 客户端是常规的最终用户电子邮件程序，它们连接到 POP3 服务器以获取邮件；示例包括 Microsoft Outlook、Eudora Email 等。

POP3 使用传输控制协议 (TCP) 进行通信，以确保命令、响应和消息数据的可靠传输。 POP3 服务器在众所周知的端口号 110 上“侦听”来自 POP3 客户端的传入连接请求。建立 TCP 连接后，将激活 POP3 会话。客户端向服务器发送命令，服务器回复响应和/或电子邮件消息内容。

<u>**命令和响应代码**</u>
POP3 命令的长度为三个或四个字母，并且不区分大小写。它们都以纯 ASCII 文本发送，并以“CRLF”序列结束，就像 FTP 和 SMTP 命令一样。 POP3 回复也是文本的，但该协议不使用 FTP（和 SMTP）复杂的三位回复代码机制。事实上，它只定义了两个基本响应：

- +OK：肯定的响应，当命令或动作成功时发送；和
- -ERR：否定响应，发送以指示发生错误。

这些消息可能伴随着解释性文本，特别是在 -ERR 响应的情况下，以提供有关错误性质的更多信息。

<u>**会话状态**</u>

POP3 根据有限状态机 (FSM) 进行描述，会话在其“生命周期”过程中会经历三种状态转换，如图 306 所示。

注意：我在描述 TCP FSM 的主题中描述了有限状态机背后的概念。


在您被吓倒之前，请意识到与 TCP 等协议的 FSM 不同，这个协议真的很简单，因为它是线性的。会话按以下顺序经历每个状态一次且仅一次：

授权状态：服务器向客户端提供问候语，表明它已准备好接受命令。客户端然后提供身份验证信息以允许访问用户的邮箱。

事务状态：允许客户端对邮箱进行各种操作。这些包括列出和检索消息，以及将检索到的消息标记为删除。

更新状态：当客户端完成所有任务并发出 QUIT 命令时，会话自动进入此状态，服务器实际删除在事务状态中标记为删除的消息。然后会话结束，两者之间的 TCP 连接终止。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\popfsm.png)

​                                                                        **图 306：邮局协议 (POP3) 有限状态机**

POP 使用有限状态机来描述它的操作，但它非常简单，因为它是线性的。一旦在 POP3 客户端和 POP3 服务器之间建立了 TCP 连接，会话将依次经历三个状态，之后连接将终止。


POP3 的设计使得在这些状态中的每一个中只能发送某些命令。接下来的三个主题描述了在这三种状态下发生的活动，包括客户端在每种状态下发出的命令。

**关键概念：**POP3 是一种客户端/服务器协议，使用简单的线性状态序列进行描述。 POP3 会话开始于 POP3 客户端与 POP3 服务器建立 TCP 连接，此时会话处于授权状态。身份验证成功后，会话进入事务状态，此时客户端可以执行邮件访问事务。完成后，客户端结束会话并自动进入更新状态，执行清理功能并结束 POP3 会话。





###### 4.2.3.5.2-3 POP3 授权状态：用户认证过程和命令（部分：1 2 3）

当客户端向服务器发送 TCP 连接请求时，POP3 客户端和 POP3 服务器之间的会话开始。 使用标准 TCP“三次握手”建立连接，POP3 会话开始。 POP3 会话的三个状态中的第一个是授权状态，它负责向服务器验证 POP3 客户端。

当会话首次进入此状态时，服务器向客户端发送问候消息。 这告诉客户端连接处于活动状态并准备好让客户端发送第一个命令。 这种问候语的一个例子是：

```
+OK POP3 server ready
```

现在要求客户端对尝试访问邮箱的用户进行身份验证。 这既证明了用户有权访问服务器，又能识别用户以便服务器知道正在请求哪个邮箱。

<u>**标准 POP3 认证**</u>

POP3 中的正常授权方法是标准的“用户名/密码”登录。这与在 FTP 中执行登录的方式几乎相同；甚至命令都是一样的。首先，客户端发出 USER 命令以及用户的邮箱名称（他或她的用户名或电子邮件地址）。服务器以中间确认响应。客户端然后使用 PASS 命令发送用户的密码。假设登录有效，服务器向客户端响应一个表明身份验证成功的确认。响应通常还会指定邮箱中等待用户的消息数。这个过程如图 307 所示。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\popauth.png)


​                                                                         **图 307：邮局协议 (POP3) 用户身份验证过程**

一旦建立了从客户端到服务器的 TCP 连接，服务器就会回复一条问候消息，然后简单的 POP3 身份验证过程就开始了。客户端使用 USER 和 PASS 命令向服务器发送用户名和密码，服务器评估信息以确定是否允许客户端访问。


表 256 显示了一个 POP3 授权示例，客户端的命令突出显示，服务器的响应以斜体显示。


​                                                                                          **表 256：POP3 授权示例**

```
+OK POP3 server ready
USER jane@somewhereelse.com
+OK
PASS *******
+OK jane@somewhereelse.com has 3 messages
```

**注意：**某些服务器可能只需要用户名（“jane”），而其他服务器则需要完整的电子邮件地址，如示例所示。 另外，我没有在表 256 中显示 Jane 的密码； 那不是很好，是吗？ 杰

如果授权成功，则 POP3 会话转换为可以执行邮件访问命令的事务状态。 如果用户名或密码不正确，则给出错误响应并且会话无法继续。 授权也可能由于技术问题而失败，例如服务器无法锁定邮箱（可能是由于新邮件通过 SMTP 到达）

<u>**使用 APOP 的替代身份验证**</u>

由于许多人认为用户/密码授权不足以满足现代互联网的安全需求，因此 POP3 标准还定义了另一种身份验证方法，即使用 APOP 命令。这是一种基于 MD5“消息摘要”加密算法的更复杂的技术。

如果服务器支持此技术，它会在其开始问候语中提供一个字符串，指示每个 POP3 会话唯一的时间戳。然后，客户端使用此时间戳值和服务器和客户端已知的“共享秘密”执行 MD5 计算。此计算的结果包含在客户端的 APOP 命令中。如果与服务器的计算相匹配，则认证成功；否则会话保持授权状态。

邮局协议还旨在允许通过添加其他身份验证机制对其进行扩展。此过程基于可选 AUTH 命令的使用，如 RFC 1734 中所述。

**关键概念：**POP3 会话开始于授权状态，在该状态下，客户端设备需要通过服务器进行身份验证。默认情况下，POP3 仅使用简单的用户名/密码身份验证方法。还为需要更高安全性的应用程序定义了可选的身份验证方法。



###### 4.2.3.5.2-4 POP3 事务状态：邮件和信息交换过程和命令（部分：1 2）

一旦 POP3 客户端成功验证了正在执行邮箱访问的用户，会话就会从授权状态转换为事务状态。 这个连接阶段的内容并不神秘：它是 POP3 客户端发出执行邮箱访问和消息检索事务的命令的地方。

<u>**POP3 事务命令**</u>
POP3 中定义的大部分命令只在Transaction 状态下有效。 表 257 按它们在 RFC 1939 中出现的顺序列出了它们中的每一个。


​                                                                        **表 257：POP3 事务命令**

| **Command Code** | **Command**            | **Parameters**                     | **Description**                                              |
| ---------------- | ---------------------- | ---------------------------------- | ------------------------------------------------------------ |
| ***STAT\***      | *Status*               | None                               | 请求邮箱的状态信息。服务器通常会响应告诉客户端邮箱中的消息数，以及它包含的数据字节数。可选地，还可以返回更多信息。 |
| ***LIST\***      | *List Messages*        | Optional message number            | 列出邮箱中消息的信息；通常这意味着显示消息编号及其大小。如果给出消息编号，则仅提供该消息的信息；否则，将描述邮箱的全部内容，一次一行，最后一行仅包含一个句点。 |
| ***RETR\***      | *Retrieve*             | Message number                     | 从邮箱中检索特定消息。服务器以标准的“+OK”消息响应，然后立即以 RFC 822 格式发送消息，一次一行。在最后一行之后发送一个带有句点的行。 |
| ***DELE\***      | *Delete*               | Message number                     | 将消息标记为已删除。删除后，任何进一步尝试访问消息（例如使用 LIST 或 RETR）都会导致错误。 |
| ***NOOP\***      | *No Operation*         | None                               | 什么也没做;服务器只返回 +OK 回复。                           |
| ***RSET\***      | *Reset*                | None                               | 将会话重置为进入事务状态时的状态。这包括“取消删除”任何已标记为删除的消息。 |
| ***TOP\***       | *Retrieve Message Top* | Message number and number of lines | 允许客户端仅检索消息的开头。服务器返回消息的标题，并且仅返回前 N 行，其中 N 是指定的行数。此命令是可选的，并非所有服务器都支持。 |
| ***UIDL\***      | *Unique ID Listing*    | Optional message number            | 如果指定了消息编号，则返回该消息的唯一标识代码；否则，返回邮箱中每条消息的标识码。此命令是可选的，并非所有服务器都支持。 |

<u>**典型的 POP3 邮件交换序列**</u>

事务状态相对“非结构化”，因为不需要以任何特定顺序发出命令来满足标准的要求。但是，检索邮箱的方式有一个自然的过程，这意味着命令通常按以下方式使用：

1. 客户端发出 STAT 命令以查看邮箱中的消息数。

2. 客户端发出 LIST 命令，服务器告诉它要检索的每条消息的编号。

3. 客户端发出 RETR 命令以获取第一条消息，如果成功，则使用 DELE 将其标记为删除。客户端对每个连续的消息使用 RETR/DELE。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\poptrans.png)

​                                                                      **图 308：邮局协议 (POP3) 邮件交换流程**

此图显示了 POP3 客户端用来从 POP3 服务器检索电子邮件的典型命令和回复交换。 STAT 命令用于获取邮箱统计信息，随后是 LIST 命令获取邮件编号列表。然后使用 RETR 依次检索每条消息，并用 DELE 标记为删除。 （直到进入更新状态，消息才真正被删除。）


表 258 和图 308 显示了一个邮箱访问序列示例，该邮箱包含两条总计 574 字节的消息；客户端的命令被突出显示，服务器的响应以斜体显示。


​                                                                           **表 258：示例 POP3 邮件交换过程**

```
STAT
+OK 2 574
LIST
+OK
1 414
2 160
.
RETR 1
+OK
(Message 1 is sent)
.
DELE 1
+OK message 1 deleted
RETR 2
+OK
(Message 2 is sent)
.
DELE 2
+OK message 2 deleted
QUIT
```

为回复每个命令而发送的确切消息取决于服务器； 有些只是说“+OK”，而另一些则提供更多描述性文本，就像我在此处对 DELE 命令的响应所做的那样。

在某些情况下，POP3 客户端可能被配置为在检索邮件后不删除它们。 这很有用，例如，当基于 Web 的访问与传统的电子邮件客户端程序结合使用时。

**关键概念：**授权成功后，POP3 会话转换为事务状态，此时客户端实际访问服务器上的电子邮件消息。 客户端通常首先从服务器检索有关邮箱的统计信息，并获得邮箱中邮件的列表。 客户端然后一次检索每条消息，在服务器上标记每条检索到的消息以供删除。



###### 4.2.3.5.2-5 POP3 更新状态：邮箱更新和会话终止过程和命令

一旦 POP3 客户端完成了它需要执行的所有电子邮件消息访问和检索事务，它就完成了 POP3 会话——只是还没有真正完成。 POP3 标准定义了一个最终会话状态，即更新状态，以执行各种内务处理功能，然后终止 POP3 会话和底层 TCP 连接。

从 Transaction 状态到 Update 状态的转换发生在 POP3 客户端发出 QUIT 命令时。此命令没有参数，用于告诉 POP3 服务器客户端已完成并希望结束会话。 POP3 标准将此命令列为其更新状态描述的一部分，尽管它显然确实是从事务状态发出的。

POP3 服务器收到 QUIT 命令后，它所做的一件事是删除任何先前在事务状态下被 DELE 命令标记为删除的邮件。有趣的是，邮局协议选择实施这个两阶段删除过程。该标准没有具体描述这样做的原因，但它似乎是一种预防措施，以确保邮件不会被意外删除和丢失。

通过将实际删除延迟到更新状态，服务器可以验证在移动到更新状态之前它已经接收并处理了所有命令。如果用户在退出事务状态之前改变了他或她对删除的想法，它还允许在必要时使用 RSET 命令“撤消”消息的删除。最后，如果客户端和服务器之间的通信出现任何问题，导致 TCP 连接在发出 QUIT 命令之前过早中断，则不会从邮箱中删除任何消息，从而为客户端提供第二次检索它们的机会，以防万一没有正确收到。

一旦删除的消息被删除，服务器向客户端返回一个确认； “+OK”表示更新成功，“-ERR”表示删除一条或多条已删除消息时出现某种问题。假设没有问题，“+OK”响应还将包含某种“再见”消息，表明会话即将关闭。然后断开客户端和服务器之间的 TCP 连接并完成会话。

POP3 邮件检索会话通常持续几秒或几分钟，但如果邮箱很大并且客户端和服务器之间的连接速度很慢，则可能需要很多分钟。只要客户端继续发送命令，客户端和服务器可以连接多长时间没有限制。 POP3 服务器通常会实现一个不活动计时器，但是，该计时器是可定制的，但持续时间必须不少于 10 分钟。如果连接在不活动计时器的整个持续时间内都处于空闲状态，则服务器会假定客户端遇到某种问题并关闭连接。如果发生这种情况，服务器不会删除任何标记为删除的消息——同样，这是为了给客户端另一个机会来检索这些消息，如果第一次获取它们时出现问题。

**关键概念：**当 POP3 客户端完成其电子邮件事务时，它会发出 QUIT 命令。这会导致自动进入更新状态，此时服务器执行必要的清理操作，包括删除在事务状态中标记为删除的任何消息。



###### 4.2.3.5.3 TCP/IP 因特网消息访问协议 (IMAP/IMAP4)

离线邮箱访问模型提供了大多数用户需要的基本邮件访问功能。使用流行的邮局协议 (POP3)，用户可以访问他或她的邮箱并检索消息，以便可以在本地机器上阅读它们。这种模型具有简单的优点，但没有提供当今需求越来越大的许多功能，例如跟踪消息的状态和允许同时从多个客户端设备进行访问。为了更好地控制邮件的访问和管理方式，我们必须使用在线或断开连接的访问模型。创建 Internet 消息访问协议 (IMAP) 是为了允许使用这些访问模型，为 TCP/IP 电子邮件用户提供丰富的功能和灵活性。

在本节中，我描述了 Internet 消息访问协议的操作。我像往常一样开始，先大致了解一下协议、它的历史、版本和标准。这包括与更简单的 POP3 相比其优点的讨论。我描述了当前版本的标准 IMAP4 的操作，着重于客户端和服务器设备如何通信，并展示了 IMAP 会话如何通过一系列四种状态。我描述了如何使用 IMAP 命令、结果和响应，并讨论了可以在 IMAP 会话期间随时使用的命令。然后，我将描述在三种主要 IMAP 状态中的每一种状态下执行的过程和使用的命令。

**相关信息：**IMAP 为拥有比 POP 更丰富的功能集而付出的主要代价是更加复杂。在本节中，我描述 IMAP 的详细程度与我在其部分中描述 POP 的详细程度大致相同。请参阅相应的 RFC 文档以获取该协议的完整描述以及对其一些细微差别的更多讨论，尤其是许多命令和参数的语法，这将需要数十页才能在此处完全涵盖。




###### 4.2.3.5.3-1 IMAP 概述、历史、版本和标准（部分：1 2 3）

邮局协议（POP，或当前版本后的 POP3）已成为访问 TCP/IP 邮箱的最流行的协议，这并不是因为它的丰富功能，而是尽管它缺乏功能。 POP 实现了离线邮件访问模型，其中邮件被检索然后从邮箱所在的服务器上删除，因此可以在本地机器上使用。每天有数百万人使用 POP3 来访问收到的邮件。不幸的是，由于离线访问模型的工作方式，POP3 不能真正用于其他用途。

正如我在邮箱访问模型概述中所说，在线模型是我们在“理想世界”中使用的模型，在这个世界中，我们所有人都始终连接到 Internet。离线访问是必要的，因为事实并非如此；大多数用户客户端计算机仅定期连接到 Internet。将邮件从服务器传输到客户端机器消除了我们在线执行邮件功能的要求，但让我们失去了服务器上中央邮件存储的好处。

<u>**集中式电子邮件存储的好处**</u>
您可能会发现将邮件存储在某个远程服务器上而不是我们的本地计算机上可能会更好，这违反直觉。主要原因是访问的灵活性。使用 POP3 进行离线访问的最大问题之一是邮件从中央服务器永久传输到一台客户端计算机。只要一个人只使用那一台机器，这就很好，但是如果这个人有不同的工作和家用电脑，或者经常出差怎么办？如果多个用户共享一个邮箱怎么办？近年来，这些担忧变得越来越重要。

另一个问题是数据安全和安全。由 Internet 服务提供商运行的邮件服务器通常位于专业管理的数据中心。它们受到仔细控制和监视，并且定期进行备份。大多数人不会对自己的 PC 和 Macintosh 电脑采取这种措施，也不会定期备份数据。因此，与保留在服务器上相比，邮件在本地机器上丢失的可能性更大。

当然，我们还有一个问题就是不想强迫用户一直在线访问他们的邮件。解决方案是断开连接的邮箱访问模型，它结合了在线和离线访问的优势。邮件在离线模式中被检索供本地使用，因此用户不必持续连接到服务器。但是，对邮箱所做的更改会在客户端和服务器之间同步。邮件保留在服务器上，将来可以从不同的客户端访问它，并且服务器充当用户邮件的永久“大本营”。

认识到这些好处后，人们尝试使用断开连接的访问模型来实现 POP。通常，这是通过使用 POP 命令检索邮件但仍将其留在服务器上来完成的，这是许多客户端程序中的一个选项。这行得通，但范围有限；例如，当消息既被检索又被留在服务器上时，跟踪哪些消息是新的或旧的就成了一个问题。 POP 只是缺少正确断开连接访问所需的功能，因为它不是为此设计的。

<u>**IMAP 功能**</u>

在 20 世纪 80 年代中期，斯坦福大学开始开发一种新协议，该协议将提供一种更强大的访问用户邮箱的方式。结果是交互式邮件访问协议，后来更名为 Internet 消息访问协议 (IMAP)。 IMAP 旨在为用户访问电子邮件消息的方式提供灵活性的特定目的。它实际上可以在所有三种访问模式下运行：在线、离线和断开连接访问。其中，协议的大多数用户感兴趣的是在线和断开连接的访问模式；脱机访问类似于 POP 的工作方式。

IMAP 允许用户执行以下所有操作：

从远程服务器访问和检索邮件，以便在本地使用邮件，同时将其保留在服务器上。

- 设置消息标志，以便用户可以跟踪他或她已经看到、已经回答等的消息。

- 管理多个邮箱并将消息从一个邮箱传输到另一个邮箱。您可以将邮件组织成类别，这对于处理多个项目的人员、在不同邮件列表中的人员等非常有用。

- 在下载消息之前确定有关消息的信息，以决定是否检索它。

- 仅下载邮件的一部分，例如 MIME 多部分邮件的一个正文部分。这在大型多媒体文件与短文本元素组合在一条消息中的情况下非常有用。

- 管理电子邮件以外的文档。例如，IMAP 可用于访问 Usenet 消息。

当然，IMAP 也有一些缺点，但并不多。一是它更复杂，但实际上并没有那么复杂，而且该协议已经存在了足够多的时间，所以这不是一个大问题。 IMAP 最重要的症结在于它的使用不如 POP，因此支持它的提供商不像支持 POP 的提供商那样容易找到。然而，随着越来越多的人发现 IMAP 的好处，这种情况正在发生变化。

**关键概念：**邮局协议因其简单和悠久的历史而广受欢迎，但 POP 的特点很少，通常只支持相当有限的离线邮件访问方法。为了让用户更灵活地访问、检索和使用电子邮件消息，开发了 Internet 消息访问协议 (IMAP)。 IMAP 主要用于在线和断开连接的访问模型；它允许用户从许多不同的设备访问邮件、管理多个邮箱、只选择某些邮件进行下载等等。由于它的许多功能，它越来越受欢迎。

<u>**IMAP 历史和标准**</u>

IMAP 有一段相当有趣的历史。我的意思是“有趣”，因为用于大多数 TCP/IP 协议的正常有序开发过程崩溃了。结果并不像 SNMP 所发生的那样糟糕，但仍然不寻常。

正式记录为 Internet 标准的第一个 IMAP 版本是 1988 年 7 月发布的 RFC 1064 中的 IMAP 版本 2 (IMAP2)。该版本在 1990 年 8 月的 RFC 1176 中进行了更新，保留了相同的版本号。然而，似乎一些参与 IMAP 的人对 RFC 1176 不满意，因此他们创建了一个定义 IMAP 版本 3 (IMAP3) 的新文档：RFC 1203，于 1991 年 2 月发布。这被其作者描述为“反提议”。

然而，无论出于何种原因，IMAP3 从未被市场接受。相反，人们继续使用 IMAP2 一段时间。后来创建了对该协议的扩展，称为 IMAP2bis，它向 IMAP 添加了对 MIME 的支持。由于 MIME 的实用性，这是一个重要的发展，并且创建了许多 IMAP2bis 的实现。尽管如此，出于某种原因，IMAP2bis 从未作为 RFC 发布。这可能是由于与 IMAP3 发布相关的问题。

**注：**“bis”是一个拉丁词，意思是“再次”。当没有分配“官方”新版本号时，它有时用于区分更改的技术文档与其以前的版本。

1994 年 12 月，IMAP 版本 4 (IMAP4) 在两个 RFC 中发布：描述主要协议的 RFC 1730 和描述 IMAP4 身份验证机制的 RFC 1731。 IMAP4 是 IMAP 的当前版本，也是当今广泛使用的版本。它继续被完善；最新的特定版本实际上称为版本 4rev1 (IMAP4rev1)，在 RFC 2060 中定义，最近由 RFC 3501 定义。大多数人仍将其称为“IMAP4”，这就是我将在本节的其余部分中所做的。



###### 4.2.3.5.3-2 IMAP 一般操作、客户端/服务器通信和会话状态（部分：1 2 3）

IMAP 执行与 POP 相同的基本工作：它允许访问存储在远程服务器上的邮箱。出于这个原因，IMAP 在操作上与 POP 有点相似也就不足为奇了，如果您已经阅读过 POP3，就会注意到本主题中的这些相似之处。但是，IMAP 比 POP 具有更多的特性和功能。因此，就操作方式而言，IMAP 比 POP 更复杂也就不足为奇了，我想您也会注意到这一点。

<u>**客户端/服务器通信**</u>
IMAP4 是一种标准的客户端/服务器协议，类似于 POP3 和大多数其他 TCP/IP 应用程序协议。为使该协议起作用，IMAP4 服务器必须在用户邮箱所在的服务器上运行。同样，与 POP3 一样，这不一定是与提供 SMTP 服务的服务器相同的物理服务器。必须以某种方式使 SMTP 可以访问传入邮件和 IMAP4 可以访问邮件检索和修改邮箱。还需要一种机制来确保独占访问以避免各种协议之间的干扰。

IMAP4 使用传输控制协议 (TCP) 进行通信。这确保所有命令和数据都以正确的顺序可靠地发送和接收。 IMAP4 服务器在众所周知的端口号 143 上侦听来自 IMAP4 客户端的传入连接请求。建立 TCP 连接后，IMAP4 会话开始。

<u>**会话状态**</u>

IMAP4 客户端和服务器之间的会话在 IMAP 标准中使用有限状态机 (FSM) 进行了描述，这是我在 TCP 操作概述中解释的一种描述性工具。同样，这类似于解释 POP3 操作的方式，只是 IMAP4 稍微复杂一些。它的 FSM 定义了四个状态而不是三个，而在 IMAP4 中 POP3 会话是线性的（每个状态只经过一次），会话不是。然而，状态流仍然相当简单，主要遵循从一个状态到下一个状态的逻辑顺序。 IMAP FSM 如图 309 所示。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\imapfsm.png)




​                                                               **图 309：互联网消息访问协议 (IMAP) 有限状态机**

IMAP 有限状态机比 POP（图 306）稍微复杂一些，但仍然相当简单。一旦在客户端和服务器之间建立了 TCP 连接，就进入未验证状态；授权成功后，会话进入 Authenticated 状态。会话可能会在 Authenticated 和 Selected 之间移动多次，因为不同的邮箱被选择使用，然后在不再需要时关闭。从任何状态开始，会话都可能终止，进入注销状态。

 


以下是 IMAP 状态，按它们在会话中出现的通常顺序排列：

1. 未验证状态：会话通常在建立 TCP 连接后在此状态下开始，除非使用了特殊的 IMAP 预验证功能（我们将很快介绍此功能）。此时，客户端除了提供身份验证信息之外实际上不能做太多事情，因此它可以进入下一个状态。

2. Authenticated State：客户端已经完成身份验证，无论是通过先前状态的身份验证过程还是通过预身份验证。现在允许客户端对整个邮箱执行操作。客户端必须在允许单个消息操作之前选择一个邮箱。

3. 选定状态：选择邮箱后，允许客户端访问和操作邮箱中的各个消息。当客户端完成当前邮箱后，它可以关闭它并返回到 Authenticated 状态以选择一个新的邮箱来使用，或者可以注销以结束会话。

4. 注销状态：客户端可以从任何其他状态发出注销命令以请求结束 IMAP 会话。如果会话不活动计时器到期，会话也可能进入此状态。服务器发送响应并终止连接。

在四种 IMAP 状态中，只有前三种是“交互式”的，即客户端主动发出命令并由服务器提供响应的状态。某些 IMAP 命令可以在会话处于任何状态时使用，而其他命令是特定于状态的。下一个主题以一般术语描述 IMAP 命令和响应。

**关键概念：**IMAP 是客户端/服务器应用程序，IMAP 会话始于客户端与服务器建立 TCP 连接。然后会话通常以未验证状态开始并保持该状态直到成功验证。在 Authenticated 状态下，客户端可以对整个邮箱执行操作，但必须选择一个邮箱才能转换到 Selected 状态，在该状态下可以操作单个邮件。客户端可以通过依次选择每个邮箱来处理多个邮箱；然后它从服务器注销。

<u>**正常会话建立和问候语**</u>

服务器确定 IMAP 会话以何种状态开始，并发送一条问候消息告诉客户端会话已建立并指示它处于哪种状态。通常，服务器将以 Not Authenticated 状态开始会话。 这通过正常的 OK 问候消息传达给客户端，例如：

```
* OK <server-name> server ready
```

<u>**预认证*Preauthentication\***</u>
在某些情况下，服务器可能已经知道客户端的身份，这可能是一些外部身份验证机制的结果，而不是 IMAP 协议的一部分。 在这种情况下，使用了一个特殊的问候语：

```
* PREAUTH <server-name> server ready, logged in as <user-name>
```

这告诉客户端它已经处于 Authenticated 状态。

如果服务器出于某种原因决定不接受来自客户端的新会话，它可以用 BYE 响应而不是 OK 或 PREAUTH 来响应，并关闭 TCP 连接。



###### 4.2.3.5.3-3 IMAP 命令、结果和响应（部分：1 2 3 4）

一旦建立了 IMAP 会话，客户端和服务器之间的所有通信都以客户端发送的命令和服务器返回的响应的形式进行。与 POP3 一样，命令和响应以 ASCII 文本字符串的形式发送，并以“CRLF”序列结束，使它们与使用 Telnet 协议发送数据的方式兼容。但是，IMAP 与 POP 和许多其他 TCP/IP 应用程序协议在某些方面有很大不同。

关于 IMAP 命令的第一个有趣的事情是，大多数命令并没有缩写为三个或四个字母的代码——它们是完整拼写的。因此，POP3 有一个 STAT 命令，而 IMAP 中的命令称为 STATUS。命令通常以大写形式显示，正如我在本指南中所做的那样，但实际上是不区分大小写的。

<u>**命令标记和多命令功能**</u>
IMAP 还使用一个有趣的命令标记系统来显式地将客户端命令与某些服务器响应相匹配。每次客户端发送命令时，它都会在命令前加上一个对于特定会话唯一的标记。标签通常是短字符串，其中的数字单调递增； IMAP 标准中的示例将第一个命令标记为“a0001”，然后是第二个“a0002”，依此类推。也就是说，只要每个命令都有唯一的标签，使用什么标签方案并不重要。当服务器需要发送特定于命令的响应时，它会使用适当的命令标记来标记响应。但是，并非所有回复都被标记。

该标准没有明确说明为什么需要这种标记方案，但我相信它可能与 IMAP 的多命令功能有关。 IMAP 客户端可以向服务器发送一系列命令进行处理，而不是一次只发送一个命令。当某些命令需要很长时间才能完成时，这可以提高性能。唯一的限制是命令必须足够独立，这样无论它们的处理顺序如何，执行它们的结果都是相同的。例如，发送读取特定实体的命令与将值存储到同一实体中的命令相结合是不允许的。

**关键概念：**IMAP 使用唯一标识符标记其命令。然后服务器可以在回复中使用这些标签，以将回复与它们对应的命令相匹配。这使得多个命令可以连续发送到 IMAP 服务器。

<u>**命令组**</u>

IMAP 命令根据使用时 IMAP 会话可能处于的会话状态组织成组。这些团体是：

- “任何状态”命令：可在 IMAP 会话期间随时使用的少量命令。

- Not Authenticated State Commands：只能在Not Authenticated状态下使用的命令。当然，它们通常用于身份验证。

- 经过身份验证的状态命令：这些命令用于对邮箱执行各种操作。 （请注意，尽管名称如此，这些命令也可以在选定状态下使用。）

- 选定状态：一组用于访问和操作只能在选定状态下使用的单个消息的命令。

具有不同的 Authenticated 和 Selected 状态和命令组的原因是 IMAP 专门设计用于启用多个邮箱的操作。在会话开始并且客户端通过身份验证后，客户端可以发出适用于整个邮箱的命令。但是，它可能不会发出操作单个消息的命令，直到它告诉服务器它想要使用哪个邮箱，这将它置于已选择状态。客户端还可以从 Selected 状态发出邮箱命令。

**注意：**除了这四组之外，该标准还定义了一种扩展机制，允许定义新的命令。这些必须以字母“X”开头。



<u>**"Any State" Commands**</u>

表 259 描述了 IMAP“任何状态”命令，可在需要时使用。


​                                                                               **表 259：IMAP“任何状态”命令**

| **Command**                | **Parameters** | **Description**                                              |
| -------------------------- | -------------- | ------------------------------------------------------------ |
| ***CAPABILITY\***          | None           | Asks the server to tell the client what capabilities and features it supports. |
| ***NOOP (No Operation)\*** | None           | Does nothing. This may be used to reset the inactivity timer or to periodically prompt the server to send notification if new messages arrive. |
| ***LOGOUT\***              | None           | Tells the server that the client is done and ready to end the session, which transitions to the Logout state for termination. |

<u>**结果和回应**</u>
当然，IMAP 客户端发送的每个命令都会引起 IMAP 服务器的某种反应。服务器根据客户端的请求采取行动，然后返回一个或多个文本字符串以指示发生了什么。服务器收到命令后实际上可以发送两种类型的回复：

- 结果：这是一个回复，通常表示命令的状态或处置。它可能标有其正在通信的结果的命令的命令标记，或者可能是未标记的一般消息。

- 响应：服务器发送给客户端的任何类型的信息。它通常不带有命令标签，也不是专门用于指示服务器状态。

**注意：**IMAP 标准有时会以我发现不一致的方式使用术语“结果”、“响应”和“回复”。如果您检查 IMAP RFC，请注意这一点。

**关键概念**：IMAP 服务器对客户端命令发出两种基本类型的回复。结果是指示命令成功、失败或状态的回复；响应是包含服务器需要发送给客户端的许多不同类型信息的一般回复。

<u>***Result Codes\***</u>

响应命令发送的结果代码主要有三种，在某些情况下会使用两种特殊代码：

- OK：命令的肯定结果，通常与成功命令的标记一起发送。会话开始时，可能会在服务器的初始问候语中不加标签地发送。

- 否：命令的否定结果。标记时，表示命令失败；未标记时，用作有关服务器上某些情况的一般警告消息。

- BAD：表示错误信息。当错误与已发送的命令直接相关时，它被标记，否则不被标记。

- PREAUTH：在会话开始时发送的未标记消息，指示不需要身份验证；会话直接进入 Authenticated 状态。

- BYE：当服务器即将关闭连接时发送。它始终是未标记的，并且在对注销命令的答复或由于任何其他原因要关闭连接时发送。

<u>***Response Codes\***</u>
与结果相反，响应用于将各种信息传递给客户端设备。响应通常包括描述性文本，提供有关所传达内容的详细信息。它们可以直接作为对命令的答复发送，也可以偶然发送给命令。后一种情况的一个例子是，如果新消息在会话期间到达邮箱。在这种情况下，服务器将在第一时间“单方面”传达此信息，而不管最近发送了什么命令。

以下是 IMAP 标准定义的响应码：

- ALERT：要发送给 IMAP 客户端的人类用户的警告消息，以通知他或她一些重要的事情。

- BADCHARSET：当由于使用不受支持的字符集而导致搜索失败时发送。

- CAPABILITY：服务器能力列表；可以作为初始服务器问候语的一部分发送，因此不需要使用 CAPABILITY 命令。

- PARSE：当解析电子邮件消息的标头或 MIME 内容时发生错误时发送。

- PERMANENTFLAGS：传达允许客户端操作的消息状态标志列表。

- READ-ONLY：告诉客户端邮箱只能在只读模式下访问。

- READ-WRITE：告诉客户端邮箱可以读写模式访问。

- TRYCREATE：当 APPEND 或 COPY 命令由于目标邮箱不存在而失败时发送，建议客户端先尝试创建邮箱。

- UIDNEXT：与指定要在操作中使用的下一个唯一标识符值的十进制数一起发送。这些标识符允许每条消息被唯一标识。

- UIDVALIDITY：用指定唯一标识符有效性值的十进制数发送，用于确认消息的唯一标识。

- UNSEEN：发送一个十进制数字，告诉客户端标记为尚未看到的消息（新消息）。



###### 4.2.3.5.3-4 IMAP 未验证状态：用户验证过程和命令（部分：1 2）

IMAP4 会话以 IMAP4 客户端与 IMAP4 服务器建立 TCP 连接开始。 正常情况下，IMAP4服务器不知道客户端是谁，因此在Not Authenticated状态下启动会话。 出于安全原因，客户端在通过身份验证之前不得执行任何操作。 因此，此状态的唯一目的是允许客户端提供有效凭据，以便会话可以进入已验证状态。

<u>**IMAP 未验证状态命令**</u>
IMAP4 标准定义了三种不同的机制，客户端可以通过这些机制来验证自己。 这些是使用仅在未验证状态下允许的三种不同命令中的一种或多种来实现的，如表 260 所示。


​                                                                             **表 260：IMAP 未验证状态命令**

| **Command**         | **Parameters**                | **Description**                                              |
| ------------------- | ----------------------------- | ------------------------------------------------------------ |
| ***LOGIN\***        | User name and password        | 指定用于身份验证的用户名和密码。                             |
| ***AUTHENTICATE\*** | Authentication mechanism name | 告诉服务器客户端想要使用特定的身份验证机制，并提示客户端和服务器交换适用于该机制的身份验证信息。 |
| ***STARTTLS\***     | None                          | 告诉 IMAP4 服务器使用传输层安全 (TLS) 协议进行身份验证，并提示 TLS 协商开始。 |

<u>**IMAP 身份验证方法**</u>

认证方式有：

1. 普通登录：这是典型的“用户名/密码”技术，单独使用 LOGIN 命令。这类似于 POP3 中使用的简单方案，除了在 IMAP4 中使用一个命令来发送用户名和密码。由于命令和参数以纯文本形式发送，这是迄今为止最不安全的身份验证方法，除非结合使用其他一些方法，否则标准不建议这样做。

2. TLS 登录：这是一种安全登录，首先使用 STARTTLS 命令启用传输层安全 (TLS) 协议，然后可以安全地使用 LOGIN 命令。请注意，STARTTLS 只会导致 TLS 协商开始，它本身不会导致 IMAP 客户端被验证。仍然必须使用 LOGIN 或 AUTHENTICATE。

3. 协商的身份验证方法：AUTHENTICATE 命令允许客户端和服务器使用它们都支持的任何身份验证方案。服务器可以指示它支持哪些方案以响应 CAPABILITY 命令。指定要使用的认证机制后，服务器和客户端按照指定机制的要求交换认证信息。这可能需要发送一行或多行附加数据。

响应 LOGIN 或 AUTHENTICATE 命令，如果身份验证成功，服务器将发送“OK”消息，然后转换到 Authenticated 状态。如果由于信息不正确导致身份验证失败，它将发送“否”响应。然后客户端可以尝试另一种身份验证方法，或者使用 LOGOUT 命令终止会话。

**关键概念：**IMAP 支持三种基本类型的身份验证：普通用户名/密码登录；使用传输层安全性进行身份验证；或者在客户端和服务器之间协商一些其他的身份验证方法。在某些情况下，IMAP 服务器可能会选择对它能够可靠识别的客户端进行预验证，在这种情况下，将完全跳过未验证状态。



###### 4.2.3.5.3-5 IMAP 身份验证状态：邮箱操作/选择过程和命令（部分：1 2）

在 IMAP 会话的正常进程中，已验证状态是 IMAP 客户端能够代表其用户执行“有用工作”的第一个状态。在使用 LOGIN 或 AUTHENTICATE 命令成功验证后，通常会从未验证状态达到此状态。或者，服务器可以预先验证客户端并直接在此状态下开始会话。

一旦进入 Authenticated 状态，客户端就被认为被授权向服务器发出命令。但是，它可能只给出处理整个邮箱的命令。如一般操作概述中所述，创建 IMAP 是为了允许访问和操作多个邮箱。出于这个原因，客户端必须在处理单个消息的命令被给出之前动态地指定它想要使用哪个邮箱。这是在这种状态下使用 SELECT 或 EXAMINE 命令完成的，这会导致转换到 Selected 状态，正如我们将看到的那样。

也可以在会话过程中重新进入 Authenticated 状态。如果从 Selected 状态使用 CLOSE 命令关闭特定邮箱，服务器将认为该邮箱“取消选择”并且会话将转换回 Authenticated 状态，直到做出新的选择。如果从选定状态给出新的 SELECT 或 EXAMINE 命令但失败，也会发生同样的情况。

<u>**认证状态命令**</u>
表 261 简要描述了可在已验证状态下使用的邮箱操作命令：


​                                                                               **表 261：IMAP 认证状态命令**

| **Command**        | **Parameters**                                      | **Description**                                              |
| ------------------ | --------------------------------------------------- | ------------------------------------------------------------ |
| ***SELECT\***      | Mailbox name                                        | 选择一个特定的邮箱，以便可以访问其中的邮件。如果命令成功，会话将转换为 Selected 状态。服务器通常还会为客户端提供有关所选邮箱的信息；见下文。 |
| ***EXAMINE\***     | Mailbox name                                        | 与 SELECT 命令完全相同，只是邮箱以“只读”方式打开；不允许对其进行任何更改。 |
| ***CREATE\***      | Mailbox name                                        | 创建具有给定名称的邮箱。                                     |
| ***DELETE\***      | Mailbox name                                        | 删除指定的邮箱。                                             |
| ***RENAME\***      | Current and new mailbox names                       | 重命名邮箱。                                                 |
| ***SUBSCRIBE\***   | Mailbox name                                        | 将邮箱添加到服务器的“活动”邮箱集。当 IMAP4 用于 Usenet 消息访问时，有时会使用它。 |
| ***UNSUBSCRIBE\*** | Mailbox name                                        | 从“活动”列表中删除邮箱。                                     |
| ***LIST\***        | Mailbox name or reference string                    | 根据提供的参数请求可用邮箱名称的部分列表。                   |
| ***LSUB\***        | Mailbox name or reference string                    | 与 LIST 相同，但仅返回“活动”列表中的名称。                   |
| ***STATUS\***      | Mailbox name                                        | 请求指定邮箱的状态。服务器响应提供信息，例如邮箱中的消息数量以及最近到达和未看到的消息的数量。 |
| ***APPEND\***      | Mailbox name, message, optional flags and date/time | 将消息添加到邮箱。                                           |

注意：以上所有命令也可以在 Selected 状态下使用； 他们真的应该被称为“Authenticated+Selected”state.commands。

<u>**SELECT 和 EXAMINE 命令**</u>

当成功发出 SELECT 或 EXAMINE 命令时，服务器将向客户端返回一组有关邮箱的有用信息，这些信息可用于指导从 Selected 状态发出的命令。此信息包括以下三个强制性响应：

- <n> EXISTS：告诉客户端邮箱中的消息数。
- <n> RECENT：告诉客户端最近到达（新）消息的数量。

- FLAGS (<flag-list>)：告诉客户端邮箱支持哪些标志。其中包括：“\Seen”、“\Answered”、“\Flagged”（标记为特别注意）、“\Deleted”、“\Draft”和“\Recent”。 （反斜杠是标志名称的一部分。）

来自服务器的回复也可能包含这些可选回复：

- UNSEEN <n>：第一条看不见的消息的消息号。

- PERMANENTFLAGS (<flag-list>)：允许客户端更改的标志列表（与上面的 FLAGS 响应一样）。

- UIDNEXT <n>：下一个唯一标识符值。这用于检查自客户端上次访问邮箱以来对邮箱所做的更改。

- UIDVALIDITY <n>：唯一标识符有效性值，用于确认有效的UID值。

**核心概念：**在Authenticated状态下，IMAP客户端可以对整个邮箱进行操作，例如创建、重命名或删除邮箱，或者列出邮箱内容。 SELECT 和 EXAMINE 命令用于告诉 IMAP 服务器客户端想要打开哪个邮箱以进行特定消息的访问。成功执行任一命令都会导致服务器向客户端提供有关邮箱的几条重要信息，之后会话转换为 Selected 状态。



###### 4.2.3.5.3-6 IMAP 选定状态：消息操作过程和命令（部分：1 2 3）

一旦 IMAP 客户端被授权访问服务器，它就会进入 Authenticated 状态，允许它在整个邮箱上执行任务。由于 IMAP 允许操作多个邮箱，因此在客户端告诉服务器想要使用哪个邮箱之前，不能使用特定于消息的命令。在给定会话中一次只能访问一个邮箱。

SELECT 或 EXAMINE 命令成功发出后，会话进入 Selected 状态。在这种状态下，消息和邮箱命令的完整“调色板”可供客户端使用。这包括下面的消息特定命令以及为已验证状态定义的邮箱命令。大多数 IMAP 的消息特定命令不包括邮箱名称作为参数，因为服务器自动知道这些命令适用于在已验证状态下选择的任何邮箱。

只要客户端继续处理特定选定（或“已检查”）邮箱的工作，会话就会保持选定状态。三种不同的操作可以导致从 Selected 状态转换：

- 如果客户端在处理完当前邮箱后无事可做，它可以使用 LOGOUT 命令结束会话。

- 客户端可以使用 CLOSE 命令告诉服务器它已完成对当前邮箱的处理，但保持会话处于活动状态。服务器将关闭邮箱，会话将返回到 Authenticated 状态。

- 客户端可以发出新的 SELECT 或 EXAMINE 命令。这将隐式关闭当前邮箱，然后打开新邮箱。在这种情况下，转换是从 Selected 状态回到 Selected 状态，但是有一个新的当前邮箱。

<u>**选定状态命令**</u>

表 262 列出了只能在选定状态下使用的消息特定命令。


​                                                                              **表 262：IMAP 选定状态命令**

| **Command**    | **Parameters**                                               | **Description**                                              |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| ***CHECK\***   | None                                                         | 为当前邮箱设置一个“检查点”。这用于标记某个操作序列何时完成。 |
| ***CLOSE\***   | None                                                         | 显式关闭当前邮箱并将会话返回到已验证状态。发出此命令时，服务器还将隐式地对邮箱执行 EXPUNGE 操作。 |
| ***EXPUNGE\*** | None                                                         | 永久删除任何被客户端标记为删除的消息。这是在邮箱关闭时自动完成的。 |
| ***SEARCH\***  | Search criteria and an optional character set specification  | 在当前邮箱中搜索符合指定搜索条件的邮件。服务器响应列出符合条件的消息编号。见下文。 |
| ***FETCH\***   | Sequence of message numbers and a list of message data items (or a macro) | 从当前邮箱中检索有关一条消息或一组消息的信息。请参阅下面的更多细节。 |
| ***STORE\***   | Sequence of message numbers, message data item name and value | 存储一组消息的特定消息数据项的值。请参阅下面的更多细节。     |
| ***COPY\***    | Sequence of message numbers and a mailbox name               | 将指定的消息集复制到指定邮箱的末尾。                         |
| ***UID\***     | Command name and arguments                                   | 用于允许使用唯一标识符号执行上述其他命令之一以指定要操作的消息，而不是通常的消息序列号。 |

<u>**FETCH 和 STORE 命令**</u>

这个命令列表可能看起来非常短；例如，您可能想知道读取邮件标题或正文、删除邮件、将邮件标记为“已读”等的特定命令在哪里。答案是这些（以及更多）都是作为强大而灵活的 FETCH 和 STORE 命令的一部分实现的。

FETCH 命令可用于从一条消息或一系列消息中读取多个特定元素。 “消息数据项”列表指定要读取的信息。可以读取的数据项包括消息的标题、消息正文、为消息设置的标志、消息的日期等等。 FETCH 命令甚至可以用来检索消息的一部分，例如 MIME 多部分消息的一个正文部分，这确实非常有用。为方便起见，还定义了特殊的“宏”。例如，客户端可以指定消息数据项“FULL”来获取与消息关联的所有数据。

FETCH 的补充，STORE，用于对消息进行更改。但是，该命令不用于修改报头内容、报文体等基本报文信息。相反，它的存在是为了改变消息的状态标志。例如，在回复特定消息后，客户端可以使用 STORE 命令为该消息设置“\Answered”标志。

与 POP 和许多其他协议一样，为了安全起见，IMAP 中的消息删除分两个阶段完成。客户端使用 STORE 命令为要删除的任何消息设置“\Deleted”标志。邮件只有在邮箱被删除时才会真正删除，通常是在邮箱关闭时。

IMAP4 中的搜索工具也非常复杂，允许客户端同时根据多个条件查找消息。例如，使用适当的语法，您可以搜索“所有标记为已回答且由 Jane Jones 在 2004 年 4 月 1 日之前发送的帖子”。因此，即使在非常大的邮箱中，IMAP 客户端的用户也可以轻松定位特定消息，而无需下载数百条消息进行搜索。

**关键概念：**客户端打开特定邮箱后，IMAP 会话进入Selected 状态，此时可以执行阅读和复制单个电子邮件消息等操作。此状态下使用的两个最重要的命令是 FETCH，可用于检索整个消息、部分消息或仅某些消息头或标志；和 STORE，它设置消息的状态信息。 IMAP 还包括一个强大的搜索工具，为用户在邮箱中查找消息提供了极大的灵活性。当客户端完成对特定邮箱的操作时，它可能会选择一个不同的邮箱并重新进入 Selected 状态，关闭邮箱并返回到 Authenticated 状态，或者退出，自动进入 Logout 状态。



##### 4.2.3.5.4 其他 TCP/IP 电子邮件访问和检索方法

邮局协议 (POP3) 和 Internet 消息访问协议 (IMAP4) 是用于 TCP/IP 电子邮件访问和检索的两种最常用的协议。今天使用电子邮件的大多数人都选择了 POP3 的简单性和普遍接受性，而越来越多的人选择了 IMAP4 的强大功能和灵活性。然而，有些人选择“替代”方式访问电子邮件，我认为其中两种方式值得仔细研究。

本节中描述的两种方法均基于“在线”电子邮件访问模型，但就它们在电子邮件系统中的作用以及它们的使用方式而言，它们是一项对比研究。第一种是我所说的直接服务器访问，它描述了几种无需使用特殊的远程访问协议（如 POP 和 IMAP）即可访问邮箱的方法。第二种是使用万维网浏览器访问电子邮件。这是最新的电子邮件访问方法，并且每年都在流行。

###### 4.2.3.5.4-1 TCP/IP 直接服务器电子邮件访问（部分：1 2）

在我对电子邮件消息通信的概述讨论中，我讨论了完整的邮件交换中涉及的不同设备，以及消息是如何创建的，然后如何从发件人传输到收件人。 SMTP 用于在大多数情况下将邮件传送到收件人的邮箱。该过程的最后一步是将消息从邮箱所在的服务器传送到客户端使用的机器。

电子邮件旅程的最后一部分通常是电子邮件访问和检索协议（如 POP3 或 IMAP4）的工作。这些是定制的协议，我的意思是它们是专门为电子邮件通信过程的最后一步创建的。但是，也有几种通用方法，电子邮件客户端可以通过这些方法访问邮箱，而根本不需要使用特殊协议。

<u>**电子邮件直接访问方法**</u>
这些方法都是在线电子邮件访问模型的变体。它们通常通过建立对邮箱所在服务器的直接访问来工作。邮箱本身只是某处服务器上的一个文件，因此如果可以使用该文件，则可以使用读取和写入邮箱文件的电子邮件客户端程序像任何其他文件一样查看和操作它。以下是一些可以做到这一点的方法：

- 直接使用 SMTP 服务器：显然，访问邮箱的最简单方法是简单地登录到服务器本身。对于大多数人来说，这不是一个选择，即使在过去的几年里，出于安全原因和其他原因，也不经常这样做。然而，即使在今天，仍有一些人在运行他们自己的 SMTP 服务器，这使他们能够相当大地控制对电子邮件的访问。

- 文件共享访问：使用诸如网络文件系统之类的协议，可以在用户的客户端机器上安装一个邮箱，在那里可以像访问本地文件一样访问它。邮件仍在服务器上而不是客户端计算机上，但是客户端和服务器之间的通信对用户和电子邮件客户端软件都是“透明的”。

- 拨号远程服务器访问：客户端计算机上的用户拨号到其邮箱所在的服务器并登录到该服务器。然后用户可以发出命令来访问该服务器上的邮件，就像他或她直接登录到它一样。

- Telnet 远程服务器访问：用户可以使用 Telnet 协议连接到服务器以进行远程访问，而不是拨入服务器。

<u>**直接服务器电子邮件访问的优点和缺点**</u>

这些技术更常与分时系统相关联，分时系统通常使用 UNIX 系列操作系统。它们也经常结合在一起；例如，通常为 UNIX 用户提供远程访问，但大多数公司不希望用户直接登录到 SMTP 服务器。相反，Internet 服务提供商可能会在一台名为“mail.companyname.com”的机器上运行 SMTP 服务器，并运行另一台专为客户端访问而设计的名为“users.companyname.com”的服务器。用户可以通过拨入“用户”机器来访问电子邮件，这将使用 NFS 来访问“邮件”机器上的用户邮箱。

直接访问服务器是一种已经存在了几十年的方法。曾几何时，这是大多数人访问电子邮件的方式，主要原因有两个。首先，如果回溯得足够远，那时还没有开发出像 POP 或 IMAP 这样的协议； TCP/IP 电子邮件系统作为一个整体早于它们很多年，直接访问是当时唯一的选择。其次，多年前使用电子邮件和网络的一般方式与今天不同。大多数人家里没有个人电脑，也没有我们所知的互联网。使用调制解调器或 Telnet 远程访问 UNIX 服务器以获取电子邮件和其他服务只是“完成方式”。

我自己在 10 多年前就开始使用直接服务器访问来访问电子邮件，并且至今仍在使用。我通过 Telnet 登录到一台客户机并使用一个名为 elm 的 UNIX 电子邮件程序来访问和操作我的邮箱。对我来说，这提供了许多优势。首先也是最重要的是，我可以在世界任何地方的任何一台 Internet 上的机器上使用 Telnet 访问我的电子邮件。其次，由于我是直接登录的，所以当新邮件到达时我会立即收到通知，而不必例行检查新邮件。第三，我的邮箱始终可以访问，我的所有邮件始终位于专业管理的数据中心的安全服务器上。第四，我可以完全控制我的邮箱，可以对其进行编辑、将其分成文件夹、编写自定义“垃圾邮件”过滤器，或者做任何我需要做的事情。

这可能听起来不错，但由于这种方法的缺点，如今大多数人不使用直接服务器访问。一个大问题是您必须登录到 Internet 才能访问您的电子邮件。另一个可能更大的要求是需要熟悉 UNIX 和 UNIX 电子邮件程序。 UNIX 根本不像 Windows 或 Apple Macintosh 等图形操作系统那样“用户友好”。例如，我的 UNIX 电子邮件程序不支持颜色，无法显示附加的图形图像。我必须从 MIME 消息中提取图像和其他文件并将它们传输到我自己的 PC 上进行查看。

今天大多数人不了解 UNIX，也不想了解它。他们更喜欢使用基于 POP3 或 IMAP4 的花哨的图形电子邮件程序。然而，仍然有一些我们周围的老 UNIX 恐龙认为直接访问的好处大于缺点。哦，我忘了提到的另一个好处是，当您使用 UNIX 时，电子邮件很难感染病毒。

**关键概念：**在某些系统上，用户可以直接访问电子邮件服务器，而不是使用 POP3 或 IMAP4 等专用协议来检索邮件。这在 UNIX 系统上最常见，其中 Telnet 或 NFS 等协议可以为用户提供对服务器上邮箱的共享访问权限。这是最古老的电子邮件访问方法；它为用户提供了对其邮箱的最大控制权，非常适合那些必须从多个位置访问邮件的用户。主要缺点是这意味着用户必须在 Internet 上才能阅读电子邮件，而且通常还需要熟悉 UNIX 操作系统，如今很少有人使用它。



###### 4.2.3.5.4-2 TCP/IP 万维网电子邮件访问（部分：1 2）

我不了解你，但当喇叭裤过时时，我非常高兴……然后，当几年前它们重新流行时，我感到非常羞愧！我想这就是时尚界的方式。有时，即使在网络中，“旧的又是新的”。在这种情况下，我指的是在线 TCP/IP 电子邮件访问模型的使用。

大多数电子邮件用户都喜欢在线访问的优势，尤其是从各种不同机器上阅读邮件的能力。他们不关心的是使用 Telnet（“Tel-what？”）、UNIX（“我父亲以前用过，我想……”J）和非直观的基于字符的电子邮件等协议的直接服务器访问程式。他们想要在线访问，但又希望它简单易用。

在 1990 年代，万维网得到发展并迅速流行起来，这在很大程度上归功于它的易用性。数以百万计的人习惯于启动 Web 浏览器来执行各种不同的任务，以至于使用 Web 几乎成为“第二天性”。没过多久，有人就发现使用 Web 是一种在服务器上轻松访问电子邮件的自然方式。现在有时称为 Webmail。

<u>**基于 Web 的电子邮件如何工作**</u>
这种技术很简单：它利用超文本传输协议 (HTTP) 的灵活性，以非正式的方式将电子邮件从邮箱服务器“隧道”到客户端。打开 Web 浏览器（客户端），并为访问用户邮箱的特殊 Web 服务器文档提供 URL。 Web 服务器从邮箱中读取信息并将其发送到 Web 浏览器，并在浏览器中显示给用户。

这种方式使用了类似直接服务器访问的在线访问模型，因为请求必须发送到Web服务器，这就需要用户在线。当使用 NFS 或 Telnet 时，邮件也会保留在服务器上。

<u>**基于 Web 的电子邮件访问的优点和缺点**</u>

基于 Web 的邮件和 UNIX 方法之间的最大区别在于前者对于非专家来说更容易使用。自从这个想法首次提出以来，许多公司都加入了 Web 邮件的行列，使用这种技术的人数在短短几年内激增至数百万。许多免费服务甚至作为“.com 泡沫”的一部分出现在 1990 年代后期，允许任何 Internet 用户使用 Web 免费发送和接收电子邮件（除了可能容忍广告）。许多 Internet 服务提供商 (ISP) 现在提供 Web 访问作为传统 POP/IMAP 访问之外的选项，这对旅行的人很有用。谷歌的新 Gmail 服务是最新加入抽奖活动的，它为用户提供 1 GB 的电子邮件存储空间，以换取在其网站上查看谷歌的文字广告。

然而，该技术也有缺点，正如您所想象的那样，这些缺点与其优点直接相关。基于 Web 的邮件易于使用，但不灵活；用户不能直接访问他或她的邮箱，只能使用提供商网站实现的任何功能。例如，假设用户想在他或她的邮箱中搜索特定的字符串；这就要求Web界面提供这个功能。如果没有，则用户就不走运了。

基于 Web 的邮件也有一个对某些人来说是个问题的缺点：性能。使用常规的UNIX直接访问，很容易快速读取一个邮箱；下载邮件后，使用 POP3 访问也是如此。相反，基于 Web 的邮件服务意味着每个请求都需要另一个 HTTP 请求/响应周期。许多基于 Web 的服务都是免费的这一事实通常意味着服务器过载，这会加剧速度问题。

请注意，当基于 Web 的邮件与其他方法（如 POP3）结合使用时，必须小心避免出现奇怪的结果。如果 Web 界面不提供传统电子邮件客户端的所有功能，则当使用基于 Web 的访问时，客户端所做的某些更改可能不会显示出来。此外，默认情况下使用 POP3 的邮件检索会从服务器中删除邮件。如果您使用 POP3 读取您的邮箱，然后尝试使用 Web 从其他地方访问这些邮件，您会发现邮件“不见了”——它在您使用 POP3 客户端的客户端机器上。许多电子邮件客户端程序现在允许您指定您希望在使用 POP3 检索邮件后将邮件保留在服务器上。

**关键概念：**在过去几年中，开发了一种允许使用万维网 (WWW) 访问电子邮件的新方法。这种技术正在迅速普及，因为它提供了直接服务器访问的许多好处，例如在世界任何地方接收电子邮件的能力，同时比旧的直接访问方法更简单、更容易，例如使到服务器的 Telnet 连接。基于 WWW 的电子邮件在某些情况下可以与其他方法或协议（例如 POP3）结合使用，从而为用户阅读邮件的方式提供了极大的灵活性。



#### 4.2.4 Usenet（网络新闻）和 TCP/IP 网络新闻传输协议 (NNTP)

电子邮件是现代 Internet 上消息传输的“中坚力量”之一，但实际上只是为相对较小的特定用户群之间的通信而设计的。在许多情况下，电子邮件并不适用，例如需要在大量参与者之间共享信息时，甚至不一定所有人都认识彼此。一个典型的例子就是分享新闻；提供新闻的人通常希望让任何感兴趣的人都能普遍获得新闻，而不是指定一组特定的收件人。

为了通过互联网分发新闻和其他类型的一般信息，创建了一个消息系统，称为 Usenet（用于用户网络）和 Network News。此应用程序类似于电子邮件，允许大量用户写入和读取消息。但是，它的设计使用与电子邮件截然不同的模型，侧重于公共共享和反馈。在 Usenet 中，任何人都可以编写可供任意数量的收件人阅读的消息，并且同样可以回复其他人编写的消息。 Usenet 是最早广泛部署的基于互联网的群组通信应用程序之一，并已发展成为世界上最大的在线社区之一，数百万人使用它来共享信息、提出问题和讨论数千个不同的主题。

在本节中，我将详细描述 Usenet，分两小节讨论它的使用方式和工作原理。第一部分概括性地介绍了 Usenet，讨论了它的历史以及它用于通信、消息存储和格式化的模型。第二部分描述了网络新闻传输协议 (NNTP)，该协议当前广泛用于在 TCP/IP 中实现 Usenet 通信。

很多人常常把Usenet系统作为一个整体等同于用于在Internet上承载Usenet消息的NNTP协议。但是，它们并不相同； Usenet 早于 NNTP，NNTP 只是一种用于传送 Usenet 消息的协议。如果您试图说 Usenet 和 NNTP 在 Usenet 本身上是相同的，那么 Usenet 的老前辈们会很快指出这一点。 J 这就是我将讨论分为两个小节的原因之一。在 Usenet 的概述中，我确实简要讨论了过去用于移动 Usenet 消息的除 NNTP 之外的方法，但是由于它们今天没有被广泛使用，所以我没有过多地强调它们。

**背景信息：**Usenet 的工作方式有几个方面与用于电子邮件的标准和技术密切相关。在本节中，我假设您对电子邮件的工作原理有基本的了解。如果您还没有阅读有关电子邮件的部分，请至少回顾一下电子邮件系统的概述，并阅读有关电子邮件消息格式的部分，因为 Usenet 消息直接基于 RFC 822 e-邮件消息标准。




##### 4.2.4.1 Usenet 概述、概念和一般操作

电子邮件是手写信件或办公室间备忘录的现代版本，Usenet 是公司时事通讯的更新版本，自助餐厅公告牌、茶歇聊天和饮水机八卦会议，都融入了一。 Usenet 新闻组消息通过 Internet 传播到世界各地，为具有共同兴趣的人们提供了一种形成在线社区、讨论事件、解决问题和相互支持的方式，同时也促进了普通的社交和娱乐活动。

在本节中，我将讨论整个 Usenet 及其运作方式。我从 Usenet 的概述和历史开始。然后，我对 Usenet 采用的通信模型进行了高层次的介绍，讨论了消息是如何创建、传播、存储和读取的。我讨论了 Usenet 寻址机制，它采用分层新闻组集的形式。我还解释了 Usenet 消息是如何格式化的，并讨论了提供有关消息的信息并控制消息的显示和通信方式的特殊标头。

###### 4.2.4.1.1 Usenet 概述、历史和标准（部分：1 2 3）

我们天生就是高度社交和创造性的动物，因此，我们总是在寻找新的交流方式。在计算机首次连接在一起后不久，人们就认识到这些互连也提供了将人联系在一起的方式。二十多年前，使用计算机创建在线社区的愿望导致了 Usenet 的创建。

<u>**新闻网的历史**</u>
就像几乎所有与网络相关的事物一样，Usenet 的起步非常卑微。 1979 年，Tom Truscott 还是北卡罗来纳州杜克大学的一名学生，并在 UNIX 操作系统的诞生地贝尔实验室实习了一个暑假。他非常享受这段经历，以至于当他那年秋天回到学校时，他怀念贝尔实验室密集的 UNIX 环境。他使用 Unix 到 Unix 复制协议 (UUCP) 将信息从他的本地机器发送到其他机器，反之亦然，包括建立返回贝尔实验室的电子连接。

基于这个想法，Truscott 和杜克大学的同学 Jim Ellis 与杜克大学和附近的北卡罗来纳大学教堂山分校的其他 UNIX 爱好者合作，开发了在线社区的想法。目标是创建一个系统，让学生可以使用 UNIX 编写和阅读消息，让他们既可以获得技术帮助，又可以保持社交联系。该系统的设计类似于对连接系统的所有用户开放的在线时事通讯。为了共享信息，消息被发布到新闻组，任何用户都可以访问消息以阅读它们并做出回应。

杜克大学和北卡罗来纳大学教堂山分校的早期工作促成了该系统最早版本的初始消息格式和软件的开发，该系统被称为网络新闻（Net News）和 Usenet（用户网络的缩写） .起初，该系统只有两台计算机，共享发布在两个不同新闻组中的消息。然而，该系统的价值立即得到认可，并且很快将许多新站点添加到该系统中。这些站点被安排在一个结构中，以允许使用直接 UUCP 连接有效地传递消息。用于传递新闻文章的软件也在不断发展并变得更加强大，阅读和撰写文章的软件也是如此。

随着时间的推移，新闻组本身也发生了变化。创建了许多新的新闻组，并定义了层次结构以帮助保持新闻组以有意义的方式组织。随着越来越多的站点和用户加入 Usenet，更多的兴趣领域被识别出来。如今，Usenet 新闻组的数量惊人：超过 100,000 个。虽然其中许多群组未被使用，但仍有成千上万个活跃的群组讨论几乎所有可以想象的话题，从太空探索、烹饪、生物化学、PC 故障排除到养马。还有专门针对特定领域的区域新闻组；例如，有一组讨论加拿大事件的新闻组；另一个用于讨论纽约地区发生的事情，等等。

<u>**Usenet 操作和特征概述**</u>

Usenet 始于用户编写要分发的消息。消息发布后，在 TCP/IP 网络上的组，它被存储在该用户的本地新闻服务器上，特殊软件将它的副本发送到其他连接的新闻服务器。该消息最终传播到世界各地，任何选择阅读 TCP/IP 网络新闻组的人都可以看到该消息。

Usenet 的真正强大之处在于，在阅读消息后，任何用户都可以在同一新闻组中对其做出响应。与原始消息一样，回复将传播到每个连接的系统，包括原始消息作者使用的系统。这使得 Usenet 对于共享有关最近发生的事件的信息、进行社交讨论，尤其是对于获得有关问题的帮助（例如解决技术故障或获得饮食计划帮助）非常有用。

Usenet 的特别之处在于它不是任何形式化的系统，也不基于任何正式定义的标准。这是一个完全以“临时”方式开发系统的典型例子；软件被创造出来，人们开始使用它，软件被改进，事情才刚刚开始。已经编写了某些标准来规范 Usenet 的工作方式，例如描述 Usenet 消息格式的 RFC 1036，但这些标准更多地作为历史文档而不是规范性标准。

同样没有负责 Usenet 操作的“中央权威”，尽管新用户通常认为有一个。与拨号公告板系统或基于 Web 的论坛不同，Usenet 仅依靠站点之间的合作来工作；没有“主管经理”。由于这个原因，Usenet 有时被称为“无政府状态”，但这并不准确。并不是没有规则，只是参与系统的管理人员做出政策决定，例如支持哪些新闻组。该系统也有某些“独裁”的方面，因为只有某些人（通常是系统管理员）可以决定是否创建某些类型的新新闻组。该系统还具有“社会主义”元素，因为机器所有者需要相互共享消息。因此，简化的政治标签实际上根本不适用于 Usenet。

每个社区都有自己的文化，包括 Usenet 在内的在线社区也是如此。在 Usenet 上有一种规定可接受行为的整体文化，在 Usenet 中还有数以千计特定于新闻组的“文化”，每一种文化都是在数以千计的参与者多年来的著作中发展而来的。甚至还有专门解释 Usenet 本身如何运作的新闻组，您可以在其中了解 newbies（新用户）、netiquette（发布消息的礼仪规则）和相关主题。

<u>**Usenet 传输方法**</u>

正如我之前所说，Usenet 消息最初是使用 UUCP 传输的，创建它是为了让 UNIX 系统直接通信，通常使用电话线。多年来，所有 Usenet 消息都只是通过计算机化的电话呼叫从一台机器发送到另一台机器（就像曾经的电子邮件一样）。每台加入网络的计算机都会连接到 Usenet 上的一台计算机，并定期从它那里接收消息；该计算机的所有者又必须同意向其他计算机提供消息。

一旦 TCP/IP 在 1980 年代开发出来并且 Internet 发展到相当大的规模和范围，开始使用它来承载 Usenet 消息而不是 UUCP 是有意义的。网络新闻传输协议 (NNTP) 专门用于描述通过 TCP 传送 Usenet 消息的机制。它在 1986 年发布的 RFC 977 中正式定义，并在 2000 年 10 月的 RFC 2980 中描述了 NNTP 扩展。

多年来，Usenet 一直使用 NNTP 和 UUCP 传输，但 NNTP 现在是用于绝大多数 Usenet 流量的机制，因此这是我在本指南中讨论 Usenet 的主要焦点。 NNTP 不仅用于将 Usenet 文章分发到各种服务器，还用于其他客户端操作，例如发布和阅读消息。因此，它用于 Usenet 消息通信中的大多数步骤。

正是由于 NNTP 和 Internet 在今天的 Usenet 中承载消息的关键作用，这些概念经常被混淆。然而，必须记住，Usenet 不是指任何类型的物理网络或网络互联技术；相反，它是一个逻辑用户网络。该逻辑网络已从 UUCP 数据传输演变为 NNTP 和 TCP/IP，但 Usenet 本身是相同的。

今天，Usenet 面临来自许多其他群组消息应用程序和协议的“竞争”，包括基于 Web 的公告板系统和聊天室。然而，在四分之一世纪之后，Usenet 已经建立起来，每天都有数百万人使用。虽然对某些人来说，主要基于文本的媒体似乎过时了，但它是全球群体交流的支柱，并且可能在未来许多年内继续如此。

**关键概念：**第一个在线电子社区是 1979 年由想要保持联系并共享新闻和其他信息的大学生建立的。今天，这个用户网络 (Usenet)，也称为网络新闻，已经发展成为一个跨越全球的逻辑网络。通过向 Usenet 新闻组发布消息，人们可以共享有关各种感兴趣主题的信息。 Usenet 最初是以参与主机之间建立的直接连接的形式实现的；今天，互联网是信息传输的载体



###### 4.2.4.1.2 Usenet 通信模型：消息组合、发布、存储、传播和访问（部分：1 2 3）

当杜克大学的学生决定创建他们的在线社区时，电子邮件已经广泛使用，并且还有许多邮件列表在运行。在互联网出现之前，电子邮件通常使用 UUCP 传输，这与 Usenet 旨在采用的方法相同。那么显而易见的问题是，为什么不简单地使用电子邮件在站点之间进行通信呢？

主要原因是电子邮件并不是真正设计用于促进在线社区的创建，在该社区中可以轻松地在群组中共享信息。电子邮件在这方面的主要问题是只有指定为邮件收件人的个人才能阅读邮件。没有任何人可以编写消息并将其放在一个开放的地方，任何人都可以阅读它，类似于在公共场所发布时事通讯。

大群电子邮件的另一个问题与效率有关：如果您将 1,000 人放入邮寄列表，则发送到该列表的每条消息都必须复制并传递 1,000 次。早期网络的带宽和资源有限；使用电子邮件进行大规模的群组通信是可能的，但远非理想。

**关键概念：**虽然电子邮件可用于群组通信，但它有两个重要的局限性。首先，消息必须专门发送给每个收件人，这样就不可能进行公共消息传递。其次，每个收件人都需要发送一份单独的邮件副本，因此向许多收件人发送邮件意味着使用大量资源。

<u>**Usenet 的公共分发方向**</u>
为了避免使用电子邮件进行群发消息的问题，Usenet 被设计为使用与电子邮件完全不同的通信和消息处理模型。 Usenet 通信模型与用于电子邮件的通信模型之间的决定性区别在于，Usenet 消息处理以公共分发的概念为导向，而不是向单个用户的私人传递。这会影响 Usenet 通信工作方式的各个方面：

- 寻址：消息不是从发件人发往任何特定的收件人或一组收件人，而是发往一个用新闻组名称标识的组。

- 存储：消息不存储在单独的邮箱中，而是存储在服务器的中央位置，服务器的任何用户都可以访问它们。

- 交付：消息不是从发件人的系统传送到收件人的系统，而是通过 Internet 传播到所有连接的系统，以便任何人都可以阅读它们。

<u>**Usenet 通信过程**</u>

为了帮助更详细地说明 Usenet 通信的工作原理，让我们看一下典型 Usenet 消息（也称为文章——这些术语可互换使用）的编写、传输和阅读所涉及的步骤。假设流程开始于用户 Ellen，向新闻组 misc.rural 发布请求帮助治疗一匹病马。由于她正在发布消息，因此她将被称为消息发布者。简化后，过程中的步骤（如图 310 所示）如下：

1. 文章撰写：Ellen 首先创建了一篇 Usenet 文章，该文章是根据 Usenet 要求的特殊消息格式构建的。此消息类似于电子邮件消息，因为它具有标题和正文。正文包含要发送的实际消息，而标头包含描述消息并控制消息传递方式的标题行。例如，一个重要的标题行指定了文章所针对的新闻组。

2. 文章发布和本地存储：完成文章后，Ellen 将文章提交给 Usenet，这一过程称为发布。 Ellen 计算机上的客户端软件程序将 Ellen 的消息传输到她的本地 Usenet 服务器。该消息存储在该服务器上适当的文件存储区域中。现在该服务器的所有其他决定阅读 misc.rural 的用户都可以立即使用它。

3. 文章传播：此时，Ellen 的本地服务器是唯一拥有她的消息副本的服务器。文章必须发送到其他站点，这个过程称为分发，或者更常见的是传播。 Ellen 的消息将从她的本地 Usenet 服务器传送到她的服务器直接连接到的其他服务器。然后它会依次从这些服务器传播到它们连接的其他服务器，依此类推，直到所有需要它的 Usenet 服务器都拥有该消息的副本。

4. 文章访问和检索：由于 Usenet 文章存储在中央服务器上，为了阅读它们，必须在服务器上访问它们。这是使用 Usenet 新闻阅读器程序完成的。例如，名为 Jane 的 misc.rural 的其他一些读者可能会访问该组并找到 Ellen 的消息。如果 Jane 能够帮助 Ellen，她可以通过发表自己的文章来回复 Ellen。然后这将传播回 Ellen 的服务器，她可以在其中读取并依次回复。当然，misc.rural 的所有其他读者也可以随时加入对话，这就是 Usenet 对于群组交流非常有用的原因。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\nntpmodel.png)

​                                                                          **图 310：Usenet（网络新闻）传播模型**

此图说明了在现代 Usenet 上使用 NNTP 创建、传播和读取消息的方法；它在某些方面类似于图 301 的电子邮件模型图。在此示例中，一条消息由发帖人 Ellen 创建，并由读者 Jane 阅读。该流程从 Ellen 在编辑器中创建消息并发布开始。她的 NNTP 客户端将它发送到她的本地 NNTP 服务器。然后它从该本地服务器传播到相邻服务器，通常包括其上游服务器，用于在 Internet 上发送消息。其他 NNTP 服务器接收消息，包括来自 Jane 本地服务器的上游服务器。它将消息传递给 Jane 的本地服务器，Jane 使用 NNTP 客户端访问和读取消息。

Jane 可以回复消息，在这种情况下，将重复相同的过程，但会朝相反的方向返回给 Ellen（当然，还会返回给成千上万的其他读者，此处未显示。）

<u>**消息传播和服务器组织**</u>

传播绝对是 Usenet 通信过程中最复杂的部分。在“过去”，UUCP 用于传播；每个 Usenet 服务器都将被编程为定期拨号到另一台服务器，并将自上次连接以来收到的所有新文章提供给它。文章会在 Usenet 上从一个服务器泛滥到另一个服务器。然而，这是耗时且低效的，并且仅在文章数量相对较小的情况下才有效。

在现代 Usenet 中，网络新闻传输协议 (NNTP) 用于在设备之间传输消息的所有阶段。文章使用客户机和本地服务器之间的 NNTP 连接发布，然后使用相同的协议将文章传播到其他相邻的 NNTP 服务器。客户端新闻阅读器软件也使用 NNTP 从服务器检索消息。

NNTP 服务器通常按层次结构排列，最大和最快的服务器向它们“下游”的较小服务器提供服务。根据连接的安排方式，NNTP 服务器可以建立连接以立即将新发布的文章发送到“上游”服务器以分发到 Usenet 的其余部分，或者服务器可以被动地等待来自上游的连接服务器询问是否有新的文章要发送。以现代互联网的速度，文章从一台服务器传播到另一台服务器通常只需要几分钟甚至几秒钟，即使跨越大洲也是如此。

也可以限制 Usenet 消息的传播，这种技术通常用于仅在某些区域或某些系统上相关的讨论。讨论马匹等农村问题很受欢迎，艾伦可能会在世界任何地方找到她的帮助，因此在全球传播她的信息是有道理的。但是，如果 Ellen 住在波士顿地区并且有兴趣了解当地一家好的牛排馆的位置，则向 ne.food（新英格兰食品讨论）发布仅包含本地分布的查询会更有意义。还有一些公司使用 Usenet 来提供根本不从本地服务器传播的“内部”新闻组。但是请注意，由于现在有如此多的新闻提供者是国内的或国际的，因此限制消息的分发在很大程度上已不再适用。

当然，这只是对 Usenet 通信的简单了解。 NNTP 部分提供了更多细节，尤其是关于如何处理和传播文章的细节。

**关键概念：**Usenet 通信由四个基本步骤组成。首先编写一条消息，然后将其发布到发起者的本地服务器。第三步是传播，消息从其原始服务器传输到 Usenet 系统上的其他服务器。该过程的最后一步是文章检索，新闻组的其他成员在此访问并阅读文章。网络新闻传输协议 (NNTP) 是用于将 Usenet 文章从一台主机移动到另一台主机的技术。



###### 4.2.4.1.3 Usenet 寻址：新闻组、新闻组层次结构和类型（部分：1 2 3 4）

正如前面提到的主题，Usenet 通信中的一个关键概念是新闻组。新闻组实际上是 Usenet 的寻址机制，将 Usenet 文章发送到新闻组相当于将电子邮件发送到电子邮件地址。新闻组类似于其他群组交流场所，例如邮件列表、聊天室、Internet 中继聊天频道或 BBS 论坛——尽管将新闻组称为“列表”、“房间”、“频道”或“BBS”可能会引起负面影响来自 Usenet 老前辈的反应。

与任何寻址机制一样，新闻组必须是唯一可识别的。每个新闻组都有一个新闻组名称，用于描述新闻组的主题，并将其与其他新闻组区分开来。由于有成千上万个不同的新闻组，它们被排列成称为层次结构的集合。每个层次结构都包含相关新闻组的树结构。

<u>**Usenet 新闻组层次结构**</u>
新闻组层次结构的总集合在许多方面类似于 DNS 中使用的域名树结构。每个 Usenet 层次结构就像 DNS 顶级域中所有域名的集合。就像www.pcguide.com这样的域名是在二级域名“pcguide”和子域“www”上加上顶级域名“com”的标签形成的，新闻组名的创建也是如此.它们是根据顶级新闻组层次结构名称创建的，该名称附加了一组描述性标签，用于描述新闻组在层次结构中的位置。

DNS 和 Usenet 层次结构之间的一个区别是，当您“沿着树向下”时，DNS 名称是从右到左创建的，而 Usenet 新闻组名称是按照更“自然”（对于说英语的人）从左到右的顺序形成的。例如，主要的 Usenet 层次结构之一是“comp”层次结构，专门用于计算机主题。在“comp”中有一个名为“dcom”的数据通信子层次结构，在该子层次结构中还有一个讨论数据布线的组。该组称为 comp.dcom.cabling。几乎所有的新闻组都是以这种方式构建的。

<u>**“八大”新闻组层次结构**</u>

Usenet 的“去中心化、无政府主义”性质的一个问题是确保在我们希望每个人都在同一页面上的某些领域进行协调；其中之一是新闻组命名。如果我们让任何人都创建一个新闻组，我们最终可能会得到许多甚至几十个讨论相同主题的组。想象一下，有人对数据布线有疑问，但没有意识到 comp.dcom.cabling 的存在，因此他们创建了一个名为 comp.datacomm.cabling 的新组。这两个群体可以共存，但这会导致对这个主题感兴趣的人群的混乱和分裂。

为了避免这个问题，许多大型 Usenet 系统的管理员合作开发了一个系统，用于将许多更常用的 Usenet 组组织成八个层次结构，并设计了一个在其中创建新新闻组的特定过程。这背后实际上有很长的历史。这些今天被称为八大 Usenet 层次结构，并在表 263 中进行了总结。


​                                                              **表 263：Usenet“八大”新闻组层次结构**

| **Hierarchy**     | **Description**                                              |
| ----------------- | ------------------------------------------------------------ |
| **comp.\***       | 讨论计算机相关主题的新闻组，包括硬件、软件、操作系统和技术。 |
| **humanities.\*** | 小组讨论人文学科，例如文学和艺术。                           |
| **misc.\***       | 不适合其他 Big Eight 层次结构的杂项主题。                    |
| **news.\***       | 讨论 Usenet 本身及其管理的小组。                             |
| **rec.\***        | 娱乐主题，例如游戏、运动和活动。                             |
| **sci.\***        | 科学新闻组，涵盖特定领域，如物理和化学、研究主题等。         |
| **soc.\***        | 社会和社会讨论，包括关于特定文化的团体。                     |
| **talk.\***       | 小组主要围绕当前事件和事件的讨论和辩论。                     |

这八个层次结构包含当今 Usenet 上许多使用最广泛的组。 例如，在 rec.sport.baseball 中讨论职业棒球，在 comp.sys.intel 中讨论英特尔计算机，在 talk.politics.mideast 中讨论中东政治。

Big Eight 层次结构在结构和它们包含的新闻组方面受到相当严格的控制。 创建新八大新闻组的过程是民主和公开的； 任何人都可以提出一个新的组，如果有足够的支持，它将由同意遵循八大系统的合作系统管理员创建。 然而，这个创建过程相当复杂且耗时。 有些人认为这是不可接受的，甚至反对这个受限过程的整个概念； 其他人认为这是有利的，因为它通过减缓对现有新闻组的更改速度和添加的新组的数量来保持八大层次结构相对“有序”。

<u>**其他新闻组层次结构**</u>

对于那些喜欢更自由的环境并且不想服从八大程序的人来说，有一个“替代的”Usenet 层次结构，它以层次结构名称 alt 开头。该层次结构包括数千个组。有些很流行，但很多根本没有用过；这是相对容易创建 alt 组的副作用。

除了这九个层次结构之外，还有几十个额外的、更小的层次结构。其中许多是区域性的，甚至是特定于公司的。例如，“ne”。层次结构包含一组讨论与新英格兰相关的问题的新闻组； “fr.*”涵盖法国，“de.*”涵盖德国。 Microsoft 在“microsoft.*”层次结构中有自己的一组公共新闻组。图 311 显示了 Big Eight 层次结构和一些其他存在的层次结构。



![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\usenetnewsgroups.png)


​                                                                         **图 311：Usenet 新闻组层次结构**

Usenet 新闻组被排列成称为层次结构的树状结构。其中八个是集中的、广泛使用的、通用的层次结构，今天被称为“八大”。 “替代”（“alt”）层次结构是一个结构非常松散的集合，由数千个组组成，涵盖了可以想象到的每个主题。除此之外，还有数百个区域、私有和特殊用途的层次结构。

**关键概念**：Usenet 消息不针对个人用户；相反，它们被发布到新闻组。每个新闻组代表一个主题；对群组主题感兴趣的人可以阅读其中的消息，也可以回复消息。 Usenet 新闻组被安排成树状层次结构，其结构类似于 DNS 域。许多最广泛使用的新闻组都位于称为“八大”的普遍兴趣层次结构的集合中。还有许多区域和特殊用途的层次结构。

<u>**未经审核和审核的新闻组**</u>

大多数新闻组都对所有人开放，并且被称为无节制的，因为发送给它们的消息直接发送到整个 Usenet 服务器互联网络。相比之下，一小部分新闻组是经过审核的，这意味着发送到该组的所有消息都经过筛选，只有经过版主（或版主团队）批准的消息才会真正发布。

主持小组的目的是确保特定小组中的讨论保持主题。它们的创建通常是为了处理有争议的话题，以确保辩论保持建设性并避免中断。例如，对 rec.guns 进行审核以确保讨论集中在枪支的使用上，而不是无休止的与枪支管制等相关的政治争论（在 talk.politics.guns 中占有一席之地）。

主持小组有时也用于仅用于发布公告的专业小组，或用于内容受限的小组。例如，rec.food.recipes 经过审核，因此它只包含食谱和食谱请求；这有助于人们轻松找到食谱，而无需费力地进行大量讨论。最后，当一些破坏性元素选择在未调节的组中发布大量内容时，有时会创建未调节组的调节版本，从而使正常的讨论变得困难。

<u>**交叉发布到多个新闻组**</u>
将一篇文章发布到多个新闻组是可能的。当消息涉及两个主题或允许发件人接触更广泛的受众时，将使用此过程，称为交叉发布。例如，如果我住在西雅图地区并且我的房子有问题，我可能会合法地交叉发布到 seattle.general 和 misc.consumers.house。

由于两个原因，这比单独向每个组发布相同的消息更有效。首先，每台 Usenet 服务器上只会存储一份消息副本，而不是两份。其次，碰巧阅读了这两个组的 Usenet 参与者不会看到该消息两次。然而，交叉发布到大量新闻组通常被认为是破坏性的并且违反了 Usenet 礼节。



###### 4.2.4.1.4 Usenet 消息格式和特殊标头（部分：1 2 3）

Usenet 旨在允许用户以从一台计算机发送到另一台计算机的消息形式交换信息。与任何基于消息的网络应用程序一样，所有 Usenet 客户端和服务器软件都必须同意使用通用消息格式。这确保所有设备和程序都能够以一致的方式解释所有 Usenet 文章。

<u>**一般消息格式**</u>
虽然 Usenet 是作为电子邮件的替代品而创建的，并且两者在处理消息的方式上存在明显差异，但也有许多相似之处。两者都是面向文本的消息传递系统，具有相似的内容和控制信息通信需求。 Usenet 的创建者意识到，将 Usenet 消息格式基于电子邮件所用的格式比从头开始创建新格式有很多优势。一方面，电子邮件消息格式已经被广泛使用，在 Usenet 中采用它可以节省实施时间和精力。它还将增强电子邮件和 Usenet 消息之间的兼容性，允许设计用于处理或显示电子邮件的软件也可以与 Usenet 文章一起使用。

出于这个原因，Usenet 消息格式是根据电子邮件消息的 RFC 822 标准定义的，在本指南的电子邮件部分的单独小节中进行了详细讨论。 RFC 822 消息以一组标头开头，其中包含有关消息的控制和描述信息，后跟一个空行，然后是包含实际内容的消息正文。

RFC 822 标准的一个重要属性是定义自定义标头的能力，这些标头添加到标准本身定义的常规标头集中。 Usenet 文章需要一些电子邮件不需要的信息类型，这些信息可以包含在专门定义的标题中，同时仍遵循基本的 RFC 822 格式。同时，可以省略 Usenet 不需要的特定于电子邮件的标头。

因此，Usenet 文章和电子邮件消息在结构上根本没有区别；它们的区别仅在于它们包含的标头种类以及这些标头的值。例如，Usenet 消息将始终包含一个标头，指定文章发布到的新闻组，但不会像电子邮件消息那样带有“收件人：”行。

**关键概念**：Usenet 文章使用与电子邮件消息相同的 RFC 822 消息格式。 Usenet 文章和电子邮件消息之间的唯一区别在于标题类型和它们所使用的值。

<u>**Usenet 标头类别和通用标头**</u>

所有 Usenet 标头均根据 RFC 822 中定义的标准标头格式定义：

```
<header name>: <header value>
```

与电子邮件消息一样，标题可以扩展到多行，遵循 RFC 822 标准中描述的缩进过程。

Usenet 消息的当前标准 RFC 1036 描述了 Usenet 消息的标头类型。 标头分为两类：强制标头和可选标头。 有些与用于电子邮件的同名标题相同，有些与电子邮件标题相似但使用方式略有不同，而另一些则为 Usenet 所独有。 表 264 描述了这些报头字段以及它们的使用方式。


​                                                                      **表 264：Usenet 标题类别和标题**

![image-20221122101321060](C:\Users\zy\AppData\Roaming\Typora\typora-user-images\image-20221122101321060.png)

![image-20221122101342201](C:\Users\zy\AppData\Roaming\Typora\typora-user-images\image-20221122101342201.png)

<u>**额外的 Usenet 标头**</u>

Usenet 消息也可能包含额外的标头，就像电子邮件消息一样。 其中一些标题完全是“自定义”的，由个人用户包含以提供有关文章的额外信息。 其他的在许多甚至大多数最新的 Usenet 文章中使用，并且通过普遍使用几乎成为“事实上的”标准标题。 许多这些自定义标头前面都有“X-”，表示它们是“实验性”或“额外”标头。

表 265 中显示了一些更经常遇到的“附加”Usenet 标头。


​                                                                          **表 265：常见的附加 Usenet 标头**

| **Header Name**                       | **Description**                                              |
| ------------------------------------- | ------------------------------------------------------------ |
| **NNTP-Posting-Host:**                | 指定用于最初发布消息的主机的 IP 地址或 DNS 域名。这通常是作者用于发布消息的客户端地址，或者是发件人的本地 NNTP 服务器。 |
| **User-Agent:****(or) X-Newsreader:** | 用于发布消息的软件的名称和版本号。                           |
| **X-Trace:**                          | 提供可用于跟踪消息的附加信息。                               |
| **X-Complaints-To:**                  | 用于报告滥用信息的电子邮件地址。许多 Internet 服务提供商现在自动包含此标头。 |

<u>**新闻组 MIME 消息**</u>
由于 Usenet 遵循 RFC 822 标准，多用途 Internet 邮件扩展 (MIME) 可用于格式化 Usenet 消息。 完成后，您将在邮件中看到常用的 MIME 标头（例如 MIME-Version、Content-Type 等）。

请注意，在 Usenet 消息中使用 MIME 是有争议的。 一些新闻阅读器不兼容 MIME，在尝试显示其中一些消息时会弄得一团糟，许多 Usenet 老手反对在 Usenet 消息中使用纯文本以外的任何内容。 尽管如此，无论好坏，MIME 消息正变得越来越普遍。



##### 4.2.4.2 TCP/IP 网络新闻传输协议 (NNTP)

Usenet 最初是一个非正式的 UNIX 计算机网络，使用拨号 UUCP 连接在服务器之间传输消息。这种安排是出于需要而产生的，并且运作良好，尽管它存在许多问题。一旦 Internet 在 1980 年代得到广泛使用，它就为更有效地分发 Usenet 文章提供了理想的机会。为发送这些消息开发了一种特殊的 TCP/IP 协议，称为网络新闻传输协议 (NNTP)。今天，NNTP 用于每天在计算机之间传送数十亿份 Usenet 消息副本。

在本节中，我将详细描述网络新闻传输协议的操作。我首先概述 NNTP 的一般工作原理。然后我解释了 NNTP 的两种基本使用方式：用于在服务器之间传播新闻文章，以及用于客户端文章发布和访问。然后，我将提供有关标准 NNTP 命令以及较新的 NNTP 命令扩展的更多信息，并说明 NNTP 状态响应和常见响应代码。

**背景信息：**NNTP 在很多方面类似于简单邮件传输协议 (SMTP)，包括它的基本操作和命令集以及回复格式。因此，如果您熟悉 SMTP，您可能会发现本节更容易理解。

###### 4.2.4.2.1 NNTP 概述和一般操作（部分：1 2）

Usenet 最初是相互直接联系的合作主机的逻辑互联网络。在早期的 Usenet 中，用户会向他或她的本地服务器发布消息。它会停留在那里，直到该服务器联系或被另一台服务器联系。然后消息将被传输到新服务器，它会一直停留在那里直到第二个服务器联系第三个，依此类推。

这种传输机制是有效的，但在许多方面存在严重缺陷。服务器之间没有持续连接；他们只能通过使用模拟调制解调器打电话来进行交流。因此，消息通常会等待数小时才能传播。按照今天的标准，当时的调制解调器也非常慢——每秒 2400 位甚至更低——因此将消息从一台服务器复制到另一台服务器需要很长时间。最糟糕的是，除非两个站点位于同一个城市，否则这些电话都是长途电话，因此非常昂贵。

尽管存在所有这些问题，为什么仍使用该系统？很简单：别无选择。在 20 世纪 70 年代末和 80 年代初，还没有我们所知的互联网，也没有其他物理基础设施可以将 Usenet 站点链接在一起。它要么在电话线上使用 UUCP，要么什么都不用。

<u>**NNTP的发展**</u>
随着刚刚起步的 ARPAnet 成长为现代互联网，一切都发生了变化。随着 Internet 的扩展，越来越多的站点连接到它，包括许多参与 Usenet 的站点。一旦两个站点都在 Internet 上，就很容易决定使用 Internet 发送 Usenet 文章，而不是缓慢而昂贵的电话。随着时间的推移，越来越多的 Usenet 站点加入了 Internet，很明显，就像电子邮件已经从 UUCP 转移到 TCP/IP Internet 一样，Usenet 的未来也在 Internet 上。

Usenet 从 UUCP 连接到 TCP/IP 互联网络的转变意味着需要重新思考 Usenet 文章如何从一个服务器转移到另一个服务器。在 Internet 上，Usenet 只是众多应用程序中的一种，消息的传输必须使用两种 TCP/IP 传输协议（TCP 或 UDP）之一来构建。

因此，与其他应用程序一样，Usenet 需要一个应用程序级协议来描述如何通过 TCP/IP 传输 Usenet 流量。正如 Usenet 从电子邮件的 RFC 822 中借用其消息格式一样，将其消息传递协议建模为电子邮件使用的协议是有意义的：简单邮件传输协议 (SMTP)。其结果是创建了网络新闻传输协议 (NNTP)，于 1986 年 2 月作为 RFC 977 发布。

<u>**NNTP 操作概述**</u>

NNTP 的一般操作确实与 SMTP 非常相似。 NNTP 使用 TCP，服务器在众所周知的 TCP 端口 119 上侦听来自客户端主机或其他 NNTP 服务器的传入连接。与在 SMTP 中一样，当两台服务器使用 NNTP 进行通信时，发起连接的服务器扮演该交换的客户端角色。

建立连接后，通信采用客户端向服务器发送命令的形式，并从服务器返回给客户端设备的回复。 NNTP 命令以纯 ASCII 文本形式发送，就像 SMTP、FTP、HTTP 和其他协议使用的命令一样。 NNTP 响应采用三位数回复代码和描述性文本的形式，再次类似于 SMTP（它又从 FTP 借用了这个概念）。

NNTP 旨在成为传输 Usenet 消息的综合工具。它通常最常被视为用于将 Usenet 文章从一台服务器移动到另一台服务器的传送协议，但也用于从客户端主机连接到 Usenet 服务器以发布和阅读消息。因此，NNTP 命令集非常广泛，包括处理服务器间和客户端-服务器通信的命令。对于消息传播，提供了一组命令以允许服务器从另一个服务器请求新文章，或向另一个服务器提供新文章。对于消息发布和访问，命令允许客户端请求新新闻组和消息的列表，并检索消息以显示给用户。

RFC 977 中定义的命令是十多年来唯一的“官方”命令。然而，甚至早在 20 世纪 80 年代后期，NNTP 服务器和客户端软件的实施者就在添加新的命令和功能，以使 NNTP 对用户更加高效和有用。这些 NNTP 扩展最终记录在 2000 年发布的 RFC 2980 中。我将在本节稍后部分更详细地描述它们。

**关键概念：**网络新闻传输协议 (NNTP) 是用于在现代 Usenet 中实现消息通信的协议。它用于两个主要目的：在 NNTP 服务器之间传播消息，以及允许 NNTP 客户端发布和阅读文章。它是一个独立的协议，但与电子邮件的简单邮件传输协议 (SMTP) 有许多共同特征。



###### 4.2.4.2.2 NNTP 服务器间通信过程：新闻文章传播（部分：1 2 3 4）

网络新闻传输协议 (NNTP) 用于现代 Usenet 通信过程中的所有传输步骤。然而，NNTP 通常与 Usenet 文章传播过程相关联。这可以说是 NNTP 最重要的功能：提供一种将大量 Usenet 文章从一台服务器移动到另一台服务器的有效方法。因此，这是开始查看协议的明智之选。

<u>**了解 Usenet 服务器结构**</u>
要了解 NNTP 传播的工作原理，我们必须先了解一下现代 Usenet 网络本身的组织方式。 Usenet 站点现在都在 Internet 上，理论上，任何 NNTP 服务器都可以联系任何其他服务器来发送和接收 Usenet 文章。然而，将一篇提交给特定服务器的新文章需要通过单独的 NNTP 连接发送到每个其他 NNTP 服务器是荒谬的。因此，即使在互联网时代，Usenet 逻辑网络仍然非常重要。

从理论上讲，Usenet 结构所需要的只是每个站点都以某种形式连接到至少一个其他站点。逻辑网络可以是无定形的，根本没有任何正式结构，只要每个站点都可以形成一条通过一些中间服务器序列到彼此的路径。然而，现代 Usenet 非常庞大，每天都有数千台服务器和数 GB 的文章被发布。这需要一个更有组织的结构来分发新闻。

出于这个原因，现代 Usenet 逻辑网络在层次结构中结构松散。一些拥有高速互联网连接和大型服务器的大型互联网服务提供商和大公司被认为处于层次结构的顶端，有时也称为 Usenet 骨干网。较小的组织连接到这些大型组织运行的服务器；这些组织被认为是骨干团体的下游。反过来，更小的组织可能会连接到与大型组织相连的组织的更下游。

这种层次结构意味着大多数 Usenet 服务器只与它们的上游邻居以及它们提供服务的任何下游站点保持直接连接。据说服务器从其上游连接接收新闻提要，因为这是它接收大部分新闻文章的地方。然后它向下游的所有服务器提供新闻提要。我在描述 Usenet 通信模型的主题中的图 310 中对此进行了说明。

例如，假设公司 A 运行一个名为 largenews 的大型 Usenet 服务器，该服务器连接到主干网。该服务器的下游是 NNTP 服务器 mediumnews。该服务器反过来为 smallnews 提供服务。如果用户向 mediumnews 发布文章，它会立即被放置在该服务器上。该服务器会将文章向下发送到 smallnews，以便该服务器的用户可以阅读。 mediumnews 也会在某个时候将文章发送到 largenews。 largenews 的消息将分发到其他骨干站点，这些站点又将消息向下传递到它们自己的下游。通过这种方式，所有站点最终都获得了消息的副本，即使 mediumnews 只需要直接连接到另外两个服务器。

用于描述如何使用 NNTP 传播新闻的术语是泛洪。这是因为消息从一个服务器开始并从它向外“泛滥”，最终到达主干站点，然后沿着所有下游“河流”向下到达 Usenet 上的每个站点的方式。

尽管我将逻辑 Usenet 网络描述为层次结构，但它并不是严格的层次结构。为了冗余，许多 NNTP 服务器保持与多个其他服务器的连接以确保消息快速传播。可以通过查看消息 ID 来控制文章的传输，以避免可能由一台服务器同时从多个邻居接收的重复消息。

<u>**基本 NNTP 传播方法**</u>

现在让我们看看消息是如何使用 NNTP 在服务器之间实际传播的。有两种技术可以做到这一点：

- “推送”消息：在推送模型中，一旦服务器收到一条新消息，它会立即将该消息告知其上游和下游邻居，并询问他们是否需要一份该消息的副本。

- “拉动”新闻：在拉动模型中，服务器不向邻居提供新文章。如果相邻服务器想查看自上次连接建立以来到达的内容，则它们必须请求新消息列表，然后请求将新消息发送给它们。

这两种技术各有优缺点，但推动是当今最常用的模型。

**关键概念：**NNTP 扮演的一个重要角色是它在 Usenet 服务器之间传播文章，这使得整个系统成为可能。文章传播使用两种模型：推模型，其中接收到新消息的服务器立即将其提供给连接的服务器，以及拉模型，其中接收新消息的服务器保留它们，直到其他服务器请求它们。推送模型通常是首选，因为它允许在系统中更快地传递消息。

<u>**使用“推”模型的文章传播**</u>

以下是推送模型的工作原理。当 NNTP 服务器的管理员与上游 Usenet 服务提供商建立服务关系时，他们会向提供商提供下游服务器想要承载的新闻组列表。每当新文章到达该组列表中的上游服务器时，它就会自动发送到下游站点。这避免了下游服务器不断地询问“有什么东西到达了吗？”

在 RFC 977 中定义的经典 NNTP 协议中，文章的交换基于推送模型，并使用 IHAVE 命令执行。假设三个新消息到达了 largenews 服务器。它将建立与 mediumnews 的 NNTP 连接，并使用 IHAVE 一次提供三个新消息中每一个的消息 ID。 mediumnews 服务器将对每个消息作出响应，表明它是否已经收到该消息。如果没有，largenews 会向它发送消息。图 312 中说明了使用传播推送模型的示例文章事务。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\nntppush.png)


​                                                                      **图 312：使用“推送”模型的 NNTP 文章传播**

此示例显示了如何使用传统的“推送”传播模型在服务器之间移动 Usenet 文章。在这里，充当 NNTP 客户端的设备（回忆起来实际上可能是 NNTP 服务器）有两条消息可提供给服务器。它发送指定第一条消息的消息 ID 的 IHAVE 命令，但服务器已经有该消息，因此它发送 435“不发送”回复。客户端然后使用第二个消息 ID 发出 IHAVE；服务器想要这个，所以它发送一个 335 回复；客户端发送 Usenet 消息，以单独一行上的单个句点结束。服务器表明它收到了消息，并且客户端完成了它的事务，退出了会话。



这种技术的主要优点是它确保不会向服务器发送它已经拥有的消息的副本。它在现代 Usenet 中的问题是它很慢，因为服务器必须在消息或客户端发送下一个命令之前响应 IHAVE 命令。

<u>**通过流模式提高推送传播效率**</u>

由于刚刚描述的低效率问题，NNTP 更重要的扩展之一是流模式，它改变了新闻推送的方式。启用此模式后，客户端计算机使用 CHECK 命令而不是 IHAVE 来询问服务器是否需要特定消息。服务器响应 IHAVE 以指示它是否需要该消息；如果是，则客户端使用 TAKETHIS 命令发送消息。

CHECK/TAKETHIS 的好处是客户端在发送下一个命令之前不必等待对 CHECK 的回复。当客户端等待对第一个 CHECK 命令的回复时，它可以做其他事情，比如发送下一个 CHECK 命令，允许命令流式传输以提高效率。因此，客户端可以为第一条新消息发送 CHECK 命令，然后在等待服务器对第一条消息的回复时为第二条消息发送 CHECK 命令。许多 CHECK 命令可以在一个流中发送，然后 TAKETHIS 命令针对收到的每个回复发送给之前发送的 CHECK，表明服务器需要该消息。

<u>**使用“拉”模型传播文章**</u>
拉模型是使用 NEWNEWS 和 ARTICLE 命令实现的。客户端连接到服务器并发送带有日期的 NEWNEWS 命令，该日期指定上次检查新消息的日期和时间。服务器使用一组消息 ID 响应自该日期以来到达的新文章。然后客户端使用 ARTICLE 命令请求每条新消息。

请注意，推和拉模型可以组合在一个会话中。客户端可以连接到服务器，使用 NEWNEWS 检查该服务器上的新消息，然后 IHAVE 或 CHECK 通知服务器客户端要发送的新消息。实际上，更常见的是在任何给定交易所的一对服务器之间只使用一个或另一个模型。

除了传播新消息之外，NNTP 还用于允许服务器传送有关已创建的新新闻组的信息。这是使用 NEWGROUPS 命令完成的，该命令指定日期和时间，如 NEWNEWS。作为响应，服务器向客户端发送自指定日期/时间以来创建的新新闻组列表。

###### 4.2.4.2.3 NNTP客户端-服务器通信过程：新闻发布和访问（部分：1 2 3 4）

Usenet 文章的传播确实是网络新闻传输协议 (NNTP) 的定义功能——我会骗你吗？ J 然而，NNTP 与其前身 SMTP 不同的一个关键领域是 NNTP 不仅用于服务器间通信。它也是用于初始发布 Usenet 消息和读取它们的协议。事实上，大多数 NNTP 命令处理用户客户端机器和 NNTP 服务器之间的交互，而不是服务器之间的通信。

NNTP 客户端是任何了解 NNTP 协议的软件程序，旨在为用户提供对 Usenet 的访问。 NNTP 客户端通常称为新闻阅读器，并为用户提供两种主要功能：发布（创建）和阅读 Usenet 消息。 Usenet 新闻阅读器几乎适用于所有硬件和软件平台，并且在功能、用户界面和其他特性方面差异很大。今天大多数人在客户端计算机上使用 Usenet 新闻阅读器，该计算机必须与单独的 NNTP 服务器建立 NNTP 连接才能阅读和发布新闻。这些程序类似于电子邮件客户端，事实上，许多电子邮件客户端也具有 NNTP 客户端的功能。

<u>**新闻发布**</u>
发布 Usenet 消息是整个 Usenet 通信过程的第一步（尽管许多 Usenet 文章实际上是对其他文章的回复，所以这是一个“先有鸡还是先有蛋”的事情。）使用 NNTP 发布文章非常简单。客户端建立到服务器的连接并发出 POST 命令。如果服务器愿意接受新文章，它会回复一个提示，让客户端将文章发送给它。文章然后由客户端传送到服务器。一些新闻阅读器可能会“批量”发布新文章，这样它们就可以在单个 NNTP 会话中发送，而不是一次提交一篇。

<u>**新闻访问和文章阅读**</u>

新闻阅读器还与服务器建立 NNTP 连接以阅读 Usenet 文章。 NNTP 提供了大量命令来支持用户可能执行的各种不同的文章访问和检索操作。阅读的第一步有时是检查可用的新闻组列表。使用 LIST 命令，客户端向服务器请求可用于阅读和发布的新闻组列表。 RFC 977 定义了基本的 LIST 命令，它向客户端返回所有组的列表。 RFC 2980 定义了命令的大量扩展，以允许客户端仅检索有关服务器上组的某些类型的信息。由于今天 Usenet 新闻组的数量如此之大，除非用户特别要求，否则现在很多时候都会跳过这个新闻组列表。

Usenet 消息访问的下一步通常是从可用组列表中选择要阅读的新闻组。同样，由于当今有如此多的群组，大多数新闻阅读器都允许用户使用模式或部分名称字符串来搜索群组名称。然后将 GROUP 命令连同所选组的名称一起发送到服务器。服务器将组的第一个和最后一个当前文章编号返回给客户端。

消息以两种方式标识，一种是绝对的，另一种是特定于站点的。文章的消息 ID 是一个固定的标识符，可用于在 Usenet 中唯一地表示它；这是在服务器间通信中用来确定每个站点是否具有给定消息的副本的内容。相反，文章编号是特定于服务器的；它们表示这些文章到达该服务器时分配给这些文章的编号，并用作“速记”以更轻松地引用新闻组中的文章。因此，同一封邮件在每个 NNTP 服务器上将具有不同的文章编号。使用它们是为了方便起见，因为文章编号比消息 ID 短得多。在会话期间，NNTP 服务器还维护一个“当前文章指针”，可用于按顺序步进新闻组。

<u>**新闻获取方式**</u>

新闻阅读器可以通过几种不同的方式访问组中的消息，这取决于它的编程方式和软件用户的需求。

<u>**全新闻组检索**</u>
这是“蛮力”技术：客户端简单地请求服务器向它发送组中的所有消息。这是通过发出 ARTICLE 命令以使用 GROUP 命令返回的第一个文章编号来选择组中的第一个当前消息来完成的。这会将会话的服务器内部指针设置为指向第一篇文章，因此可以检索它。然后使用 NEXT 命令将指针前进到下一条消息，并使用 ARTICLE 命令检索它。这一直持续到整个组都被读取为止。图 313 说明了该过程。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\nntpread.png)




​                                                         **图 313：NNTP 全新闻组检索过程**

NNTP 客户端可以通过多种方式访问和读取服务器上的 Usenet 消息。一种常见的方法是检索新闻组的全部内容。本例中客户端使用GROUP命令选择新闻组comp.protocols.tcp-ip进行阅读；服务器响应一个 211“group selected”回复，其中包括有关该组的重要统计信息。客户端使用带有组中第一篇文章编号 177 的 ARTICLE 命令从服务器读取它。然后服务器逐行发送消息，在一行中以一个句点结束。客户端使用 NEXT 命令告诉服务器将其内部文章指针前进到下一条消息，这通常不会是刚刚读取的消息之后的下一个连续数字；这里是 179。然后客户端可以通过自己发送 ARTICLE 命令来读取该消息；由于没有给出参数，服务器返回当前消息（#179）。




检索到的消息由新闻阅读器存储，可供用户即时访问。此方法最适合相对较小的新闻组和/或具有快速 Internet 连接的用户。

<u>**新闻组标题检索**</u>
由于下载整个新闻组非常耗时，许多新闻阅读器通过下载所有消息的标题而不是完整消息来妥协。该过程与完整新闻组检索相同，但 HEAD 命令用于检索文章的标题而不是 ARTICLE 命令。这比检索完整的每条消息花费的时间更少。

如果服务器支持，也可以使用 XHDR 命令扩展来更有效地仅检索邮件标头的子集，例如主题行和作者。

<u>**单篇文章检索**</u>
也可以使用 ARTICLE 命令并指定文章的消息标识符，从组中检索单个消息。

**关键概念：**虽然 NNTP 因其在服务器间传播中的作用而广为人知，但 Usenet 客户端也使用它来编写和阅读文章。许多不同的命令提供了客户端设备如何阅读文章的灵活性。客户端可以检索整个新闻组、仅一组新闻组标题或个别文章。其他命令也支持各种管理功能。

<u>**其他客户端-服务器功能**</u>

除了阅读和发布之外，NNTP 还包括支持 Usenet 用户可能希望执行的其他“杂项”任务的命令。客户端可以使用 HELP 命令向服务器请求帮助信息，或者使用 NEWGROUPS 命令获取新新闻组的列表，如服务器间通信主题中所述。

大多数现代新闻阅读器都包含远远超出上述基本发布和阅读功能的功能。大多数维护自己的配置文件集，允许用户维护一组最喜欢的“订阅”新闻组，而不是每次访问 Usenet 时都必须从主列表中选择一个组来阅读。新闻阅读器还跟踪用户在每个订阅的新闻组中阅读了哪些文章，因此用户无需费力地浏览整个新闻组即可查看已发布的新消息。

<u>**文章线程**</u>
对基本 Usenet 文章阅读的一个特别有用的增强是线程化。此功能允许新闻阅读器不严格按字母顺序或时间顺序显示文章，而是使用文章的参考标题中的信息分组到对话中。线程在繁忙的新闻组中特别有用，因为它允许您一次查看特定讨论中的所有文章，而不是试图同时处理来自多个对话的消息。

线程的一个问题是新闻阅读器需要很长时间来筛选所有这些参考行并构建文章线程。为了加快这个过程，许多服务器现在缓存新闻组的额外线程或概览信息，客户端可以检索这些信息以节省打开新闻组的时间。这是使用 XTHREAD 或 XOVER NNTP 命令扩展来完成的。



###### 4.2.4.2.4 NNTP 命令（部分：1 2）

用于开发 Internet 标准的开放、合作过程的一大优势是，新协议通常是在旧协议成功的基础上设计的。这既节省了开发时间和精力，又促进了技术之间的兼容性。正如我在 NNTP 概述中所解释的，它在很多方面都基于 SMTP 的原则； SMTP 又借鉴了早期协议 Telnet 和 FTP 的思想。从 NNTP 命令与这些早期协议的命令之间的相似之处可以看出这一传统。

<u>**命令语法**</u>
与在 SMTP 中一样，所有 NNTP 命令都是通过 NNTP TCP 连接发送到 NNTP 服务器的 ASCII 文本，从充当客户端的设备（可能是新闻阅读器客户端或 NNTP 服务器本身）。这些是符合 Telnet 网络虚拟终端 (NVT) 格式的标准文本字符串，以两个字符的“CRLF”序列结尾。与 SMTP 和 FTP 的情况一样，您可以通过使用 Telnet 在端口 119 上连接到它来与 NNTP 服务器进行交互式会话。

NNTP 命令的基本语法如下：

```
<command-code> <parameters>
```

与 SMTP 不同，NNTP 命令的长度不限于四个字符。命令后面的参数由一个或多个空格字符分隔，用于提供必要的信息以允许服务器执行该命令。 NNTP 命令不区分大小写。

<u>**基本命令集**</u>

主要的 NNTP 规范 RFC 977 描述了 NNTP 客户端和服务器支持的基本命令集。 它们没有分成类别，而是按字母顺序列出，正如我在表 266 中所做的那样。有关如何使用这些命令中的大多数的更多详细信息可以在有关新闻文章传播和新闻发布和访问的主题中找到。


​                                                                                   **表 266：NNTP 基本命令**

| **Command Code** | **Command**                   | **Parameters**                                         | **Description**                                              |
| ---------------- | ----------------------------- | ------------------------------------------------------ | ------------------------------------------------------------ |
| ***ARTICLE\***   | *Retrieve Article*            | Message ID or server article number.                   | 告诉服务器向客户端发送特定的 Usenet 文章。要检索的文章可以使用其绝对的通用消息 ID 或其本地分配的文章编号来指定。当命令与文章编号一起发出时，这会导致服务器的内部消息指针被设置为指定的文章。如果消息指针已设置为特定文章，则可以在没有文章编号的情况下发出 ARTICLE 命令并检索当前消息。 |
| ***HEAD\***      | *Retrieve Article Headers*    | Message ID or server article number.                   | 与 ARTICLE 命令相同，但仅检索文章的标题。                    |
| ***BODY\***      | *Retrieve Article Body*       | Message ID or server article number.                   | 与 ARTICLE 命令相同，但只返回文章的正文。                    |
| ***STAT\***      | *Retrieve Article Statistics* | Server article number                                  | 概念上与 ARTICLE 命令相同，但不返回任何消息文本，仅返回文章的消息 ID。此命令通常用于设置服务器的内部消息指针，因此通常仅使用商品编号（而不是消息 ID）调用 STAT。 |
| ***GROUP\***     | *Select Newsgroup*            | Newsgroup name                                         | 告诉服务器客户端要访问的新闻组的名称。假设指定的组存在，服务器向客户端返回组中当前第一篇和最后一篇文章的编号，以及组中消息数量的估计值。服务器的内部文章指针也设置为组中的第一条消息。 |
| ***HELP\***      | *Get Help Information*        | None                                                   | 提示服务器发送客户端帮助信息，通常采用服务器支持的有效命令列表的形式。 |
| ***IHAVE\***     | *Offer Article To Server*     | Message ID                                             | 由客户端在 NNTP 会话中用来告诉服务器它有一篇服务器可能需要的新文章。服务器将检查提供的消息 ID 并响应客户端指示它是否希望客户端发送文章。 |
| ***LAST\***      | *Go To Last Message*          | None                                                   | 告诉服务器将其当前文章指针设置为新闻组中的最后一条消息。     |
| ***LIST\***      | *List Newsgroups*             | None                                                   | 要求服务器发送它支持的新闻组列表，以及每个组中的第一个和最后一个文章编号。 RFC 977 中描述的命令很简单，不支持任何参数并导致将新闻组的完整列表发送到客户端。 NNTP 命令扩展显着扩展了该命令的语法。 |
| ***NEWGROUPS\*** | *List New Newsgroups*         | Date and time, and optional distribution specification | 提示服务器发送自指定日期和时间以来创建的新新闻组列表。客户端还可以限制命令只返回特定区域分布中的新新闻组。 |
| ***NEWNEWS\***   | *List New News Articles*      | Date and time, and optional distribution specification | 向服务器请求自特定日期和时间以来到达的所有新文章的列表。与 NEWGROUPS 命令一样，这可能在分发中受到限制。服务器以新文章的消息 ID 列表进行响应。 |
| ***NEXT\***      | *Go To Next Message*          | None                                                   | 将服务器的当前文章指针前进到新闻组中的下一条消息。           |
| ***POST\***      | *Post Article*                | None                                                   | 告诉服务器客户端想要发布一篇新文章。服务器以肯定或否定的确认响应。假设允许发布，则客户端将消息的全文发送到服务器，服务器存储它并开始将其传播到其他服务器的过程。 |
| ***QUIT\***      | *End Session*                 | None                                                   | 终止 NNTP 会话。为了“礼貌”，客户端应在关闭 TCP 连接之前发出此命令。 |
| ***SLAVE\***     | *Set Slave Status*            | None                                                   | 此命令旨在用于特殊配置，其中一台 NNTP 服务器充当其他服务器的附属服务器。它在实践中并不经常使用。 |

RFC 2980 定义了一些扩展，既可以向该集合添加新命令，也可以对其中一个命令 (LIST) 进行更改。 NNTP 扩展在下一主题中描述。

**关键概念：**主要的 NNTP 标准定义了一些基本的 NNTP 命令，设备使用这些命令发起 NNTP 连接以完成文章传播、发布或阅读功能。 NNTP 命令由命令代码和可选的参数组成，这些参数指定如何执行命令。



###### 4.2.4.2.5 NNTP 命令扩展（部分：1 2 3 4）

RFC 977 中描述的基本命令集足以启用客户端-服务器和服务器间功能，但在许多方面都非常基础并且在效率和实用性方面受到限制。随着 Usenet 在 20 世纪 80 年代后期变得越来越大和越来越流行，对改进 NNTP 可用性的需求也在增长。 1991 年，开始对 NNTP 标准进行正式修订，但从未完成。尽管如此，该工作中的许多概念在随后几年的 NNTP 实施中被“非正式地”采用。此外，一些 Usenet 软件作者创建了他们自己的非标准功能来改进协议。其中一些本身通过广泛采用成为事实上的标准。

结果，到 1990 年代后期，大多数 Usenet 软件实际上实现了 NNTP 的变体，其功能远远超过标准中记录的内容。当然，并非所有 NNTP 软件都支持相同的“额外”功能，这导致服务器和客户端之间存在潜在的兼容性困难。 RFC 2980，Common NNTP Extensions，于 2000 年 10 月发布，将许多这些扩展正式化为 RFC 977 中定义的基本 NNTP 标准。

NNTP 扩展主要包括添加到基本 NNTP 命令集中的新 NNTP 命令，以及对 NNTP 其他命令和功能工作方式的一些小更改。这些扩展通常分为三类：提高服务器之间 NNTP 消息传输效率的扩展；使 NNTP 更有效地访问客户端消息的那些，以及不属于这两个组中任何一个的“杂项”。

<u>**NNTP 传输扩展**</u>

第一组称为 NNTP 传输扩展，由一小组旨在改进服务器间消息传播的相关命令组成。 其中大部分实现了 NNTP 的流模式，它提供了一种将大量文章从一台服务器移动到另一台服务器的更有效方法，如服务器间通信主题中所述。 表 267 描述了新的传输命令。


​                                                                                           **表 267：NNTP 传输扩展**

| **Command Code**   | **Command**               | **Parameters**                         | **Description**                                              |
| ------------------ | ------------------------- | -------------------------------------- | ------------------------------------------------------------ |
| ***MODE STREAM\*** | *Set Stream Mode*         | None                                   | 用于告诉服务器客户端要以流模式操作，使用 CHECK 和 TAKETHIS 命令。 |
| ***CHECK\***       | *Check If Article Exists* | Message ID                             | 由充当客户端的服务器以流模式使用，以询问另一台服务器是否有特定文章的副本。服务器响应表明它是否希望被发送文章的副本。此命令类似于 IHAVE，不同之处在于客户端在发送下一个命令之前不必等待回复。 |
| ***TAKETHIS\***    | *Send Article To Server*  | Message ID                             | 当服务器响应 CHECK 命令表明它需要特定消息的副本时，客户端使用此命令发送它。 |
| ***XREPLIC\***     | *Replicate Articles*      | List of newsgroups and article numbers | 创建此命令是为了将大量文章从一台服务器复制到另一台服务器的特殊目的。它没有被广泛使用。 |

<u>**NNTP 新闻阅读器扩展**</u>

RFC 2980 定义的第二组扩展是新闻阅读器扩展，主要关注新闻阅读器客户端在与 NNTP 服务器交互时使用的命令。 这些扩展包括几个新命令以及对 RFC 977 中功能非常有限的一个重要命令的显着增强：LIST。

原始的 LIST 命令没有参数，只允许客户端检索服务器携带的整个新闻组列表。 当只有几百个 Usenet 新闻组时，这可能就足够了，但现在有数万个。 RFC 2980 定义了 LIST 命令的许多新变体，以允许客户端在服务器返回的信息类型方面有更大的灵活性。 表 268 显示了新的 LIST 命令变体。


​                                                                                       **表 268：NNTP LIST 命令扩展**

| **Command Code**          | **Command**                            | **Parameters**            | **Description**                                              |
| ------------------------- | -------------------------------------- | ------------------------- | ------------------------------------------------------------ |
| ***LIST ACTIVE\***        | *List Active Newsgroups*               | Newsgroup name or pattern | 提供服务器上活动新闻组的列表。这在语义上与原始 LIST 命令相同，但客户端可以提供新闻组名称或模式来限制返回的新闻组数量。例如，客户端可以请求仅包含其中包含“football”的新闻组的列表。 |
| ***LIST ACTIVE.TIMES\***  | *List Active Newsgroup Creation Times* | None                      | 提示服务器向客户端发送它的 active.times 文件，其中包含有关服务器携带的新闻组何时创建的信息。 |
| ***LIST DISTRIBUTIONS\*** | *List Distributions*                   | None                      | 使服务器向客户端发送分发文件的内容，该文件显示服务器识别的区域分发字符串（用于消息的分发标头）。 |
| ***LIST DISTRIB.PATS\***  | *List Distribution Patterns*           | None                      | 向服务器请求它的 distribution.pats 文件，它类似于 distributions 文件，但使用模式来汇总不同新闻组的分发信息。 |
| ***LIST NEWSGROUPS\***    | *List Newsgroups*                      | Newsgroup name or pattern | 提供新闻组名称和描述的列表。这与 LIST ACTIVE 的不同之处在于只返回新闻组名称和描述，而不是每个新闻组的文章编号。它在功能上与 XGTITLE（见表 269）相同，通常由用户用来定位要添加到他或她的订阅列表中的新闻组。 |
| ***LIST OVERVIEW.FMT\***  | *Display Overview Format*              | None                      | 提示服务器显示有关其概览文件格式的信息。有关更多信息，请参阅下面的 XOVER 命令说明。 |
| ***LIST SUBSCRIPTIONS\*** | *Retrieve Default Subscription List*   | None                      | 要求服务器向客户端发送订阅新闻组的默认列表。这用于使用建议的新闻组列表设置新用户。例如，如果一个组织有一个内部支持新闻组，他们可以将这个组放在默认订阅列表中，以便所有新用户在他们第一次启动新闻阅读器时立即了解它。 |

除了对 LIST 命令的这些更改之外，还定义了许多新的与新闻阅读器相关的命令扩展，这些扩展在表 269 中进行了描述。


​                                                          **表 269：NNTP 新闻阅读器扩展**

| **Command Code**   | **Command**                                   | **Parameters**                                               | **Description**                                              |
| ------------------ | --------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| ***LISTGROUP\***   | *List Article Numbers In Newsgroup*           | Newsgroup name                                               | 使服务器返回新闻组中当前消息的本地文章编号列表。服务器的当前文章指针也设置为组中的第一条消息。 |
| ***MODE READER\*** | *Set Newsreader Mode*                         | None                                                         | 告诉服务器充当客户端的设备实际上是客户端新闻阅读器，而不是另一个 NNTP 服务器。虽然技术上不需要——所有命令都可以由充当客户端的任何设备发送——如果给出此命令，一些服务器可能会被优化以响应面向新闻阅读器的命令。 |
| ***XGTITLE\***     | *Retrieve Newsgroup Descriptions*             | Newsgroup name or pattern                                    | 用于列出与特定文本模式匹配的新闻组或一组新闻组的描述。该命令在功能上与 LIST NEWSGROUP 命令扩展相同（参见表 268）。因此建议不再使用 XGTITLE。 |
| ***XHDR\***        | *Retrieve Article Headers*                    | Header name and optionally, either a message ID or a range of article numbers | 允许客户端仅请求一组消息中的特定标头。如果仅提供标头名称，则会为当前组中的所有消息返回标头。否则，将为所选消息提供标头。此扩展为新闻阅读器客户端提供了一种更有效的方式来检索新闻组中的重要标题并将其显示给用户。 |
| ***XINDEX\***      | *Retrieve Index Information*                  | Newsgroup name                                               | 检索索引文件，供新闻阅读器 TIN 使用，以提高阅读新闻组的效率。 TIN 现在支持更常见的“概览”格式，因此 XOVER 命令优于此命令。 |
| ***XOVER\***       | *Retrieve Overview Information*               | Article number or range of article numbers in a newsgroup    | 检索一篇文章或一组文章的概述。支持此功能的服务器为其新闻组维护一个特殊的数据库，其中包含有关当前文章的信息，其格式可供各种新闻阅读器使用。与客户端必须检索每条消息的标头并手动分析它们相比，检索概览信息允许更快地执行消息线程等功能。 |
| ***XPAT\***        | *Retrieve Article Headers Matching A Pattern* | Header name, pattern, and either a message ID or a range of article numbers | 此命令类似于 XHDR，因为它允许为一组消息检索特定的标头。不同之处在于客户端可以指定一个模式，该模式必须与要检索的标头匹配。这允许客户端让服务器搜索并返回某些消息，例如带有指示特定类型讨论的主题行的消息，而不是要求客户端下载所有标题并在其中进行搜索。 |
| ***XPATH\***       | *Retrieve Filename Information*               | Message ID                                                   | 允许客户端询问服务器上存储特定消息的实际文件的名称。         |
| ***XROVER\***      | *Retrieve Overview Reference Information*     | Article number or range of article numbers in a newsgroup    | 类似于 XOVER 命令，但专门检索指定文章的 References 标题中的信息。当然，这是包含创建线程对话所需数据的标头。 |
| ***XTHREAD\***     | *Retrieve Threading Information*              | Optional “DBINIT” parameter                                  | 与 XINDEX 类似，但以新闻阅读器 TRN 使用的格式检索特殊的线程信息文件。与 TIN 一样，TRN 现在支持通用的“概览”格式，因此 XOVER 优于此命令。“DBINIT”参数可用于检查线程数据库是否存在。 |

<u>**其他 NNTP 扩展**</u>

最后一个扩展组是“其他”扩展，与服务器间或客户端-服务器 NNTP 交互不严格相关的杂项。该组中有两个命令：AUTHINFO 和 DATE。后者是一个简单的命令，它使服务器告诉客户端它的当前日期和时间。 AUTHINFO 更有趣：客户端使用它向服务器提供身份验证数据。

您可能已经注意到 RFC 977 协议中没有描述与安全相关的命令。那是因为最初的 NNTP 没有任何安全功能。与现代互联网时代之前编写的许多协议一样，早在 80 年代初期，安全性并不被认为是一个大问题。大多数新闻服务器仅由拥有该服务器的组织内的人员使用，并且使用了简单的安全措施，例如通过 IP 地址或使用访问列表限制对服务器的访问。

随着 Usenet 规模的增长，许多 NNTP 软件实施做出的更重要的变化之一是要求身份验证。现代客户端通常会在与服务器建立连接时发出 AUTHINFO 作为其首批命令之一，因为在完成此操作之前服务器将拒绝接受大多数其他命令。一个特殊的回复代码也被添加到 NNTP 中，供服务器在由于不正确的身份验证而拒绝命令时使用。

可以用几种不同的方式调用 AUTHINFO 命令。该命令的原始版本要求客户端发出带有用户名的 AUTHINFO USER 命令，然后是带有密码的 AUTHINFO PASS。自然，这是简单的用户/密码登录验证。它的一个变体是 AUTHINFO SIMPLE 命令，客户端只需要发送一个密码。

客户端和服务器还可以通过使用 AUTHINFO GENERIC 命令同意使用更复杂的身份验证方法。客户端向服务器提供它想要使用的身份验证方法的名称，以及身份验证所需的任何参数。然后，客户端和服务器根据它们正在使用的特定身份验证器的要求交换消息和身份验证信息。

**关键概念：**其基本命令集中的许多限制导致 1980 年代和 1990 年代期间 NNTP 的非标准增强功能激增。这些最终记录在一组正式补充原始 RFC 977 命令的 NNTP 命令扩展中。这些扩展在概念上分为三组：改进 NNTP 传播消息方式的传输扩展；改善客户文章访问的新闻阅读器扩展；和各种扩展，其中最重要的是为 NNTP 添加安全性的 AUTHINFO 扩展。



###### 4.2.4.2.6 NNTP 状态响应和响应代码（部分：1 2 3）

 每次在 NNTP 连接中充当客户端的设备发送命令时，服务器都会发回响应。响应用于确认收到命令，通知客户端处理命令的结果，并可能提示其他信息。由于 NNTP 命令的结构和格式与 SMTP 命令非常相似，我相信 NNTP 响应与 SMTP 的响应同样非常相似也就不足为奇了。反过来，SMTP 响应基于为 FTP 中的响应而设计的系统。

NNTP 响应的第一行包含一个三位数字响应代码，以及一行总结响应的描述性文本。这些响应代码的结构使得每个数字都具有特定的意义，这使客户端可以快速确定向其发送回复的命令的状态。在初始响应行之后，根据回复，可能会跟随一些额外的响应行。例如，成功的 LIST 命令会产生 215 响应代码，后跟新闻组列表。

**背景信息：**关于 FTP 回复代码的主题更完整地讨论了除了描述性文本之外还使用数字回复代码的原因。

<u>**回复代码结构和数字解释**</u>

与 SMTP 和 FTP 一样，NNTP 回复代码可以被认为是“xyz”形式，其中“x”是第一个数字，“y”是第二个数字，“z”是第三个数字。

```
First Reply Code Digit (“x”)
```

第一个数字一般表示命令的成功、失败或进度，成功的命令是完整的还是未完成的，以及不成功的命令不起作用的一般原因。 该数字值的定义与 SMTP 和 FTP 中的略有不同。 在某些情况下，术语只是被简化了； 例如，第二类是“Command OK”而不是“Positive Completion Reply”。 表 270 显示了该位可能值的具体含义。


​                                                     **表 270：NNTP 回复代码格式：首位解释**

| **Reply Code Format** | **Meaning**                                                  | **Description**                                              |
| --------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **1yz**               | **Informative Message**                                      | 一般信息;用于帮助信息和调试。                                |
| **2yz**               | **Command OK**                                               | 命令已成功完成。                                             |
| **3yz**               | **Command OK So Far, Send The Rest**                         | 中间回复，发送以提示客户端发送更多信息。通常用于回复 IHAVE 或 POST 等命令，其中服务器确认命令，然后请求客户端传输文章。 |
| **4yz**               | **Command Was Correct, But Couldn't Be Performed**           | 该命令有效但无法执行。这种类型的错误通常是由于错误的参数、服务器的暂时性问题、错误的命令序列或类似情况而发生的。 |
| **5yz**               | **Command Unimplemented Or Incorrect, Or Serious Program Error** | 该命令无效或重大程序错误阻止其执行。                         |

<u>**第二个回复代码数字（“y”）**</u>
第二个数字将消息分类为功能组。 该数字的使用方式与 SMTP 和 FTP 中的一般方式相同，但功能组不同； 它们在表 271 中进行了描述。


​                                                      表 271：NNTP 回复代码格式：第二位数字解释

| **Reply Code Format** | **Meaning**                             | **Description**                                              |
| --------------------- | --------------------------------------- | ------------------------------------------------------------ |
| **x0z**               | **Connection, Setup and Miscellaneous** | 笼统的和杂项的答复。                                         |
| **x1z**               | **Newsgroup Selection**                 | 与用于选择新闻组的命令相关的消息。                           |
| **x2z**               | **Article Selection**                   | 与用于选择文章的命令相关的消息。                             |
| **x3z**               | **Distribution Functions**              | 与消息传输相关的消息。                                       |
| **x4z**               | **Posting**                             | 与发布消息相关的消息。                                       |
| **x5z**               | **Authentication**                      | 与身份验证和 AUTHINFO 命令扩展相关的消息。 （此类别未正式列入标准，但这些响应的中间数字为“5”）。 |
| **x8z**               | **Nonstandard Extensions**              | 保留供私人、非标准实施使用。                                 |
| **x9z**               | **Debugging**                           | 调试输出消息。                                               |



<u>**第三个回复代码数字（“z”）**</u>
最后一位表示第二位描述的每个功能组中的特定类型的消息。 第三个数字允许每个功能组对第一个代码数字给出的每种回复类型有 10 个不同的回复代码。

<u>**组合数字值以生成特定的回复代码**</u>
如同在 FTP 和 SMTP 中一样，这些“x”、“y”和“z”数字的含义组合起来构成特定的回复代码。 例如，如果客户端发出 IHAVE 命令但服务器不希望提供该文章，则服务器会发送回复代码“435”。 命令正确但回复是否定的，因此以“4”开头，消息与消息分发有关，因此中间数字为“3”。

<u>**常见的 NNTP 回复代码**</u>

表 272 包含一些按数字顺序排列的更常见 NNTP 回复代码的列表，以及来自标准的典型回复文本和其他描述信息。


​                                                                       **表 272：NNTP 回复代码**

| **Reply Code** | **Reply Text**                                      | **Description**                                              |
| -------------- | --------------------------------------------------- | ------------------------------------------------------------ |
| **100**        | help text follows                                   | Precedes response to *HELP* command.                         |
| **111**        | (date and time)                                     | Response to *DATE* command extension.                        |
| **199**        | (debugging output)                                  | Debugging information.                                       |
| **200**        | server ready - posting allowed                      | Sent by the server upon initiation of the session, if the client is allowed to post messages. |
| **201**        | server ready - no posting allowed                   | Sent by the server upon initiation of the session, if the client is not allowed to post messages. |
| **202**        | slave status noted                                  | Response to the *SLAVE* command.                             |
| **203**        | streaming is ok                                     | Successful response to *MODE STREAM* command.                |
| **205**        | closing connection - goodbye!                       | Goodbye message sent in response to a *QUIT* message.        |
| **211**        | n f l s group selected                              | Successful response to the *GROUP* command, indicating the estimated number of messages in the group (“n”), first and last article numbers (“f” and “l”) and group name (“s”). |
| **215**        | list of newsgroups follows (OR) information follows | Successful response to *LIST* command. The second form is for variations of *LIST* defined as [NNTP command extensions](http://www.tcpipguide.com/free/t_NNTPCommandExtensions.htm). |
| **218**        | tin-style index follows                             | Successful response to *XINDEX* command extension.           |
| **220**        | n <a> article retrieved - head and body follow      | Successful response to the *ARTICLE* command, indicating the article number and message ID of the article. |
| **221**        | n <a> article retrieved - head follows              | Successful response to the *HEAD* command, indicating the article number and message ID of the article. |
| **222**        | n <a> article retrieved - body follows              | Successful response to the *BODY* command, indicating the article number and message ID of the article. |
| **223**        | n <a> article retrieved - request text separately   | Successful response to the *STAT* command, indicating the article number and message ID of the article. |
| **224**        | overview information follows                        | Successful response to the *XOVER* command extension.        |
| **230**        | list of new articles by message-id follows          | Successful response to the *NEWNEWS* command.                |
| **235**        | article transferred ok                              | Successful response to the *IHAVE* command, after article has been sent. |
| **239**        | article transferred ok                              | Successful response to the *TAKETHIS* command.               |
| **240**        | article posted ok                                   | Successful response to the *POST* command, after article has been posted. |
| **250 or 281** | authentication accepted                             | Successful authentication using the *AUTHINFO* command extension. |
| **282**        | list of groups and descriptions follows             | Positive response to the *XGTITLE* command extension.        |
| **288**        | binary data to follow                               | Successful response to the *XTHREAD* command extension.      |
| **335**        | send article to be transferred                      | Preliminary response to the *IHAVE* command.                 |
| **340**        | send article to be posted                           | Preliminary response to the *POST* command.                  |
| **381**        | more authentication information required            | Preliminary response to the *AUTHINFO* command extension.    |
| **400**        | service discontinued                                | Session is being terminated, perhaps due to user request.    |
| **411**        | no such newsgroup                                   | Invalid newsgroup name specified.                            |
| **412**        | no newsgroup has been selected                      | Attempt to issue a command that refers to the current newsgroup before one has been selected using *GROUP*. |
| **420**        | no current article has been selected                | Attempt to issue a command that refers to the current article using the server's current article pointer, before the pointer has been set through article selection. |
| **421**        | no next article in this group                       | Response to *NEXT* command when at last article of a newsgroup. |
| **422**        | no previous article in this group                   | Possible response to *LAST*; I have no idea why the word “previous” is in there. |
| **423**        | no such article number in this group                | Command with invalid article number.                         |
| **430**        | no such article found                               | Article not found; it may have been deleted.                 |
| **435**        | article not wanted - do not send it                 | Negative response to *IHAVE* if server doesn't need the article. |
| **436**        | transfer failed - try again later                   | Temporary failure of article transfer, retry.                |
| **437**        | article rejected - do not try again                 | Article refused for whatever reason.                         |
| **438**        | already have it, please don't send it to me         | Same as reply code 435, but for the *CHECK* command extension. |
| **440**        | posting not allowed                                 | *POST* command issued when posting is not allowed.           |
| **441**        | posting failed                                      | *POST* command failed.                                       |
| **450**        | authorization required for this command             | Response sent when server requires authentication but client has not yet authenticated. |
| **452**        | authorization rejected                              | Failed authentication.                                       |
| **480**        | transfer permission denied                          | Response to *CHECK* if transfer is not allowed.              |
| **500**        | command not recognized                              | Bad command.                                                 |
| **501**        | command syntax error                                | Bad syntax in command.                                       |
| **502**        | access restriction or permission denied             | Permission denied; sent if the client has not properly authentication but the server requires it. |
| **503**        | program fault - command not performed               | General fatal error message.                                 |

**关键概念：**在 NNTP 连接中充当客户端的设备发送的每个命令都会导致服务器返回一个答复。 NNTP 回复由一个三位数的回复代码和一串描述性文本组成； 它们以 SMTP 和 FTP 为蓝本。

#### 4.2.5 TCP/IP 万维网（WWW，“Web”）和超文本传输协议 (HTTP)

所以最后，我们来到了Big Kahuna。 J 在我对文件和消息传输协议的概述中，我说过万维网“几乎可以肯定”是最重要的 TCP/IP 应用程序。如果有的话，我可能低估了这个案子。很明显，Web 不仅是当今最重要的 TCP/IP 应用程序，而且可以说是网络历史上最重要的应用程序，甚至可能是整个计算史上最重要的应用程序。

这听起来是不是有点夸张？不止一点？也许吧，但想想网络在它出现的十年左右的时间里做了什么。它不仅改变了互联网的使用方式，而且在许多方面改变了社会本身。可以说，Web 将 Internet 置于“地图上”，将其从技术人员和学者的领域中转移出来，成为主流世界的重要组成部分。

在本节中，我将分两小节描述万维网。第一部分一般性地讨论了 Web 以及超文本和超文本文档背后的概念。第二部分解释了非常重要的超文本传输协议 (HTTP) 的操作，该协议是使 Web 正常工作的 TCP/IP 应用层协议。

注意：正如我在许多其他章节标题中所说的那样，对于像万维网这样大的主题，我无法在这里完全公正地对待。不仅有关于 Web 的整本书，书架上也摆满了这样的书。由于本指南的篇幅已经很大，而且它总体上侧重于协议和技术的工作原理，我必须克制自己的热情并将范围限制在概述 Web 的全部内容，同时重点介绍 Web 的具体细节。 HTTP 本身。

##### 4.2.5.1 TCP/IP 万维网和超文本概述和概念

万维网扩展了消息传递的概念，超越了电子邮件、FTP 和 Usenet 的简单文本文件传输的限制。它的强大之处在于它结合了超文本，一个允许相关文档链接在一起的系统，它的丰富的文档格式不仅支持文本，还支持图形和多媒体，以及允许这些媒体高效移动的特殊协议。结果是一个功能强大的系统一经推出，几乎立即在从大公司到个人的所有人中流行开来，并在短短几年内主导了 Internet 上的所有其他应用程序。

在本节中，我将对万维网背后的概念进行高层次的总结。我从 Web 和超文本的简短概述和历史开始，并讨论构成 Web 系统的组件。我简要描述了 Web 上使用的文档和媒体，并解释了超文本标记语言 (HTML) 的重要性。最后，我概述了如何使用统一资源定位器 (URL) 在 Web 上寻址文档。

###### 4.2.5.1.1 万维网和超文本概述和历史（部分：1 2 3）

有一次，我考虑将我的部分放在 Web 上的一个不同位置，与其他文件和消息传输协议的讨论分开。起初对我来说，它“看起来”不像是一种消息传输协议。但我意识到，归根结底，网络实际上只是另一种存储信息然后将其从一台计算机传输到另一台计算机的方式。一个问题立即打动了我：如果是这种情况，那么 Web 有什么特别之处使其以一种以前的消息传递应用程序从未有过的方式流行起来？

这个问题没有简单的答案。但是，如果我无论如何都必须给出一个，那就是：超文本。当然，电子邮件和 Usenet 等应用程序允许用户发送和接收信息，而 FTP 允许用户访问服务器上的一组文件。但是这些方法缺少的是任何能够轻松表示文档之间关系或提供从一个文档移动到另一个文档的方法的方法。高度简化的超文本正是这样做的：它允许文档的创建者在该文档的其他地方或其他地方包含相关信息的链接。使用适当的软件，用户可以轻松地从一个位置移动到另一个位置。

大不了？事实上，这比最初看起来更重要。如果没有某种方式将文档链接在一起，它们将保持在未连接的“孤岛”中。在某些方面，超文本链接的文档与未链接的文档的关系就像联网的计算机与未联网的计算机一样。考虑本指南与硬拷贝书之间的区别；如果我顺便提到一个话题，我可以提供一个链接；印刷书籍不能。希望您已经发现了它提供的优势。

<u>**超文本的历史**</u>

超文本背后的想法实际上可以追溯到网络甚至电子计算机之外。一般认为 Vannevar Bush（1890-1974 年）在 1945 年描述了一种称为 Memex 的理论设备时引入了这一想法，该设备旨在用于存储和检索文件。他描述了将相关信息链接在一起的轨迹的概念，以便更轻松地组织和访问设备中的信息。

布什的想法被用作随后的几位研究人员的工作基础。其中之一是 Ted Nelson，他创造了“超文本”一词，并于 1960 年首次描述了一个名为 Xanadu 的系统，该系统被认为是原始超文本软件模型之一。

万维网本身的历史可以追溯到 1989 年在日内瓦的欧洲核子研究组织 CERN。 （该组织的法语名称是 Conseil Européene pour la Recherche Nucléaire 的首字母缩写词。）CERN 承担的许多项目都很大、很复杂，需要很多年才能完成。他们还涉及许多必须处理和共享相关文件的科学家。

<u>**网络的发展和成长**</u>
CERN 的研究员 Tim Berners-Lee 提出了创建电子链接文档“网络”的想法。快速发展的互联网是这个项目的明显渠道。他于 1990 年为 TCP/IP 设计了第一个（非常粗糙和简单的）版本的超文本传输协议 (HTTP)。他还负责开发或共同开发 Web 背后的其他几个关键概念和组件，例如统一资源标识符 (URI) 和超文本标记语言 (HTML)。

将文档和文件链接在一起的能力具有巨大的吸引力，创意人士很快就发现了这项新技术的许多不同用途。 1990 年代初期出现了一系列开发活动。 Web 服务器和客户端软件得到开发和完善，第一个图形化 Web 浏览器 Mosaic 于 1993 年由国家超级计算机应用中心 (NCSA) 创建。（该程序的开发者 Marc Andreesen 最终成立了 Netscape Communications。）

一旦 Web 开始形成，它确实发展得非常快。事实上，将 Web 的增长称为“爆炸性”以外的任何东西都不公平。 1993 年初，只有 50 个活动的 HTTP Web 服务器。到 1993 年底，已超过 1,000 个。到 1995 年底，每天都有数以千计的新网站上线，并且 HTTP 请求和响应已经超过了所有其他 TCP/IP 应用程序流量。到本世纪末，Web 上有数百万个网站和超过 10 亿个文档。

<u>**今天的万维网**</u>

尽管 Web 规模的快速增长令人惊叹，但更令人着迷的是其范围的增长。由于您正在阅读有关网络的指南，您很可能是 Web 用户，并且熟悉当今可以在 WWW 上找到的令人难以置信的各种不同类型的信息。早期的超文本系统仅基于文本文档的使用；今天，Web 是一个包含许多媒体的世界，包括图片、声音和电影。在许多情况下，术语超文本已被更通用的超媒体所取代——即使不是正式的，也只是功能上的。

Web 还超越了简单的文档检索，提供了无数的服务。一个网站可以提供的不仅仅是文档，还允许用户运行数千种程序。这使得从网上购物到娱乐的一切都成为可能。网站还模糊了不同类型应用程序之间的界限，提供基于 Web 的电子邮件、基于 Web 的 Usenet 访问、公告板和其他用于讨论的交互式论坛等等。

Web 对网络和整个社会都产生了影响，即使是其最狂热的早期粉丝也无法预料。事实上，Web 是整个 Internet 的最终“杀手级应用程序”。在 90 年代初期，大公司将 Web 视为一种有趣的好奇心；到本世纪末，它已成为许多企业的必需品。数以百万计的个人和家庭发现触手可及的大量信息，互联网接入成为许多另一种“实用工具”，如电话服务。事实上，Web 流量的巨大增长催生了数十亿美元用于 Internet 基础设施的支出。

21 世纪初的“.com 崩溃”使 Web 的风帆失去了一些活力。 Web 令人难以置信的增长无法以其最初的速度继续，并且已经有所放缓。但 Web 作为一个整体继续扩展和成熟，并可能在未来一段时间内成为 Internet 上最重要的信息和服务资源。

**关键概念：**万维网 (WWW) 始于 1989 年，是一个旨在促进文档之间关系表示和研究人员之间信息共享的项目。使 Web 如此强大的主要特征是超文本，它允许从一个文档链接到另一个文档。 Web 的诸多好处使其在短短几年内从一个小型应用程序发展成为网络世界中最大且可以说是最重要的应用程序；它主要负责将互联网带入社会主流。

###### 4.2.5.1.2 万维网系统概念和组件（部分：1 2 3）

超文本是使万维网不仅仅是另一个消息传输系统的主要概念。然而，超文本背后的想法在 Web 诞生之前已经存在了几十年，某些基于该想法的软件产品也是如此。显然，要将一个想法发展成一个成功的系统，需要的不仅仅是一个概念。

Web 之所以成为一种现象，是因为它将超文本的基本思想与其他几种概念和技术相结合，创造了一种丰富、全面的交互式通信机制。今天的这个系统包含如此多不同的概念和软件元素，并且与其他技术如此集成，以至于很难找到任何两个人就 Web 的确切组成以及哪些是最关键的部分达成一致。

例如，不可否认，万维网成功的关键之一是 TCP/IP 互联网络协议套件与将世界各地的计算机连接在一起的互联网基础设施的结合。那么互联网是万维网的重要组成部分吗？在很多方面都是如此；事实上，由于当今 Web 的流行程度，人们常常将 Web 称为“Internet”。

万维网的功能组件如图 314 所示。现在让我们更详细地看一下它们。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\webfunctions (1).png)


​                                                                     **图 314：万维网的主要功能组件**

<u>**Web 的主要功能组件**</u>

我们知道，将 Web 等同于整个 Internet 并不是一个精确的术语使用，但它显示了 Web 的重要性以及它与 Internet 的紧密联系。尽管如此，尽管 Internet 和 TCP/IP 显然是 Web 成功的重要组成部分，但它们本质上是通用的。在更具体地定义万维网系统本身时，通常认为三个特定组件是最重要的：

- 超文本标记语言 (HTML)：用于定义超文本文档的文本语言。 HTML 背后的想法是向常规文本文档添加称为标签的简单结构，以实现一个文档与另一个文档的链接，以及允许特殊数据格式和不同类型媒体的组合。 HTML 已成为在超文本中实现信息的标准语言，并催生了许多其他相关语言的创建。

- 超文本传输协议 (HTTP)：实现万维网的 TCP/IP 应用层协议，支持在客户端和服务器之间传输超文本文档和其他文件。 HTTP 最初是一个非常粗糙的协议，用于在计算机之间传输 HTML 文档，现在已经发展成为一个功能齐全且复杂的消息传递协议。它支持多种不同类型文档的传输、连接上多个文件的流式传输以及各种高级功能，包括缓存、代理和身份验证。

- 统一资源标识符 (URI)：一种定义标签的方法，用于标识 Internet 上的资源，以便可以轻松找到和引用它们。最初开发 URI 是为了提供一种方法，Web 用户可以通过这种方法找到超文本文档，以便对其进行检索。 URI 实际上并不特定于 Web，尽管它们通常与 Web 和 HTTP 相关联。

**注意：**统一资源定位符 (URL) 是统一资源标识符 (URI) 的子集。这些术语在万维网讨论中经常互换使用。


所有这三个都是大约在同一时间创建和开发的，并且共同代表了定义万维网的关键技术。本节接下来的两个主题描述了 HTML 和 URI 在万维网上下文中的使用。 HTTP 确实是 Web 的核心，并且在本指南后面的部分中进行了广泛介绍。

<u>**网络硬件和软件**</u>

这三个主要组成部分由许多其他元素补充，这些元素在完善整个系统时起着“支持作用”。其中最主要的是用于实现使 Web 正常工作的客户端/服务器通信的硬件和软件：Web 服务器和 Web 浏览器。

Web 服务器是运行特殊服务器软件的计算机，允许它们向请求它们的客户提供超文本文档和其他文件。全世界数以百万计的此类机器现在充当虚拟的分布式存储库，存储着 Web 所代表的大量信息。

Web 浏览器是运行在 TCP/IP 客户端计算机上以访问 Web 服务器上的 Web 文档的 HTTP 客户端软件程序。这些浏览器程序检索超文本文档并显示它们，还实现了 Web 的许多高级功能，例如缓存。今天的浏览器支持各种各样的媒体，允许 Web 除了简单的超文本文档传输之外还可以实现许多不同的功能。示例包括显示图像、播放声音和实现交互式程序。

最后但并非最不重要的一点是，Web 用户可能是其最重要的组成部分。这是一种“作弊”，因为这在某些方面类似于将 Internet 定义为 Web 的一部分。同时，我觉得用户参与在塑造 Web 技术发展方面的作用比任何其他网络应用程序都大。 Web 最初只是一种交换文档的简单方式。今天，它已经发展到包括数以千计的不同应用程序和服务，这在很大程度上是用户创造力的结果。内容提供商通过为信息和服务创造新的想法，突破了 Web 可以做的事情的界限，以满足最终用户社区永无止境的需求。

**关键概念：**万维网是一个完整的系统，由许多相关组件组成，其中三个是最重要的。第一个是超文本标记语言 (HTML)，它描述了超文本文档是如何构建的； HTML 允许表示文档之间的链接。第二种是超文本传输协议 (HTTP)，这是一种在 Web 上移动超文本和其他文档的应用层协议。第三个是统一资源标识符 (URI) 机制，它提供了一种一致的方法来标识资源，无论是在 Web 上还是在整个 Internet 上。



###### 4.2.5.1.3 万维网媒体和超文本标记语言 (HTML)（部分：1 2 3 4）

我们在前两个主题中看到，万维网是基于超文本的中心概念。前缀“hyper”通常表示“高于”或“超越”，因此超文本类似于文本，但在功能上超越了文本。用超文本编写的文档类似于常规文本文件，但包含实现超文本功能的信息。当然，这些通常称为超文本文档或超文本文件。

超文本文档中的额外信息用于告诉向用户显示文件的计算机程序如何格式化它。此信息采用特殊说明的形式，这些说明散布在文档本身的实际文本中，这些文本是根据定义语言的语法编写的。这种向文档内容添加额外元素的操作通常称为标记文档。

<u>**HTML 概述**</u>
因此，万维网使用的标准语言称为超文本标记语言 (HTML)。 HTML 是万维网的三个主要系统组件之一，由 Web 的创建者 Tim Berners-Lee 于 1990 年发明。它不是凭空产生的。相反，它是 ISO 标准 8879:1986 中描述的标记语言的一般概念的特定应用：标准通用标记语言 (SGML)。

标记语言背后的想法是定义特殊项目，这些项目向显示文档的软件提供有关应如何呈现文档的信息。就超文本而言，文档中最基本的信息类型是一种特殊指令，它指定如何将一个文档链接到另一个文档——毕竟，这种链接过程是超文本的定义属性。

然而，HTML 远不止于此；它定义了一整套文本代码，用于描述文档如何向用户显示的几乎所有方面。这包括格式化文本的说明（例如定义其颜色、大小和对齐方式）、显示表格数据的方法、如何与文档一起呈现图像和其他媒体的规范、交互式表单等等。从理论上讲，该语言只应该定义文档并将其如何显示留给浏览器，但在实践中，现代 HTML 文档通常还包含有关如何显示其信息的相当具体的说明。

为了公正地对待 HTML，我将不得不用几十页来讨论这个主题。我决定不这样做，因为尽管 HTML 是 Web 的重要组成部分，但实际上它对于理解 Web 的工作原理并不是那么重要。如果您正在编写 Web 内容，了解 HTML 是必不可少的，如果您想了解如何编写 Web 软件，那么了解 HTML 也很重要。也许具有讽刺意味的是，对于使 Web 运行的实际机制（例如 HTTP）来说，“文档就是文档”。 HTTP 的设计并不是假设它会传输 HTML，而且在大多数情况下服务器甚至不会查看 HTML 文件的内容——它们只是传输它。

也就是说，对 HTML 的基本理解很重要，不提供至少对该语言的概述似乎是不对的，所以我将在这里做。如果您想了解更多信息，我鼓励您从许多优秀的 HTML 资源中寻找一种：万维网上有许多这样的资源（还有什么地方？）

<u>**HTML 元素和标签**</u>

用最简单的话来说，HTML 文档是纯 ASCII 文本文件，如电子邮件或其他文本文档。然而，HTML 和常规文本之间的最大区别在于 HTML 文档是结构化的。该文档在逻辑上被组织成一系列根据语言规则排列的元素。每个元素将文档的一部分定义为一个整体。例如，文档的标题、段落、表格和指向另一个文档的超链接都是元素的示例。

每个元素都使用遵循特定语法的特殊文本标签进行描述。每个标记都以“<”符号开头，然后是（不区分大小写的）元素名称，以及可选的描述元素的其他参数。标签以“>”符号结尾。以下是标签的一般外观：

```
<element parameter1=“value1” parameter2=“value2”…>
```

有些元素完全由标签的存在来描述，在这种情况下，标签就是整个元素。更常见的是，标签成对出现在元素的实际内容周围；开始标签以元素名称开头，结束标签以元素名称开头，前面加一个斜杠符号。例如，文档的标题是一个定义如下的元素：

```
<title>This Is A Great Story</title>
```

每个元素的内容都可以包含其他元素，这会导致标签相互嵌套。例如，如果我们想通过以粗体显示标题中的单词“Great”来突出显示它，我们可以添加“<b>”标签，如下所示：

```
<title>This Is A <b>Great</b> Story</title>
```

实际上，每个完整的 HTML 文档都被定义为一个称为“html”的“元素”；整个文档包含在“<html>”和“</html>”标签中。在此元素中，文档分为两个必须出现在每个文档中的标准子元素：头部和主体。文档的头部包含描述文档及其处理方式的信息；它最常包含如上所述的文档标题。正文包含文档的实际内容。这三个元素定义了基本的 HTML 文档结构：

```
<html>
<head>
(head elements go here…)
</head>
<body>
(body elements go here…)
</body>
</html>
```

文档的大部分由放置在“<body>”和“</body>”标签之间的正文元素组成。 HTML 文档的范围可以从仅包含文本段落和可能的几个链接等元素的非常简单的主体到由计算机生成并包含数百甚至数千个各种嵌套标签的非常复杂的文档。

<u>b</u>

表 273 简要描述了 HTML 消息正文中使用的一些更常见的元素以及定义它们的标签，让您了解该语言的工作原理：


​                                                              **表 273：通用超文本标记语言 (HTML) 元素**

| **Element**     | **Example Element and Tags**                                 | **Description**                                              |
| --------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Paragraph       | <p>Jack and Jill went up the hill to fetch a pail of water…</p> | 描绘一段文字。请注意，开始和结束标记之间的所有内容都将被视为一个段落，即使像我在这里所做的那样分成多行也是如此；换行符在 HTML 格式中并不重要，只有标记。 |
| Line Break      | George W. Bush<br> The White House<br> 1600 Pennsylvania Ave., NW<br> Washington, DC 20500 | 强制换行。用于代替段落标记来显示靠在一起的行，例如地址。     |
| Heading         | <h1>First Topic</h1> <h2>Subtopic</h2>                       | 定义节标题，以允许以分层形式显示长文档中的信息。定义了六组标签，从<h1>和</h1>到<h6>和</h6>。浏览器会自动以更突出的方式显示“更高级别”的标题，例如使用更大的字体、在文本下划线等。 |
| List            | <p>Shopping list: <ul> <li>Milk <li>Eggs <li>Sushi </ul> </p> | 允许将信息显示为列表。标签“<ul>”的意思是“未编号的列表”，并导致列表项通常显示为项目符号。或者，“<ol>”（“有序列表”）可用于显示以 1、2、3 等开头的项目。 |
| Horizontal Rule | …end of this part of the story.</p> <hr size= “3”> <p>Start of next part of story… | 在页面上绘制一条水平线； “大小”参数控制其厚度。用于分隔文档中的逻辑部分。 |
| Image           | <img src=”companylogo.gif” alt=”XYZ Industries Logo” align=“center”> | 在文本的适当部分显示内联图像。 “src”参数是图像的相对或绝对 URL，并且可以包含许多其他参数来定义图像的对齐方式、大小、如果浏览器是非图形浏览器则要显示的“替代文本”（如此处所示的“ alt”参数）等等。 |
| Link            | <a href=&t_.htm“http://www.PCGuide.com”>Click here to visit The PC Guide</a> | 指向另一个文档的超链接。标签中的“a”代表“anchor”，这是超链接的正式名称。 “href”参数指定链接的 URL。大多数浏览器会在开始和结束标记之间的文本下划线或以其他方式突出显示，以明确文本代表超链接。也可以通过组合“<img>”和“<a>”标签为图像提供超链接。 |
| Bookmark        | <a name=“Step4”>Step 4: Remove paint using scrubbing tool.</a> | 创建可用于超链接到文档中特定部分的书签。例如，如果此示例中的书签位于 URL“http://www.homefixitup.com/repainting.htm”的文档中，则 URL“http://www.homefixitup.com/repainting.htm#Step4”指文档中的这个特定位置。有关更多详细信息，请参阅有关 URL 的下一个主题。 |
| Table           | <table> <tr> <td>1st row, 1st column.</td> <td>1st row, 2nd column.</td> </tr> <tr> <td>2nd row, 1st column.</td> <td>2nd row, 2nd column.</td> </tr> </table> | 以表格形式显示信息。每个“<tr>”和“</tr>”标签集定义表格的一行；在每一行中，每个“<td>”和“</td>”对定义一个表数据元素。可以为这些标签中的每一个提供许多不同的参数来控制表的大小和外观。 |
| Form            | <form method="POST" action="https://www.myfavesite.com/order.php"> <input type="hidden" name="PRODUCT" value="widget"> <input type=”text” name=”QUANTITY” size="3"> <input type="submit" value="Click Here to Proceed to the Secure Processing Site"> </form> | 定义 HTML 表单，允许客户端将各种类型的信息提交给网站上设计用于处理表单的程序。表单由初始的“<form>”标签组成，该标签描述了按下提交按钮时要采取的操作，以及其他表单项，例如预定义变量、文本输入字段和按钮；此处显示了其中每一项的一个示例。 |
| Script          | <script language=javascript> *(Javascript code)*</script>    | 允许将脚本语言的指令包含在 HTML 文档中。最常用于 Javascript。 |

<u>**通用文本格式标签**</u>

还有许多标签用于格式化文档中文本的外观；一些更常见的：

- <b>文本</b>：以粗体显示封闭的文本。

- <i>text</i>：以斜体显示封闭的文本。

- <u>text</u>：显示带下划线的封闭文本。

- <font (parameters)>text</font>：使用指定的字体类型、大小或颜色显示封闭的文本。

同样，这只是 HTML 的冰山一角。但是，如果您不熟悉 HTML，了解这些基本标记应该足以帮助您理解基本的 HTML 文档并了解 HTTP 的工作原理。

**关键概念：**万维网超文本文档使用的语言称为超文本标记语言 (HTML)。 HTML 文档是 ASCII 文本文件，但使用 HTML 元素的特殊结构进行排列，这些元素定义了文档的不同部分以及它们应如何显示给用户。每个元素都使用定义它及其特征的特殊文本标签进行描述。



###### 4.2.5.1.4 万维网寻址：HTTP 统一资源定位符 (URL)（部分：1 2 3）

超文本如此强大和有用的主要原因是它允许将相关文档链接在一起。在万维网的情况下，这是使用一组特殊的超文本标记语言 (HTML) 标记来完成的，这些标记在一个文档中指定以某种重要方式相关的另一个文档的名称。用户只需单击鼠标即可从一个文档移动到下一个文档。 Web 的成功很大程度上基于这种简单而优雅的推荐方法。

超链接的概念对如何处理 Web 文档和其他资源有一些重要的影响。尽管 Web 的核心是类似于文件传输协议 (FTP) 的消息传输协议，但能够定义超链接的需求意味着使用一组命令指定如何检索资源的传统 FTP 模型具有被遗弃。相反，需要一个系统，通过该系统可以使用简单、紧凑的字符串唯一地指定资源。

这种需求的结果是定义了万维网的三个主要元素之一：统一资源标识符 (URI)。 URI 分为两类：统一资源定位符 (URL) 和统一资源名称 (URN)。虽然 URI、URL 和 URN 起源于 Web 的发展，但它们现在已经被普遍化，为各种各样的 TCP/IP 应用层协议提供寻址机制。因此，它们在单独的部分中进行了详细描述；本主题将提供有关如何将它们专门用于 Web 的更多信息。

目前，Web 几乎完全使用 URL。 URN 仍在开发中。 Web URL 指定使用超文本传输协议 (HTTP) 进行资源检索，因此通常称为 HTTP URL。这些 URL 允许通过指定主机名、目录路径和文件所在位置的文件名来唯一寻址文档、图形图像或多媒体文件等资源。

**关键概念：**统一资源标识符 (URI) 的开发是为了让万维网资源能够轻松且一致地被识别；它们现在也用于其他协议和应用程序。当前在 Web 上使用的 URI 类型是统一资源定位符 (URL)，它标识使用 HTTP 检索资源，并提供有关在何处以及如何找到和检索资源的信息。

<u>**HTTP 网址语法**</u>

HTTP URL 可以是绝对的或相对的。绝对 URL 通常用于从一个网站到另一个网站的超链接，或者由用户在没有任何事先上下文的情况下请求新文档。绝对 HTTP URL 基于以下常见的 Internet URL 语法：

```
<scheme>://<user>:<password>@<host>:<port>/<url-path>;<params>?<query>#<fragment>
```

对于 Web，方案是“http:”，不同 URL 元素的语义被定义为具有与 Web 相关的含义。因此，HTTP URL 的一般结构是：

```
http://<user>:<password>@<host>:<port>/<url-path>?<query>#<bookmark>
```

下面展示了这些句法元素是如何专门为 HTTP 绝对 URL 定义的：

- <user> 和 <password>：可选的身份验证信息，用于位于受密码保护的服务器上的资源。这种结构在实践中很少使用，所以大多数人没有意识到它是一种选择；因此，它已成为骗子滥用的目标，骗子使用它来隐藏不需要的 URL。
- <host>：资源所在的 Web 服务器的主机名。这通常是完全限定的 DNS 域名，但也可能是 IP 地址。

- <port>：用于连接到 Web 服务器的 TCP 端口号。对于 HTTP，这默认为 80，通常被省略。在极少数情况下，您可能会看到使用了一些其他端口号，有时是为了允许 Web 服务器软件的两个副本专门用于同一 IP 地址上的不同用途；端口 8080 作为替代方案特别常见。

- <url-path>：指向要使用 HTTP 检索的特定资源的路径。这通常是一个完整的目录路径，表示从根目录到资源所在位置要遍历的目录顺序，然后是资源名称。重要的是要记住路径区分大小写，即使 DNS 域名不区分大小写。

- <query>：要传递给 Web 服务器的可选查询或其他信息。该特性通常用于实现交互功能，因为查询值可以由用户指定，然后从 Web 浏览器传递到 Web 服务器。另一种方法是使用 HTTP POST 方法。

- <bookmark>：标识 HTML 文档中的特定位置。这通常用于非常大的 HTML 文档中，以允许用户单击超链接并滚动到文档中的特定位置。请参阅上一主题中的示例（接近表 273 的末尾）。

尽管 Web 的 URL 语法非常“丰富”并且可能很复杂，但大多数 Web URL 实际上都很短。这些组件中的绝大多数都被省略了，尤其是用户、密码、端口和书签元素；查询也仅用于特殊目的。这留下了您通常会遇到的更简化的 URL 形式：

```
http://<host>/<url-path>
```

<u>**资源路径和目录列表**</u>

用于引用特定文档的 <url-path> 也可以省略。这为用户提供了一种方便的方式来查看网站上提供的内容，而无需知道要请求的特定文档。例如，只想查看 CNN 当前头条新闻的用户只需访问“http://www.cnn.com”即可。在这种情况下，请求被发送到 Web 服务器以获取空文档“/”（如果未指定则隐含；从技术上讲，您应该指定“http://www.cnn.com/”）。

如何处理这样的“/”请求取决于服务器。从技术上讲，这样的请求实际上是向服务器询问“请显示服务器根目录的内容”。然而，这既丑陋（文件名列表并不是给人留下第一印象的最佳方式），也存在潜在的安全问题（因为任何人都可以看到服务器上每个文件的名称）。相反，大多数 HTTP 服务器都设置为自动识别此类请求并返回默认文档，通常命名为“index.html”或“default.html”之类的名称。如果 URL 中指定了任何其他目录，许多服务器将类似地返回某种默认文档；例如，“http://www.pcguide.com/ref”实际上返回“http://www.pcguide.com/ref/index.htm”。

上述形式适用于绝对 HTTP URL。 URL 也可能是相对的；这是密切相关的文档之间链接的规范，例如文档附带的图形，或者一组或项目中的文档之间的链接。在这种情况下，通常只指定 URL 路径的一小部分；这在关于相对 URL 的主题中有完整描述。

**请注意**，虽然在 HTTP URL 中保留“http://”在技术上是不正确的，但如果省略，大多数 Web 浏览器会自动添加它。因此，许多 Web 用户习惯于输入只是主机名的“URL”，例如“www.pcguide.com”。



##### 4.2.5.2 TCP/IP 超文本传输协议 (HTTP)

 万维网的成功是其实施的完整超媒体系统的效率和实用性的结果。我们在上一节研究了超文本背后的基本概念，并研究了构成万维网系统的三个主要组件中的两个：HTML 和 URL。 Web 的第三个主要组件可以说是最重要的：实际在 Web 服务器和 Web 客户端（浏览器）之间传输超文本文档和其他文件的协议。这是所有网络中最广为人知的软件协议之一：超文本传输协议 (HTTP)。

在本节中，我提供了超文本传输协议的详细描述。我首先概述了 HTTP，并讨论了它的历史和版本，以及定义它们的标准。然后，我将在五个小节中描述协议的操作。第一部分一般性地讨论了 HTTP 的操作，重点是如何建立和维护连接。第二部分描述了 HTTP 消息及其格式，并描述了 HTTP 方法（命令）和状态代码。第三部分详细介绍了许多 HTTP 标头，这些标头非常重要，因为它们是 HTTP 服务器和客户端之间传递信息的主要方式。第四小节提供有关资源（称为实体）如何在 HTTP 中编码和传输的信息。最后一小节描述了现代 HTTP 协议的特殊特性和功能。

**背景信息：**与许多 TCP/IP 协议一样，在设计 HTTP 时，其创建者从其他应用程序协议中“借用”了元素。在这种情况下，HTTP 使用电子邮件中的某些元素，尤其是多用途 Internet 邮件扩展 (MIME)。在阅读本节之前，我建议您熟悉 RFC 822 电子邮件消息格式和 MIME，尤其是 MIME 标头和媒体类型。 HTTP 和 MIME 之间的关系包含在讨论 HTTP 实体和媒体类型的主题中。

###### 4.2.5.2.1 HTTP 概述、历史、版本和标准（部分：1 2 3）

万维网起源于瑞士研究机构 CERN 的一个研究项目。该项目的主要目标是允许超文本文档进行电子链接，因此在一个文档中选择对另一个文档的引用将导致它被检索。为了实现这个系统，需要某种机制来允许客户端计算机告诉服务器向它发送文档。为了填补这个功能，Web 的早期开发人员创建了一个新的 TCP/IP 应用层协议：超文本传输协议 (HTTP)。

<u>**HTTP/0.9**</u>
HTTP 的原始版本仅用于传输超文本文档，并且设计得非常简单，以便更容易实施刚刚起步的 Web。这个早期的 HTTP 指定 HTTP 客户端使用 TCP 建立到 HTTP 服务器的连接。然后，客户端发出一个“GET”请求，指定要检索的资源。服务器通过将文件作为文本字节流发送来响应，然后连接终止。定义这个版本的 HTTP 的整个文档只有几页那么长！

HTTP 的第一个版本是可用的，但其功能极其有限。它不支持超文本以外的任何类型的数据传输，并且不提供客户端和服务器之间任何类型的“智能”通信的机制。这个早期的 HTTP 原型无法胜任为万维网的未来提供数据传输基础的任务。它从未成为官方的 RFC 标准，事实上，甚至从未有过正式的版本号；它今天被称为 HTTP 版本 0.9，或使用 HTTP 使用的版本格式的“HTTP/0.9”。我相信这个数字除了比协议第一个正式版本的数字小一点外，没有什么特别的意义。

<u>**HTTP/1.0**</u>
HTTP/0.9 的功能框架构成了 1990 年代初期 HTTP 快速发展的基础。随着万维网的规模和接受度的增长，许多新的想法和特性被合并到 HTTP 中。大量开发工作的结果是第一个 HTTP 标准的形式化：1.0 版。这个大大增强的 HTTP 于 1996 年 5 月发布为 RFC 1945，超文本传输协议 — HTTP/1.0。然而，在该正式发布日期之前，它已经使用了几年。

HTTP/1.0 将 HTTP 从一个普通的请求/响应应用程序转变为一个真正的消息传递协议。它描述了 HTTP 的完整消息格式，并解释了它应该如何用于客户端请求和服务器响应。 HTTP/1.0 中最重要的变化之一是协议的通用化以处理多种类型的不同媒体，而不是严格的超文本文档。这是通过从为电子邮件定义的多用途 Internet 邮件扩展 (MIME) 标准中借用概念和标头结构来完成的。在它定义了更强大的 Web 服务器和客户端的同时，HTTP/1.0 保留了与仍在使用 HTTP/0.9 的服务器和客户端的向后兼容性。

HTTP/1.0 是在 20 世纪 90 年代中期随着 Web 爆炸式普及而广泛实施的 HTTP 版本。仅仅几年后，HTTP 就占据了新兴互联网上的大部分流量。 HTTP 的流行实际上是如此之大，以至于它单枪匹马地促使安装了许多新硬件来处理浏览器请求和 Web 服务器回复的负载。

不幸的是，这种巨大的流量负载大部分是由于 HTTP 本身的一些限制造成的。这些只是由于协议使用的巨大增长而变得明显，再加上 Internet 的正常成长痛苦，导致许多 Web 用户感到沮丧。 HTTP 1.0 版的低效率是设计限制的结果，例如每个站点都需要托管在不同的服务器上，每个 HTTP 会话只处理一个客户端请求的事实，以及普遍缺乏对必要的性能增强的支持缓存、代理和部分资源检索等功能。

<u>**HTTP/1.1**</u>

虽然不耐烦的专家们创造了诸如“全球等待”之类的讽刺术语，但 IETF 仍在继续努力改进 HTTP。 1997 年 1 月，出现了 HTTP/1.1 的第一个草案版本：在 RFC 2068 中。此文档后来被修订并于 1999 年 6 月发布为 RFC 2616，超文本传输协议 - HTTP/1.1。HTTP/1.1 保留与 HTTP 的向后兼容性/1.0 和 HTTP/0.9。它伴随着 RFC 2617，HTTP 身份验证：基本和摘要访问身份验证，处理安全和身份验证问题。

- HTTP/1.1 在协议 1.0 版的基础上引入了几项重大改进，其中大部分专门解决了我刚才描述的性能问题。 1.1 版中一些比较重要的改进是：

- 多主机名支持：在 HTTP/1.0 中，无法指定客户端需要连接的服务器的主机名。结果，特定IP地址的Web服务器只能支持一个域名。这不仅效率低下，而且在 1990 年代加剧了 IP 地址的枯竭，因为每个新的 Web 服务器上线都需要一个新的 IP 地址。 HTTP/1.1 允许一台 Web 服务器处理对几十个甚至上百个不同虚拟主机的请求。

- 持久连接：HTTP/1.1 允许客户端在单个 TCP 会话中向服务器发送对相关文档的多个请求。这大大提高了 HTTP/1.0 的性能，在 HTTP/1.0 中，每个请求都需要与服务器建立新连接。

- 部分资源选择：在 HTTP/1.1 中，客户端可以只请求资源的一部分而不是整个文档，这减少了服务器的负载并节省了传输带宽。

- 更好的缓存和代理支持：HTTP/1.1 包含许多条款，使缓存和代理比 HTTP/1.0 中的更有效。这些技术可以通过为客户提供更快的请求回复来提高性能，同时减少服务器的负载，以及增强安全性和实现其他功能。

- 内容协商：添加了协商功能，允许客户端和服务器交换信息，以在多个变体可用时帮助选择最佳资源或资源版本。

- 更好的安全性：HTTP/1.1 定义了身份验证方法，通常比 HTTP/1.0 更“安全”。

除了这些显着改进之外，HTTP/1.1 中还进行了许多其他小的改进。其中一些采用新标头的形式，可以包含在客户端请求中以更好地控制在什么情况下从服务器检索资源，以及服务器响应中的标头以向客户端提供附加信息。

<u>**未来的 HTTP 版本**</u>

HTTP/1.1 仍然是超文本传输协议的当前版本，尽管它已经存在好几年了。考虑到 HTTP 的广泛使用，这似乎有些令人惊讶。话又说回来，可能有数以百万计的服务器和客户端实现了 HTTP/1.1，以至于没有创建新版本。有一段时间有人猜测将开发 HTTP 1.2 版，但这并没有发生。

在 1990 年代后期，开始研究通过扩展现有 1.1 版本来扩展 HTTP 的方法。 HTTP 扩展框架的开发进行了很多年，并于 1998 年创建了新 Internet 标准的拟议草案。然而，正如我刚才所说，HTTP/1.1 的部署如此广泛且如此重要，以至于很难就任何修改它的提议达成共识。因此，当 HTTP 扩展框架最终于 2000 年 2 月作为 RFC 2774 发布时，新标准所需的普遍接受性并不存在。该框架被赋予“实验”地位，从未成为正式标准。

**关键概念：**万维网的引擎是定义 Web 服务器和客户端如何交换信息的应用程序协议：超文本传输协议 (HTTP)。 HTTP 的第一个版本 HTTP/0.9 是早期万维网的一部分，是一种非常简单的请求/响应协议，功能有限，只能传输文本文件。第一个广泛使用的版本是 HTTP/1.0，这是一个更完整的协议，允许传输多种类型的文件和资源。当前版本是 HTTP/1.1，它扩展了 HTTP/1.0 的功能，增加了几个提高传输效率的特性，并满足了快速发展的现代万维网的许多需求。



###### 4.2.5.2.2 HTTP 通用操作和连接

超文本传输协议 (HTTP) 最初是一个极其基本的协议，旨在只做一件事：允许客户端发送对超文本文件的简单请求并从服务器接收回它。现代 HTTP 的核心仍然是一个直接的请求/回复协议，但现在包括许多新的特性和功能，以支持不断增长的万维网和人们发现的越来越多的使用方式。因此，解释 HTTP 的最佳起点是从整体上看它的操作，以及 Web 服务器和 Web 客户端之间的通信是如何发生的。

在本节中，我通过一般术语描述其操作来介绍超文本传输协议。我将从 HTTP 的高级概述和对其操作模型的讨论开始。我解释了 HTTP 客户端和服务器之间支持的两种连接类型，以及在 HTTP/1.1 中可以通过管道传输请求的方法。然后，我将提供有关如何在当前版本的 HTTP 中建立、管理和终止持久连接的更多信息。

###### 4.2.5.2.2-1 HTTP 操作模型和客户端/服务器通信（部分：1 2 3）

超文本传输协议是实现万维网的应用层协议。虽然 Web 本身有许多不同的方面，但 HTTP 只涉及一个基本功能：将超文本文档和其他文件从 Web 服务器传输到 Web 客户端。在实际通信方面，客户端主要关心向服务器发出请求，服务器响应这些请求。

因此，尽管 HTTP 包含很多功能来满足客户端和服务器的需求，但当您将其归结起来时，您看到的是一个非常简单的客户端/服务器、请求/响应协议。在这方面，与 FTP 和 SMTP 等其他应用层协议相比，HTTP 更类似于 BOOTP 或 ARP 等基本协议，后者都涉及多个通信步骤和命令/回复序列。

<u>**基本 HTTP 客户端/服务器通信**</u>
在其最简单的形式中，HTTP 的操作仅涉及一个 HTTP 客户端（通常是客户端计算机上的 Web 浏览器）和一个 HTTP 服务器（通常称为 Web 服务器）。 TCP连接建立后，通信的两个步骤如下：

- 客户端请求：HTTP 客户端发送一个根据 HTTP 标准规则格式化的请求消息——一个 HTTP 请求。此消息指定客户端希望检索的资源，或包含要提供给服务器的信息。

- 服务器响应：服务器读取并解释请求。它采取与请求相关的操作并创建 HTTP 响应消息，并将其发送回客户端。响应消息指示请求是否成功，如果合适，还可能包含客户端请求的资源的内容。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\httpclientserver.png)

​                                                                           **图 315：HTTP 客户端/服务器通信**

在最简单的形式中，HTTP 通信由客户端发送到服务器的 HTTP 请求消息组成，服务器使用 HTTP 响应进行回复。


在 HTTP/1.0 中，每个 TCP 连接只涉及一次这样的交换，如图 315 所示；在 HTTP/1.1 中，多重交换是可能的，我们将在下一个主题中看到。另请注意，在某些情况下，服务器可能会在发送完整响应之前以一个或初步响应进行响应。如果服务器在“真实”回复之前使用“100 Continue”状态代码发送初步响应，则可能会发生这种情况。有关更多信息，请参阅有关 HTTP 状态代码的主题。

**关键概念：**HTTP 是一种面向客户端/服务器的请求/回复协议。基本通信由 HTTP 客户端发送到 HTTP 服务器的 HTTP 请求消息组成，HTTP 服务器将 HTTP 响应消息返回给客户端。

<u>**中介和 HTTP 请求/响应链**</u>

当在客户端和服务器之间的虚拟通信路径中放置中介时，客户端和服务器之间的简单请求/响应对变得更加复杂。这些是用于提高性能、提供安全性或为特定客户端或服务器执行其他必要功能的代理、网关或隧道等设备。代理在 Web 上特别常用，因为它们可以大大缩短相关客户端计算机组的响应时间。

当中介参与 HTTP 通信时，它充当“中间人”。客户端不是直接与服务器对话（反之亦然），而是各自与中介对话。这允许中介执行缓存、翻译、聚合或封装等功能。例如，考虑通过单个中间设备进行交换。上面的两步通信过程将变成四步：

1. 客户端请求：HTTP 客户端向中间设备发送请求消息。

2. 中介请求：中介处理请求，并在必要时对其进行更改。然后它将请求转发到实际的服务器。

3. 服务器响应：服务器读取并解释请求，采取适当的操作然后发送响应。由于它收到了来自中介的请求，因此它的回复会返回给中介。

4. 中介响应：中介处理请求，可能再次进行更改，然后将其转发回客户端。

如您所见，中介的行为从客户端的角度看就像是服务器，从服务器的角度看就像是客户端。许多中介被设计为能够“拦截”各种 TCP/IP 协议，通过“冒充”为客户端的服务器和服务器的客户端。大多数协议都不知道以这种方式进行中介干预的存在。然而，HTTP 包括对某些中介的特殊支持，例如代理服务器，提供控制中介如何处理 HTTP 请求和回复的标头。

客户端和服务器之间可以将两个或多个中介链接在一起。例如，客户端可能会向中介 1 发送请求，然后转发给中介 2，然后中介 2 与服务器对话；参见图 316。回复过程与此相反。 HTTP 标准使用短语请求/响应链来统指参与 HTTP 消息交换的整套设备。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\httpchain.png)

​																  		**图 316：使用中介的 HTTP 请求/响应链**

HTTP 客户端和服务器可以使用一个或多个中间设备（例如代理）链接，而不是直接连接。在此示例中，存在两个中介。客户端发送的HTTP Request实际上会中转三次：从客户端到第一个中介，再到第二个，最后到服务器。 HTTP 响应同样会创建一次，但会传输三个不同的时间。参与消息交换的全套设备称为请求/响应链。

**关键概念：**当在 HTTP 客户端和服务器之间的通信路径中插入代理、隧道或网关等中间设备时，简单的 HTTP 客户端/服务器操作模型变得复杂。 HTTP/1.1 专门设计了一些功能来支持请求和响应的有效传输，通过一系列从客户端到中介到服务器再返回的步骤。此类通信中涉及的整套设备称为请求/响应链。

<u>**缓存对 HTTP 通信的影响**</u>

通过对客户端请求应用缓存，改变了正常的 HTTP 通信模型。 Web 上的各种设备都使用缓存来存储最近检索到的资源，以便可以快速提供这些资源以响应请求。客户端本身将缓存最近访问的 Web 文档，这样如果用户再次请求它们，甚至无需向服务器发出请求就可以显示它们。如果确实需要请求，则任何中间设备都可以满足对文件的请求，前提是文件在其缓存中。

当使用缓存时，请求缓存资源的设备直接返回它，“短路”正常的 HTTP 通信过程。在上面的例子中，如果中介 1 有客户端需要的文件，它会直接将它提供给客户端，而中介 2 和客户端最初试图访问的真实 Web 服务器甚至不会意识到请求是做过;有关 HTTP 缓存的主题更详细地讨论了该主题。

**注意：**大多数 Web 资源请求都是使用基于域名系统 (DNS) 主机名的 HTTP URL 发出的。满足此类请求的第一步是将 DNS 域名解析为 IP 地址，但此过程与 HTTP 通信本身是分开的。



###### 4.2.5.2.2-2 HTTP 临时和持久连接和流水线（部分：1 2 3）

基本的 HTTP 通信过程是一个简单的“两步舞”：客户端向服务器发送请求，服务器回复客户端。由于这就是 HTTP 的全部目的，因此协议的第一个版本被设计为在客户端和服务器之间建立 TCP 连接后，执行单个请求/响应交换。请求得到满足，然后 TCP 连接将终止。

<u>**临时连接**</u>
这些连接由于其生命周期短而被称为临时连接，是原始 HTTP/0.9 支持的唯一类型，并且在更广泛部署的 HTTP/1.0 中维护了相同的模型。这种连接模型的优点是概念简单；它的问题是当客户端需要向同一服务器发出许多请求时效率低下。现代超文本文档通常就是这种情况，它们通常包含对图像和其他媒体的内联引用。对网站主页的典型客户端请求从对 HTML 文件的单个请求开始，但随后会导致对该文档附带的每个其他相关文件的后续请求。

对于临时连接，客户端发出的每个请求都需要在客户端和服务器之间建立一个新的、不同的 TCP 连接。每个连接都会占用服务器资源和网络带宽，因此必须为每个文件建立一个新连接，效率极低。假设您正在与需要问一系列问题的人交谈。现在想象一下，在回答完每个问题后，对方挂断了电话，而你不得不再次给他们打电话！你明白了。

有些人认为 HTTP/0.9 和 HTTP/1.0 连接的临时性是这些早期 HTTP 版本的“设计缺陷”，但我认为这不一定很公平。在早期，这种运营模式确实不是什么大问题；只有当 Web 和超文本的使用得到发展时，它才会成为问题。

在其存在的最初几年，超文本主要是：文本。由于整个资源都在一个文件中，因此让 HTTP 会话仅持续足够长的时间用于一个请求/响应通常就足够了。直到 1990 年代，超文本才成为超媒体，重点放在嵌入式图形和其他文件上。当网页从简单的文本变成拥有数十个甚至数百个嵌入式图像的多媒体奇迹时，HTTP/1.0 的局限性真正变得显而易见。

<u>**持久连接**</u>

临时连接效率低下问题的解决方案出现在 HTTP/1.1 中，它允许 HTTP 客户端和服务器建立持久连接。 HTTP的基本操作没有改变；主要区别在于默认情况下，TCP 连接在每个请求/响应设置后保持打开状态，以便可以立即交换下一个请求和响应。仅当客户端请求完其所需的所有文档时，会话才会关闭。

在请求之间保持 HTTP 客户端和服务器之间的 TCP 连接活动可能是 HTTP/1.1 提高 1.0 版性能的最重要的方法。客户能够更快地获取他们的文件，因为他们不必在检索每个资源之前等待 TCP 连接。服务器负载减少，繁忙服务器的内存使用得以节省。通过消除不必要的 TCP 握手段，减少了网络拥塞。

<u>**流水线**</u>
持久连接为 HTTP 客户端提供了另一个重要的性能增强选项：管道请求的能力。假设客户端需要向服务器发送对文件 A、B 和 C 的请求。由于对所有这些文件的请求将在同一个 TCP 会话中发送，因此客户端无需在发送对 B 的请求之前等待对其对 A 的请求的响应。客户端可以“快速发送”请求“， 一个接一个地。这也提高了服务器的效率，服务器将能够尽快按照接收请求的顺序填充请求，而不必暂停等待每个新请求的发送。异步概念

**关键概念：**HTTP/0.9 和 HTTP/1.0 仅支持 HTTP 客户端和服务器之间的临时连接，其中只能在 TCP 连接上交换单个请求和响应。这对于现代 Web 来说是非常低效的，因为客户端经常需要向服务器发出数十个请求。 HTTP/1.1 默认使用持久连接运行：一旦建立了 TCP 连接，客户端可以向服务器发送许多请求并依次接收对每个请求的回复。这允许更快地检索文件，并节省服务器资源和 Internet 带宽。客户端甚至可以通过管道传输其请求，立即发送第二个请求，而无需先等待对第一个请求的回复。 HTTP/1.1 在需要时仍然支持临时连接以实现向后兼容性。

<u>**持久连接和流水线引起的并发症**</u>

持久连接的明显优点使它们成为现代 HTTP 通信的默认设置，但它们确实有一个缺点：它们使从服务器向客户端发送数据的过程变得复杂。通过临时连接，客户端知道它从服务器收到的所有数据都是对它发送的一个请求的回复。一旦收到服务器发送的所有字节并且 TCP 会话结束，客户端就知道文件已完成。

对于持久连接，尤其是在使用流水线时，服务器通常会一个接一个地向客户端发送文件，客户端必须区分它们。请记住，TCP 只是将数据作为一系列非结构化字节发送；应用程序必须注意指定文件之间的分界点。这意味着持久连接和流水线会导致必须在 HTTP 中专门解决的数据长度问题。

为了提供与旧版本软件的兼容性，HTTP/1.1 服务器仍然支持临时连接，并且如果它们收到 HTTP/0.9 或 HTTP/1.0 请求，将在一次响应后自动关闭 TCP 连接。 HTTP/1.1 客户端也可以指定它们不想在初始请求中使用持久连接。下一个主题描述如何创建和管理持久连接。



###### 4.2.5.2.2-3 HTTP 持久连接的建立、管理和终止（部分：1 2）

持久连接的引入大大提高了 HTTP 的效率，它减少了客户端和服务器对之间一系列 HTTP/1.0 请求中涉及的大部分开销。这些连接现已成为 Web 上客户端/服务器通信的标准。

<u>**连接建立**</u>
与大多数 TCP/IP 客户端/服务器协议一样，HTTP 中的服务器通过侦听特定端口号上的请求来扮演被动角色。 HTTP 的默认端口号是众所周知的 TCP 端口号 80，Web 浏览器将其用于大多数 HTTP 请求，除非在 URL 中指定了不同的端口号。客户端通过打开从它自己到它希望联系的服务器的 TCP 连接来启动 HTTP 连接。

**注意：**DNS 名称解析步骤可能先于整个 HTTP 连接，因为大多数 URL 包含主机名，而 HTTP 要求客户端知道服务器的 IP 地址。这可能会造成混淆，尤其是因为 DNS 使用 UDP 而 HTTP 使用 TCP。


一旦 TCP 连接处于活动状态，客户端就会发送其第一个请求消息。正如我们将在下一节中看到的，请求指定了客户端使用的 HTTP 版本。如果是HTTP/0.9或者HTTP/1.0，服务器会自动工作在瞬态连接模型，只会发送一个回复然后关闭链接。如果是 HTTP/1.1，则假定需要持久连接。 HTTP/1.1 客户端可以通过在其初始请求中包含特殊的 Connection:close 标头来覆盖此设置，该标头告诉服务器它不想在发送的请求完成后保持会话活动。

<u>**持久连接的使用和管理**</u>
假设正在使用持久连接，客户端可能会在发送其第一个请求后开始对后续请求进行流水线处理，同时等待服务器对初始查询的响应。当服务器开始响应请求时，客户端处理它们并采取行动，例如向用户显示检索到的数据。从服务器接收到的数据也可能会提示客户端在同一连接上请求更多文件，例如包含图像引用的 HTML 文档。

服务器通常会缓冲一定数量的来自客户端的流水线请求。在客户端发送太多请求的速度太快的情况下，服务器可能会使用 TCP 内置的流量控制机制“限制”客户端。理论上，服务器也可以直接决定终止与客户端的连接，但最好使用 TCP 的现有特性。关闭连接将导致客户端启动一个新连接，可能会加剧任何过载问题。

<u>**连接终止**</u>

只要客户端有请求，请求和响应的流程就会继续。客户端可以通过在需要发送到服务器的最后一个请求中包含 Connection: close 标头来优雅地终止连接。所有请求都按顺序填写，因此服务器将满足所有未完成的请求，然后关闭会话。

由于 HTTP/1.1 支持请求流水线，因此客户端通常不需要同时与同一服务器建立多个连接。无论如何，客户端偶尔会这样做，以允许他们更快地从服务器获取信息。这被许多人认为是“反社会的”，因为它可能导致繁忙的服务器资源被一个客户端独占，而其他想要访问它的客户端被排除在外。

在特殊情况下，客户端或服务器可能会意外关闭一个活动的持久连接。例如，如果客户端检测到自服务器上次回复以来已经过去了太多时间，它可能会断定服务器已崩溃并终止连接。同样，服务器可能会收到来自其管理员的关闭命令，或者由于其他原因突然终止与客户端的会话。服务器通常会避免在发送响应的过程中关闭链接。

客户端和服务器都必须能够处理突然的会话终止。对于服务器，没有什么可做的；如果客户端终止连接，服务器将简单地“清理”与连接相关的任何资源，并继续为下一个客户端提供服务。

当服务器过早地终止会话时，客户端需要做更多的事情，尤其是在流水线请求时。客户端必须跟踪发送到服务器的所有请求，以确保每个请求都被填充。如果服务器意外关闭会话，客户端通常会尝试建立新连接以重新传输未填充的请求。由于会话突然关闭通常是服务器繁忙的标志，因此 HTTP 标准指定客户端使用二进制指数退避算法来等待可变但增加的时间，然后再提交对文件的重新请求（在概念上类似于所使用的方法处理以太网中的冲突）。这有助于防止客户端向已经不堪重负的设备“堆积”请求。



###### 4.2.5.2.3 HTTP 消息、消息格式、方法和状态代码

正如我们在超文本传输协议的操作概述中看到的那样，HTTP 完全面向客户端请求和服务器响应的发送。它们采用在客户端和服务器之间发送的 HTTP 消息的形式。与所有协议一样，HTTP 使用一种特殊格式来规定客户端请求消息和服务器响应消息的结构；了解这些消息如何工作是理解整个 HTTP 的重要组成部分。

在本节中，我将描述 HTTP 使用的消息以及客户端和服务器发出的特定命令和响应。我首先介绍通用 HTTP 消息格式和每条 HTTP 消息的主要组成部分。然后，我将讨论用于请求和响应的特定格式。我解释了客户端请求中使用的不同类型的 HTTP 方法（命令），以及服务器回复中使用的 HTTP 状态代码。

**注意：**HTTP 的大部分功能是使用出现在每个 HTTP 请求和响应开头的标头字段实现的。由于标头的数量及其潜在的复杂性，它们在各自的部分中进行了详细介绍。

###### 4.2.5.2.3-1 HTTP 通用消息格式（部分：1 2）

正如我们已经看到的，使用超文本传输协议的设备之间的所有通信都是通过 HTTP 消息进行的，其中只有两种类型：请求和响应。客户端通常发送请求并接收响应，而服务器接收请求并发送响应。网关或代理等中间设备可以发送和接收这两种类型的消息。

创建所有 HTTP 消息以适应标准称为通用消息格式的消息结构。与大多数其他 TCP/IP 消息传递协议（如 SMTP 和 NNTP）一样，HTTP 消息不使用二进制消息格式；相反，它们是基于文本的。 HTTP 消息大致基于电子邮件 RFC 822 和 2822 消息标准，以及多用途 Internet 邮件扩展 (MIME) 标准。我说“宽松”是因为 HTTP 消息在构造上与电子邮件消息类似，但并不严格遵循所有电子邮件或 MIME 格式要求。一方面，并不是所有的 RFC 822 和 MIME 标头都被使用；还有其他差异，我们将很快加以研究。

HTTP通用消息格式如下：

```
<start-line>
<message-headers>
<empty-line>
[<message-body>]
[<message-trailers>]
```

您可以看到这与用于电子邮件消息和 Usenet 新闻组消息的格式几乎相同：标题、空行和消息正文。所有文本行都以标准的“CRLF”控制字符序列结束；空行只包含这两个字符，没有其他内容。标头始终作为常规文本发送；然而，主体可以是文本或 8 位二进制信息，这取决于要发送的数据的性质。 （这是 HTTP 不严格遵守 RFC 822 标准的另一种方式；有关完整讨论，请参阅实体和媒体类型的讨论。）

起始行是一个特殊的文本行，用于传达消息的性质。在请求中，此行以方法的形式指示请求的性质，并指定 URI 以指示作为请求对象的资源。响应使用开始行来指示响应请求的状态信息。有关使用起始行的更多详细信息，请参见接下来分别详述请求消息和响应消息的两个主题。

<u>**标题格式**</u>

HTTP 中定义了数十种消息标头，它们按功能分组，我们很快就会看到。几乎所有这些都是可选的；一个例外是 Host 标头，它必须出现在 HTTP/1.1 中的每个请求中。标头可以按任何顺序发送，并且都遵循电子邮件消息中使用的相同标头格式：

```
<header-name>: <header-value>
```

<u>**消息正文内容**</u>
消息正文是可选的，因为只有某些类型的消息才需要它。正文可以携带一组要在客户端和服务器之间通信的信息，例如响应中的详细错误消息。更常见的是，当存在时，它携带文件或其他资源，在 HTTP 标准中正式称为实体。实体最常出现在响应消息的主体中，因为大多数客户端请求要求服务器发送文件或其他资源。但是，它们也可以在某些请求中找到。 HTTP 支持多种实体，并提供编码方法以支持广泛的媒体。特殊标头描述实体的特征（如果存在）。 HTTP 实体和相关问题在本指南各自的部分中有详细描述。

**关键概念：**所有 HTTP 消息都符合一种称为通用消息格式的结构。此格式基于 RFC 822 和 MIME 电子邮件消息标准，但 HTTP 并未严格遵循这些格式。每个 HTTP 消息都以起始行开头，然后包含多个消息标头，后跟一个空行和可选的消息正文。消息的主体可能包含资源，例如要在客户端和服务器之间通信的文件，称为实体。

<u>**分块和消息尾部**</u>
HTTP/1.1 默认使用持久连接，因此消息以稳定的流从客户端发送到服务器，再从服务器发送到客户端。这需要使用某种方法来标记一条消息的结束位置和下一条消息的开始位置，这通常通过以下两种方式之一来完成。第一种是使用指示消息长度的特殊标头，以便接收设备知道何时收到了整个消息。第二种是称为“分块”的方法，其中将消息分成多个部分进行传输，每个部分的长度在消息正文中指示。

分块完成后，一组消息尾部可能会跟在消息正文之后。尾部实际上与标题相同，只是它们在文件中的位置不同，但只能用于实体标题。有关所有这些问题的更多详细信息，请参阅有关数据长度问题、“分块”传输和尾部的主题。



###### 4.2.5.2.3-2 HTTP 请求消息格式（部分：1 2 3）

客户端通过打开到它希望与之通信的 HTTP 服务器的 TCP 连接来启动 HTTP 会话。然后它向服务器发送请求消息，每个请求消息指定 HTTP 客户端的用户希望服务器执行的特定类型的操作。请求可以通过特定的用户操作（例如单击 Web 浏览器中的超链接）或作为先前操作的结果间接生成（例如对 HTML 文档中的内联图像的引用导致对该图像的请求）。 )

HTTP 请求使用的消息格式基于上一主题中描述的通用消息格式，但特定于请求的需要。这种格式的结构如下（见图317）：

```
<request-line>
<general-headers>
<request-headers>
<entity-headers>
<empty-line>
[<message-body>]
[<message-trailers>]
```

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\httprequest.png)

​                                                                    **图 317：HTTP 请求报文格式**

此图显示了 HTTP 请求的结构元素以及请求可能包含的各种标头的示例。与大多数 HTTP 请求一样，此请求不携带任何实体，因此没有实体标头且消息正文为空。 HTTP 响应格式见图 318。

<u>**请求行**</u>

开始所有 HTTP 消息的通用起始行在请求消息中称为请求行。它有三个目的：指示客户想要执行的命令或动作；指定应采取行动的资源；并向服务器指示客户端正在使用的 HTTP 版本。请求行的正式语法是：

```
<METHOD> <request-uri> <HTTP-VERSION>
```

<u>**方法**</u>
方法只是客户端希望服务器执行的操作类型；它总是以大写字母指定。 HTTP/1.1 中定义了八个标准方法，其中三个被广泛使用：GET、HEAD 和 POST。它们被称为“方法”而不是“命令”，因为 HTTP 标准使用面向对象编程的术语。我在描述 HTTP 方法的主题中解释了这一点并描述了方法本身。

<u>**Request URI**</u>
请求 URI 是请求适用的资源的统一资源标识符。虽然 URI 理论上可以引用统一资源定位符 (URL) 或统一资源名称 (URN)，但目前 URI 几乎总是遵循 Web URL 标准语法规则的 HTTP URL。

有趣的是，HTTP 请求行中使用的 URL 的确切形式通常与 HTML 文档中使用的或用户输入的不同。这是因为完整 URL 中的某些信息用于控制 HTTP 本身。它需要作为用户和 HTTP 客户端之间通信的一部分，而不是在从客户端到服务器的请求中。在请求中指定资源的标准方法是在请求行中包含路径和文件名（以及任何可选的查询信息），同时在 HTTP/1.1 请求中必须使用的特殊 Host 标头中指定主机。

例如，假设用户输入如下 URL：

```
http://www.myfavoritewebsite.com:8080/chatware/chatroom.php
```

我们显然不需要将“http:”发送到服务器。客户端将获取剩余信息并将其拆分，因此 URI 被指定为“/chatware/chatroom.php”，主机行将包含“www.myfavoritewebsite.com:8080”。因此，请求的开头将如下所示：

```
GET /chatware/chatroom.php HTTP/1.1
Host: www.myfavoritewebsite.com:8080
```

此规则的例外情况是向代理服务器发出请求时。在这种情况下，请求是使用其原始形式的完整 URL 发出的，因此代理可以像原始客户端一样处理它。请求将是：

```
GET http://www.myfavoritewebsite.com:8080/chatware/chatroom.php HTTP/1.1
```

最后，还有一种特殊情况，可以使用单个星号代替真实的 URL。这是针对 OPTIONS 方法的，它不需要指定资源。 （名义上，星号表示该方法指的是服务器本身。）

<u>**HTTP Version**</u>
HTTP-VERSION 元素告诉服务器客户端使用的版本，以便服务器知道如何解释请求，以及在其响应中发送和不发送客户端的内容。例如，从使用 0.9 或 1.0 版本的客户端接收请求的服务器将假定正在使用临时连接而不是持久连接，并且将避免在其回复中使用 1.1 版标头。版本令牌以大写字母“HTTP/0.9”、“HTTP/1.0”或“HTTP/1.1”发送——这正是我在整个协议讨论中一直采用的方式。

<u>**标头**</u>

在请求行之后是客户端想要包含在消息中的任何标头；正是在这些标头中，向服务器提供了有关请求的详细信息。标头都使用相同的结构，但根据它们所服务的功能以及它们是否特定于一种消息而被组织成类别：

- 通用标头：通用标头主要是指消息本身，而不是其内容，用于控制其处理或为收件人提供额外信息。它们并不特定于请求或响应消息，因此它们可以出现在任何一个中。它们同样与消息可能携带的任何实体都没有特别相关。

- 请求标头：这些标头向服务器传达有关客户端请求性质的更多详细信息，并让客户端更好地控制请求的处理方式。例如，客户端可以使用特殊的请求标头来指定条件请求——只有在满足特定条件时才会填充的请求。其他人可以在响应消息中告诉服务器客户端能够处理哪些格式或编码。

- 实体标头：这些标头描述了请求正文中包含的实体（如果有）。

请求标头显然只用于请求消息中，但通用标头和实体标头都可以出现在请求或响应消息中。由于有如此多的标头，而且大多数都不是特定于一种消息类型，因此在它们自己的完整部分中对它们进行了详细描述。

**关键概念**：HTTP 请求是 HTTP 客户端请求服务器执行特定类型操作的方式，例如发送文件或处理用户输入。每个请求消息都以请求行开头，其中包含三个关键信息：客户端请求的方法（操作类型）；客户端希望在其上执行操作的资源的 URI，以及客户端正在使用的 HTTP 版本。请求行之后是一组与请求相关的消息标头，后跟一个空行，然后是请求的消息正文（可选）。



###### 4.2.5.2.3-3 HTTP 响应消息格式（部分：1 2 3）

上和下;东和西;黑与白;阴阳。反正你懂这个意思。 HTTP 客户端向服务器发送的每个请求消息都会提示服务器发回响应消息。实际上，在某些情况下，服务器实际上可能会发送两个响应，一个初步响应，然后是真正的响应。但通常情况下，一个请求产生一个响应，它表示服务器对请求的处理结果，并且通常还会在消息体中携带一个实体（文件或资源）。

与请求一样，响应使用它们自己的基于 HTTP 通用消息格式的特定消息格式。如图 318 所示，格式为：

```
<status-line>
<general-headers>
<response-headers>
<entity-headers>
<empty-line>
[<message-body>]
[<message-trailers>]
```

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\httpresponse.png)

​                                                                   **图 318：HTTP 响应消息格式**

此图说明了 HTTP 响应的构造，并包括消息标头和正文的示例。状态码“200”表示这是对请求的成功响应；它在消息正文中包含一个简短的文本 HTML 实体。 HTTP请求格式见图317。

<u>**状态行**</u>

注意，状态行——不是“响应行”，是用于响应消息的起始行。它有两个功能：告诉客户端服务器正在使用什么版本的协议，以及传达处理客户端请求的结果的摘要。状态行的正式语法是：

```
<HTTP-VERSION> <status-code> <reason-phrase>
```

<u>**版本**</u>
状态行中的 HTTP-VERSION 标签与其在请求消息的请求行中的作用相同；在这里，它告诉客户端服务器用于其响应的版本号。它使用与请求行中相同的格式，大写为“HTTP/0.9”、“HTTP/1.0”或“HTTP/1.1”。服务器需要返回一个不大于客户端在其请求中发送的版本号的 HTTP 版本号。

<u>**Status Code and Reason Phrase**</u>
状态代码和原因短语以两种不同的形式提供有关处理客户端请求的结果的信息。状态码是一个三位数字，表示服务器与客户端通信的正式结果；它旨在供客户端 HTTP 实现进行处理，以便软件可以采取适当的操作。原因短语是一个附加的描述性文本字符串，它可以显示给 HTTP 客户端的人类用户，以便他或她可以看到服务器如何响应。我将在本节后面描述状态代码和原因短语，并列出所有标准代码。

<u>**标头**</u>

响应消息将始终包含许多提供有关它的额外信息的标头。响应消息标头分为以下类别：

- 通用标头：通用标头，指的是消息本身，并不特定于响应消息或消息正文中的实体。这些与可以出现在请求消息中的通用标头相同（尽管某些标头更常出现在响应中，而其他标头在请求中更常见）。

- 响应标头：这些标头提供了额外的数据，这些数据扩展了状态行中的摘要结果信息。服务器还可以在消息正文中返回额外的结果信息，尤其是在发生错误时，如下所述。

- 实体标头：这些标头描述响应正文中包含的实体（如果有）。这些是可以出现在请求消息中的相同实体标头，但它们更常出现在响应消息中。原因很简单，响应比请求更经常携带实体，因为大多数请求都是为了检索资源。

**注意：**实体标头可能会出现在响应中，以描述作为请求主题的资源，即使实体本身未在消息中发送也是如此。当 HEAD 方法用于仅请求与实体关联的标头时，会发生这种情况。


响应头当然只用在响应消息中，而其他的就消息类型而言是通用的。有关更多详细信息，请参阅描述 HTTP 标头的部分。

大多数响应消息在消息正文中包含一个实体。在成功请求检索资源的情况下，这是资源本身。指示不成功请求的响应通常包含详细的错误信息，通常采用 HTML 格式的错误消息形式。

**关键概念：**客户端发送的每个 HTTP 请求都会导致服务器返回一个或多个 HTTP 响应。每个响应消息都以状态行开头，其中包含服务器的 HTTP 版本号、数字状态代码和文本原因短语，指示处理客户端请求的结果。该消息然后包含与响应相关的标头，后跟一个空行，然后是可选的消息正文。由于大多数 HTTP 请求要求服务器返回文件或其他资源，因此许多 HTTP 响应在消息正文中携带一个实体。



###### 4.2.5.2.3-4 HTTP 方法（部分：1 2 3 4）

客户端向服务器发送的请求显然……请求服务器做某事。所有客户端/服务器协议都为客户端提供了一种提示服务器采取行动的方式，通常是让客户端向服务器发出一系列命令。相比之下，HTTP 没有命令，只有方法。每个客户端请求消息都以作为请求主题的方法的规范开始。

方法和命令有什么区别？实际上，什么都没有；他们是一样的。那么为什么 HTTP 使用术语“方法”而不是“命令”呢？好问题。 J 答案可以在定义 HTTP/1.0 的标准摘要 RFC 1945 中找到。它部分地指出 HTTP 是：

​		“一个通用的、无状态的、面向对象的协议，可用于许多任务……”
用高度简化的术语来说，面向对象编程是一种技术，在这种技术中，软件模块不是被描述为过程集，而是被描述为具有属性的对象。这些模块相互发送消息进行通信，并促使执行操作，其中所采取的操作取决于对象的性质。在面向对象编程中，每个对象可以执行的过程称为方法。

HTTP 被认为是面向对象的，因为在许多情况下，服务器采取的操作取决于作为请求主题的对象。例如，如果您请求服务器检索文本文档，它会发送该文档，但如果您请求目录，服务器可能会返回该目录的默认文档。相反，指定程序名称的请求将导致程序被执行并返回其输出（与返回程序的源代码相反）。

<u>**常用方法**</u>

每种方法都允许客户端指定服务器要执行的特定类型的操作。方法名称始终使用大写字母。 HTTP中常用的方法有3种。

<u>**GET**</u>
GET 方法请求服务器检索由 HTTP 请求行上的 URL 指定的资源，并将其作为响应发送回客户端。这是最基本的请求类型，也是 HTTP 流量的主要来源。当您输入常规 URL 或单击文档或其他文件的链接时，通常会提示您的 Web 浏览器发送 GET 请求。

GET 请求的处理取决于许多因素。如果 URL 正确并且服务器可以找到资源，它当然会向客户端发回适当的响应。如上所述，返回的确切资源取决于所请求对象的性质。如果无法正确处理请求，可能会出现错误消息。缓存也开始发挥作用，因为代理服务器甚至客户端本身可能会在请求到达服务器之前满足请求。

重要的是要记住，如果使用某些标头（例如 If-Modified-Since 或 If-Match），GET 请求的含义可能会发生变化——这些标头和其他类似标头告诉服务器仅在满足某些条件时才发送资源。这种请求有时称为条件 GET。同样，客户端可以使用 Range 标头请求服务器只向其发送资源的一部分；这通常用于大文件。当包含此标头时，请求可称为部分 GET。

<u>**HEAD**</u>
这与 GET 方法相同，但告诉服务器不要发送消息的实际主体。因此，响应将包含所有响应等效 GET 消息的标头，包括实体标头，描述如果方法为 GET，服务器将发送的实体。客户端经常使用这种方法来检查文件的存在、状态或大小，然后再决定是否要服务器发送整个文件。

HEAD 请求的处理方式与 GET 请求相同，只是只返回标头，而不返回实际资源。

<u>**POST**</u>
此方法允许客户端将包含任意数据的实体发送到服务器进行处理。它通常用于使客户端能够向服务器上的程序提交诸如交互式 HTML 表单之类的信息，然后服务器根据该输入采取行动并发送响应。此功能现在用于各种在线程序。请求中的 URL 指定服务器上要接受数据的程序的名称。

将此与下面的 PUT 方法进行对比。

<u>**其他不太常见的方法**</u>

HTTP 标准定义的其他方法并不经常使用，但我将简要介绍它们，因为您可能仍会不时遇到它们。

***OPTIONS\***
允许客户端请求服务器向其发送有关可用通信选项的信息。可以指定资源的 URI 以请求与访问该资源相关的信息，或者可以使用星号（“*”）来指示查询是关于服务器本身的。响应包含标头，这些标头为客户端提供有关如何访问服务器的更多详细信息。

***PUT\***
请求服务器将包含在请求正文中的实体存储在请求行中指定的 URL 中。 PUT 和 POST 之间的区别在于，在 PUT 中，URI 标识请求中的实体，而在 POST 中，URI 标识旨在处理请求中的实体的程序。因此，PUT 将用于允许将文件复制到服务器，这与 GET 请求将文件复制到客户端的方式完全互补。如上所述，POST 用于交互式程序。

现在，您是否希望人们能够按照他们请求文件的方式将文件存储在您的服务器上？我也不会。这是不经常使用 PUT 的主要原因之一。它具有有效用途，例如将内容上传到网站，并且在这种情况下必须与身份验证一起使用。但是，一般来说，在站点上存储文件通常使用其他方式来完成，例如 FTP。

***DELETE\***
请求删除指定的资源。这与 PUT 有相同的问题，并且由于类似的原因不经常使用。

***TRACE\***
允许客户端接收回它自己发送给服务器的请求的副本，用于诊断目的。

注意：除了上述方法外，HTTP 标准还保留了方法名称 CONNECT 以供将来使用。 HTTP/1.1 的早期版本 RFC 2068 也定义了方法 PATCH、LINK 和 UNLINK。这些在最终版本中被删除，但有时仍会看到对它们的引用。

**关键概念**：每个 HTTP 客户端请求指定服务器执行的特定类型的操作；在 HTTP 中，这些被称为方法而不是命令。三种最常见的 HTTP 方法是 GET，提示服务器返回资源； HEAD，它只返回与资源关联的标头； PUT，它允许客户端将数据提交给服务器进行处理。



<u>**“安全”和幂等方法分类**</u>

正如我们在上面看到的，方法在它们导致服务器采取的行为类型方面差异很大。 HTTP 标准定义了两个特征，可用于根据它们对服务器的影响来区分方法：

- “安全”方法：服务器管理员可以放心地允许客户端发送这些方法，因为它们不太可能产生任何负面“副作用”。通常归入此类的方法有 GET、HEAD、OPTIONS 和 TRACE。导致数据被服务器接受以进行处理或导致服务器发生更改的方法被视为“不安全”：POST、PUT 和 DELETE。 （它们“不安全”的事实并不意味着服务器永远不允许它们，只是它们在处理时需要比其他服务器更加小心和详细。）

- 幂等方法：哇，10 美元单词时间。 J 如果多次重复相同的方法请求会导致与只发出该方法一次完全相同的结果，则称该方法是幂等的。例如，如果您在浏览器中加载一个网页，然后再次输入相同的 URL，您会得到相同的结果，至少在大多数情况下是这样。一般来说，HTTP 中的所有方法都固有地具有此属性，除了一个：POST。

POST 方法不是幂等的，因为 POST 请求的每个实例都会导致接收服务器处理请求正文中的数据。两次或多次提交 POST 请求通常会导致不良结果。典型的例子是多次点击表单上的“提交”按钮，这可能会导致烦扰，例如在 Internet 论坛上出现重复消息，甚至在网上商店出现重复订单。

还有一些情况下，通常是幂等的方法可能不是。对简单文档的 GET 请求是幂等的，但对脚本的 GET 请求可以更改服务器上的文件，因此不是幂等的。类似地，一系列幂等方法可以是非幂等的。例如，考虑 PUT 请求后跟同一资源的 GET 请求的情况。此序列是非幂等的，因为第二个请求取决于第一个请求的结果。

非幂等性的意义在于客户端必须专门处理这样的请求或序列。客户必须跟踪它们，并确保它们按顺序填写并且只填写一次。 HTTP 标准还规定非幂等方法不应流水线化，以避免在 HTTP 会话意外终止时出现问题。例如，如果两个 POST 请求被流水线处理并且服务器在处理它们时挂断了，客户端将需要重新发出它们，但可能不知道有多少原始请求已被成功处理。

###### 4.2.5.2.3-5 HTTP 状态代码格式、状态代码和原因短语（部分：1 2 3 4）

HTTP 客户端发送的每个请求都会导致接收它的服务器返回一个（或多个）响应。正如我们在描述响应消息格式的主题中看到的，响应的第一行是状态行，其中包含处理请求的结果的摘要。此行的目的是快速传达请求是否成功以及原因。

HTTP 状态行包含数字状态代码和文本原因短语。这背后的想法直接取自早期的应用层协议，如 FTP、SMTP 和 NNTP。同时拥有数字和文本字符串的原因是计算机可以通过查看数字更容易地“理解”请求的结果，然后可以快速做出相应的响应。另一方面，人类发现数字神秘而文本描述更容易理解。 （关于 FTP 回复代码的主题更完整地讨论了除了描述性文本之外还使用数字回复代码的原因。）

<u>**状态码格式**</u>

HTTP 状态代码的长度为三位数字，并遵循特定格式，其中第一位数字具有特殊意义。 与 FTP 等不同，第二位数字不代表功能分组； 第二个和第三个数字加在一起只是为第一个数字指示的每个类别提供了 100 个不同的选项。 因此，HTTP 状态代码的一般形式是“xyy”，其中第一个数字“x”在表 274 中指定。


​                                                                      **表 274：HTTP 状态码格式：首位解释**

| **Status Code Format** | **Meaning**               | **Description**                                              |
| ---------------------- | ------------------------- | ------------------------------------------------------------ |
| **1yy**                | **Informational Message** | 提供一般信息；不表示请求的成功或失败。                       |
| **2yy**                | **Success**               | 该方法已被服务器接收、理解和接受。                           |
| **3yy**                | **Redirection**           | 该请求并未完全失败，但在成功完成之前需要执行其他操作。       |
| **4yy**                | **Client Error**          | 该请求无效，包含错误的语法或由于服务器认为是客户端错误的某些其他原因而无法完成。 |
| **5yy**                | **Server Error**          | 请求有效，但服务器由于自身问题无法完成请求。                 |

在这五个组中的每个组中，“yy”为“00”的代码被定义为该组的“通用”状态代码，而其他两位数组合是更具体的响应。例如，“404”是众所周知的特定错误消息，表示请求的资源未被服务器找到，而“400”是不太具体的“错误请求”错误。该系统的设置是为了允许定义某些客户可能无法理解的新状态代码。如果客户端收到一个奇怪的代码，它只会将其视为等同于适当类别中的通用响应。因此，如果服务器响应以代码“491”开头，而客户端不知道这是什么，它只会将其视为 400“错误请求”回复。

<u>***Reason Phrases\***</u>
原因短语是一个文本字符串，它为那些不记得密码代表什么的人（我们大多数人都是！）提供更有意义的错误描述。HTTP 标准包括每个状态代码的“样本”原因短语, 但如果需要，这些可以由服务器管理员自定义。当服务器在其响应消息正文中返回更详细的 HTML 错误消息时，原因短语通常用于该消息正文中的“标题”标签。

**关键概念：**每个 HTTP 响应都包括一个数字状态代码和一个文本原因短语，两者都指示相应客户端请求的处理。数字代码允许软件程序轻松解释请求的结果，而文本短语则为人类用户提供更有用的信息。 HTTP 状态代码的长度为三位数字，第一位数字表示回复的一般类别。

<u>**状态代码和Reason Phrases**</u>

表 275 按数字顺序列出了 HTTP/1.1 标准定义的状态代码，以及“标准”原因短语和每个的简短描述：


​                                                                               **表 275：HTTP 状态代码**

| **Status Code** | **Reason Phrase**               | **Description**                                              |
| --------------- | ------------------------------- | ------------------------------------------------------------ |
| **100**         | Continue                        | 客户端应继续发送其请求。这是一个特殊的状态码；详情见下文。   |
| **101**         | Switching Protocols             | 客户端已使用 Upgrade 标头请求使用替代协议，并且服务器已同意。 |
| **200**         | OK                              | 通用成功请求消息响应。这是正常填充请求时最常发送的代码。     |
| **201**         | Created                         | 请求成功并导致创建资源。这将是对 PUT 方法的典型响应。        |
| **202**         | Accepted                        | 该请求已被服务器接受但尚未处理。这是一个故意“不承诺”的回应，不告诉客户请求是否会被执行；客户端以某种未指定的方式确定请求的最终处理。它仅在特殊情况下使用。 |
| **203**         | Non-Authoritative Information   | 请求成功，但服务器返回的部分信息不是来自与资源关联的原始服务器，而是来自第三方。 |
| **204**         | No Content                      | 请求成功，但服务端已经确定不需要向客户端返回实体体。         |
| **205**         | Reset Content                   | 请求成功；服务器告诉客户端它应该重置生成请求的文档，这样就不会发送重复的请求。此代码旨在与表单一起使用。 |
| **206**         | Partial Content                 | 服务器已成功完成部分 GET 请求。有关这方面的更多详细信息以及 Range 标头的描述，请参阅有关方法的主题。 |
| **300**         | Multiple Choices                | 资源在服务器上以不止一种方式表示。服务器正在返回描述这些表示的信息，因此客户端可以选择最合适的一个，这个过程称为代理驱动协商。 |
| **301**         | Moved Permanently               | 请求的资源已永久移至新 URL。以后对此资源的任何请求都应使用新的 URL。这是处理服务器上的文件被重命名或移动到新目录的情况的正确方法。大多数人都懒得设置它，这就是为什么 URL 经常“中断”，导致 404 错误，如下所述。 |
| **302**         | Found                           | 请求的资源暂时使用不同的 URL。客户端应该继续使用原来的 URL。参见代码 307。 |
| **303**         | See Other                       | 可以在服务器指定的不同 URL 中找到请求的响应。客户端必须对该 URL 执行新的 GET 操作才能查看先前请求的结果。 |
| **304**         | Not Modified                    | 客户端发送了条件 GET 请求，但资源自指定日期/时间以来未被修改，因此服务器未发送它。 |
| **305**         | Use Proxy                       | 要访问请求的资源，客户端必须使用代理，其 URL 由服务器在其响应中给出。 |
| **306**         | (unused)                        | 在 HTTP 的早期（草稿？）版本中定义并且不再使用。             |
| **307**         | Temporary Redirect              | 该资源暂时位于与客户端指定的不同的 URL。注意302和307基本上是同一个状态码。创建 307 是为了消除与 302 相关的一些混乱，这些混乱发生在早期版本的 HTTP 中（我不想深入探讨！） |
| **400**         | Bad Request                     | 服务器说，“嗯？” J 由于客户端出现问题而无法理解或执行请求时的一般响应。 |
| **401**         | Unauthorized                    | 客户端无权访问该资源。如果在没有适当凭据的情况下尝试访问受密码或其他方式保护的资源，通常会返回。 |
| **402**         | Payment Required                | 这是为将来使用保留的。它仅仅出现在 HTTP 标准中就让很多人摸不着头脑说“嗯……”J |
| **403**         | Forbidden                       | 该请求已被服务器拒绝。这是与授权无关的通用“没办法”响应。例如，如果网站维护者阻止特定客户端访问它，则来自该客户端的任何请求都将导致 403 回复。 |
| **404**         | Not Found                       | 最常见的 HTTP 错误消息，当服务器无法找到所请求的资源时返回。通常是由于服务器移动/删除了资源，或者客户端提供了无效的 URL（拼写错误是最常见的原因）。 |
| **405**         | Method Not Allowed              | 指定资源不允许使用请求的方法。响应包含一个 Allow 标头，指示服务器将允许哪些方法。 |
| **406**         | Not Acceptable                  | 客户端发送了一个请求，该请求指定服务器无法满足指定资源的限制。如果将过于严格的条件列表放入请求中，致使服务器无法返回资源的任何部分，则可能会发生此错误。 |
| **407**         | Proxy Authentication Required   | 与 401 类似，但客户端必须首先向代理进行身份验证。            |
| **408**         | Request Timeout                 | 服务器期望客户端在特定时间范围内发送请求，但客户端没有发送。 |
| **409**         | Conflict                        | 由于与资源相关的某种冲突，无法满足请求。这通常发生在响应 PUT 方法时，例如，如果一个用户试图 PUT 另一个用户已打开以进行编辑的资源。 |
| **410**         | Gone                            | 该资源在不知道其新 URL 的服务器上不再可用。这是 404 代码的更具体版本，仅当服务器知道资源被有意删除时才使用。与 404 相比，它很少（如果有的话）出现。 |
| **411**         | Length Required                 | 该请求需要一个 Content-Length 标头字段，但未包括在内。       |
| **412**         | Precondition Failed             | 指示客户端在其请求中指定了前提条件，例如使用 If-Match 标头，该标头的计算结果为假值。这表明条件不满足，因此请求未被填充。客户端在特殊情况下使用它来确保它们不会意外收到错误的资源。 |
| **413**         | Request Entity Too Large        | 服务器拒绝完成请求，因为客户端请求的实体太大。               |
| **414**         | Request-URI Too Long            | 服务器拒绝完成请求，因为指定的 URL 长于服务器可以处理的长度。这种情况很少发生在格式正确的 URL 中，但如果客户端试图向服务器发送乱码，则可能会出现这种情况。 |
| **415**         | Unsupported Media Type          | 无法处理请求，因为它包含使用服务器不支持的媒体类型的实体。   |
| **416**         | Requested Range Not Satisfiable | 客户端包含一个 Range 标头，指定对资源无效的值范围。例如，请求一个 2,400 字节文件的第 3,000 到 4,000 个字节。 |
| **417**         | Expectation Failed              | 该请求包含服务器无法满足的 Expect 标头。                     |
| **500**         | Internal Server Error           | 一般错误消息，指示由于服务器问题而无法完成请求。             |
| **501**         | Not Implemented                 | 服务器不知道如何执行请求，因此无法满足请求。                 |
| **502**         | Bad Gateway                     | 服务器在充当网关或代理时，从它试图代表客户端访问的另一台服务器收到无效响应。 |
| **503**         | Service Unavailable             | 由于内部原因，服务器暂时无法完成请求。这通常在服务器过载或停机维护时返回。 |
| **504**         | Gateway Timeout                 | 服务器在充当网关或代理时，在等待它试图代表客户端访问的另一台服务器的响应时超时。 |
| **505**         | HTTP Version Not Supported      | 该请求使用了服务器无法理解的 HTTP 版本。                     |

<u>**100（继续）初步答复**</u>

呸。现在，让我们回到顶部，状态代码 100。通常情况下，客户端向服务器发送一个完整的请求，并等待对它的响应（同时可选择流水线化其他请求）。然而，在某些情况下，客户端可能希望在发送整个消息之前提前检查服务器是否愿意接受请求。这并不常见，因为大多数请求都非常小，不值得这么麻烦。但是，如果用户想要向在线程序提交大量数据，或者使用 PUT 来存储大文件，例如，首先检查服务器可能是一种有用的优化。

在这种情况下，客户端发送一个包含特殊标头“Expect: 100-continue”的请求。假设服务器支持该功能，它将处理请求的标头并立即发回“100 Continue”初步回复。这告诉客户端继续发送请求的其余部分。服务器随后对其进行处理并正常响应。如果服务器在一定时间后没有发送 100 响应，客户端通常只会发送请求的其余部分。

**注意：**在某些情况下，服务器即使不应该发送这些初步回复，所以客户端必须准备好处理它们（它们只是被丢弃，因为它们不包含任何信息）。



###### 4.2.5.2.4 HTTP 消息头

HTTP 通信通过相对简单的请求和响应消息交换进行。该协议仅支持少量方法（命令），这可能给人一种协议非常有限的印象。然而，外表可能具有欺骗性。 HTTP 中的许多功能实际上是以消息头的形式实现的，它在客户端和服务器之间传达重要的细节。

有些标头只能出现在 HTTP 请求中，有些只能出现在 HTTP 响应中，有些则可能出现在任一类型的消息中。由于它们非常重要，实际上有几十种，而且很多都适用于请求和响应，所以我决定在一个单独的部分中详细描述它们，而不是在描述消息格式的过程中尝试过多地总结它们

在本节中，我将对 HTTP 请求和响应消息中使用的众多标头中的每一个进行描述。本节包含四个主题，每个主题涵盖四种基本类型的 HTTP 标头中的一种：通用标头、请求标头、响应标头和实体标头。

**背景信息：**我假设您已经阅读了前面描述 HTTP 消息格式的部分。

**注意：**为了确定 Web 缓存如何处理 HTTP 消息，HTTP 标头被分类为端到端或逐跳标头。前者仅对消息的最终接收者有意义，而后者与连接客户端和服务器的设备链（例如代理）中的每个设备相关。为了避免不必要的复杂化，我没有使用这些类别对本节中的标题进行分类；有关更多信息，请参阅有关缓存的主题。在各个标头的描述中，我指出哪些标头是逐跳的；所有其他的都是端到端的。

###### 4.2.5.2.4-1 HTTP 通用标头（部分：1 2 3）

HTTP 通用标头之所以如此命名，是因为与其他三个类别不同，它们不特定于任何特定类型的消息或消息组件（请求、响应或消息实体）。通用标头主要用于传达有关消息本身的信息，而不是它所携带的内容。它们提供一般信息并控制消息的处理和处理方式。

尽管不特定于请求或回复，但一些通用标头大部分或全部用于一种或另一种类型的消息中。还有一些通用标头可以出现在请求或回复中，但两者的含义有所不同。

<u>**缓存控制**</u>
指定管理如何为 HTTP 请求或响应执行缓存的指令。这些指令影响请求/响应链中所有设备对请求或响应的处理，从 HTTP 客户端，通过任何存在的中介，到 HTTP 服务器（或者从服务器，通过中介，到客户端） .它们覆盖设备执行的任何默认缓存行为。有关该主题的完整说明，请参阅有关缓存的主题。

此标头中可以出现十几个单独的指令，其完整详细信息可以在 RFC 2616 中找到。即使这是一个通用标头，一些指令也只能出现在请求或响应中。有些还包括一个附加参数，例如秒数，用于控制它们的解释。表 276 简要总结了不同的 Cache-Control 选项及其使用方式。

请注意，在 Cache-Control 标头中只能出现一个指令，但在一条消息中可以出现多个此类标头。

​                                                                         **表 276：HTTP 缓存控制指令**

| **Cache-Control Directive** | **HTTP Message Type** | **Description**                                              |
| --------------------------- | --------------------- | ------------------------------------------------------------ |
| ***no-cache\***             | *Request or Response* | 如果存在，则强制缓存设备将对相同内容的任何后续请求转发到服务器以进行重新验证。也就是说，缓存必须与服务器核对以确保缓存的数据仍然有效。另请参阅 Pragma 标头描述，以了解完成相同事情的另一种方法。 |
| ***public\***               | *Response*            | 指示响应可以由任何缓存缓存，包括共享缓存（许多客户端使用的缓存）。有关共享缓存的更多详细信息，请参阅缓存主题。指定响应仅供特定用户使用，不应放入共享缓存中。 |
| ***private\***              | *Response*            | 指定响应仅供特定用户使用，不应放入共享缓存中。               |
| ***no-store\***             | *Request or Response* | 指定整个请求或响应不应存储在缓存中。这有时用于防止将敏感文档存储在未经授权的人可能能够访问它们的缓存中。然而，正如 HTTP 标准指出的那样，这实际上是一种非常基本的安全措施，不应该被高度信任（因为恶意缓存操作员可以简单地忽略该指令。） |
| ***max-age\***              | *Request or Response* | 在请求中，表示客户端愿意接受age不大于指定值的响应。在响应中，指示响应被视为“陈旧”之前的最长期限——这是使用 Expires 标头的替代方法，并优先于它。 |
| ***s-maxage\***             | *Response*            | 如果存在，该指令指定共享缓存接收响应的最长期限。专用缓存（仅服务于单个客户端的缓存）使用上面描述的 max-age 值。 |
| ***min-fresh\***            | *Request*             | 指定客户端想要的响应不仅在收到请求时不会过时，而且会在指定的秒数内保持“新鲜”。 |
| ***max-stale\***            | *Request*             | 如果不带参数发送，则表示客户端愿意接受过时的回复（已过期的回复）。如果包含数字参数，则它指示响应的陈旧程度（以秒为单位）。 |
| ***only-if-cached\***       | *Request*             | 仅在特殊情况下使用，该指令强制回复仅来自缓存；内容可能不是来自实际指定的 HTTP 服务器。 |
| ***must-revalidate\***      | *Response*            | 指示缓存在原始服务器变得陈旧后为给定响应重新验证其缓存条目。这用于防止某些类型的事务出现问题，如果将过时的缓存条目发送到客户端（可能是客户端使用 max-stale 指令的结果），可能会发生这些问题。 |
| ***proxy-revalidate\***     | *Response*            | 类似于 must-revalidate，但仅适用于为许多用户提供服务的代理。专用缓存（例如个人客户端计算机上的缓存）不受影响。 |
| ***no-transform\***         | *Request or Response* | 默认情况下，某些缓存会更改某些缓存条目的存储形式，以节省空间或提高性能。在这可能会导致问题的情况下，客户端或服务器可以使用此指令来请求不执行此转换。 |

<u>***Connection\***</u>

包含仅适用于此特定连接的说明，不得由代理保留并用于进一步的连接。此标头最常见的用法是与参数“close”一起使用，如下所示：

```
Connection: close
```

这会覆盖 HTTP/1.1 的默认持久连接行为，强制连接在服务器响应后终止。 Connection 是逐跳标头。

<u>***Date\***</u>
指示消息发出的日期和时间。这与 RFC 822 电子邮件格式中的日期标头相同。一个典型的例子是：

```
Date: Wed, 06 Aug 2003 16:43:50 GMT
```

***Pragma\***
用于使特定于实现的指令应用于请求/响应链中的所有设备。此标头的一个常见用途是通过在消息中包含“Pragma: no-cache”来抑制缓存。这与“Cache-Control: no-cache”标头具有相同的含义，并包含在 HTTP/1.1 中以向后兼容 HTTP/1.0（支持 Pragma 但不支持 Cache-Control）。

<u>**尾部**</u>
当使用“分块”传输时，某些标头可能会作为尾部放置在数据发送之后。在这种情况下，Trailer 标头包含在数据之前，并列出了该消息中实际上是尾部的标头的名称。这警告收件人在数据之后寻找他们。 Trailer 是逐跳标头。

***Transfer-Encoding\***
指示消息正文使用的编码，以确保它能够在设备之间正确传输。此标头最常与“分块”传输方法一起使用。请注意，此标头描述应用于整个消息的编码，因此与 Content-Encoding 实体标头不同，Content-Encoding 实体标头专门描述消息中携带的实体。有关完整讨论，请参阅内容和传输编码主题。此标头仅适用于单次传输，因此它是逐跳标头。

***Upgrade\***

允许客户端设备指定它支持的附加协议。如果服务器也支持客户端列出的协议之一，则服务器可能同意将连接“升级”到替代协议。它通过在对客户端的 101（“切换协议”）响应中包含升级标头来指示要升级到的协议。这是逐跳标头。

***Via\***
包含在中间设备中，用于向接收者指示在传送请求或响应时使用了哪些网关、代理和/或隧道。此标头允许轻松跟踪消息接管客户端和服务器之间可能复杂的设备链的路径。

***Warning\***
在需要提供有关消息状态的附加信息时使用。许多定义的警告标头类型都与缓存相关。一条消息中可能会出现多个警告标头，每个警告标头通常包括一个三位数字代码和一条纯文本消息——与 HTTP 响应状态代码中使用的基本格式相同。

表 277 简要列出了 RFC 2616 中定义的警告。


​                                                                           **Table 277: HTTP \*Warning\* Header Codes**

| **Warning Code** | **Warning Text**                 | **Description**                                              |
| ---------------- | -------------------------------- | ------------------------------------------------------------ |
| **110**          | Response is stale                | 当缓存提供的响应过时（即已经过了为其设置的过期时间）时必须包含在内。 |
| **111**          | Revalidation failed              | 缓存尝试重新验证缓存条目但未成功，因此它返回了其（陈旧的）缓存条目。 |
| **112**          | Disconnected operation           | 缓存与网络的其余部分断开连接。                               |
| **113**          | Heuristic expiration             | 如果缓存选择了超过 24 小时的新鲜度生命周期，并且响应的年龄也大于 24 小时，则包括在内。 |
| **199**          | Miscellaneous warning            | 其他非特定警告的全部代码。                                   |
| **214**          | Transformation applied           | 警告收件人中间缓存或代理应用了某种类型的转换以更改消息或消息正文的内容编码或媒体类型。 |
| **299**          | Miscellaneous persistent warning | 类似于代码 199，但表示持续警告。                             |

**关键概念：**HTTP 通用标头可以出现在 HTTP 请求或 HTTP 响应消息中。 它们用于传达有关消息本身的信息，而不是其内容。 通用标头用于指定消息的日期和时间、控制消息的缓存方式以及指示其传输编码方法等功能。



###### 4.2.5.2.4-2 HTTP 请求标头（部分：1 2 3 4）

正如您想象的那样，HTTP 请求标头仅在 HTTP 请求消息中使用，并在其中提供许多功能。首先，它们允许客户端向服务器提供有关其自身的信息。其次，它们提供了有关客户提出的请求的性质的更多详细信息。第三，它们允许客户端更好地控制其请求的处理方式以及服务器或中介如何（甚至是否）返回响应。

这是四种 HTTP 标头类别中最大的一种，包含十几种不同的类型。

<u>***Accept\***</u>
允许客户端告诉服务器它愿意在响应中接受哪些 Internet 媒体类型。标头可能会列出客户端知道如何处理的几种不同的 MIME 媒体类型和子类型。每个都可以预先加上一个“quality value”（“q”参数）来指示客户的偏好。如果未指定此标头，则服务器默认假定可以将任何媒体类型发送到客户端。有关如何使用此标头的更多信息，请参阅有关实体媒体类型和内容协商的主题。

<u>***Accept-Charset\***</u>
类似于 Accept，但指定客户端愿意在响应中接受的字符集，而不是媒体类型。同样，列出的字符集可以使用“q”值，如果省略标头，则客户端默认接受任何字符集。

<u>***Accept-Encoding\***</u>
类似于 Accept 和 Accept-Charset，但指定客户端愿意接受的内容编码。这通常用于控制服务器是否可以以压缩形式发送内容。 （请记住，内容编码与传输编码不同。）

**<u>Accept-Language</u>**
类似于前面的 Accept-type 标头，但提供了一个语言标记列表，指示客户端支持或期望服务器在其响应中使用的语言。

***Authorization\***

由客户端用来向服务器提供身份验证信息（称为“凭据”）以允许对客户端进行身份验证。这仅在服务器请求身份验证时才需要，通常是通过向客户端的初始请求发送 401（“未授权”）响应。此响应将包含 WWW-Authenticate 标头，为客户端提供有关如何通过服务器进行身份验证的详细信息。请参阅有关安全和隐私的主题。

***Expect\***
指示客户端期望服务器执行的某些类型的操作。通常服务器会接受指定的参数；如果不是，它将发回 417（“预期失败”）响应。该字段最常见的用途是控制服务器何时发送 100（“继续”）响应。客户端通过在其请求中包含“Expect: 100-continue”标头来表明它希望服务器发送此初步答复。 （有关详细信息，请参阅状态代码主题的末尾。）

***From\***
包含发出请求的人类用户的电子邮件地址。这是可选的，因为它很容易被欺骗，所以应该只用于提供信息，而不是用于任何类型的访问权限确定或身份验证。

***Host\***
将 Internet 主机指定为 DNS 域名，也可能包含端口号规范（通常，仅当使用 HTTP 默认端口 80 以外的端口时）。此标头用于允许多个域由特定 IP 主机上的同一 Web 服务器提供服务。它的区别在于它是唯一的强制标头——它必须出现在所有 HTTP/1.1 请求中。

***If-Match\***

通过指定与客户端希望访问的特定实体相对应的实体标记（或多个标记），使方法成为条件方法。这通常用在 GET 方法中，服务器仅在实体与此标头中指定的实体匹配时才响应该实体。否则，将发送 412（“前提条件失败”）回复。

***If-Modified-Since\***
通过告诉服务器仅当请求的实体自此标头中指定的时间以来已被修改时才返回请求的实体，从而使方法成为条件方法。否则，服务器发送 304（“未修改”）响应。这用于检查资源自上次访问以来是否已更改，以避免不必要的传输。

***If-None-Match\***
这与 If-Match 相反；它创建一个条件请求，只有在指定的标签与请求的实体不匹配时才会填充该请求。

***If-Range\***
此标头与 Range 标头结合使用，以有效地允许客户端检查实体是否已更改并请求在单个请求中发送实体的一部分。 （另一种方法是先发出条件请求，如果失败则需要第二次请求。）如果存在，If-Range 告诉服务器向客户端发送 Range 标头中指示的实体部分，如果实体没有改变。如果实体已更改，则发送整个实体作为响应。

***If-Unmodified-Since\***
If-Modified-Since 标头的逻辑相反；仅当资源自指定时间以来未被修改时才填充请求；否则发送 412 回复。

***Max-Forwards\***
指定请求可以转发到请求链中的下一个设备的次数限制。此标头仅与 TRACE 或 OPTIONS 方法一起使用，以允许诊断转发失败或循环。当出现在其中一种方法中时，每次设备转发请求时，此标头中的数字都会减少。如果设备收到 Max-Forwards 值为 0 的请求，则它不得转发它，而是响应客户端。 （在某种程度上，这有点类似于 Time To Live 字段在 Internet 协议数据报格式中的使用方式。）

***Proxy-Authorization\***
这类似于 Authorization 标头，但用于向代理服务器而不是终端服务器提供凭据以进行身份验证。它是使用代理在包含 Proxy-Authenticate 标头的响应中发送的信息创建的。这是逐跳标头，仅发送给接收请求的第一个代理。如果需要使用多个代理进行身份验证，则可以将多个 Proxy-Authorization 标头放入一条消息中，每个代理依次“使用”其中一个标头。

***Range\***

通过指定要检索的实体中的字节范围，允许客户端请求服务器仅向其发送实体的一部分。如果请求的范围有效，服务器仅发送文件的指示部分，使用 206（“部分内容”）状态代码；如果无法填充请求的范围，则回复 416（“Requested Range Not Satisfiable”）。

***Referer [sic]\***
告诉服务器资源的 URL，从中获取当前请求的 URL。通常，当用户单击一个网页上的链接以加载另一个网页时，发送对单击链接的请求时，原始网页的地址将放入 Referer 行。这允许跟踪和记录服务器的访问方式。如果人类用户手动将 URI 输入 Web 浏览器，则此标头不会包含在请求中。由于此标头提供与网页使用方式相关的信息，因此它具有一定的隐私隐患。

这个词的正确拼写是“referrer”。多年前，它在 HTTP 标准的早期版本中被拼写错误，在这被注意到并更正之前，它被合并到如此多的软件中，以至于 IETF 选择不更正 HTTP/1.1 中的拼写。

***TE\***
向服务器提供有关客户端希望如何处理服务器发送的实体的传输编码的信息。如果定义了对标准 HTTP 传输编码的扩展，则客户端可以在此标头中表明其愿意接受它们。当数据“分块”完成时，客户端也可以使用标头“TE:trailers”来指示其处理将标头作为数据尾随数据发送的能力。这是逐跳报头，仅适用于直接连接。

***User-Agent\***
提供有关客户端软件的信息。这通常是 Web 浏览器或其他发送请求的程序的名称和版本号。它用于服务器访问统计日志记录，也可用于定制服务器如何响应不同客户端的需求。请注意，代理在转发请求时不会修改此字段；相反，他们使用 Via 标头。

**关键概念：**HTTP 请求标头仅在 HTTP 请求消息中使用。它们允许客户端向服务器提供有关其自身的信息，并提供有关请求的更多详细信息并控制请求的执行方式。

###### 4.2.5.2.4-3 HTTP 响应标头（部分：1 2）

请求标头的对应物，响应标头仅出现在服务器或中介发送的 HTTP 响应中。它们提供了额外的数据，这些数据扩展了每个服务器回复开始时状态行中显示的摘要信息。许多响应标头仅在响应接收到特定类型的请求时发送，甚至是某些请求中的特定标头。

为 HTTP/1.1 定义了九个响应标头。

***Accept-Ranges\***
使用 Range 请求标头告诉客户端服务器是否接受部分内容请求，如果接受，是什么类型。典型示例包括“Accept-Range: bytes”（如果服务器接受字节范围）或“Accept-Range: none”（如果不支持范围请求）。

请注意，此标头不同于其他“Accept-”标头，后者在 HTTP 请求中用于执行内容协商。

***Age\***
告诉客户端资源的大致缓存数值，由发送响应的设备计算得出。

***ETag\***
指定响应中包含的实体的实体标签。客户端可以在未来的请求中使用此值来唯一标识实体，使用 If-Match 请求标头或类似内容。

***Location\***
指示服务器指示客户端使用的新 URL 来代替客户端最初请求的 URL。当服务器使用 301、302 或 307 回复将客户端请求重定向到新位置时，通常会使用此标头。它还用于在对 PUT 请求的 201（“已创建”）响应中指示已创建资源的位置。

请注意，这与 Content-Location 实体标头不同，Content-Location 实体标头用于指示最初请求的资源的位置。

***Proxy-Authenticate\***

这是 WWW-Authenticate 标头的代理版本（见下文）。它包含在 407（“需要代理身份验证”）响应中，以指示代理如何要求客户端执行身份验证。标头指定身份验证方法以及身份验证所需的任何其他参数。客户端将使用它来生成包含 Proxy-Authorization 标头的新请求。这是逐跳标头。

***Retry-After\***
这个标头有时会包含在不成功的请求中——例如那些导致 503（“服务不可用”）响应的请求——以告诉客户端何时应该再次尝试其请求。它也可以与重定向响应（例如 301、302 或 307）一起使用，以指示客户端在发送对重定向 URL 的请求之前应等待多长时间。 Retry-After 标头可以指定等待的时间间隔（以秒为单位）或服务器建议客户端重试时的完整日期/时间。

***Server\***
这是 User-Agent 请求标头的服务器版本；它标识生成响应的服务器软件的类型和版本。请注意，代理在转发响应时不会修改此字段；他们将自己的身份信息放入 Via 标头中。

***Vary\***
指定哪些请求标头字段完全确定是否允许缓存使用此响应来回复对同一资源的后续请求而无需重新验证。缓存设备检查 Vary 标头以确定它需要检查哪些其他标头，以确定它是否可以响应缓存的条目，当客户端在此答复中发出下一个资源请求时。是的，这个有点令人困惑。

***WWW-Authenticate\***
此标头包含在 401（“未授权”）响应中，以指示服务器希望客户端如何进行身份验证。标头指定身份验证方法以及身份验证所需的任何其他参数。客户端将使用它来生成包含 Authorization 标头的新请求。

**关键概念：**HTTP 响应标头出现在 HTTP 响应消息中，它们提供有关 HTTP 服务器功能和要求以及处理客户端请求的结果的附加信息。



###### 4.2.5.2.4-4 HTTP 实体标头（部分：1 2 3）

最后但同样重要的是，我们来到第四组 HTTP 标头：实体标头。这些标头提供有关 HTTP 消息正文中携带的资源的信息，在 HTTP 标准中称为实体。它们的总体目的是向消息的接收者传达正确处理和显示实体所需的信息，例如它的类型和编码方法。

最常见的实体类型是客户端请求的文件或其他信息集，因此，实体标头最常出现在 HTTP 响应中。但是，它们也可以出现在 HTTP 请求中，尤其是那些使用 PUT 和 POST 方法的请求，这些方法将数据从客户端传输到服务器。

任何携带实体的 HTTP 消息中至少应出现一个实体标头。但是，它们也可能出现在某些没有实际实体的响应中。最值得注意的是，对 HEAD 请求的响应将包含与请求中指定的资源关联的所有实体标头；如果在同一资源上使用 GET 方法而不是 HEAD，这些是实体中包含的相同标头。实体标头也可能出现在某些错误响应中，以提供信息以帮助客户端成功进行后续请求。

**注意：**许多实体标头与某些 MIME 标头具有相同的名称，但它们通常以不同的方式使用。有关 HTTP 和 MIME 之间关系的完整讨论，请参阅有关 HTTP Internet 媒体类型的主题。


以下是 HTTP/1.1 中定义的实体头：

***Allow\***
列出特定资源支持的所有方法。可以在服务器响应中提供此标头，作为有关客户端将来可以在资源上使用什么方法的指南。当服务器对包含不受支持的方法的请求返回 405（“不允许的方法”）响应时，必须包含标头。

***Content-Encoding\***

描述可能已用于对实体进行编码的任何可选方法。此标头最常用于传输已压缩的实体；它告诉接收者使用了什么算法以便可以解压缩实体。请注意，此标头仅描述对消息中的实体执行的转换； Transfer-Encoding 标头描述了对整个消息进行的编码。有关更多详细信息，请参阅有关内容编码和传输编码的主题。

***Content-Language\***
指定用于使用实体的自然（人类）语言。这是一个可选的标头，可能不适用于所有资源类型。如果需要，可以指定多种语言。

此标头旨在提供指导，以便将实体呈现给正确的受众；因此，应该根据谁最会使用材料来选择语言，这不一定包括实体中使用的所有语言。例如，对意大利歌剧的德语分析可能最好只用语言“de”标记。 （他们确实有对意大利歌剧的德语分析，不是吗？）

***Content-Length\***
指示实体的大小（以八位字节为单位）。此标头很重要，因为收件人使用它来确定消息的结尾。但是，它可能只包含在消息的长度可以在传输实体之前完全确定的情况下。对于动态生成的内容，这并不总是可行的，这会使消息长度的计算变得复杂；数据长度和“分块”传输编码的讨论包含了对这个问题的全面探讨。

***Content-Location\***
以绝对或相对统一资源定位器 (URL) 的形式指定实体的资源位置。这是一个可选的标头，通常仅在实体从与请求中指定的位置不同的位置提供的情况下包含。如果特定资源存储在多个位置，则可能会发生这种情况。

***Content-MD5\***
包含实体的 MD5 摘要，用于消息完整性检查。

***Content-Range\***
当消息包含的实体只是完整资源的一部分时发送；例如，为响应包含 Range 标头的 HTTP GET 请求而发送的文件片段。 Content-Range 标头指示此消息包含整个文件的哪一部分，以及资源的总大小。此信息以字节范围的形式给出，第一个字节编号为 0；例如，如果实体包含一个 2,000 字节文件的前 1,200 个字节，则此标头的值为“0-1199/2000”。

***Content-Type\***

指定实体的媒体类型和子类型，其方式与此标头在 MIME 中的使用方式非常相似。有关完整讨论，请参阅描述 HTTP 实体和 Internet 媒体类型的主题。

***Expires\***
指定一个日期和时间，在该日期和时间之后消息中的实体应被视为“陈旧”。这可用于识别某些实体，这些实体应在 HTTP 缓存中保留比平时更长或更短的时间。

如果消息中存在包含“max-age”指令的 Cache-Control 标头，则忽略此标头。

***Last-Modified\***
指示服务器认为上次更改实体的日期和时间。此标头通常用于确定资源自上次检索以来是否已被修改。例如，假设一台客户机已经包含两个月前获得的一个非常大的文件的副本，并且其用户想要检查是否有对该文件的更新可用。客户端可以发送文件的 HEAD 请求，并将返回的 Last-Modified 标头的值与它已有的文件副本的日期进行比较。然后它只需要在文件发生变化时请求整个文件。

请注意在上面的描述中使用了“相信”这个词。这种措辞的原因是服务器不能总是确定资源被修改的时间。对于文件，这非常简单——通常是操作系统为文件存储的最后修改时间。然而，对于其他更复杂的资源，例如数据库记录或虚拟对象，可能更难确定特定信息的最后一次更改发生的时间。对于动态生成的内容，Last-Modified 日期/时间可能与整个消息的日期/时间相同，如 Date 字段中指定的那样。

**关键概念：**HTTP 实体标头出现在消息正文中携带实体的请求或响应消息中。它们描述实体的性质，包括其类型、语言和编码，以促进接收实体的设备正确处理和呈现实体。



###### 4.2.5.2.5 HTTP 实体、传输、编码方法和内容管理

HTTP 消息标头非常重要，因为它们是 HTTP 用来允许设备指定客户端请求和服务器响应的详细信息的机制。然而，这些标头只是达到目的的手段，目的是将文件、表单输入和程序输出等资源从一个设备传输到另一个设备。当资源承载在 HTTP 消息体中时，它被称为实体。 HTTP 为如何识别、编码和传输这些实体定义了特殊规则。

在本节中，我将详细了解 HTTP 如何处理实体。我首先从笼统的角度讨论实体，然后看看它们的内容是如何识别的；这包括检查 HTTP 和 MIME 之间的关系。我讨论了客户端和服务器之间实体传输背后的问题，以及内容编码和传输编码之间的区别。我描述了与识别 HTTP 消息中的实体长度相关的特殊问题，并详细介绍了特殊的“分块”传输编码和消息尾部。最后，我描述了设备执行内容协商的方法，以及质量值如何允许客户端智能地选择资源的不同变体。



###### 4.2.5.2.5-1 HTTP 实体和 Internet 媒体类型（部分：1 2 3）

“超文本传输协议”名称中“文本”一词的出现提醒人们注意 HTTP 的遗留问题。正如我在万维网简史中所解释的那样，它最初是为了让文本文档链接在一起而创建的。这是有道理的，因为在创建 Web 的时候，大多数计算仍然是通过文本完成的。因此，HTTP 的第一个版本 (HTTP/0.9) 只支持一种类型的消息体：纯 ASCII 文本文档。

在 20 世纪 90 年代初期，计算能力和网络性能的迅速提高将信息技术世界从文本转变为多媒体。这也是万维网形成的年代，没过多久，许多用户就想利用网络的力量来共享文本文件和图片、绘图、声音剪辑、电影等等。因此，HTTP 也必须发展；从 HTTP/1.0 开始，进行了重大更改以允许协议传输和处理的不仅仅是文本。今天，HTTP 确实被描述为处理超媒体而不是超文本更好，尽管协议的名称从未改变。

在 HTTP 中支持多种文件类型的缺点之一是增加了复杂性。以前每个消息接收者都知道正文包含 ASCII 文本，现在任何消息都可以包含多种数据中的任何一种。当 HTTP 被扩展以支持灵活的媒体时，它需要一个系统来解决两个具体问题：将各种类型的实体编码到 HTTP 消息体中，以及为消息的接收者清楚地识别实体的特征。

在 HTTP 被更改为支持非文本实体的同时，另一个重要的 TCP/IP 应用程序也从其长达数十年的文本消息传递媒体角色转变为可以传输多媒体的角色：电子邮件。这是使用一种称为多媒体 Internet 邮件扩展 (MIME) 的技术实现的，它定义了一种编码和识别非文本数据的机制——这正是 HTTP 需要做的。由于 TCP/IP 开发人员明智地重用有效的技术，因此 HTTP 的创建者从 MIME 中借用了许多概念，包括许多用于标识 MIME 消息内容的 MIME 电子邮件标头。

<u>**媒体类型和子类型**</u>

HTTP 从 MIME 中采用的最重要的概念是使用标准化的 Internet 媒体类型，它描述了 HTTP 实体的内容。每种媒体类型都包含一个定义其一般性质的顶级媒体类型，以及一个指示其形式或结构的更具体的子类型。在某些情况下，还可以提供附加参数以提供更多信息来帮助接收者解释实体。 HTTP 媒体类型的正式语法与 MIME 中使用的语法相同：

```
<type>/<subtype> [; parameter1 ; parameter2 … ; parameterN ]
```

要理解顶级媒体类型和子类型之间的区别，我们只需要举几个例子。文本文档使用通用类型“文本”；其中，存在子类型，例如用于常规无格式文本的“plain”和用于 HTML 文档的“html”。因此，通常使用 HTTP 传输的 HTML 文档类型将被识别为媒体类型“text/html”。同样，“image”是顶级媒体类型，还有“jpeg”、“gif”和“tiff”等子类型。照片通常使用“image/jpeg”，而线条图通常被视为“image/gif”。

<u>**HTTP 对媒体类型的使用**</u>
在 HTTP 中，媒体类型最常出现在特殊的 Content-Type 实体标头中，它存在于任何携带实体的 HTTP 消息中。此标头使用与 MIME 中同名标头相同的格式：

```
Content-Type: <type>/<subtype> [; parameter1 ; parameter2 … ; parameterN ]
```

HTTP 中使用媒体类型的另一个地方是 Accept 请求标头，它可能出现在客户端发送的 HTTP 请求中。如果存在，此标头的目的是告诉服务器客户端可以处理哪些类型的媒体类型，因此服务器不会发送无法处理的响应。例如，如果客户端只能处理文本文档，它可能会发送一个在 Accept 标头中指定这一点的请求。这是 HTTP 支持的整个内容协商过程的一部分。

当在 Accept 标头中指定媒体类型时，可以将子类型或类型和子类型都替换为“*”通配符以表示“任何可接受的”。例如，在 Accept 标头中，规范“text/html”指的是 HTML 文档，而“text/*”表示“任何文本类型”。字符串“*/*”表示任何类型的媒体；这通常与“q”值结合使用，如有关 HTTP 内容协商过程的主题中所述。

**相关信息：**我在 MIME 部分的媒体类型主题中提供了对 Content-Type 标头和 Internet 媒体类型的更完整描述，包括对许多类型和子类型的描述。 HTTP 还可以支持复合媒体类型，例如多部分媒体类型。

**关键概念：**虽然 HTTP 最常与超文本相关联，但其消息可以传输各种不同类型的文件，包括图像、音频、视频等等。要指示 HTTP 消息中包含的实体类型，其发送者必须标识其媒体类型和子类型。这是使用从多用途 Internet 邮件扩展 (MIME) 规范借用的 HTTP Content-Type 标头完成的。

<u>**HTTP 中使用的其他 MIME 结构**</u>

除了媒体类型之外，HTTP 还以其他几种方式借鉴了 MIME。这些包括内容编码的概念和使用标头来指示实体的长度。然而，重要的是要认识到，尽管 HTTP 对 Internet 媒体的处理与 MIME 非常相似，但它们并不完全相同。事实上，我的理解是，有一个早期的提议，即 HTTP 完全按照定义使用 MIME，但具体决定不这样做。我们将在下一个主题中探讨可能的原因。

然而，底线是 HTTP 的开发人员选择采用 MIME 中有意义的概念，而忽略了其他部分。因此，HTTP 消息不符合 MIME，即使您可能会在 HTTP 消息中看到多个以 MIME 的“Content-”前缀开头的标头。例如，尽管 HTTP 有一个 Content-Encoding 标头，但它的使用与 MIME 的使用有很大不同，我们将在下一个主题中再次看到。 HTTP 和 MIME 之间差异的确认可以在 HTTP 不使用 MIME 消息中所需的 MIME-Version 标头这一事实中找到。

**关键概念：**尽管 HTTP 从 MIME 借用了几个概念和标头类型，但该协议不符合 MIME。



###### 4.2.5.2.5-2 HTTP 数据传输、内容编码和传输编码（部分：1 2 3）

在上一个主题中，我提到了 HTTP 必须解决的两个具体问题，以便在其消息中携带多种媒体类型：对数据进行编码并识别其类型和特征。正如我们已经看到的，HTTP 从 MIME 借用了媒体类型的概念和 Content-Type 标头来处理类型识别。它同样借鉴了 MIME 的概念和标头来处理编码问题。然而，在这里，我们遇到了 HTTP 和 MIME 之间的一些重要区别。

编码对于 MIME 来说是一个重要问题，因为它是为使用旧的 RFC 822 电子邮件消息标准发送非文本数据的特定目的而创建的。 RFC 822 对其携带的消息施加了多项重要限制，其中最重要的是数据必须使用 7 位 ASCII 编码。 RFC 822 消息也被限制为不超过 1000 个以“CRLF”序列结尾的字符的行。

这些限制意味着无法使用 RFC 822 以其本机格式发送任意二进制文件，这些文件没有行的概念并且由字节组成，每个字节可以包含 0 到 255 之间的值。为了让 MIME 传输这些文件，它们必须使用诸如 base64 之类的方法进行编码，它将三个 8 位字符转换为一组可以用 ASCII 表示的四个 6 位字符。完成此类转换后，MIME Content-Transfer-Encoding 标头将包含在消息中，以便收件人可以反转编码以将数据返回到其正常格式。

现在，虽然这种技术有效，但它比直接以二进制形式发送数据效率低，因为 base64 编码将消息的大小增加了 33%（三个字节使用四个 ASCII 字符编码，每个字符需要一个字节来传输） . HTTP 消息通过 TCP 连接在客户端和服务器之间直接传输，不使用 RFC 822 标准。因此，二进制数据可以在 HTTP 客户端和服务器之间发送，而不需要 base64 编码或其他转换技术。由于发送未编码的数据效率更高，这可能是 HTTP 开发人员决定不使协议严格符合 MIME 的原因之一。

<u>**HTTP的二级编码方案**</u>

这似乎是 HTTP 比 MIME 更简单的一个领域——因为不需要对实体进行编码，所以不需要 Content-Transfer-Encoding 标头，我们就少了一件需要担心的事情。哈，不错的尝试！ J的确，HTTP 可以简单地设计为所有实体一次只发送一个字节，而无需指定编码。但该协议的开发人员认识到，这会使该协议变得不灵活。在某些情况下，转换或编码实体或消息以进行传输可能很有用，然后在收到时反转操作。

这种使 HTTP 变得灵活的努力导致了一个实际上比 MIME 更复杂的表示编码的系统。理解它的关键是要认识到 HTTP/1.1 实际上将 MIME 的“内容传输编码”概念拆分为两个不同的编码级别：

- **Content Encoding**：这是一种专门应用于 HTTP 消息中携带的实体的编码，用于在传输之前对其进行准备或打包。内容编码被称为“端到端”，因为实体的编码在客户端或服务器发送之前完成一次，并且只有在最终接收者（服务器或客户端）接收后才进行解码。完成这种类型的编码后，该方法将在特殊的 Content-Encoding 实体标头中标识。客户端还可以使用 Accept-Encoding 标头指定它可以处理的内容编码，正如我们将在内容协商主题中看到的那样。
- **Transfer Encoding**：这是一种专门用于确保数据可以在设备之间安全传输的编码。它应用于整个 HTTP 消息，而不是专门应用于实体。这种类型的编码是“逐跳”的，因为不同的传输编码可能用于通过请求/响应链中的许多中介传输的消息的每一跳。传输编码方法（如果有的话）在传输编码通用报头中指示。

<u>**在 HTTP 中使用内容和传输编码**</u>

由于两种编码应用于不同的级别，因此可以同时使用两者。内容编码可以应用于实体，然后放入消息中。在用于移动包含该实体的消息的一些或所有跳上，可以将传输编码应用于整个消息（当然包括该实体）。首先删除传输编码，然后删除内容编码。

好的，那么这些在实践中有什么用呢？没什么大不了的。 HTTP 标准定义了少量的内容和传输编码，并指定了可以向 IANA 注册的其他方法。然而，在我写这篇文章时，只有 HTTP/1.1 标准中定义的那些被使用。

内容编码目前仅用于实现压缩。这是一个很好的编码示例，虽然不是绝对必要的，但由于它可以显着提高某些类型的数据的性能，因此很有用。 RFC 2616 定义了三种不同的编码算法： gzip（UNIX gzip 程序使用的压缩，在 RFC 1952 中描述）； compress（再次代表同名 UNIX 程序使用的压缩方法）和 deflate（RFC 1950 和 1951 中定义的方法）。

注意：也可以将压缩应用于整个 HTTP 消息作为传输编码。显然，如果实体已经使用内容编码进行压缩，这将导致一些重复工作。由于 HTTP 标头的大小与 HTTP 消息携带的某些实体相比并没有那么大，因此使用内容编码压缩实体通常更简单。


由于传输编码旨在使数据传输安全，并且我们已经讨论了 HTTP 可以处理任意二进制数据这一事实，这表明传输编码并不是真正必要的。然而，事实证明，在一种情况下“安全传输”确实成为一个问题：识别消息结束的问题。这个问题是下一个主题的主题。

**关键概念**：HTTP 支持两级数据传输编码。第一个是内容编码，在某些情况下用于转换 HTTP 消息中携带的实体；第二种是传输编码，用于对整个 HTTP 消息进行编码以确保其安全传输。当压缩实体以提高通信效率时，通常会使用内容编码；传输编码主要用于处理识别消息结束的问题。



###### 4.2.5.2.5-3 HTTP 数据长度问题、“分块”传输和消息尾部（部分：1 2 3）

HTTP 中使用了两种不同级别的编码：应用于 HTTP 实体的内容编码和用于整个 HTTP 消息的传输编码。内容编码用于方便地打包实体以进行传输，其中传输编码是特定于hop-specific的，并且旨在用于需要使数据“安全”传输的情况。

但是，我们已经在前面的主题中看到 HTTP 可以传输任意二进制数据，因此与 MIME 必须使二进制数据对 RFC 822 “安全”的情况不同，这不是问题。因此，为什么根本需要传输编码？理论上它们不是，而且 HTTP/1.0 甚至没有 Transfer-Encoding 标头（尽管它确实使用了内容编码）。传输编码的概念在 HTTP/1.1 中变得很重要，因为该版本的 HTTP 的另一个关键特性：持久连接。

回想一下，HTTP 使用传输控制协议 (TCP) 进行连接。 TCP 的一个关键特征是它以非结构化字节流的形式传输所有数据。 TCP 本身不提供任何方式来区分一个数据的结束和下一个数据的开始；这留给每个应用程序。

在 HTTP/1.0（和 HTTP/0.9）中这不是问题，因为那些版本只使用临时连接。每个 HTTP 会话只包含一个请求和一个响应；由于客户端和服务器只各自发送一份数据，因此无需担心区分连接上的 HTTP 消息。 HTTP/1.1 的持久连接通过让设备通过单个 TCP 连接一个接一个地发送请求和响应来提高性能。然而，消息按顺序发送的事实使得区分它们成为一个问题。

<u>**使用内容长度标头**</u>
处理此类数据长度问题有两种常用方法：使用显式定界符来标记消息的结尾，或者包括长度标头或字段以告诉接收者每条消息的长度。在保持与旧版本协议的兼容性的同时，第一种方法并不能真正轻松地完成。这就剩下第二种方法了；由于 HTTP 已经有一个 Content-Length 实体标头，解决方案是使用它来指示传输时每条消息的长度。

这种方法在事先知道要传输的实体的大小的情况下效果很好，例如当需要传输文本文档、图像或可执行程序等静态文件时。但是，有许多类型的资源是动态生成的；此类资源的总大小在完全处理之前是未知的。虽然在 HTTP 的早期并不常见，但它们占了当今万维网流量的很大一部分。

许多网页通常不是静态的 HTML 文件，而是根据用户输入创建为脚本或程序的输出；论坛就是一个很好的例子。即使是今天的 HTML 文件通常也不是静态的。它们通常包含诸如服务器端包含 (SSI) 之类的程序元素，这些元素会导致动态生成代码，因此无法提前确定它们的确切大小。

<u>**使用“分块”传输**</u>

消息长度未知的问题可以通过在传输之前缓冲整个资源来解决。然而，这会浪费服务器内存并且会不必要地延迟实体的传输——在整个实体准备好之前不能发送任何部分。相反，开发了一种特殊的传输编码方法来处理这种“不安全”传输的特殊问题：不知道文件的长度。该方法称为分块。

使用此技术时，不是将实体作为原始字节序列发送，而是将其分解为块。 J这允许 HTTP 发送动态生成的资源，例如脚本的输出，当数据从处理它的软件中可用时，一次发送一个片段。为了表明已使用此方法，将特殊标头“Transfer-Encoding: chunked”放置在消息中。 HTTP 消息的主体也使用一种特殊格式来描述块：

```
<chunk-1-length>
<chunk-1-data>
<chunk-2-length>
<chunk-2-data>
...
0
<message-trailers>
```

基本上，不是将整个实体放在正文中并在 Content-Length 标头中指示其长度，而是将每个块按顺序放置在正文中，每个块前面都有块的长度。长度以十六进制指定，并使用 ASCII 字符表示。所有块长度和块数据都以“CRLF”序列结束。当接收方看到块长度为零时，它就知道它已经收到了最后一个块。

**关键概念：**由于 HTTP/1.1 使用持久连接，允许通过 TCP 连接发送多个请求和响应，因此客户端和服务器需要某种方式来识别一条消息的结束位置和下一条消息的开始位置。更简单的解决方案是使用 Content-Length 标头来指示消息的大小，但这只适用于可以轻松预先确定消息长度的情况。对于动态内容或在发送数据之前无法轻易计算消息长度的其他情况，可以使用特殊的分块传输编码，其中消息正文作为一系列分块发送，每个分块前面都有分块的长度。

***Message Trailers\***
当使用分块传输编码时，消息的发送者也可以选择指定一个或多个消息尾。这些与实体标头相同，描述消息正文的内容，但出现在实体之后而不是之前。它们以与分块本身相同的方式提供灵活性——它们允许设备包含一个 HTTP 标头，该标头可能包含 HTTP 消息传输开始时不可用的信息。一个很好的例子是根据整个实体的字节值计算的完整性检查字段。

Trailers是可选的，并不总是需要的。使用它们时，它们的处理方式与常规实体标头一样。为了让消息的接收者“注意”已使用尾部，应在消息的开头包含特殊的尾部标题，其中列出了显示为尾部的每个标题的名称。

<u>**使用内容长度标头和“分块”的示例**</u>

是的，我确实说过标题实际上可以是 *Trailer*，在这种情况下，名为 Trailer 的标题列出了每个实际上是预告片的标题。也许一个例子可以帮助澄清一些事情？假设我们有一个包含程序的服务器，当提供文件名时，该程序返回一个简单的 HTML 响应，其中包含文件的大小和最后修改日期。这显然是动态内容，因此无法预先确定响应的长度。

如果服务器要缓冲这个程序的整个输出（因为它很小），它可以使用 Content-Length 标头构造一个传统的 HTTP 响应，如表 278 的示例输出所示。相反，分块允许服务器发送一旦部分响应从程序中可用，就将其输出。该示例使用分块传输的等效输出如表 279 所示；请注意，Expires 标头现在是一个尾部，因此它可以根据程序的输出进行计算，这由“Trailer: Expires”标头指示。请记住，Content-Length 标头将长度指定为十进制数，而分块将块长度指定为十六进制；此示例中的块分别为 41、5、35、29 和 19 字节。

​                                                        **表 278：使用 Content-Length 标头的 HTTP 响应示例**

![image-20221122210535524](C:\Users\zy\AppData\Roaming\Typora\typora-user-images\image-20221122210535524.png)



**注意：**HTTP/1.1 客户端可以通过在其请求中包含“Connection: close”标头来指定它不想使用持久连接。 在这种情况下，服务器不必在其响应中使用分块——因为它会在第一个响应消息后关闭连接，客户端知道它从服务器接收到的所有内容都是该响应的一部分。 但是，某些服务器可能无论如何都使用分块传输，即使在这种情况下也是如此。

**关键概念：**当使用分块传输编码时，消息的发送方可以将某些标头从消息的开头移动到结尾，它们被称为尾部。 它们被接收者以与普通标头相同的方式解释。 此类消息中使用特殊的 Trailer 标头，告诉收件人在消息正文之后查找Trailer。



###### 4.2.5.2.5-4 HTTP 内容协商和“质量值”（部分：1 2 3）

许多 Internet 资源只有一种表示形式，即存储或提供它们的单一方式。在这种情况下，客户端对服务器的请求是一个“全有或全无”的命题。客户端可以使用“If-”系列请求标头指定它希望服务器发送资源的条件。如果满足条件，资源将以其存在的一种形式在服务器的响应中发送；如果不满足条件，则不会返回任何实体。

然而，其他资源可能有多种表示形式。最常见的例子是一个文档有多种语言版本，或者使用多个字符集存储。类似地，图形图像可能以两种不同的格式存在：一种是标记图像文件格式 (TIFF) 文件，适用于尽管 TIFF 图像尺寸较大但仍希望获得最佳图像质量的用户；以及更紧凑的 JPEG 文件，适合那些需要快速查看图像且不太关心其质量水平的人。

<u>**内容协商技术**</u>
为了使客户端能够灵活地获取以多种形式存在的最佳资源版本，HTTP/1.1 定义了一组统称为内容协商的特性。该标准定义了两种可以执行此协商的基本方法：

- 服务器驱动的协商：在这种技术中，客户端在其请求中包含标头，这些标头向服务器提供有关其所需资源表示的指导。服务器使用一种算法来处理此信息并提供它认为最符合客户端偏好的资源版本。

- 代理驱动的协商：这种方法让客户负责协商过程。它首先向服务器发送对资源的初步请求。如果资源以多种形式可用，服务器通常会发回 300（“多项选择”）响应，其中包含资源可用的各种表示形式的列表。客户端然后发送第二个请求，以获得它更喜欢的请求。

***Comparing Negotiation Methods\***

打个比方，假设一位同事提议在午餐时间出去为你们两个人去一家新开的餐厅，你们之前都没有吃过。你可以向他提供一些关于你喜欢吃什么的参数——“我喜欢烤牛肉三明治、炸鱼薯条和披萨，但不喜欢鸡肉”——然后相信他会挑选你喜欢的东西。或者，他可以去餐厅，用他的手机给你打电话，把菜单读给你听，让你做出选择。这首先类似于服务器驱动的协商；第二，像代理驱动的谈判。 

我认为这是一个很好的类比，不仅因为它（希望）可以帮助您了解两种方法之间的差异，而且还突出了每种方法的主要优缺点。信任您的同事来选择午餐既简单又高效，但并非万无一失。餐厅可能没有您指定的任何项目，或者您的朋友可能会给您提供含有另一种您不喜欢但您忘记提及的成分的东西。类似地，基于服务器的协商是一个“最佳猜测”过程，不保证客户端将以它想要的格式接收资源。客户端使用少数请求标头指定其首选项的方式只有这么多，这一事实加剧了这一点。

另一方面，基于代理的协商允许客户从可用的选项中准确地选择它想要的，就像你可以从餐厅的菜单中选择你最喜欢的菜一样。这里的问题是效率低下，因为每次资源访问都需要两次请求和响应。 （你真的想通过电话把餐厅的菜单读给别人听，这样他们就可以选择自己喜欢的菜吗？J）

**关键概念：**HTTP 包括一个称为内容协商的功能，它允许选择具有多个表示的资源的特定变体。有两种协商技术：服务器驱动，客户端在其请求中包含标头，表明它想要什么，服务器会尽力选择最合适的变体；和代理驱动，其中服务器向客户端发送可用资源备选列表，客户端选择一个。

<u>**HTTP 中基于服务器的协商**</u>
实际上，基于服务器的协商是当今最常用的类型。客户端使用一组四个请求标头指定其首选项，这些请求标头指示在资源表示中它更喜欢什么。每个标头代表资源的一个特征：Accept（媒体类型）； Accept-Charset（字符集）； Accept-Encoding（内容编码）；和接受语言（资源语言）。任何或所有这些都可以包含在请求中。

每个“Accept-”报头都包含一个可接受的值列表，这些值适合于它指定的特征，用逗号分隔。例如，Accept 标头列出了客户端认为可接受的媒体类型，而 Accept-Language 包含语言标签。假设你有一个精通英语、法语和西班牙语三种语言的朋友。她可以阅读任何这些语言的特定文档，因此她可能会指示她的浏览器在她的请求中包含以下标头：

```
Accept-Language: en, fr, sp
```

<u>***Weighting Preferences with "Quality Values"\***</u>

比简单的接受列表更好的是，HTTP 允许客户端对此类列表中的每个项目进行加权，以指示备选方案中哪个是首选。这是通过使用语法“q=<value>”在每个参数后添加一个十进制质量值来完成的，它表示该参数相对于其他参数的相对优先级。最高优先级为1，最低为0；如果没有指定值，则默认值为 1，而值为 0 表示客户端明确表示不愿意接受具有该特征的文档。

最好用一个例子来说明这一点，所以让我们再次以我们的会说三种语言的朋友为例。这一次，假设她懂英语、法语和西班牙语，但她的法语有点生疏（她有一段时间没用过）。此外，她可能需要与她的一个只懂一点西班牙语的朋友分享这份文件，所以她最好能拿到英文文件。最后，她知道有一个她绝对不想要的德语版本的资源。这可以表示如下：

```
Accept-Language: en, fr;q=0.3, sp;q=0.7, de;q=0
```

翻译成英文，这意味着“如果你用英文发给我文件，我更愿意。如果没有，西班牙语也可以，如果你只有法语，也可以，但绝对不要用德语发送”。

顺便说一句，“quality value”这个名称是在 HTTP 标准中使用的，但实际上是一个糟糕的术语选择（公平地说，标准中也提到了！）这些值与质量;据我们所知，该文档的德文版本可能是原版，而其他版本可能是糟糕的翻译。 “q”值仅指定发出请求的客户端的相对偏好。

最后，“*”通配符可用于 Accept 标头系列中以表示“任何值”或“其他所有值”。这通常用于告诉服务器“如果你找不到我特别要求的东西，那么这是我对替代品的偏好级别”。让我们举一个使用 Accept 标头的例子：

```
Accept: text/html, text/*;q=0.6, */*;q=0.1
```

此标头表示客户端说“我的偏好 (q=1) 是 HTML 文本文档。如果没有，我更喜欢其他类型的文本文档。如果做不到这一点，您可以向我发送与所请求资源相关的任何其他类型的文件。”

**关键概念：**服务器驱动的内容协商是 HTTP 中最常用的类型。发送请求的客户端最多可以包含四个不同的标头，这些标头提供有关服务器应如何填充其请求的信息。这些可能包括可选的*quality values*，这些值指定客户端在一组可选资源特性（如媒体类型、语言、字符集或编码）中的相对偏好。



###### 4.2.5.2.6 HTTP 特性、功能和问题

涵盖超文本传输协议的大节的前四个小节旨在让您很好地理解该协议的基本概念和基本操作。然而，现代 HTTP 超越了交换 HTTP 请求和响应的简单机制。它包括许多扩展基本协议以提高性能并满足使用现代 TCP/IP 互联网络的组织的各种需求的特性和功能。

在本节中，我将通过讨论现代万维网运行所必需的几个重要事项来完成对 HTTP 的描述。我首先概述 HTTP 缓存，它是提高 Web 事务效率的最重要的特性。我讨论了代理在 HTTP 中的不同用途以及与它们相关的一些问题。我简要检查了 HTTP 中与安全和隐私相关的问题，最后讨论了状态管理问题，以及尽管 HTTP 本质上是一种无状态协议，但它是如何实现的。

**背景信息：**本节假定您已经在这个关于 HTTP 的较大部分中介绍了前面的内容。如果您还不熟悉 HTTP 请求/回复链、HTTP 消息结构和 HTTP 标头等概念，您应该先查看这些材料。




###### 4.2.5.2.6.1 HTTP 缓存功能和问题（部分：1 2 3）

万维网的爆炸式增长对其用户来说是一个奇迹，但对网络工程师来说却是一场噩梦。蓬勃发展的网络造成的最大问题是其运行的互联网超载。许多添加到 HTTP/1.1 的功能都是专门为提高协议效率和减少 HTTP 请求和响应所消耗的不必要带宽而设计的。可以说，其中最重要的是一组旨在支持缓存的功能。

缓存的主题在计算机和网络的讨论中一次又一次地出现，因为在这些技术中广泛观察到的一个现象：每当用户、硬件设备或软件进程请求特定数据时，很有可能它会在不久的将来再次要求它。因此，通过将最近检索的项目存储在缓存中，我们可以消除重复的工作。这就是为什么缓存对 ARP 和 DNS 等协议的效率起着重要作用的原因。

<u>**缓存对 HTTP 的意义**</u>
缓存对 HTTP 很重要，因为 Web 用户往往会一遍又一遍地请求相同的文档。例如，在编写有关 HTTP 的这一部分时，我多次参考了 RFC 2616。每次，我都从特定的 Web 服务器加载它。由于文档永远不会更改，因此只从本地缓存加载它比每次都必须从远程 Web 服务器检索它效率更高。

然而，缓存对于 HTTP 比它所使用的大多数其他协议或技术更为重要。原因是 Web 文档往往是结构化的，因此对一种资源的请求会导致对许多其他资源的请求。即使我加载了许多不同的文档，它们也可能各自引用在用户请求之间不会改变的公共元素。因此，缓存在 HTTP 中可能是有益的，即使用户从未两次请求同一个文档，或者如果单个文档随时间发生变化以致缓存文档本身的价值很小。

例如，假设我每天早上都打开 CNN 的网站，看看世界上发生了什么。显然，每天的标题都会不同，因此 CCN.com 主 Web 主页的缓存不会有太大价值。然而，页面上的许多图形元素（CNN 的徽标、分隔条，也许是“突发新闻”图形）每天都是相同的，并且可以缓存这些元素。另一个例子是网站上的一组讨论论坛。当我加载不同的主题进行阅读时，每个主题都是不同的，但它们具有共同的元素（例如图标和其他图像），如果必须一遍又一遍地检索这些元素会很浪费。

在 HTTP 中缓存有两个主要好处。首先是通过消除不必要的请求和响应传输来减少带宽使用。其次，同样重要的是，用户加载资源的响应时间更快。想想今天在许多网页上，图像文件比引用它们的 HTML 页面大得多。缓存这些图形将使整个页面加载得更快。图 319 说明了缓存如何通过“短路”请求/响应链来减少带宽并加速资源检索。

​       ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\httpchaincache.png) 

​                                                   **图 319：缓存对 HTTP 请求/响应链的影响**

此图说明了缓存对图 316 的请求/响应链的影响。在此示例中，中介 #2 能够从其缓存中满足客户端的请求。这会在两次传输后“短路”通信链，这意味着客户端可以更快地获取其资源，并且 HTTP 服务器无需处理客户端的请求。


缓存的明显优势使其几乎从一开始就成为 Web 的一部分。然而，直到 HTTP/1.1 协议本身才真正认识到缓存的重要性，并添加了许多特性来支持它。 HTTP/1.0 标准顺便提到了缓存和一些与之相关的问题，而 HTTP/1.1 则用了整整 26 页的篇幅来介绍缓存（超过文档主体的 20%！）我显然不能进入那个级别详细信息，但我将以一般术语讨论 HTTP 缓存，让您对这个主题有一个感觉。

<u>**缓存位置的权衡**</u>

HTTP 缓存可以在请求/响应链中的多个位置实现。必须根据缓存中始终出现的基本权衡来选择缓存的位置：邻近性与普遍性。简而言之，缓存离信息请求者越近，从缓存中提取数据而不是从源中提取数据时节省的费用就越多。但是，缓存距离请求者越远（因此离源越近），可以从缓存中受益的设备数量就越多。让我们看看这在可以找到缓存的三类设备中是如何表现出来的。

<u>**Web 客户端缓存**</u>
大多数 Internet 用户熟悉的缓存是在本地客户端上找到的。它通常内置于 Web 浏览器软件中，因此称为 Web 浏览器缓存。此缓存存储特定用户最近访问的文档和文件，以便在该用户再次请求时可以快速使用它们。

由于缓存在用户自己的机器上，对缓存中包含的项目的请求会立即被填充，从而导致用户没有网络事务和“即时满足”。但是，该用户是唯一可以从缓存中受益的用户，因此有时将缓存称为私有缓存。

<u>**中介（代理）缓存**</u>
位于 Web 客户端和服务器之间的代理服务器等设备通常也配备有缓存。如果用户想要一个不在他或她的本地客户端缓存中的文档，中介可以提供它，如图 319 所示。这不如从本地缓存中检索有效，但比返回到网络服务器。然而，中介的优势在于所有使用它的设备都可以从其高速缓存中获益，这可以称为公共或共享。这可能很有用，因为组织的成员经常访问类似的文档。

例如，在开发用于 Apple 计算机的硬件产品的组织中，许多不同的人可能正在访问 Apple 网站上的文档。使用共享缓存，来自用户 A 的请求通常会导致缓存可以由用户 B 使用的项目。

<u>**Web 服务器缓存**</u>
Web 服务器本身也可以实现缓存。虽然让服务器维护自己文档的缓存看起来有点奇怪，但在某些情况下这可能是有益的。资源可能需要大量服务器资源才能创建；例如，考虑使用复杂的数据库查询生成的网页。如果许多客户端频繁检索此页面，那么定期创建它并缓存它而不是为每个请求即时生成它会带来很大的好处。

由于 Web 服务器离用户“最远”，这导致缓存命中的节省最少，因为客户端请求和服务器响应仍必须通过客户端和服务器之间的网络完整路径传输。然而，与客户端的这种距离也意味着服务器的所有用户都可以从中受益。

**关键概念：**提高 HTTP 运行效率的最重要的特性是缓存——将最近请求的资源存储在一个临时区域中。如果在短时间内再次需要相同的资源，则可以从缓存中检索它，而不需要向服务器发出新的请求，从而节省了时间和带宽。缓存可以由 Web 客户端、服务器和中介执行。缓存离用户越近，效率收益越大；离用户越远，可以从缓存中受益的用户数量就越多。

<u>**缓存控制**</u>
客户端和服务器中缓存的控制与大多数其他类型的控制在 HTTP 中实现的方式相同：通过使用特殊标头。其中最重要的是 Cache-Control 通用标头，它具有许多允许管理缓存操作的指令。还有其他重要的与缓存相关的标头，包括 Expires 和 Vary。有关 HTTP 缓存的更多更具体的信息，请参阅 RFC 2616 第 13 节。

<u>**重要的缓存问题**</u>

虽然缓存的性能优势使其成为“无需动脑筋的人”，但不可否认的是，缓存有一个明显的缺点：它以多种方式使 HTTP 的操作复杂化。下面是对 HTTP/1.1 客户端、服务器和中介需要处理的一些比较重要的问题的描述。只要是，这个列表就不是详尽无遗的，它让您了解 HTTP 中的缓存涉及什么（以及为什么标准需要 26 页来涵盖这个主题！）

<u>**缓存老化和“陈旧”**</u>
当用户直接从服务器上的原始来源检索文档时，他或她始终可以确保获得该资源的当前版本。使用缓存时，情况就不再如此。虽然许多资源很少更改，但几乎所有资源都会在某个时间点更改。以上面的 CNN 网站为例，CNN 徽标可能不会经常更改，但网站可能会定期重新设计，并以某种方式修改徽标，例如大小或颜色。

因此，设备无法无限期地将项目保留在 HTTP 缓存中。项目在缓存中保存的时间越长（称为老化的过程），服务器上的资源发生变化并且缓存变得“陈旧”的可能性就越大。使事情变得更加复杂的是，一些资源比其他资源更快地过时。因此，HTTP 的许多与缓存相关的功能都与处理缓存老化问题有关。

<u>**缓存过期和验证**</u>
HTTP 处理缓存老化问题的方法之一是通过标头和逻辑，允许缓存、客户端和服务器指定项目在过期和必须刷新之前应该缓存多长时间。还定义了一个验证过程，允许缓存在适当的时间检查服务器以查看它存储的项目是否已被修改。

<u>**向用户传达缓存状态**</u>
在大多数情况下，项目是从缓存而不是其源中检索的这一事实对用户来说是透明的（尽管他或她可能会注意到资源加载速度比预期的要快！）然而，在某些情况下，用户可能需要被告知资源来自缓存而不是其原始来源。当缓存项可能过时时尤其如此，在这种情况下，客户端应警告用户信息可能已过时。

<u>**标头缓存**</u>
HTTP 中的缓存很复杂，因为它可以出现在多个地方，而且一些 HTTP 标头的处理方式与其他标头不同。 HTTP 标头分为两大类：旨在伴随资源一直到其最终接收者的端到端标头，以及仅用于两个设备之间特定通信的逐跳标头（是他们是客户端、服务器或中间设备）。端到端标头必须与缓存资源一起存储，其中逐跳标头仅对特定传输有意义，不会被缓存。

<u>**资源更新的影响**</u>
一些 HTTP 方法会自动导致缓存条目失效，因为它们本质上会导致底层资源发生变化。例如，如果用户对先前使用 GET 检索到的资源执行 PUT，则该资源的任何缓存副本都应自动失效，以防止从缓存中提供旧版本。

<u>**隐私问题**</u>
在共享缓存的情况下（例如可能存在于代理中），需要关注潜在的隐私问题。虽然在大多数情况下让用户 A 的缓存资源对用户 B 可用是有利的，但我们必须注意不要缓存任何可能特定于用户 A 的项目，而用户 B 不应看到这些项目。



###### 4.2.5.2.6.2 HTTP 代理服务器和代理（部分：1 2 3）

在我对 HTTP 操作模型的概述中，我描述了 HTTP 是如何被设计成不仅支持客户端和服务器之间的通信，而且还包括可能位于它们之间的通信路径中的中介。最重要的中介类型之一是称为代理服务器的设备，或者更简单地说，就是代理。

代理是既充当客户端又充当服务器的“中间人”。它像服务器一样接受来自客户端的请求，然后将它们转发（可能修改）到真正的服务器，后者将代理视为客户端。服务器响应代理，代理将响应转发回客户端。代理可以是透明的，这意味着它们不修改请求和响应，也可以是非透明的，如果它们这样做是为了提供特定服务。

**注意：**术语“透明代理”也可用于指代自动插入客户端和服务器之间的代理（例如组织范围的防火墙），而不是用户手动配置的代理。

<u>**代理的好处**</u>
由于代理具有完全处理所有客户端请求和服务器响应的能力，因此它们在许多情况下都非常有用。它们可用于实现或增强许多重要功能。

<u>**安全**</u>
可以设置代理来检查传出请求和传入响应，以解决各种安全问题。例如，可以设置过滤以防止用户请求“令人反感”的内容，或者过滤掉有害的回复，例如包含隐藏病毒的文件。

<u>**缓存**</u>
正如我在上一个主题中提到的，设置在中介上实现的“共享缓存”可能是有利的，因此一个客户端请求的资源可以供另一个客户端使用。这可以在代理服务器内完成。

<u>**表现**</u>
在某些情况下，代理服务器的存在可以显着提高性能，特别是通过减少延迟。我自己的卫星互联网连接使用的代理服务器就是一个很好的例子。

由于从地球到卫星的距离，我的 PC 和 Internet 服务器之间的往返请求/响应周期需要 500 多毫秒。如果我加载一个包含图像的网页，我将不得不等待 500 多毫秒才能获得 HTML 页面，此时我的浏览器将不得不为每个图形元素生成新的请求，这意味着每个图形元素又会有 500 多毫秒的延迟。

相反，我的 ISP 有一个代理服务器，我向其发送网页请求。它查看这些页面的 HTML 并自动为我请求任何元素，例如图形。然后它直接将它们发送回我的机器，大大缩短了显示完整网页所需的时间。

**关键概念：**HTTP 中最重要的中间设备类型之一是代理服务器，它充当客户端和服务器之间的中间人，处理请求和响应。代理服务器可以不改变地传输消息，也可以修改它们以实现某些特性和功能。代理通常用于提高 Web 访问的安全性和/或性能

<u>**比较代理和缓存**</u>

代理和缓存是有许多相似之处的概念，尤其是在它们对基本 HTTP 操作的影响方面。与缓存一样，代理在最近几年变得越来越重要，并且在许多方面也使 HTTP 变得复杂。 HTTP/1.1 标准包括许多支持代理的特定功能，并且还解决了与代理相关的许多问题。

事实上，代理和缓存都代表了基本 HTTP 客户端/服务器通信发生变化的方式，再加上代理执行缓存的能力，有时会导致人们认为缓存和代理是相同的，但实际上并非如此。代理实际上是驻留在 HTTP 请求/响应链中的一个单独元素，其中可以在该链中的任何设备（包括代理）中实现缓存。

缓存和代理不同的另一个关键方式是缓存在启用时会“自动”使用，而代理则不会。要使用代理，必须告知客户端软件使用代理，并提供其 IP 地址或域名。然后客户端将所有请求发送到代理而不是用户指定的实际服务器。

**注意：**我在这里的大部分解释都集中在硬件代理服务器上，但代理通常也作为客户端设备中的软件实现。软件代理执行处理请求和响应的相同任务；它比硬件代理更便宜，但不能被许多设备共享。

<u>**重要的代理问题**</u>

正如我上面提到的，在 HTTP 中使用代理时会出现一些不同的问题。下面是一些比较重要的，以及 HTTP 如何处理它们。同样，有关代理的更多信息，请参阅您可信赖的 RFC 2616 副本。

<u>**能力不一致：**</u>
当客户端和服务器不使用相同版本的 HTTP 或不支持相同的功能时，就会出现问题；例如，某些服务器可能不支持客户端可能尝试使用的所有方法。当代理进入画面时，这变得更加复杂。特别值得关注的是客户端和服务器可能就代理不同意的特定功能达成一致的情况。代理必须确保它传递标头或它可能无法理解的其他元素。

<u>**认证问题**</u>
代理服务器的使用通常会引入新的身份验证或安全要求。除了向终端服务器进行身份验证外，代理还可以指定客户端也需要向其提供单独的身份验证凭据。这是使用 HTTP Proxy-Authorization 和 Proxy-Authenticate 标头完成的；有关详细信息，请参阅有关 HTTP 安全性的主题。

<u>**缓存交互**</u>
不仅缓存和代理都使 HTTP 复杂化，它们还会相互复杂化。当涉及到代理时，处理缓存的许多问题（例如标头缓存、过期和验证）会变得更加复杂。一些 Cache-Control 通用标头指令特定于代理。

另一个问题是同时使用代理和缓存会导致访问 Web 资源的表观次数失真。这在基于页面访问次数的广告支持网页的情况下很重要。有时在这种情况下，特殊代码被放置在称为“缓存破坏者”的 URL 中，用于强制页面不存储在共享缓存中。原来如此

<u>**编码**</u>
内容编码是端到端应用的，因此不应受到代理的影响。传输编码是逐跳完成的，因此代理可以使用不同的编码来处理单个请求或响应的不同传输。

<u>**跟踪代理处理**</u>
它在某些情况下很有用，特别是当请求/响应链中可能有多个代理时，能够跟踪哪些代理处理了特定消息。为此，HTTP/1.1 要求处理消息的每个代理在 Via 标头中标识自己。



###### 4.2.5.2.6.3 HTTP 安全和隐私（部分：1 2）

本指南中有许多不同的协议，我在其中解决了安全问题。通常，我首先会说一些大意是该协议在安全方面并没有包含太多内容，因为在它最初开发时，Internet 很小并且由一个紧密联系的群体使用，因此安全性并不重要一个大问题。今天，互联网遍及全球，被数以百万计的陌生人使用，这确实使安全成为一个大问题，等等等等。杰

嗯，在万维网的情况下，这是真的，但由于 HTTP 消息所携带内容的变化的重要性，这个问题甚至更加重要。 HTTP 已成为传输各种信息（包括大量个人数据）的工具。 HTTP 最初设计用于传输学术文件，例如关于研究项目的备忘录，但今天更可能传输某人的抵押贷款申请、信用卡详细信息或医疗详细信息。因此，HTTP 不仅具有防止未授权访问等常见的安全问题，还需要处理隐私问题。

<u>**HTTP 身份验证方法**</u>
主要的 HTTP/1.1 标准 RFC 2616 也没有广泛涉及安全问题。这些在配套文档 RFC 2617 中有详细说明，该文档解释了 HTTP 身份验证的两种方法。高度概括，它们是：

- 基本身份验证：这是一种传统的用户/密码类型的身份验证。当客户端向需要身份验证才能访问资源的服务器发送请求时，服务器会向客户端发送包含 WWW-Authenticate 标头的初始请求的响应。然后，客户端发送一个包含 Authorization 标头的新请求，该标头带有 base64 编码的用户名和密码组合。

- 摘要式身份验证：基本身份验证不被认为是强安全性，因为它“明文”发送凭据，这意味着它们可以被拦截。摘要式身份验证使用与基本身份验证相同的标头，但采用了更复杂的技术，包括加密，以防止恶意人员“窥探”凭据信息。摘要式身份验证不如公钥加密强，但比基本身份验证好很多。这也是一个更复杂的景象。 RFC 2617 中提供了有关其工作原理的完整详细信息。

<u>**安全和隐私问题**</u>

RFC 2616 和 2617 还解决了一些可能影响 HTTP 客户端和服务器的特定安全问题和威胁。其中包括欺骗、伪造服务器、重放攻击等行为。解决的一个问题是“中间人”攻击的可能性，攻击者会介入客户端和服务器之间。由于代理本质上是“中间人”，因此它们代表了该领域的安全问题。用于服务器的相同身份验证方法也可以应用于代理身份验证。使用 Proxy-Authenticate 和 Proxy-Authorization 标头代替 WWW-Authenticate 和 Authorization。

这些标准还讨论了一些隐私问题。一些值得注意的：

- 敏感信息的处理：HTTP协议可以承载任何类型的信息，它本身并不保护HTTP消息实体中数据的隐私。为确保敏感信息的隐私，必须使用其他技术（我们将在稍后讨论）。

- URL 中信息的隐私：HTTP 中有时会出现的一个问题是设计不当的网站可能会无意中将私人信息编码到 URL 中。这些 URL 可能会记录在 Web 日志中，在那里它们可能会落入可能滥用它们的人的手中。这方面的一个例子是一个网站，它通过将用户登录名和密码编码为 GET 请求的参数来向服务器提交用户登录名和密码，如下所示：

```
GET http://www.somesite.com/login?name=xxx&password=yyy”
```

- 应该使用 POST 方法代替这种功能，因为它在消息正文中传输数据，而不是将其放入 URL 中。
  Accept 标头中的私人信息：虽然乍一看这可能看起来很奇怪，但有可能通过使用某些用于内容协商的“Accept-”标头来传输有关用户的私人信息。例如，某些用户可能不希望其他人知道他们说的是什么语言，因此他们可能担心谁会查看 Accept-Language 标头。
- 从 Referer Header 获取的信息： Referer [sic] 请求头是一把双刃剑；它对网站运营商非常有用，因为它可以让他们看到指向其资源的链接来源。同时，它可能会被那些可能利用它来研究用户的 Web 访问模式的人滥用。 HTTP 标准还引发了潜在的隐私问题。例如，用户可能不希望引用公共网页的私有文档的名称在 Referer 标头中传输。

<u>**确保 HTTP 隐私的方法**</u>
如前所述，HTTP 不包含任何机制来保护传输的文档或消息的隐私。这通常有两种不同的方法来完成。最简单的方法是在服务器上加密资源并只向授权用户提供有效的解密密钥；即使截获了整个消息，实体本身仍然是安全的。这里的保护级别取决于加密的质量。

另一种更常见的方法是使用专门设计的“附加”协议来确保 HTTP 交易的隐私。今天经常使用的一种称为安全套接字层 (SSL)。服务器使用 SSL 来保护敏感资源，例如与金融交易相关的资源。在支持该协议的 Web 浏览器中使用 URL 方案“https”而不是“http”访问它们。 SSL 最初由 Netscape 开发，现在广泛用于万维网。



###### 4.2.5.2.6.4 使用“Cookies”的 HTTP 状态管理（部分：1 2 3）

尽管现代超文本传输协议具有很多功能和特性，但从本质上讲，它仍然是一个简单的请求/回复协议。由此导致的不幸问题之一是 HTTP 是完全无状态的。这意味着每次服务器收到来自客户端的请求时，它都会处理该请求，发送响应，然后忘记该请求。来自客户端的下一个请求被视为独立于任何先前的请求。

注意：HTTP/1.1 的持久连接特性并没有改变协议的无状态特性。即使可以在单个 TCP 连接上发送多个请求和响应，它们仍然不会以任何方式被视为相关。


那么为什么这是一个问题呢？这难道不是我们对旨在允许客户端快速有效地从服务器检索资源的协议的期望吗？嗯，这又是另一个地方，HTTP 的行为非常适合其最初的预期用途，但不适合当今 Web 的使用方式。当然，如果我们只想说“嘿服务器，请把那边的那个文件给我”，那么服务器就不必关心它之前是否已经为客户端提供了文件中的任何其他文件。过去的。这就是 HTTP 最初的用途。

今天，正如我们大多数人所知，Web 不仅仅是一个简单的资源检索协议。如果你去网上商店，你希望能够选择一些物品放入“购物车”，并让商店的服务器记住它们。您可能还想参加论坛，这需要您提供用户名和密码才能发布消息。理想情况下，服务器应该让您登录一次，然后记住您的身份，这样您就可以发布许多消息，而不必每次都输入您的登录信息。 （我使用过需要后者的论坛——它很快就会变老，相信我。）

<u>**Cookies：存储 HTTP 状态信息**</u>
对于这些和其他交互式应用程序，HTTP 的无状态特性是一个严重的问题。解决方案是添加一项称为状态管理的新技术，该技术允许跨一系列 HTTP 事务维护客户端与服务器的会话状态。最初由 Netscape 开发，此技术后来在 RFC 2109 中成为正式的 Internet 标准，后来在 RFC 2965（HTTP 状态管理机制）中进行了修订。请注意，此功能实际上不是 HTTP 的一部分；它是一个可选元素，但由于其实用性，几乎所有 Web 浏览器都已实现它。

状态管理背后的想法非常简单。当服务器实现需要跨一组事务维护状态的功能时，它会向 Web 客户端发送少量数据，称为“cookie”。 cookie 包含与特定 Web 应用程序相关的重要信息，例如客户姓名、购物车中的商品或用户名和密码。客户端将信息存储在 cookie 中，然后在对设置 cookie 的服务器的后续请求中使用它。服务器然后可以根据新请求中的信息更新 cookie，并将其发送回客户端。以这种方式，状态信息可以无限期地保持，让客户端和服务器有一个持续一段时间的“记忆”。

**注意：**“Cookie”可能看起来是一个奇怪的术语，但在一些上下文中用于指代一小部分重要数据——另一个例子是在 BOOTP/DHCP 消息格式中找到的。今天，如果你提到“HTTP 状态管理机制”，大多数知识渊博的 Web 用户都会对你眨眼，但他们通常知道什么是“cookies”。

<u>**Cookie 的问题**</u>

饼干听起来是个好主意，对吧？嗯，他们是——但他们不是。从积极的方面来说，cookie 对于使 Web 成为当今强大动力的许多应用程序来说绝对是必不可少的，在线购物和论坛只是其中的两个例子。大多数时候，cookie 用于这些有用且有益的目的。不幸的是，就像每一个好主意一样，有些人找到了一种通过滥用 cookie 的方法将 cookie 变成“阴暗面”的方法。如果没有恶意，它们甚至可能存在潜在问题。出于这个原因，cookies 颇受争议。

cookie 的一些问题：

- 敏感信息的传输：假设您使用网上银行系统。您登录到服务器，然后服务器将您的登录名和密码（控制对您帐户的访问）存储在 cookie 中。如果应用程序实施不当，包含该 cookie 的消息可能会被拦截，从而使他人可以访问您的帐户。即使不是，获得访问您计算机的知识渊博的人也可以从存储 cookie 的文件中检索信息。

- Cookies 的不良使用：理论上，cookies 应该是对用户的帮助，而不是障碍。但是，任何服务器都可以出于任何原因设置 cookie。在某些情况下，服务器可以设置 cookie 来跟踪用户访问的站点，有些人认为这侵犯了他们的隐私。由于某些 Web 浏览器在设置 cookie 时不会通知用户，因此他们甚至可能不知道这正在发生。

- 第三方或“无意”Cookie：虽然大多数人认为 Cookie 是在他们专门请求的资源的上下文中设置的，但无论用户是否意识到，Cookie 都可能由向其发送请求的任何服务器设置.假设您向“http://www.myfavoritesite.com/index.htm”发送请求，并且该页面包含对服务器“http://www.bigbrotherishere.com”上的一个小图像的引用。第二个站点可以在您的计算机上设置一个 cookie，即使您根本没有打算访问它。这称为“第三方 cookie”。

<u>**管理 Cookie 使用**</u>

描述 cookie 状态管理技术的 RFC 广泛地处理了这些问题和其他问题，但是对于这些问题没有明确的解决方案。与大多数安全和隐私问题一样，决定潜在 cookie 滥用程度的最重要因素是您个人的舒适度。每天都有数以百万计的人浏览 Web，让任何和所有网站设置他们想要的任何 cookie，并且永远不会有问题。其他人认为 cookie 是一种冒犯性的想法并禁用所有 cookie，这消除了隐私问题，但可能会导致交互式网站等有用应用程序出现问题。与往常一样，最好的方法通常是介于两者之间，您可以在其中选择何时以及如何允许设置 cookie。

“cookie 控制”的可行程度在很大程度上取决于您的 Web 客户端软件的质量和功能集。许多浏览器没有对设置 cookie 的方式和时间提供大量控制，而其他浏览器在这方面要好得多。有些允许禁用 cookie，但默认情况下它们是打开的，由于许多人甚至没有意识到我上面提到的问题，他们甚至不会意识到何时发送 cookie。在这方面最值得注意的是世界上最流行的浏览器，微软的 Internet Explorer，它通常默认设置为接受所有 cookie，而不会抱怨甚至评论。

Internet Explorer 确实允许您禁用 cookie，但您必须自己动手。它还允许您区分第一方和第三方 cookie，但同样，您必须打开它。其他浏览器有更复杂的设置，可以让您指定可以设置 cookie 的条件，以及其他浏览器不能设置 cookie 的条件。有些甚至会让您允许某些网站发送 cookie，同时禁止其他网站发送 cookie。更好的还会让您目视检查 cookie，并有选择地清除机器上不需要的 cookie。

在线广告公司和其他公司可以使用第三方 cookie 来跟踪 Web 用户访问的站点。因此，许多人认为它们属于称为间谍软件的一般不良软件类别。有许多工具可以让您从计算机中识别和删除跟踪 cookie；很多都可以在网上免费获得。

**关键概念：**HTTP 本质上是一种无状态协议，因为服务器独立处理来自客户端的每个请求，而忽略所有先前的请求。 HTTP 的这一特性对于万维网的大多数常规使用来说不是问题，但对于交互式应用程序（例如在线购物）来说是个问题，服务器需要随着时间的推移跟踪用户的信息。为了支持这些应用程序，大多数 HTTP 实现都包含一个称为状态管理的可选功能。启用后，服务器会向客户端发送少量信息，称为 cookie，这些信息存储在客户端计算机上。 cookie 中的数据随每个后续请求返回到服务器，允许服务器更新它并再次将其发送回客户端。因此，Cookie 使服务器能够记住请求之间的用户数据。然而，由于与使用相关的某些潜在隐私和安全问题，它们存在争议。



#### 4.2.6 Gopher 协议 (Gopher)（部分：1 2 3 4）

假设我告诉过你我要描述一个 TCP/IP 应用层协议，该协议专为分布式文档搜索和检索的特定目的而设计。该协议使用客户端/服务器操作模型，其中服务器提供指向相关资源的链接，例如用户使用显示选项供用户选择的客户端软件访问的文件或程序。您可能认为我在谈论万维网，并且有充分的理由。然而，在这种情况下，我实际上是在谈论 Web 的前身之一：Gopher 协议。

我们讨论这个协议的一个好地方是它的名字，这个名字的选择有很多原因。 Gopher 协议由明尼苏达大学开发，其运动队被称为“Golden Gophers”（明尼苏达州被称为“Gopher State”）。这是该名称的直接来源，但它也很合适，因为共享它的啮齿动物以挖洞着称，就像该协议旨在通过 Internet 进行“挖洞”一样。当然，术语“gopher”也适用于执行差事的人，例如检索文件（他们“go fer”这个，“go fer”那个）。

Gopher 协议是在 80 年代后期开发的，旨在提供一种组织文件的机制，以便大学的学生和教职员工轻松访问。指导系统开发的核心原则是简单性。 Gopher 是在少数核心原则的基础上设计的，并使用非常直接的机制在客户端和服务器设备之间传递信息。它在 1993 年 3 月发布的 RFC 1436 中进行了描述。

<u>**Gopher 服务器上的信息存储**</u>
Gopher 可访问的信息以文件形式存储在 Gopher 服务器上。它以类似于 Windows PC 或 UNIX 工作站等计算机的文件系统树的分层方式组织。正如文件系统由包含文件和子目录（子文件夹）的顶级目录（或文件夹）组成一样，Gopher 服务器将信息呈现为包含资源（例如文件）和/或包含其他资源的子目录的顶级目录。不同服务器上的资源可以通过在彼此的资源层次结构中提及来链接在一起。还可以创建“虚拟”资源，就像它们是文件一样，例如允许搜索 Gopher 服务器的程序。

<u>**Gopher 客户端/服务器操作**</u>

Gopher 的典型使用开始于客户端计算机上的用户使用众所周知的 TCP 端口号 70 创建到 Gopher 服务器的 TCP 连接。连接建立后，服务器等待客户端通过发送服务器请求特定资源一段称为选择器字符串的文本。通常，当用户第一次访问服务器时，他或她不知道要请求什么资源，因此会发送一个 null（空）选择器字符串。这会导致服务器向客户端发送回服务器文件系统树的顶级（根）目录中可用资源的列表。

<u>**目录列表结构**</u>
服务器发送的目录列表由一组行组成，每行描述该目录中的一个可用资源。每行包含以下元素，每个元素由“<Tab>”字符分隔：

- 类型字符和资源名称：该行的第一个字符告诉客户端软件该行代表哪种资源。最常见的类型字符是“0”代表文件，“1”代表子目录，“7”代表搜索服务。直到第一个“<Tab>”的其余字符包含要呈现给用户的资源的名称。

- 选择器字符串：要发送到服务器以检索此资源的文本字符串。

- 服务器名称：资源所在服务器的名称。

- 服务器端口号：用于访问该资源服务器的端口号；通常70。

每行以符合 Telnet 网络虚拟终端 (NVT) 规范的“<CR><LF>”字符序列结尾。发送目录列表（或任何其他响应）后，客户端和服务器之间的连接将关闭。

<u>**菜单和用户资源选择**</u>

Gopher 客户端软件收到此类目录列表后，会向用户显示一个菜单，其中包含服务器提供的所有资源名称。然后用户从菜单中选择他或她想要的项目，客户端通过连接到适当的服务器和端口号并发送该资源的选择器字符串来检索它。如果这本身代表一个子目录，则服务器将发送该子目录的新目录列表；如果是其他类型的资源，则根据资源类型的要求进行访问。

例如，假设此行是从服务器发送到客户端的：

```
0Gopher Introduction<Tab>intro<Tab>gopher.someserver.org<Tab>70
```

这将在包含其他选项的菜单中作为名为“Gopher Introduction”的文件呈现给用户。如果用户选择它，客户端将在端口 70 启动到 gopher 服务器“gopher.someserver.org”的连接，然后将选择器字符串“intro”发送到该服务器以检索文档。

<u>**Gopher 和 Web 之间的重要区别**</u>
正如我在本次讨论开始时暗示的那样，Gopher 和万维网都旨在实现相同的基本目的：提供对信息存储库的访问，以及相关文档和资源之间的链接。然而，他们对信息的访问方式采取了截然不同的方法，尤其是在两个关键领域：用户界面和资源链接。

Gopher 对用户的呈现完全围绕其分层文件系统。因此，Gopher 本质上是基于菜单的，并且用户界面通常基于这些菜单的简单文本表示。相反，万维网服务器上的信息可以以任何方式组织，并以服务器所有者希望的任何形式或方式呈现给用户。 Web 更加“自由形式”，没有必要使用目录结构，除非它在某种程度上是有利的。

万维网中的链接是直接在文档之间进行的，通常使用超文本标记语言 (HTML) 标签。当撰写文档 A 的人提到与文档 B 相关的内容时，他或她会将指向 B 的链接直接放入文档 A 本身。另一方面，Gopher 并未设计为以这种方式使用链接。相反，链接旨在使用我们之前描述的目录树来完成。

<u>**Gopher 在现代互联网中的作用**</u>

有些人认为 Gopher 在许多方面在技术上优于 Web。他们认为由服务器完成链接比将链接嵌入文档更简洁。也可以说，Gopher 的文本导向是高效的，能够更好地保证平台间的兼容性，也更适合低带宽链接和视障人士访问等特殊需求情况。因此，一些 Gopher 爱好者认为它是一个比万维网“更纯粹”的超文本系统。

然而，历史告诉我们，尽管 Gopher 早于万维网，但仅在短短几年内，Web 的流行度就超过了它。今天，Web 是互联网中 900 磅重的大猩猩，而大多数人甚至从未听说过 Gopher。发生了什么？

我相信 Gopher 输给 Web 的主要原因是 Web 更加灵活。 Gopher 使用文本超链接和服务器目录结构可能很有效，但也有局限性。相比之下，Web 允许以多种方式呈现信息。 Web 的开放、非结构化特性使其成为信息提供者和应用程序开发人员发挥创造力的理想工具。在 20 世纪 90 年代中期，Web 也完全准备好支持计算从文本到图形的过渡，而 Gopher 确实不是。

简而言之，与使用 Gopher 相比，您可以使用 Web 做更多的事情，并且更多的人关心功能和选项的广度，而不是直接的效率。一旦 Web 开始获得动力，它就会迅速滚雪球，正如我在 Web 历史主题中所讨论的那样。仅用了几年时间，Web 的使用就根深蒂固，而 Gopher 无法与之竞争。

就其本身而言，明尼苏达大学可能加速了 Gopher 的消亡，因为它有争议地决定向希望将 Gopher 用于商业目的的公司收取许可费。我不认为这有什么不好的地方：大学的预算有限，希望有能力负担得起的公司支付少量费用来支持 Gopher 软件的开发。然而，计算历史一次又一次地表明，无论出于何种原因，没有比尝试为其收取许可费或特许权使用费更快地扼杀协议或标准的方法。

到 1990 年代后期，Gopher 已经快要过时了。随着协议使用的减少，许多组织不再证明继续运行 Gopher 服务器的成本是合理的。由于利用率低，甚至明尼苏达大学本身最终也关闭了自己的 Gopher 服务器。 Gopher 的最后一次“致命一击”发生在 2002 年，当时在 Internet Explorer 中发现了与 Gopher 相关的安全漏洞，微软选择简单地从产品中删除对 Gopher 的支持，而不是修复该问题。今天，Gopher 仍然存在，但它是一种小众协议，仅供相对较小的爱好者群体和少数过去使用过它的组织使用。

**关键概念：**Gopher 协议是 1980 年代后期在明尼苏达大学开发的分布式文档搜索和检索协议。资源存储在 Gopher 服务器上，这些服务器使用分层目录结构来组织信息。 Gopher 客户端访问服务器以检索可用资源的目录列表，这些目录列表作为菜单呈现给用户，可以从中选择项目进行检索。 Gopher 的主要优势是简单易用，但缺乏表现的灵活性以及有效呈现图形和多媒体的能力。出于这个原因，尽管 Gopher 早于万维网，但 Web 几乎完全取代了它，并且 Gopher 现在是一个小众协议。

![image-20221122230652346](C:\Users\zy\AppData\Roaming\Typora\typora-user-images\image-20221122230652346.png)

**丧钟为谁而鸣，丧钟为你而鸣**



### 4.3 TCP/IP 交互和远程应用协议

在谈到 TCP/IP 应用程序时，文件和消息传输应用程序（如电子邮件、FTP 和万维网）受到最多的关注，因为它们是现代互联网络中最常用的应用程序。另一类鲜为人知的 TCP/IP 应用协议是允许用户直接通过互联网（例如公共互联网）交互访问和使用其他计算机的协议组。如今，这些应用程序并不经常被最终用户使用，但仍然很重要——既从历史的角度来看，又因为它们在某些情况下非常有用，尤其是对网络管理员而言。

在本节中，我将简要介绍 TCP/IP 中使用的“经典”交互和远程应用程序协议。第一部分描述了 Telnet 协议，它是 TCP/IP 中最早和最重要的应用协议之一，至今仍在用于远程设备访问和许多其他协议的通信基础。第二个描述了 Berkeley 远程访问系列，通常称为“r”命令或协议，因为它们的命令名称以该字母开头。最后，我简要概述了 Internet 中继聊天 (IRC) 协议，它是 Internet 的原始交互式聊天应用程序，至今仍在广泛使用。

#### 4.3.1 远程登录协议

在互联网的早期，计算机科学家需要解决的最重要的问题之一是如何允许操作一台计算机的人访问和使用另一台计算机，就好像他或她在本地连接到它一样。为满足这种需要而创建的协议称为 Telnet，开发它的努力与 Internet 和整个 TCP/IP 的努力密切相关。尽管今天的大多数 Internet 用户从不直接调用 Telnet 协议，但他们始终间接地使用它的一些基本原理。每次发送电子邮件、使用 FTP 传输文件或加载网页时，您都在使用基于 Telnet 的技术。正因如此，Telnet协议可以称得上TCP/IP历史上最重要的应用协议的称号。

在本节中，我将描述 Telnet 协议的操作。我从协议的概述和历史以及定义它的标准的讨论开始。我描述了 Telnet 客户端和服务器的一般操作以及如何建立和维护连接。然后我解释了网络虚拟终端 (NVT) 的重要概念、Telnet 的协议命令以及如何使用 Telnet 的特殊同步功能处理中断。最后，我将详细了解 Telnet 的选项以及它们是如何协商的。

**背景信息：**对传输控制协议 (TCP) 的基本了解，尤其是其滑动窗口机制和流量控制功能，将有助于理解本节。

##### 4.3.1.1 Telnet 概述、历史和标准（部分：1 2 3）

正如我在本指南中所做的那样，对 TCP/IP 等网际网络协议套件的描述通常是从较低层向上进行的。虽然出于多种原因这是有道理的——最值得注意的是，协议更容易以这种方式理解——但这并不能反映开发了多少协议套件的历史。应用程序实际上通常是最先出现的：它们被定义为满足用户的需求，而开发套件的其余部分以使应用程序能够运行。 Telnet 和 TCP/IP 是这种“自上而下”过程的一个很好的例子。

Telnet 的历史实际上可以追溯到我们今天所知道的现代 TCP/IP 协议套件之前十多年。正如我在文件传输协议 (FTP) 概述中提到的，TCP/IP 互联网络技术的早期开发人员确定了网络需要满足的两个总体应用程序需求：启用对资源的直接访问和间接访问。 FTP 是为间接访问而创建的，允许用户从远程主机检索资源，在本地使用它，如果需要，还可以将其复制回源。 Telnet 是为直接访问而设计的：让用户访问远程机器并像在本地连接一样使用它。

<u>**Telnet的发展动力**</u>
理解为什么需要 Telnet 需要我们记住协议最初开发时的计算性质：1960 年代后期。这远早于我们今天许多人专门使用的小型个人电脑时代。那个时期的所有计算机都很大，通常由许多用户共享。要在计算机上工作，您必须访问连接到该计算机的物理终端，这通常是根据主机的需要和要求专门定制的。

这种情况导致了两个具体问题。第一个是，如果您在一个组织中有几台不同的计算机，那么每个用户都需要一个单独的终端来访问他或她需要使用的每台计算机。这是昂贵且低效的；我记得读过一本书中的一句话，将这种情况比作一个房间里有许多电视机，每台电视机只能显示一个频道。

第二个也许更重要的问题是难以允许一个站点的用户访问和使用另一个站点的机器。当时实现这一目标的唯一方法是在计算机站点和用户站点之间安装专用数据电路，以将用户终端连接到远程机器。同样，每个电路只能访问一台机器。用户和计算机的每种组合都需要安装和维护单独的、昂贵的电路。

解决这两个问题的方法是创建一种更通用的方法，允许任何终端访问任何计算机。底层互联网络将提供计算机之间通信信息的机制；这成为连接站点的物理网络和连接网络的 TCP/IP 协议套件。在此之上将运行一个应用程序协议，该协议允许用户与任何联网计算机建立会话并使用它：Telnet 协议。

<u>***Telnet History\***</u>

Telnet 是 1969 年在初出茅庐的 ARPAnet 上展示的第一个应用协议。第一个专门定义 Telnet 的 RFC 是 RFC 97，First Cut at a Proposed Telnet Protocol，于 1971 年 2 月发布。Telnet 的开发在整个 1970 年代持续进行，有相当多的不同的 RFC 致力于协议的修订和相关问题的讨论。花了很多年时间来改进 Telnet 并解决与其开发相关的所有困难。

该协议的最终版本 Telnet 协议规范于 1983 年 5 月作为 RFC 854 发布。多年来，已发布其他 RFC 以阐明该协议的使用并解决身份验证等各种问题。还有许多其他 RFC 定义了 Telnet 选项，我们将在本节后面看到。

<u>**基本的 Telnet 概念**</u>
乍一看，Telnet 花了这么长时间才开发出来可能会令人惊讶，因为从理论上讲，它应该是一个定义起来非常简单的协议：它需要做的就是像任何其他协议一样通过网络发送击键和程序输出。如果每个终端和计算机都使用相同的通信方法，这将是正确的，但它们没有。 Telnet 变得复杂，因为它需要允许来自一个制造商的终端能够与可能使用非常不同的数据表示的计算机对话。

Telnet 通过定义一种方法解决了这个问题，该方法确保终端类型和计算机之间的兼容性，同时允许同意支持它们的计算机和终端使用特殊功能。该协议建立在三个主要概念的基础上：

- 网络虚拟终端 (NVT)：Telnet 定义了一个标准化的虚构终端，称为网络虚拟终端 (NVT)，用于所有设备的通用通信。 Telnet 客户端从用户获取输入并将其从其本机格式转换为 NVT 格式，以发送到远程计算机上运行的 Telnet 服务器；服务器将 NVT 转换为被访问计算机所需的任何表示形式。当数据从远程计算机发送回用户时，过程相反。该系统允许客户端和服务器进行通信，即使它们使用完全不同的硬件和内部数据表示。特殊的 Telnet 命令散布在数据中，以允许客户端和服务器设备执行管理协议操作所需的各种功能。

- 选项和选项协商：让 Telnet 客户端和服务器充当 NVT 可以避免设备之间的不兼容性，但是通过剥离所有特定于终端的功能以提供每个人都可以理解的通用基础表示来实现。由于在许多情况下，更智能的终端和计算机可能希望使用更高级的通信功能或服务，因此 Telnet 定义了一组丰富的选项和一种 Telnet 客户端和服务器可以协商其使用的机制。如果客户端和服务器同意使用某个选项，则可以启用该选项；如果没有，他们总是可以求助于 NVT 以确保基本通信。

- 对称操作：虽然 Telnet 是一种客户端/服务器协议，但它专门设计用于不对客户端和服务器软件的性质做出假设。一旦建立了 Telnet 会话，它们就可以平等地发送和接收数据。他们还可以各自发起选项的协商。这使得该协议非常灵活，并导致它在各种地方使用，我们稍后将讨论。

<u>**Telnet 应用程序**</u>

Telnet 通常与远程登录相关联，这是它最常见的传统用法。用户通常使用 Telnet 客户端程序打开到远程服务器的 Telnet 连接，然后远程服务器将 Telnet 客户端视为本地终端，允许用户登录并访问服务器的资源，就好像他或她直接使用 -附加终端。 Telnet 仍然被 UNIX 用户广泛使用，他们经常需要从本地机器登录到远程主机；我自己每天都以这种方式使用 Telnet 访问数百英里外的机器。然而，这种 Telnet 的使用在大多数使用 Windows 或 Apple 计算机的互联网用户中并不常见，在这些计算机上，网络资源不是通过直接登录而是通过其他方式访问的。

然而，虽然远程登录是 Telnet 的重要组成部分，但重要的是要注意该协议并非天生就是为该特定功能设计的。当使用Telnet访问远程设备时，协议本身只是用来建立客户端和服务器机器之间的连接，根据Telnet NVT的规则对要传输的数据进行编码，方便选项的协商和使用.是客户端和服务器设备本身决定 Telnet 是用于远程访问还是用于其他目的。

<u>**Telnet 的遗产**</u>
Telnet 的灵活性，加上它在 TCP/IP 套件中的历史，导致 Telnet 被各种其他协议采用。由于 Telnet 不假设什么是客户端和什么是服务器，因此任何程序或应用程序都可以使用它。许多文件和消息传输应用程序，包括 FTP、SMTP、NNTP 和 HTTP，通过发送文本命令和消息进行通信，并使用 Telnet 的 NVT 规范来确保设备之间通信的兼容性。它们实际上并不建立 Telnet 会话或使用选项协商等功能，它们只是以与 Telnet 工作方式一致的方式发送数据。

因此，即使现代 Internet 用户可能从未有意专门调用 Telnet，但他们每次发送或接收电子邮件或浏览 Web 时都会间接使用它。管理员甚至可以使用 Telnet 客户端软件访问 FTP 和 HTTP 服务器等设备，并手动向它们发送命令。

关键概念：Telnet 是 TCP/IP 套件中最古老的协议之一，最初于 1960 年代开发，允许一台计算机系统上的用户直接访问和使用另一台计算机系统。它最常用于远程登录，用户机器上的 Telnet 客户端软件与远程主机上的 Telnet 服务器建立会话，让用户像直接连接一样与主机一起工作。为了确保使用不同硬件和软件的终端和主机之间的兼容性，Telnet 客户端和服务器软件之间的通信基于简化的、虚构的数据表示，可以通过协商选项来增强这种表示。



##### 4.3.1.2 Telnet 连接和客户端/服务器操作

Telnet 的总体功能是定义一种方法，一台机器上的用户或进程可以访问和使用另一台机器，就好像它是本地连接的一样。这使得 Telnet 在操作中本质上是客户端/服务器，就像 TCP/IP 中的许多其他应用程序协议一样。通常，Telnet 客户端是一个充当用户界面的软件，处理击键和用户命令并显示远程机器的输出。 Telnet 服务器是在已设置为允许远程会话的远程计算机上运行的程序。

<u>**TCP 会话和客户端/服务器通信**</u>
Telnet 用于客户端和服务器之间长时间的数据和命令交互通信，因此强烈基于会话的概念。因此，Telnet 在面向连接的传输控制协议 (TCP) 上运行。 Telnet 服务器侦听众所周知的 TCP 端口号 23 上的连接。当客户端想要访问特定服务器时，它会启动到适当服务器的 TCP 连接，该服务器响应使用标准 TCP 三向握手建立 TCP 连接.

TCP 连接在 Telnet 会话期间保持不变，Telnet 会话一次可以保持数小时、数天甚至数周。 TCP 的服务质量特性保证了数据的可靠和有序接收，并确保数据不会以过高的速率发送给客户端或服务器。提供 Telnet 服务的机器可以支持与不同用户的多个同时会话，通过使用客户端的 IP 地址和端口号来识别每个会话来保持每个会话的不同。

由于 TCP 是全双工协议，客户端和服务器都可以通过 Telnet 会话随意发送信息。默认情况下，这两种设备都首先使用标准的 Telnet 网络虚拟终端 (NVT) 方法对数据和控制命令进行编码。他们还可以协商使用 Telnet 选项以为会话提供更多功能。虽然选项协商随时都可能发生，但在首次建立 Telnet 会话时“爆发”这种选项交换是正常的，此后只有偶尔的选项命令交换。

建立 TCP 连接并激活 Telnet 会话后，客户端和服务器软件开始将用户连接到远程主机的正常工作。对用户而言，Telnet 会话与坐在直接连接到远程主机的终端上基本相同。在大多数情况下，服务器将通过发送登录提示以询问用户名和密码来开始用户会话。 Telnet 客户端将从用户那里接受此信息并将其发送到服务器。假设信息有效，用户将登录并可以以他或她的帐户授权的任何方式使用主机。

如 Telnet 概述中所述，即使该协议通常用于远程登录，也不需要以这种方式使用。运行 Telnet 服务器的计算机的管理员决定如何在该计算机上使用它。仅举一个例子，Telnet 服务器可以直接连接到提供服务的进程或程序。我记得几年前使用互联网服务器通过 Telnet 向公众提供天气信息。使用该协议连接到该机器后，您将看到的不是登录提示，而是天气显示选项的菜单。当然，今天，Web 已经取代了大部分此类设施，因为它更适合这种类型的信息检索。

**关键概念：**Telnet 是一种客户端/服务器协议，它使用 TCP 在用户终端和远程主机之间建立会话。 Telnet 客户端软件从用户那里获取输入并将其发送到服务器，服务器将其提供给主机的操作系统。 Telnet 服务器从主机获取输出并将其发送到客户端以显示给用户。虽然 Telnet 最常用于实现远程登录功能，但协议中没有专门与登录相关的概念，该协议足够通用，可以用于多种功能。

<u>**使用Telnet访问其他服务器**</u>
Telnet NVT 表示被各种其他协议使用，例如 SMTP 和 HTTP。这意味着允许您访问 Telnet 服务器的同一 Telnet 客户端可用于直接访问其他应用程序服务器。您需要做的就是指定服务对应的端口号。例如，此命令将允许您直接连接到 Web 服务器：

```
telnet www.someserversomewhere.org 80
```

您不会收到登录提示，但服务器会等待您发送 HTTP 请求消息，就好像您是 Web 浏览器一样。如果您输入一个有效的请求，服务器将向您发送一个 HTTP 响应消息。以这种方式使用，Telnet 作为一种诊断工具是非常有价值的。

**关键概念**：Telnet 网络虚拟终端 (NVT) 数据表示许多其他 TCP/IP 协议已采用该协议作为其消息系统的基础。 因此，Telnet 客户端软件不仅可以用于连接到 Telnet 服务器，还可以用于连接到 SMTP 和 HTTP 等协议的服务器，这对于诊断目的很有用。



##### 4.3.1.3 Telnet 通信模型和网络虚拟终端 (NVT)（部分：1 2 3 4）

Telnet 的核心是一个相当简单的协议。一旦建立了 TCP 连接并且 Telnet 会话开始，客户端和服务器软件唯一真正的任务就是捕获输入和输出，并通过网络重定向。因此，当用户在其本地终端上键入一个键时，Telnet 客户端软件会捕获它并通过网络将其发送到远程机器。在那里，Telnet 服务器软件将它发送到操作系统，操作系统将其视为在本地键入。当操作系统产生输出时，过程相反：Telnet 服务器软件捕获输出并通过网络将其发送到用户的客户端程序，后者将其显示在打印机或显示器上。

引用两个众所周知的陈词滥调，我可以说这“在纸面上看起来不错”，但“细节决定成败”。这种简化的实施只有在每台计算机和终端都使用完全相同的硬件、软件和数据表示时才有效。当然，今天的情况远非如此，在开发 Telnet 时更糟。

<u>**不同表示的问题**</u>
回到“过去的美好时光”的计算机是高度专有的，并不是为了互操作而设计的。它们在很多方面都不同，从终端使用的键盘类型和它可以发送的击键，到终端上每行和每个屏幕的行数，再到用于编码数据和控制功能的字符集。简而言之，计算机 A 旨在接受来自其自己终端的特定形式的输入，而不是计算机 B 的终端。

这实际上是网络世界中一个相当普遍的问题，我们可以用现实世界的类比来帮助解释这个问题以及如何解决它。假设一个重要的国际会议有来自不同国家的 30 位大使出席，每个大使都有一名助手。每对大使和助理都只说他们自己的语言，因此只能互相交谈——就像计算机和终端被设计成只能相互连接一样。

为了让一个国家的助理与其他国家的大使交谈，一种解决方案是训练助理讲所有其他与会国家的语言。回到计算世界，这就像定义 Telnet 协议，以便每个 Telnet 客户端软件实现都知道如何与现有的每台计算机对话。在这两种情况下，这都可行，但非常不切实际且难以做到。

另一种方法是定义一种通用语言，让所有大使和助理都学习它。虽然这需要一些工作，但比要求人们学习几十种语言要少得多。每位大使和助理都会说他或她的母语和选定的共同语言。每个人都可以使用这种通用语言与所有其他人交流，而不必知道会议上任何人可能使用的所有语言。更重要的是，如果一位大使和助理出现在会议上说一种新的第 31 种语言，那么所有其他代表都不需要学习它。

<u>**网络虚拟终端**</u>

Telnet 使用类似于上述类比的方法来处理其硬件和软件兼容性问题。所有 Telnet 客户端和服务器都同意发送数据和命令，这些数据和命令遵循虚构的“虚拟”终端类型，称为网络虚拟终端 (NVT)，而不是让终端和主机使用它们的各种本地“语言”进行通信。 NVT 为如何格式化和发送信息定义了一组规则，例如字符集、线路终止以及有关 Telnet 会话本身的信息如何发送。

在终端上运行的每个 Telnet 客户端都能理解其母语和 NVT。当用户在他或她的本地终端上输入信息时，它被转换为 NVT，以 NVT 形式在网络上传输。当 Telnet 服务器接收到此信息时，它将它从 NVT 转换为远程主机希望接收的格式。对于从服务器到客户端的传输，以相反的方式执行相同的过程。这在图 320 中进行了说明。

​        ![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\telnetnvt.png)

​                                              **图 320：Telnet 通信和网络虚拟终端 (NVT)**

Telnet 使用网络虚拟终端 (NVT) 表示允许使用不同内部格式的用户终端和远程主机进行通信。

**关键概念：**Telnet 网络虚拟终端 (NVT) 是一种统一的数据表示，可确保终端和可能使用非常不同的硬件、软件和数据格式的主机之间的通信兼容性。 Telnet 客户端将用户输入从终端的本机格式转换为 NVT，以便传输到 Telnet 服务器，在那里它被转换为主机的内部格式。对于从主机到用户的输出，该过程是相反的。


NVT 被定义为由用于输入的逻辑“键盘”和用于输出的逻辑“打印机”组成（协议的年代反映在这些术语中；几十年前没有显示器，所有输出都在纸上）。 NVT 使用 7 位美国 ASCII (USASCII) 字符集。每个字符都使用一个 8 位字节进行编码。但是请注意，客户端和服务器可以使用 Telnet 选项来协商其他数据表示形式，包括扩展 ASCII 或什至完整的 8 位二进制数据的传输。

<u>**NVT ASCII 控制代码**</u>

常规 ASCII 由 95 个常规“可打印”字符（代码 32 到 126）和 33 个控制代码（0 到 31 和 127）组成。 Telnet 标准指定输出设备必须能够处理所有可打印字符，并且规定了应该如何解释其他几个常见的 ASCII 控制代码。 在这些代码中，所有 Telnet 软件都需要接受三个（0、10 和 13）； 其他五个是可选的，但如果支持，则必须以与 Telnet 规范一致的方式进行解释。 它们都在表 280 中描述。


​                                                     **表 280：标准 Telnet NVT ASCII 控制码的解释**

| **ASCII Value (Decimal)** | **ASCII Character Code** | **ASCII Character** | **Description**                                              | **Support Optional / Mandatory** |
| ------------------------- | ------------------------ | ------------------- | ------------------------------------------------------------ | -------------------------------- |
| **0**                     | **NUL**                  | **Null**            | 无操作（对输出无影响）。                                     | Mandatory                        |
| **7**                     | **BEL**                  | **Bell**            | 在不移动打印头的情况下在输出端产生声音或视觉信号。此通知可用于引起用户的注意，如在出现错误的情况下。 | Optional                         |
| **8**                     | **BS**                   | **Back Space**      | 将打印位置向左移动一个字符。                                 | Optional                         |
| **9**                     | **HT**                   | **Horizontal Tab**  | 将打印机移动到下一个水平制表位。该标准没有指定设备如何就制表位位置达成一致；这可以使用 Telnet 选项协商。 | Optional                         |
| **10**                    | **LF**                   | **Line Feed**       | 将打印机移到下一行，保持打印位置不变。                       | Mandatory                        |
| **11**                    | **VT**                   | **Vertical Tab**    | 将打印行移动到下一个垂直制表位。对于“HT”字符，设备必须使用一个选项来就垂直制表位位置达成一致。 | Optional                         |
| **12**                    | **FF**                   | **Form Feed**       | 将打印机移动到下一页的顶部（或在显示器上，清除屏幕并将光标定位在顶部。） | Optional                         |
| **13**                    | **CR**                   | **Carriage Return** | 将打印机移动到当前打印行的左边距。                           | Mandatory                        |

<u>***End-of-Line Representations\***</u>

Telnet NVT 方案定义了回车（“CR”）和换行（“LF”）字符的组合来表示 ASCII 文本行的结尾。这两个字符的字面意思是“返回到左边距”（来自“CR”）和“转到下一行”（来自“LF”）。然而，NVT 将“CR+LF”序列视为不仅仅是两个独立的字符；它们被共同定义为一个合乎逻辑的“行尾”字符。这是必要的，因为并非所有终端类型都使用“CR”和“LF”定义行尾。在本机格式和 NVT 格式之间转换行尾字符是 Telnet 客户端和服务器软件必须执行的功能之一，以确保终端和主机之间的兼容性。

关键概念：Telnet NVT 格式基于 7 位美国 ASCII，每个字节携带一个字符。该标准规定设备必须处理所有标准的可打印 ASCII 字符，以及三个强制控制字符。其中两个是回车符（“CR”）和换行符（“LF”）；组合时，它们定义了一行文本的逻辑结尾。 Telnet 标准还描述了其他五个可选 ASCII 控制字符的解释。

<u>***Half-Duplex and Full-Duplex Modes\***</u>
Telnet 时代的另一个神器是，为了最大的兼容性，网络虚拟终端规范是在半双工操作的假设下设计的：一次只能有一个设备进行传输。正在发送数据的设备应该使用特殊的 Telnet Go Ahead 命令结束其传输，告诉其他设备它现在可以传输（下一主题介绍 Telnet 协议命令）。这类似于使用对讲机的人如何以“结束”结束每次传输，告诉他们的伙伴他们现在可以回应了。

当然，现代网络以全双工模式运行，使用半双工通信会不必要地低效。在大多数情况下，Telnet 客户端和服务器同意使用一个选项（Suppress Go Ahead）来消除发送此命令的需要。然而，将此设置为默认值是 NVT 如何在 Telnet 中充当“least common denominator”的一个很好的例子，以防任一设备需要更简单的操作模式。



##### 4.3.1.4 Telnet 协议命令（部分：1 2 3）

用户在终端输入的大部分输入都采用数据和命令的形式，这些数据和命令被发送到他或她正在使用的应用程序。然而，计算机系统也提供了一种手段，用户可以通过该手段指示终端发送某些命令，这些命令控制终端本身如何操作，以及它如何与它所连接的计算机交互。最好的例子是中断进程的命令，通常通过在用户终端上按下一个特殊的键或组合键来发送。

Telnet 需要有一种方法允许用户输入此类命令。然而，这里我们遇到了与上一个主题相同的问题，当我们谈到终端和计算机之间的数据通信时：表示缺乏统一性。例如，虽然所有终端和计算机都支持中断正在运行的程序的能力，但它们可能各自使用不同的击键来表示它。例如，在大多数 UNIX 系统上，组合键“<Ctrl>+C”会中断程序，但在 Windows 系统上键入它不会（它通常代表“复制数据”功能！）

<u>**为标准命令函数定义通用表示**</u>
由于问题与我们在表示数据流时遇到的问题相同，因此解决方案相同也就不足为奇了：对要在终端和主机之间传递的一组标准命令使用通用表示。代表这些命令的所有击键都被翻译成标准的 Telnet 代码进行传输，然后再翻译成主机的特定需要。因此，再次以我们的示例为例，如果用户在 UNIX 终端上按下“<Ctrl>+C”，这被定义为中断功能，那么 Telnet 客户端不会发送确切的击键，而是发送特殊的 Telnet 中断进程命令， Telnet 服务器将其转换为适用于所连接主机的命令代码。

Telnet 标准包括许多这样的特殊代码，以允许用户控制远程计算机的操作。它还定义了一组特定于 Telnet 协议本身的命令；这些让 Telnet 客户端和 Telnet 服务器软件进行通信。这些统称为 Telnet 协议命令。

<u>**转义命令和解释为命令 (IAC) 字符**</u>

所有 Telnet 命令都在与常规数据相同的通信流中发送；它们使用 240 到 254 范围内的特殊字节值表示。为了区分这些值的数据字节和 Telnet 命令，每个命令前面都有一个特殊的转义字符，命名为 Interpret As Command (IAC)。 IAC 的值为 255；当接收者看到这个字符时，它知道下一个字节是命令而不是数据。因此，由于 Telnet 中断处理命令的值为 244，要发送此命令，Telnet 客户端将传输字节 255，然后传输字节 244。如果需要发送实际数据字节值 255，则将其作为两个 255 字节传输。一些 Telnet 命令还包括额外的字节数据，这些数据在命令代码本身之后发送；一个很好的例子是在 Telnet 选项协商中使用参数。

此时您可能想知道为什么需要 IAC 字符。毕竟，Telnet 使用 US ASCII，它是字节范围为 0 到 127 的 7 位数据，并且 Telnet 命令的值高于 127。使用 IAC 转义的一个一般理由是明确表示正在执行命令发送。一个更具体的原因是为了适应通过 Telnet 可选地发送 8 位二进制数据，客户端和服务器可以协商。如果启用此模式并且命令前面没有 IAC 字符，则这将需要对值从 240 到 255 的所有数据字节进行某种标记，以便将它们解释为数据而不是命令。为命令包含一个额外的字节比数据更有效，因为它们发送的频率较低。通过转义命令，只有数据字节值 255 需要发送两个字节。

**关键概念：**Telnet 协议定义了一组协议命令，用于两个目的：第一，表示需要在终端和主机之间发送的标准控制功能，例如中断进程的命令；第二，实现Telnet客户端和服务器软件之间的协议通信。协议命令通过 Telnet 会话的 TCP 连接在正常数据通信流中发送。每个都由一个从 240 到 254 的字节值表示，并且前面是解释为命令 (IAC) 命令，字节值 255，它告诉接收者流中的下一个字节是一个命令。

<u>**Telnet 协议命令代码**</u>

表 281 以数字字节值顺序列出了 Telnet 协议命令，显示了每个命令代码和名称并描述了其含义和用途。

​                                                                     **表 281：Telnet 协议命令**

| **Command Byte Value (Decimal)** | **Command Code** | **Command**              | **Description**                                              |
| -------------------------------- | ---------------- | ------------------------ | ------------------------------------------------------------ |
| **240**                          | ***SE\***        | **Subnegotiation End**   | 标记 Telnet 选项子协商的结束，与 SB 代码一起使用以指定更具体的选项参数。有关详细信息，请参阅有关 Telnet 选项的主题。 |
| **241**                          | ***NOP\***       | **No Operation**         | Null command; does nothing.                                  |
| **242**                          | ***DM\***        | **Data Mark**            | 用于标记接收者应扫描以查找紧急 Telnet 命令的数据序列的结尾。请参阅有关 Telnet 中断处理的主题以获取更多信息。 |
| **243**                          | ***BRK\***       | **Break**                | 表示按下终端上的“break”或“attention”键。                     |
| **244**                          | ***IP\***        | **Interrupt Process**    | 告诉接收者中断、中止、暂停或终止当前正在使用的进程。         |
| **245**                          | ***AO\***        | **Abort Output**         | 指示远程主机继续运行当前进程，但丢弃所有剩余的输出。如果程序开始向用户发送意外的大量数据，则可能需要这样做。 |
| **246**                          | ***AYT\***       | **Are You There**        | 可用于检查远程主机是否仍然“活着”。发送此字符时，远程主机返回某种类型的输出以指示它仍在运行。 |
| **247**                          | ***EC\***        | **Erase Character**      | 指示接收者从数据流中删除最后一个未删除的字符。用于“撤消”字符的发送。 |
| **248**                          | ***EL\***        | **Erase Line**           | 告诉接收者从数据流中删除所有字符回到（但不包括）行的最后一个结尾（“CR”+“LF”）序列。 |
| **249**                          | ***GA\***        | **Go Ahead**             | 用于 Telnet 半双工模式，向其他设备发出信号，表明它可以传输。 |
| **250**                          | ***SB\***        | **Subnegotiation**       | 标记了telnet选项子谈判的开头，该选项在选项需要客户端和服务器交换参数时使用。有关完整说明，请参阅有关 Telnet 选项的主题。 |
| **251**                          | ***WILL\***      | **Will Perform**         | 在 Telnet 选项协商中，表示发送此代码的设备愿意执行或继续执行特定选项。 |
| **252**                          | ***WON’T\***     | **Won’t Perform**        | 在 Telnet 选项协商中，表示发送此代码的设备不愿意执行特定选项，或者现在拒绝继续执行它。 |
| **253**                          | ***DO\***        | **Do Perform**           | 在 Telnet 选项协商中，请求其他设备执行特定选项或确认其他设备将执行该选项的期望。 |
| **254**                          | ***DON’T\***     | **Don’t Perform**        | 在Telnet选项协商中，指定对方不执行选项，或者确认设备期望对方不执行选项。 |
| **255**                          | ***IAC\***       | **Interpret As Command** | 如上所述，在命令值 240 到 254 之前。一行中的一对 IAC 字节表示数据值 255。 |

也许具有讽刺意味的是，今天 Telnet 命令的使用不像 Telnet 早期那样广泛，因为我们之前讨论的许多兼容性问题已不复存在。 ASCII 已成为计算世界的标准字符集，因此许多功能（如中止输出或中断进程）不再需要使用 Telnet 命令。 然而，它们仍然广泛用于内部 Telnet 操作，例如选项协商。

##### 4.3.1.5 使用带外信号处理 Telnet 中断：Telnet 同步功能（部分：1 2）

从 Telnet 客户端发送到服务器的所有数据字节都按发送顺序接收，反之亦然。当然，这是我们期望应用程序运行的方式；事实上，确保数据不会乱序接收是我们假设 Telnet 在其上运行的可靠传输协议 TCP 的工作之一。但是，由于协议通过同一连接发送数据和命令的方式，这可能会导致 Telnet 出现问题。

<u>**问题：发送中断命令**</u>
出现按顺序接收所有数据问题的最重要情况是用户需要中断进程时。例如，假设您正在使用 Telnet 运行一个交互式程序，该程序接受用户输入、处理它，然后产生输出。当您注意到有一段时间没有看到程序的任何输出时，您正在愉快地打字。由于编程错误或其他故障，它显然已挂断。

如果您在直接连接的终端上使用该程序，您只需使用适合该终端的键或击键命令来中断或终止进程并重新启动它。相反，您使用的是 Telnet，因此您输入适当的击键，该击键将转换为特殊的 Telnet 中断进程命令代码（字节值 244，前面是 Telnet Interpret As 命令代码 255）。

由于 Telnet 仅对命令和数据使用单个流，因此该代码被放入 TCP 数据流中以发送到 Telnet 服务器。由于您输入了一段时间的数据，因此 Telnet 中断进程代码将位于一堆常规数据字节的后面。现在，远程进程已停止读取此数据，这意味着服务器上的 TCP 接收缓冲区将开始填满。因此，中断进程命令将停留在缓冲区中，等待读取。事实上，如果命令前面的数据字节数足够多，服务器上的 TCP 缓冲区可能会填满，导致服务器关闭客户端的 TCP 发送窗口。这意味着中断进程命令将在客户端的传出 TCP 队列中等待，甚至根本不会发送到远程主机！

显然，我们在这里需要的是某种能够标记中断进程命令的方法，以便它可以发送到远程主机，而不管它前面未完成的数据字节数。如果您已经仔细阅读了本指南中专门针对 TCP 的大部分内容，您现在可能会认为您已经阅读了该协议的一项功能，该功能似乎非常适合解决这个问题……您是对的！ TCP“紧急”功能允许标记一条重要数据，使其优先于常规数据，这一过程有时称为带外信号（因为信号在正常数据流“外部”）。 Telnet 利用 TCP 的这个特性来定义它所谓的同步功能。

<u>**同步功能**</u>

需要时，如刚才所述的示例，同步功能由客户端调用，发送特殊的 Telnet 数据标记 (DM) 协议命令，同时指示其 TCP 层将该数据标记为“紧急”。携带此命令的 TCP 段中的 URG 位导致它绕过 TCP 的正常流量控制机制，因此它被发送到远程主机。 Telnet 服务器软件看到数据流中的同步，然后搜索其缓冲区中的所有数据，只查找 Telnet 控制命令，例如中断进程、中止输出和你在那里。然后立即执行这些命令。服务器继续搜索重要命令，直到看到数据标记命令为止。所有中间数据都被丢弃；它将需要重新传输。处理完数据标记后，服务器恢复正常运行。

服务器还可以使用同步功能与客户端设备上的用户进行通信。例如，如果用户向服务器发送 Abort Output 命令，他或她是在告诉服务器放弃当前进程的所有剩余输出。服务器将停止发送该输出，并且还可以使用同步功能清除缓冲区中等待发送到客户端机器的所有未完成数据（因为它会导致数据被丢弃，如上所述）。

<u>**关键概念：**</u>Telnet 协议命令与用户数据在同一流中发送，这意味着停止数据流的远程主机出现问题可能会导致用户命令被备份并且永远不会被主机接收。由于这可能包括用户发出的尝试修复主机问题的命令，因此这可能是一个严重的问题。为了缓解这种情况，Telnet 包含同步功能，它使用 TCP 的紧急数据传输功能，即使在没有处理常规数据的情况下也能强制接收重要命令。



##### 4.3.1.6 Telnet 选项和选项协商（部分：1 2 3 4）

基本的 Telnet 网络虚拟终端 (NVT) 规范通过定义每个 Telnet 客户端和服务器使用的数据和命令的通用表示，解决了不同终端和计算机类型之间的兼容性问题。然而，这种通用表示的代价非常高：终端和主机的所有高级或特殊功能都被剥夺了。结果是一种人人都能说的语言，但只能进行基本对话。

Telnet 的创建者认识到，虽然将 NVT 定义为公共基础以确保跨设备兼容性很重要，但提供一些方式也很重要，客户端和服务器可以通过这些方式同意使用更高级的通信方式。他们定义了一组 Telnet 选项，以及 Telnet 客户端和服务器可以协商使用哪些选项的机制。

大多数 Telnet 选项用于提高设备间数据传输效率的目的。例如，默认情况下，NVT 假定半双工操作，每个设备在每次传输后都需要使用 Go Ahead 命令。但是，现在几乎所有硬件都支持全双工通信，因此设备通常会同意使用 Suppress Go Ahead 选项来消除发送此字符的需要。同样，设备可以协商发送 8 位二进制数据而不是 Telnet NVT 的标准 7 位 ASCII。

Telnet 选项协商的过程在主要的 Telnet 标准文档 RFC 854 以及配套文档 RFC 855（Telnet 选项规范）中进行了描述。这些选项本身在一组单独的 Internet 标准中进行了描述。其中一些与 RFC 854 和 855 同时发布；其他的在早期被定义为 Telnet 以前版本的一部分，还有一些是多年来添加的。现在有几十种不同的 Telnet 选项；主列表由 IANA 维护（与所有其他 TCP/IP 参数一样）。

internet ：可以在 IANA 网站上找到所有 Telnet 选项的最新列表：http://www.iana.org/assignments/telnet-options

<u>**常用的 Telnet 选项**</u>

每个 Telnet 选项都使用十进制字节代码标识，可能的值为 0 到 254； 如果需要超过 255 个选项，则保留值 255 以扩展选项列表。 每个选项还有一个与之关联的文本代码字符串，在协议讨论和诊断输出中，它通常用作代替代码编号的符号。 表 282 列出了一些更有趣的 Telnet 选项并提供了每个选项的简要说明。

​                                                                            **表 282：常用 Telnet 选项**

| **Option Number** | **Option Code**            | **Option Name**                            | **Description**                                              | **Defining RFC** |
| ----------------- | -------------------------- | ------------------------------------------ | ------------------------------------------------------------ | ---------------- |
| **0**             | ***TRANSMIT-BINARY\***     | **Binary Transmission**                    | 允许设备以 8 位二进制格式而不是 7 位 ASCII 格式发送数据。    | 856              |
| **1**             | ***ECHO\***                | **Echo**                                   | 当您在终端上按下一个键时，您还希望看到您输入的字符作为输出出现在终端屏幕上；这称为回显输入。回显是终端应用程序中的一个重要问题，因为它可以通过多种不同的方式实现。此选项允许设备协商各种不同回声模式中的任何一种。 | 857              |
| **3**             | ***SUPPRESS-GO-AHEAD\***   | **Suppress Go Ahead**                      | 允许不在半双工模式下运行的设备不再需要使用 Telnet Go Ahead 命令结束传输。 | 858              |
| **5**             | ***STATUS\***              | **Status**                                 | 让设备请求 Telnet 选项的状态。                               | 859              |
| **6**             | ***TIMING-MARK\***         | **Timing Mark**                            | 允许设备协商将特殊时间标记插入数据流，用于同步。             | 860              |
| **10**            | ***NAOCRD\***              | **Output Carriage-Return Disposition**     | 让设备协商如何处理回车。                                     | 652              |
| **11**            | ***NAOHTS\***              | **Output Horizontal Tab Stops**            | 允许设备确定哪些水平制表位位置将用于输出显示。               | 653              |
| **12**            | ***NAOHTD\***              | **Output Horizontal Tab Stop Disposition** | 允许设备协商如何处理水平制表符以及由连接的哪一端处理。       | 654              |
| **13**            | ***NAOFFD\***              | **Output Formfeed Disposition**            | 允许设备协商如何处理换页字符。                               | 655              |
| **14**            | ***NAOVTS\***              | **Output Vertical Tabstops**               | 用于确定将用于输出显示的垂直制表位位置。                     | 656              |
| **15**            | ***NAOVTD\***              | **Output Vertical Tab Disposition**        | 让设备协商垂直制表位的配置。                                 | 657              |
| **16**            | ***NAOLFD\***              | **Output Linefeed Disposition**            | 允许设备决定应如何处理换行字符。                             | 658              |
| **17**            | ***EXTEND-ASCII\***        | **Extended ASCII**                         | 让设备同意使用扩展 ASCII 进行传输并协商如何使用它。          | 698              |
| **24**            | ***TERMINAL-TYPE\***       | **Terminal Type**                          | 允许客户端和服务器协商特定终端类型的使用。如果他们同意，就可以根据用户正在使用的特定终端的需要理想地定制服务器的输出。 | 1091             |
| **31**            | ***NAWS\***                | **Negotiate About Window Size**            | 允许终端窗口大小的通信。                                     | 1073             |
| **32**            | ***TERMINAL-SPEED\***      | **Terminal Speed**                         | 允许设备报告当前的终端速度。                                 | 1079             |
| **33**            | ***TOGGLE-FLOW-CONTROL\*** | **Remote Flow Control**                    | 允许启用和禁用客户端和服务器之间的流量控制。                 | 1372             |
| **34**            | ***LINEMODE\***            | **Linemode**                               | 允许客户端一次发送一行数据而不是一次发送一个字符。这通过用较少数量的较大传输替换大量微小的 TCP 传输来提高性能。 | 1184             |
| **37**            | ***AUTHENTICATION\***      | **Authentication**                         | 让客户端和服务器协商一种身份验证方法以保护连接。             | 1416             |

**关键概念**：Telnet NVT 规范确保所有使用 Telnet 的设备都可以相互交谈，但通过将通信简化为最简单的表示来实现这一点。 为了允许使用更复杂的格式和服务，Telnet 定义了许多选项。 如果客户端和服务器都实现了特定选项，则它们可以通过协商过程启用该选项。

<u>**使用协商启用选项**</u>

Telnet 选项协商的第一阶段是客户端和服务器决定是否要启用特定选项。 Telnet 操作对称性的一个方面是任一设备都可以选择启动一个选项的使用。发起设备可以指定它想要开始使用一个选项，或者它想要其他设备开始使用它。在这两种情况下，响应设备可能同意或不同意；一个选项只有在两个设备都同意使用时才能启用。

该协商使用四个 Telnet 协议命令执行，如下所示：

**WILL**：由发起者发送，表示它想开始使用一个特定的选项。响应设备有两种可能的回复：
				

- DO：发送以表明同意发起者应该使用该选项；然后它被认为是启用的。
- DONT：发送以指定发起者不得使用该选项。


**DO**：由发起者发送，请求其他设备开始使用一个选项。该设备可能以两种方式响应：

- WILL：发送指定响应设备将同意使用该选项；该选项已启用。
- WONT：发送以告知发起者响应者将不会使用所请求的选项。



Telnet 的对称性，再加上 DO 和 WILL 都可以用来发起协商或响应协商，这使得 Telnet 的选项协商可能很复杂。由于任何一个设备都可以随时启动选项协商，如果两个设备都试图同时启用一个选项，或者进入每个都不断响应对方回复的情况，则可能会出现确认循环。

为此，Telnet 标准对何时使用 WILL 和 DO 命令进行了限制。一种是设备只能发送协商命令来请求选项状态的改变；它不能发送 DO 或 WILL 只是为了确认或加强选项的当前状态。另一个是接收到开始使用它已经在使用的选项的请求的设备不应该使用 DO 或 WILL 来确认它。

<u>**禁用选项**</u>
由于一个选项只有在两个设备都同意使用它的情况下才能激活，因此任何一个都可以通过发送以下任一命令随时禁用该选项的使用：

- WONT：由设备发送以指示它将停止使用某个选项。其他设备必须以 DONT 响应作为确认。

- DONT：由设备发送以指示它希望其他设备停止使用某个选项。另一个设备必须以 WONT 响应。

关键概念：任一设备都可以选择协商使用 Telnet 选项。启动器使用 WILL 命令指定它要使用特定选项启动；如果其他设备同意，它会响应 DO；否则，它发送 DONT。或者，发起者可以使用 DO 命令来指示它希望其他设备开始使用一个选项；如果该设备同意，则该设备以 WILL 响应，如果不同意，则以 WONT 响应。任何一个设备都可以随时通过向另一个发送 WONT 或 DONT 命令来禁用选项的使用。

<u>***Option Subnegotiation\***</u>

上面的所有 DO/DONT/WILL/WONT 内容仅用于启用或禁用选项。一些选项只能关闭或打开，在这种情况下，上面的协商就足够了。一个例子是二进制传输选项，TRANSMIT-BINARY。其他人则要求在启用后，客户端和服务器交换参数以控制该选项的工作方式。例如，TERMINAL-TYPE 选项要求客户端通过某种方式向服务器发送终端名称。

Telnet 允许客户端和服务器使用称为选项子协商的过程发送与选项相关的任意数量的数据。设备通过发送一系列特殊的 Telnet 协议命令和数据来开始此过程。首先发送命令 SB，然后发送选项编号和特定选项定义的参数；子协商数据的结尾由协议命令 SE 标记。当然，SB 和 SE 之前都必须有解释为命令 (IAC) 命令字节。

那么，让我们再次以终端类型选项为例。假设服务器支持这个选项并且希望客户端使用它。它会发送：

<u>**IAC DO TERMINAL-TYPE**</u>
注意：为了方便起见，我显示了文本助记符；这实际上将作为三个十进制字节 255 253 24 发送。


假设客户端同意，它将响应：

​		IAC WILL TERMINAL-TYPE
现在终端类型选项生效了，但是服务器仍然不知道客户端使用的是什么终端。它可以提示客户端通过发送以下内容来提供该信息：

​		IAC SB TERMINAL-TYPE SEND IAC SE
收到此“子协商”命令的客户端将响应：

​		IAC SB TERMINAL-TYPE IS <some_terminal_type> IAC SE
**关键概念：**WILL 和 DO 命令只打开客户端和服务器同意使用的 Telnet 选项。在某些情况下，选项需要在客户端和服务器设备之间发送附加信息才能正常运行。这是通过选项子协商过程完成的。任一设备向另一设备发送一组与选项相关的数据，由 SB（子协商）和 SE（结束子协商）Telnet 协议命令括起来。



#### 4.3.2 伯克利远程（“r”）命令

TCP/IP 的成功很大程度上归功于它的普遍性：它几乎已在每个主要计算平台上实现。因此，虽然该套件并不特定于任何操作系统，但不可否认它的历史与特定操作系统 - UNIX 密切相关。早期 Internet 上的大多数计算机都使用 UNIX，TCP/IP 的发展在许多方面与 UNIX 并行。

参与 UNIX 开发并因此间接参与 TCP/IP 开发的最重要组织之一是加州大学伯克利分校。他们著名的 Berkeley Software Distribution (BSD) UNIX 已被广泛使用 20 多年。为 BSD UNIX 开发了一组命令，以促进 TCP/IP 互联网络上的各种远程操作功能。这些程序中的每一个都以字母“r”（“远程”）开头，因此它们被称为 Berkeley 远程命令（或实用程序），也简称为“r”命令。自最初创建以来，它们已被大多数 UNIX 变体和其他一些操作系统采用。

在本节中，我将简要介绍 Berkeley 远程协议及其使用方法。我首先讨论该组中的主要协议 rlogin，以及如何使用它来启用远程主机访问。然后，我将描述远程 shell 程序 rsh，以及它如何允许在网络主机上执行命令。最后，我简要总结了“r”协议家族的其他成员：rcp、ruptime 和 rwho。

**背景信息**：与不了解 UNIX 操作系统的人相比，本节可能对那些了解 UNIX 操作系统的人更有意义。在本节中我还参考了 Telnet，因此您可能希望至少对该协议有基本的了解。

##### 4.3.2.1 Berkeley 远程登录 (rlogin)（部分：1 2）

伯克利远程协议系列的 "head"是远程登录命令，即rlogin。正如其名称所明确暗示的那样，这个程序的目的是允许UNIX主机上的用户通过TCP/IP网络登录到另一台主机上。由于Telnet也经常被用于远程登录，所以rlogin和Telnet有时被认为是TCP/IP远程登录的替代品。虽然它们的使用方式非常相似，然而，它们在一些方面有很大的不同。

从概念的角度来看，Telnet被设计为一个实现终端/主机通信的协议。正如我在Telnet概述主题中提到的，该协议不是专门为远程登录而设计的。相比之下，rlogin是为这一特定目的而设计的，这在它的操作中得到了反映。

<u>**rlogin的操作**</u>
该协议要求在允许远程访问的主机上运行rlogin服务器软件；它通常被称为rlogind（代表rlogin daemon，后一个词是UNIX对后台服务器进程的标准术语）。该服务器在TCP 513端口监听传入的连接请求。一个想远程登录服务器的用户在他或她的本地主机上运行rlogin命令，并指定服务器的名称。客户端与服务器建立一个TCP连接，然后向服务器发送一个包含以下信息的字符串。

- 客户机上用户的登录名。

- 用户想在服务器上使用的登录名（通常与用户在客户端的登录名相同，但不一定。）

- 控制信息，如终端的类型和速度。

服务器处理这些信息并开始登录过程。它通常会提示用户输入密码以登录到远程主机。假设密码正确，用户将被登录到远程主机，并可以像在本地连接一样使用它。

<u>**rlogin与Telnet的比较**</u>
从实用的角度来看，rlogin命令比Telnet简单得多；它不支持Telnet的全部命令结构，也不支持诸如选项协商的功能。然而，它确实包括一小部分命令。客户端能够向服务器发送一个关键信息：正在使用的终端窗口的当前大小。服务器能够告诉客户机打开或关闭流量控制，要求客户机向其发送当前的窗口大小，或刷新服务器已发送的待定输出，直到数据流中的某个点。

<u>**自动化登录**</u>

在某些组织中，每天都使用许多不同的 UNIX 主机，并且在使用 rlogin 时需要一直输入密码被认为是一件苦差事。在这些系统上，管理员可以设置指定主机名、用户名和密码组合的控制文件。如果设置正确，这使授权用户能够利用 rlogin 自动远程访问主机，而无需输入登录名或密码，这可以节省时间。

<u>**rlogin 安全问题和 slogin**</u>
按照最初的设计，rlogin 是 TCP/IP 早期协议的典型示例：它强调简单性和可用性而不是安全性。对于刚刚描述的自动登录过程尤其如此。 rlogin 用于身份验证的原始方案被认为不适用于现代 TCP/IP 互连网络，尤其是那些连接到 Internet 的互连网络。 rlogin 的更高版本已通过更安全的授权方法得到增强。还有一个名为 slogin（用于安全登录）的较新程序，它使用更强大的身份验证和加密，旨在取代较新系统上的 rlogin。

**关键概念**：Berkeley 远程或“r”命令促进了 TCP/IP 互联网络上 UNIX 主机之间的远程操作。该系列的基本命令是远程登录命令 rlogin，它允许一台主机上的设备访问和使用另一台设备，就像他或她在本地连接到它一样。 rlogin 通常用作 Telnet 的替代方法，但在概念和实践上都更简单。



##### 4.3.2.1 伯克利远程 Shell (rsh)

Berkeley 远程登录命令 (rlogin) 允许用户通过 TCP/IP 互联网络轻松访问远程 UNIX 主机。当用户需要登录服务器以执行多项任务时，他或她通常会使用 rlogin。然而，在某些情况下，用户只需要在远程主机上输入一个命令。使用 rlogin，用户必须登录到主机，执行命令，然后再次注销。

这并不是一个惊天动地的不便，特别是当设置了正确的配置文件以允许自动登录时。然而，随着时间的推移，所有额外的登录和注销都会变得乏味。为方便起见，创建了 rlogin 的变体，称为远程 shell (rsh)，它允许用户访问远程主机并在其上执行单个命令，而无需登录和注销步骤。

**注意：**“Shell”是 UNIX 中使用的标准术语，指的是接受用户命令并在屏幕上显示输出的用户界面。

<u>**rsh操作**</u>
rsh 命令是基于 rlogin 的，并且实际上以几乎相同的方式工作，除了它是面向执行命令而不是建立持久登录会话的。远程主机上的服务器进程通常称为 rshd（远程 shell 守护进程）并侦听传入的 rsh 请求。当收到一个时，用户通过与 rlogin 相同的机制登录。该命令随后在远程主机上运行，用户自动注销。

<u>**程序自动使用 rsh**</u>
rsh 在使用自动登录时最有用，这样程序就可以在不需要用户输入登录名或密码的情况下运行。在那种情况下，可以让程序使用 rsh 在远程主机上自动运行命令，而无需人工干预，这为 UNIX 用户开辟了许多可能性。标准输入 (stdin)、标准输出 (stdout) 和标准错误 (stderr) 等标准 UNIX 用户界面概念也适用于 rsh，因此您可以使用它来执行远程命令并将输出重定向到本地文件。例如，此命令可以让用户获取他或她在服务器“<somehost>”上的主目录列表，并将其存储在本地文件“remotelist”中：

```
rsh <somehost> ls -l >remotelist
```

**关键概念：**远程 shell 或 rsh 命令类似于 Berkeley rlogin 命令，但它不是在远程主机上打开登录会话，而是执行单个用户提供的命令。 rsh 对需要在远程主机上执行快速操作的用户很有帮助，也可以被其他程序用来自动执行网络任务。

<u>**rsh 安全问题和 ssh**</u>
由于 rsh 基于 rlogin，因此适用于 rlogin 的所有问题在这里也相关，尤其是与安全性相关的问题。 （我们不希望未经授权的用户在我们的服务器上运行命令，而是登录到它们！）与 rlogin 一样，rsh 的新版本支持比原始软件更高级的身份验证选项。此外，正如 slogin 是更新、更安全的 rlogin 版本一样，有一个名为 ssh（安全 shell）的程序在许多系统上取代了 rsh。

**注意：**在某些系统上，如果在没有指定要执行的命令的情况下输入 rsh，则会建立交互式远程会话，就像输入 rlogin 命令而不是 rsh 一样。



##### 4.3.2.1 其他 Berkeley 远程（“r”）命令（rcp、ruptime、rwho）

rlogin 和 rsh 命令是 Berkeley “r” 系列程序的通用成员，它们允许远程访问主机。为了补充这些，还定义了少量特定的远程命令。这些本质上是一些更常见的 UNIX 功能的远程版本，而不是只应用于一个系统的命令，而是在两个系统之间或在 TCP/IP 网络上的所有系统之间使用。

所有这些命令都基于 rlogin，就像 rsh 一样。它们以相同的方式工作，但它们不是打开会话或将用户指定的命令传递给远程主机，而是执行特定的功能。以下是这些远程命令中最常见的命令，并简要介绍了每个命令的使用方式：

- 远程复制 (rcp)：这是 UNIX 复制 (cp) 命令的远程版本；它允许在本地主机和远程主机之间或两个远程主机之间复制文件。通常的语法与常规 cp 命令基本相同，但源和/或目标被指定为在远程主机上。

- rcp 命令的使用方式类似于 FTP，但更简单且功能更差。或者换句话说：rcp 是 FTP，rlogin 是 Telnet。 （这不是一个完美的类比，但非常接近。）

- Remote Uptime (ruptime)：UNIX 命令 uptime 用于显示计算机自上次启动以来运行了多长时间，以及与其当前负载相关的信息。 ruptime 是这个命令的远程版本；它显示网络上每台机器的当前状态（启动或关闭）、每台启动的机器自上次启动后启动了多长时间及其负载统计信息。

- Remote Who (rwho)：这是 who 命令的远程版本。 where where 显示登录到运行它的主机的所有用户，rwho 显示登录到网络上所有机器的所有用户。

ruptime 和 rwho 命令都依赖于在联网机器的后台运行的 rwhod（远程 who 守护进程）的存在。这些进程定期相互共享有关主机正常运行时间以及谁登录到每个系统的信息，因此可以在运行 ruptime 或 rwho 时快速显示。

在某些操作系统上，还可以执行其他远程命令。与 rlogin 和 rsh 一样，安全问题可能适用于这些命令，并且其他命令（例如 rwho）可能存在效率问题。由于这些原因，在许多网络上不再使用这些命令。

#### 4.3.3 Internet 中继聊天协议 (IRC)（部分：1 2 3）

电子邮件相对于传统邮件的主要优势是速度。不必等待数天或数周才能传递消息，它通常会在几分钟甚至几秒钟内到达。对于大多数类型的信息传输，这使得电子邮件比普通邮政服务更有用。然而，在某些情况下，交付速度不足以使电子邮件成为理想的通信机制。一种这样的情况是需要在两方之间进行对话。

考虑一下，尽管电子邮件可能传递得非常快，但它使用的是一种解耦的通信模型。当 A 向 B 发送电子邮件时，邮件可能会在几秒钟内出现在 B 的收件箱中，但实际上 B 在到达时可能不在身边阅读它。 B 可能要到几个小时后才能看到消息；然后他会向 A 发送回复，而 A 可能暂时看不到它。如果他们正在讨论的主题需要几十次这样的迭代，那么可能需要很长时间才能完成交流。

当然，在现实世界中，我们中的大多数人绝不会使用邮件进行此类对话，而更喜欢我们称之为……电话的高科技通信设备。 J 许多使用计算机的人意识到，让两个或更多人以类似于电话交谈的方式交互式地讨论问题是很有用的。在网络世界中，这通常称为聊天，而设计用于在 TCP/IP 中实现它的第一个也是最重要的应用程序协议之一是 Internet 中继聊天协议 (IRC)。

<u>**IRC 历史和标准**</u>
在 Internet 广泛使用之前，拥有计算机的人们通常会通过拨入公告板系统 (BBS) 或其他专有服务来进行交流。 IRC 最初是由一位名叫 Jarkko Oikarinen 的芬兰绅士根据他在 BBS 上使用聊天应用程序的经验创建的。他于 1988 年编写了第一个客户端和服务器软件；该协议后来在 1993 年 5 月发布的 RFC 1459，Internet 中继聊天协议中正式定义。2000 年 4 月，IRC 标准被修订并增强了几个新的扩展功能，并作为一组四个较小的文档发布：RFC 2810 到 2813 . 其中每一个都专注于 IRC 功能的一个特定领域。

**注意：**RFC 1459 的 RFC 状态为“Experimental”，RFC 2810 至 2813 组指定为“Informational”。这使得 IRC 成为可选的；它不需要在 TCP/IP 设备上实现。

<u>**IRC 通信模型和客户端/服务器操作**</u>

IRC 是一个有趣的协议，因为它并非严格基于 TCP/IP 协议操作的标准客户端/服务器模型。 IRC 服务器是运行 IRC 服务器软件的 TCP/IP 机器。它们配置有允许它们相互建立 TCP 连接的信息；使用 TCP 是因为连接要保持很长时间，并且需要可靠的数据传输。服务器连接用于交换控制信息和用户数据，在应用程序级别形成一个逻辑 IRC 网络，它允许任何服务器使用中间服务器作为管道发送给任何其他服务器。服务器由 IRC 操作员 (IRCops) 管理，他们拥有特殊权限，可以确保网络上的一切顺利运行。

IRC 网络构成了 IRC 通信服务的主干。用户可以通过在任何支持 TCP/IP 的设备上运行 IRC 客户端软件来访问网络。用户输入网络上其中一台服务器的名称，并与该服务器建立 TCP 连接。这会导致用户直接连接到一台服务器，从而间接连接到网络上的所有其他服务器。这允许该用户向连接到该用户的服务器或其他服务器的所有其他用户发送和接收消息。

<u>**群组消息和 IRC 频道**</u>
IRC 中最常见的通信类型是群组消息传递，它是使用 IRC 频道完成的。频道是各种虚拟聚会场所，有时也称为聊天室（尽管 IRC 纯粹主义者嘲笑该术语的使用。）每个 IRC 网络都有成百上千个不同的频道，每个频道都专用于一个特定类型的讨论，从严肃到愚蠢。例如，一群对气象学感兴趣的人可以建立一个名为“#weather”的频道，他们会定期开会讨论气候学的各个方面和有趣的天气事件。

IRC 本质上是一种基于文本的协议（尽管也可以使用 IRC 客户端在用户之间传输任意文件，包括图像和可执行程序。）要在频道中进行通信，用户需要做的就是在适当的位置输入文本点在 IRC 客户端程序上；此文本会自动发送给频道的所有其他成员。 IRC 网络处理这些消息的实时中继，从一个用户到该用户连接的服务器，再到网络中的其他服务器，然后再到这些服务器上的所有用户机器。当其他用户看到第一个用户的消息时，他们可以回复自己的消息，这些消息将依次传播到整个网络。每个 IRC 用户都选择一个昵称（通常缩写为 nick），就像连接到网络时用于通信的“句柄”。

<u>**个人信息**</u>

IRC还支持一对一交流，可用于私密对话。要使用这种方法，用户只需要他或她想与之交谈的另一个用户的昵称即可；他或她使用特殊命令直接向该用户发送消息，该用户可以以实物形式回复。这不是一种安全的通信形式，因为消息未加密，并且它们通过可以监视它们的服务器。然而，典型的 IRC 网络上有如此多的流量，以至于任何给定的消息都不太可能被监视，所以没有太大的担忧（除非你为中央情报局工作或者刚刚开发出治疗普通感冒的方法。）

IRC 协议定义了丰富的命令集，允许用户执行基本功能，例如加入或离开频道、更改昵称、更改服务器、设置频道的操作模式等。确切的命令集和可用的功能取决于用户的 IRC 客户端使用的特定软件，以及 IRC 网络本身可用的功能，并非所有这些都运行相同版本的协议。

IRC 在 1990 年代初期变得非常流行，因为它允许来自 Internet 上任何地方的用户动态地会面和共享信息的强大方式。它不仅像基于文本的“电话”，还允许全球用户进行通信，而无需支付长途电话的费用。

<u>**IRC 和现代互联网**</u>
IRC 最重要的特征之一是它的开放性：它让每个人都可以自由地以他或她认为最好的方式进行交流。例如，每个 IRC 频道都有一个所有者，该所有者拥有与频道使用方式相关的某些权利，包括决定允许哪些人进入频道以及不允许哪些人进入频道的能力。这可能看起来很专制，但 IRC 允许任何人立即启动一个新频道并成为该频道的所有者，而无需事先注册或授权。这意味着如果您不喜欢某个特定频道的运行方式，您可以毫不费力地开始自己的频道；除了为服务器制定的规则（通常只是为了防止滥用）之外，您不会被迫遵守任何人的规则。

同样的原则也适用于 IRC 网络本身——不仅仅是一个单一的 IRC 网络，还有几十个不同的网络。有些是大型的、完善的网络，可能拥有超过 100 台服务器和数千名用户，而另一些则较小，专门用于特定的兴趣领域或地理区域。如果拥有硬件和软件，任何人都可以建立自己的 IRC 网络，而且一些组织实际上已经建立了私有的、专用的 IRC 服务器供自己使用。

许多人认为 IRC 是统称为即时消息的相关交互应用程序最重要的“祖先”。这些服务由多个组织提供，包括美国在线 (AOL)、雅虎！和微软的 MSN。它们背后的想法与IRC非常相似；每个都允许一个用户发送的消息立即显示给另一个用户，尽管大多数主要关注用户到用户的消息而不是组。事实上，即时消息在整体使用上已经超过了 IRC，这可能是因为像 AOL 这样的服务拥有庞大的用户群。然而，IRC 每天仍被成千上万的爱好者广泛用于娱乐和商业目的。

### 4.4 TCP/IP 管理和故障排除实用程序和协议

专门介绍 TCP/IP 应用程序和应用程序协议的大节的前两个大节分别讨论了文件和消息传输应用程序以及交互式和远程访问应用程序。这些是 TCP/IP 互联网络用户最常使用的经典应用程序。由于它们是用户进行通信的方式，因此在某些方面可以将它们视为 TCP/IP 和 Internet 本身的“存在理由”。

相比之下，第三小节有点不同。它不描述为最终用户设计的应用程序。相反，它讨论了一组 TCP/IP 故障排除实用程序和协议，它们通常是互联网络管理员的职责范围。尽管数以百万计的人每天都在使用 TCP/IP，甚至不知道这些应用程序的存在——更不用说它们是如何工作的——但它们对于维护 TCP/IP 互联网络的人来说至关重要。由于你们中的许多人正在研究 TCP/IP，以便您可以实施和管理这项技术，因此了解这些应用程序的工作原理非常值得您花时间。

在本节中，我提供了一些软件实用程序的概述，这些实用程序通常用于帮助设置、配置和维护 TCP/IP 互联网络。这些程序允许网络管理员执行检查主机身份等功能；验证两台主机之间的连通性；检查设备之间路由器的路径；检查计算机的配置；查找 DNS 域名；以及更多。

注意：本节的目的是解释故障排除实用程序的一般用途和功能，以便您了解它们如何帮助您管理 TCP/IP 网络。作为这些描述的一部分，我演示了用于在 UNIX 和 Windows 中调用每个实用程序的典型语法。虽然我已尝试在这些描述中做到非常完整，但它们只是为了让您更好地了解这些程序的功能 — 本节不应被视为这些实用程序的参考手册。由于软件实现的差异，请查阅您的操作系统文档以了解有关每个程序应如何在您自己的网络上使用的详细信息。在 Windows 系统上，尝试“<program> /?”查看程序的语法；在 UNIX/Linux 上尝试“man <program>”。

**背景信息：**本节中描述的许多软件工具旨在管理其他 TCP/IP 协议的操作，例如 Internet 协议、域名系统或动态主机配置协议。要充分了解这些实用程序的工作原理，您需要了解这些和其他关键 TCP/IP 协议的基础知识。特别是，此处讨论的许多实用程序使用 ICMP 消息进行通信，因此我建议在继续之前熟悉 ICMP。



#### 4.4.1 TCP/IP 主机名实用程序（hostname）

他们说最好的起点是起点。因此，在检查 TCP/IP 管理和故障排除实用程序时，为什么不从基础开始呢？诊断联网计算机问题的最基本任务之一是识别它。正如我们遇到某人时通常做的第一件事是交换姓名一样，管理员在访问设备时首先采取的行动之一就是确定其名称（如果不知道）。这是使用主机名实用程序完成的。

您可能还记得我们对 TCP/IP 名称系统的讨论，有两种不同的主机命名方式。第一种方法是使用主机表或等效方法手动为设备分配“平面”名称；这最常用于不会在公共互联网上访问的设备。第二种是在域名系统 (DNS) 中为设备提供域名。 hostname 实用程序可用于两种类型的命名主机，但它对每种类型的功能略有不同。

在大多数系统上，包括 Windows 和许多 UNIX 实现，主机名实用程序非常非常简单。当在没有参数的行中单独输入命令时，它会显示主机的全名。如果与“-s”（“短”）参数一起输入，则如果主机名是完全限定的 DNS 域名，则仅显示节点的本地标签，而不显示完整域名；如果主机具有平面（非 DNS）名称，则该参数无效。表 283 中显示了一个简单示例。


​                                                             **表 283：使用主机名实用程序检查主机名**

```
% hostname
fearn.pair.com
% hostname -s
fearn
```


主机名实用程序还旨在允许管理员设置主机名。这个语法也很简单；您只需提供主机名作为参数，如下所示：

​		hostname <new_hostname>
然而，在大多数实现中，使用主机名命令设置设备名称要么被禁用要么被限制。在 Windows 系统中，控制面板中有一个特殊的小程序用于设置设备的名称；尝试使用主机名设置它会导致错误消息。在 UNIX 中，系统的超级用户可以使用主机名来设置设备的名称，但更常见的是通过其他方式来完成，例如编辑配置文件 /etc/hosts。显然，如果为该主机分配一个简单的平面名称，则管理员可以完全控制它，而如果使用 DNS，则必须遵循正确的名称注册程序。

在大多数操作系统中，“-s”参数是该命令唯一支持的参数。但是，并非所有“主机名”命令的实现都支持该参数；在其中一些上，如果您使用“hostname -s”，系统可能会将其主机名报告为“-s”。在某些 Linux 系统上，包含一些附加参数，允许以不同方式显示主机名，以及一些杂项功能，例如显示程序的版本号。

注意：值得一提的一点是，严格来说，主机名实用程序并未绑定到 DNS 或其他用于识别主机的正式机制的操作中。它只显示管理员设置的显示内容。显然将其设置为主机的 DNS 名称是有意义的，但也可能有例外。

**关键概念：**最简单和最基本的 TCP/IP 管理实用程序是主机名，它返回运行它的主机的名称。



#### 4.4.2 TCP/IP 通信验证实用程序 (ping/ping6)（部分：1 2 3 4 5）

网络管理员经常需要解决的最常见问题之一是两台主机无法通信。例如，公司网络上的用户可能无法从本地服务器检索他的文件之一，或者另一个用户可能无法加载她最喜欢的网站。在这些和许多类似的情况下，诊断问题的一个重要步骤是验证两台机器上的 TCP/IP 软件堆栈之间是否可以进行基本通信。这通常使用 ping 实用程序或 IPv6 实现中的 ping6 来完成。

**注意：**有人说“ping”是“Packet Internet Groper”的首字母缩写词，而其他人坚持认为它实际上是基于使用该术语来指代潜艇发送的声纳脉冲以检查附近的物体。我真的不知道哪一个是真的，但我更喜欢第二种解释。考虑到该实用程序的工作方式类似于声纳“ping”，并且它最初是由一位名叫 Mike Muuss 的绅士编写的，他曾在美国陆军弹道学研究实验室工作。第一种解释较弱；有可能，但是“Packet Internet Groper”这个短语并不是真正符合语法的，我什至不想去想这个实用程序应该“摸索”的是什么！


ping 诊断实用程序是最常用的诊断实用程序之一，几乎出现在每个 TCP/IP 实现中。它通常作为命令行实用程序实现和访问，尽管现在在某些操作系统上也有图形和基于菜单的程序版本。

<u>**ping 实用程序的操作**</u>

ping 实用程序是使用 ICMP Echo（请求）和 Echo Reply 消息实现的。正如讨论这些消息类型的主题中所解释的那样，它们是专门为这些类型的诊断目的而设计的。当设备 A 向设备 B 发送 ICMP Echo 消息时，设备 B 通过向设备 A 发送回 ICMP Echo Reply 消息进行响应。ICMPv6（ICMP 的 IPv6 版本）中存在相同的功能； ICMPv6 Echo 和 Echo Reply 消息仅在字段结构上与 IPv4 消息略有不同。

这似乎表明 ping 将是一个极其简单的实用程序，它会发送一个 Echo 消息并等待查看是否收到回显回复；如果是这样，那么这将表明这两个设备能够通信，如果不是，这将表明两者之间的互联网络某处存在问题。然而，几乎所有的 ping 实现都比这复杂得多。他们使用多组 Echo 和 Echo Reply 消息，以及相当多的内部逻辑，以允许管理员确定以下所有内容，以及更多：

- 两个设备是否可以通信；

- 是否存在拥塞或其他问题，有时可以使通信成功，但有时会导致通信失败，这被视为数据包丢失——如果是，损失的严重程度；

- 在设备之间发送一条简单的 ICMP 消息需要多少时间，它指示主机之间的整体延迟，还指示是否存在某些类型的问题。

<u>**基本ping使用**</u>

ping命令最基本的用法就是自己输入一个主机的IP地址。几乎所有的实现都允许使用主机名，主机名将自动解析为 IP 地址。当在没有附加选项的情况下调用实用程序时，默认值用于参数，例如要发送的消息大小、要发送的消息数、等待回复的时间等。该实用程序将向主机发送一系列 Echo 消息，并报告是否收到了每个消息的回复；如果看到回复，它还会显示收到回复所需的时间。程序完成后，它将提供一个统计摘要，显示收到回复的 Echo 消息的百分比，以及收到回复的平均时间。

表 284 显示了在 Windows XP 计算机（我的！）上使用 ping 命令的示例，它默认发送四个 32 字节的 Echo 消息，并在考虑丢失 Echo 消息之前等待四秒钟。我使用的卫星互联网连接具有相当高的延迟，并且偶尔也会丢失数据包。这对我来说不是很好，但它有助于说明 ping 的工作原理。


​                                                                     **表 284：使用 ping 实用程序验证通信**

```
D:\aa>ping www.pcguide.com
Pinging pcguide.com [209.68.14.80] with 32 bytes of data:

Reply from 209.68.14.80: bytes=32 time=582ms TTL=56
Reply from 209.68.14.80: bytes=32 time=601ms TTL=56
Request timed out.
Reply from 209.68.14.80: bytes=32 time=583ms TTL=56

Ping statistics for 209.68.14.80:
Packets: Sent = 4, Received = 3, Lost = 1 (25% loss),
Approximate round trip times in milli-seconds:
Minimum = 582ms, Maximum = 601ms, Average = 588ms
```

<u>**使用 ping 诊断连接问题的方法**</u>

大多数人发现使用具有默认设置的 ping 足以满足他们的需要。事实上，该实用程序可以以这种最简单的形式使用来执行数量惊人的诊断检查。在许多情况下，ping 命令可用于诊断连接问题，方法是按顺序多次使用它，通常从检查传输设备或靠近传输设备开始，然后向外检测到发现通信问题的其他设备。如何以这种方式使用 ping 的一些示例：

- 内部设备 TCP/IP 堆栈操作：通过对设备自己的地址执行 ping，您可以验证其内部 TCP/IP 堆栈是否正常工作。这也可以使用标准 IP 环回地址 127.0.0.1 来完成。

- 本地网络连接：如果内部测试成功，最好在本地网络上的另一台设备上执行 ping 操作，以验证本地通信是否可行。

- 本地路由器操作：如果本地网络没有问题，则可以对设备正在使用的任何本地路由器执行 ping 操作，以确保它正在运行并且可以访问。

- 域名解析功能：如果对 DNS 域名执行的 ping 失败，您应该尝试使用设备的 IP 地址。如果可行，则意味着域名配置或解析存在问题。

- 远程主机操作：如果上述所有检查都成功，您可以尝试 ping 远程主机以查看它是否响应。如果没有，您可以尝试使用不同的远程主机；如果那个有效，则问题实际上可能出在第一个远程设备本身而不是您的本地设备上。

**注意：**虽然无法从设备获得对 ping 的响应传统上被解释为通信中的问题，但情况并非总是如此。在当前安全意识增强的时代，一些网络被设置为不响应 Echo 消息，以防止使用此类消息泛滥的攻击。在这种情况下，ping 将失败，即使主机可能非常可达。

**关键概念：**TCP/IP ping 实用程序用于验证 TCP/IP 互联网络上两个设备的通信能力。它通过让一台设备向另一台设备发送 ICMP Echo（请求）消息进行操作，另一台设备使用 Echo Reply 消息进行响应。该程序有助于诊断许多连接问题，尤其是当它用于测试与不同位置的其他设备通信的能力时。它还允许估计与另一个设备交换消息的平均往返延迟。

<u>**ping 选项和参数**</u>

所有 ping 实施都包括许多选项和参数，允许管理员微调其工作方式。它们允许 ping 用于更广泛或特定类型的测试。例如，可以将 ping 设置为连续发送 Echo 消息的模式，以检查长时间内是否存在间歇性问题。您还可以增加发送消息的大小或发送消息的频率，以测试本地网络处理大量流量的能力。

与往常一样，ping 程序的确切功能是依赖于实现的；尽管 UNIX 和 Windows 系统通常包含许多相同的选项，但它们通常使用完全不同的选项代码。表 285 显示了一些通常为许多 UNIX 系统上的实用程序定义的更重要的选项，以及在适当情况下随选项提供的参数。表 286 显示了典型 Windows 系统的比较表。

​                                                              **表 285：通用 UNIX ping 实用程序选项和参数**

| **Option / Parameters**   | **Description**                                              |
| ------------------------- | ------------------------------------------------------------ |
| ***-c <count>\***         | 指定应发送的 Echo 消息数。                                   |
| ***-f\***                 | 洪水模式；高速发送Echo包对网络进行压力测试。如果不小心使用，这可能会导致严重的问题！ |
| ***-i <wait-interval>\*** | 告诉实用程序在传输之间等待多长时间。                         |
| ***-m <ttl-value>\***     | 覆盖传出 Echo 消息的默认生存时间 (TTL) 值。                  |
| ***-n\***                 | 仅数字输出；禁止查找 DNS 主机名以节省时间。                  |
| ***-p <pattern>\***       | 允许指定字节模式以包含在传输的 Echo 消息中。这对于诊断可能仅在某些类型的传输中出现的某些奇怪问题很有用。 |
| ***-q\***                 | 告诉实用程序包括 Record Route IP 选项，以便可以显示 ICMP Echo 消息采用的路由。并非所有实现都支持此选项； traceroute 实用程序通常是一个更好的主意。 |
| ***-R\***                 | 指定要使用的传出消息的大小。                                 |
| ***-s <packet-size>\***   | 指定要使用的传出消息的大小。                                 |
| ***-S <src-addr>\***      | 在具有多个 IP 接口（地址）的设备上，允许从一个接口发送的 ping 使用来自其他接口之一的地址。 |
| ***-t <timeout>\***       | 指定一个超时期限（以秒为单位），在此之后 ping 实用程序将终止，而不管已发送或接收了多少请求或答复。 |

​                                  **Table 286: Common Windows \*ping\* Utility Options and Parameters**

| **Option / Parameters** | **Description**                                              |
| ----------------------- | ------------------------------------------------------------ |
| ***-a\***               | 如果目标设备指定为 IP 地址，则强制将地址解析为 DNS 主机名并显示。 |
| ***-f\***               | 在传出数据报中设置 Don't Fragment 位。                       |
| ***-i <ttl-value>\***   | 指定用于传出 Echo 消息的 TTL 值。                            |
| ***-j <host-list>\***   | 使用指定的松散源路由发送传出消息。                           |
| ***-k <host-list>\***   | 使用指示的严格源路由发送传出消息。                           |
| ***-l <buffer-size>\*** | 指定传输的 Echo 消息中数据字段的大小。                       |
| ***-n <count>\***       | 告诉实用程序要发送多少 Echo 消息。                           |
| ***-r <count>\***       | 指定记录路由 IP 选项的使用和要记录的跃点数。与相应的 UNIX“-R”选项一样，traceroute 实用程序通常更可取。 |
| ***-s <count>\***       | 指定使用 IP Timestamp 选项来记录 Echo 和 Echo Reply 消息的到达时间。 |
| ***-t\***               | 不断发送 Echo 消息，直到程序被中断。                         |
| ***-w <timeout>\***     | 指定程序在放弃之前应等待每个 Echo Reply 的时间，以毫秒为单位（默认为 4000，即 4 秒）。 |



<u>**ping6 实用程序**</u>
ping 的 IPv6 版本（有时称为 ping6）与 IPv4 ping 的工作方式非常相似。 这两个实用程序之间的主要区别在于 ping6 的选项和参数反映了 IPv6 中寻址和路由的变化。



#### 4.4.3 TCP/IP 路由跟踪实用程序 (traceroute/tracert/traceroute6)（部分：1 2 3 4）

上一主题中描述的 ping 实用程序对于检查两个设备是否能够相互通信非常有用。但是，它提供的关于这两个设备之间发生的事情的信息很少。如果 ping 显示完全无法通信或间歇性连接且传输数据大量丢失，我们需要更多地了解 IP 数据报在互联网上传输时发生了什么。当两个设备彼此相距很远时，这一点尤其重要，尤其是当我们试图访问公共互联网上的服务器时。

我在 IP 数据报传递概述中描述过，当两个设备不在同一网络上时，它们之间发送的数据必须从一个网络传递到下一个网络，直到到达目的地。这意味着任何时候数据从一个网络上的设备 A 发送到另一个网络上的设备 B 时，都会遵循一条路径，每次传输可能都不相同。

当出现通信问题时，能够检查两个设备之间的数据所采用的具体路径是非常有用的。为此功能提供了一个特殊的路由跟踪实用程序，称为 traceroute（Windows 系统中的缩写 tracert，是 DOS 程序名称的旧八字符限制的遗留物）。该程序的 IPv6 等价物称为 traceroute6。

<u>**traceroute 实用程序的操作**</u>

与 ping 实用程序一样，traceroute 是使用 ICMP 消息实现的。但是，与 ping 不同的是，traceroute 最初并非设计为使用专门用于路由跟踪的特殊 ICMP 消息类型。相反，它巧妙地利用了旨在防止路由问题的 IP 和 ICMP 功能。

回想一下，IP 数据报格式包括生存时间 (TTL) 字段。该字段设置为数据报在必须被丢弃之前可以转发的最大次数；它的存在是为了防止数据报无休止地在互联网上循环。如果由于 TTL 字段过期而必须丢弃数据报，则丢弃它的设备应该向发送该数据报的设备发送回 ICMP 超时消息。这在描述该消息的主题中有更详细的解释。

在正常情况下，这只会在出现问题时发生，例如路由器环路或其他错误配置问题。 traceroute 的作用是通过故意将测试数据报中的 TTL 值设置为太低的值以使其无法到达目的地，从而强制路由中的每个路由器向其返回报告。

假设我们有设备 A 和设备 B，它们被路由器 R1 和 R2 分开——总共三跳。如果您执行从设备 A 到设备 B 的跟踪路由，则会发生以下情况：

1. traceroute 实用程序将虚拟 UDP 消息（有时称为探测）发送到故意选择为无效的端口号。 IP 数据报的 TTL 字段设置为 1。当 R1 收到消息时，它会将该字段递减，这将使它的值为 0。该路由器丢弃探测并将 ICMP Time Exceeded 消息发送回设备 A。

2. 然后，设备 A 发送第二条 TTL 字段设置为 2 的 UDP 消息。这一次，R1 将 TTL 值减为 1 并将其发送到 R2，R2 将 TTL 字段减为 0 并将超时消息发送回 A。

3. 设备 A 发送第三条 UDP 消息，TTL 字段设置为 3。这一次，该消息将通过两个路由器并被设备 B 接收。但是，由于端口号无效，该消息被设备 B 拒绝，它向设备 A 发送回 Destination Unreachable 消息。

这个过程如图 321 所示。有趣的是，我们看到 A 向 B 发送了三个消息，并返回了三个错误消息，并且很高兴！ J 因此，到设备 B 的路由由按顺序发回错误消息的设备的身份指示。通过跟踪发送每个 UDP 消息和收到相应错误消息之间的时间，traceroute 实用程序还可以显示与每个设备通信所花费的时间。实际上，通常每个 TTL 值都会发送三个虚拟消息，因此如果需要，用户可以对它们的传输时间进行平均。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\utiltraceroute.png)


​                                                               **图 321：traceroute/tracert 实用程序的操作**

traceroute 实用程序通过强制它们报告路由数据报的失败来识别路由中的设备，这些数据报的参数有意设置为无效值。设备 A 在此处发送的第一条消息的生存时间 (TTL) 值为 1，这将导致 R1 丢弃它并向 A 发送回 ICMP Time Exceeded 消息。第二条消息的 TTL 值为 2，因此它将被 R2 丢弃和报告。第三个将通过两个路由器并到达目标主机 B，但由于该消息是故意使用虚假端口号选择的，这将导致返回 ICMP Destination Unreachable。这些错误消息标识设备 A 和 B 之间路由中的设备顺序。

**关键概念：**traceroute 实用程序将 ping 背后的想法更进一步，不仅可以检查两个设备之间的通信，还可以让管理员查看这对设备之间所有中间设备的列表。它的工作原理是让发起主机发送一系列带有 TTL 值的测试数据报，这些 TTL 值会导致每个测试数据报在路由上的每个设备上按顺序过期。 traceroute 程序还显示在发送主机和目标设备之间与每个设备通信所花费的时间。

<u>**traceroute 实用程序的基本使用**</u>

表 287 显示了我定期使用的两台 UNIX 计算机之间发送的跟踪路由示例。 我添加了“-q2”参数以将每跳三个虚拟消息的默认值更改为两个，因此输出更适合其显示表。 在这种情况下，服务器之间相隔 14 个跃点。 请注意经过的时间通常如何随着与传输设备的距离增加而增加，但由于任意两个设备之间的延迟中的随机元素，它并不一致（例如，请参见第 10 跳中的不协调大值）。 还要注意第七跳中的星号（“*”），这意味着在 TTL 值为 7 的第二次传输的超时期限之前没有收到任何响应。最后，对于 #13 跳根本没有报告； 此机器可能已配置为不发送超时消息。


​                                                      **表 287：使用 traceroute 实用程序进行路由跟踪**

```
traceroute -q2 www.pcguide.com
traceroute to www.pcguide.com (209.68.14.80), 40 hops max, 40 byte packets
1 cisco0fe0-0-1.bf.sover.net (209.198.87.10) 1.223 ms 1.143 ms
2 cisco1fe0.bf.sover.net (209.198.87.12) 1.265 ms 1.117 ms
3 cisco0a5-0-102.wnskvtao.sover.net (216.114.153.170) 8.004 ms 7.270 ms
4 207.136.212.234 (207.136.212.234) 7.163 ms 7.601 ms
5 sl-gw18-nyc-2-0.sprintlink.net (144.232.228.145) 15.948 ms 20.931 ms
6 sl-bb21-nyc-12-1.sprintlink.net (144.232.13.162) 21.578 ms 16.324 ms
7 sl-bb27-pen-12-0.sprintlink.net (144.232.20.97) 18.296 ms *
8 sl-bb24-pen-15-0.sprintlink.net (144.232.16.81) 18.041 ms 18.338 ms
9 sl-bb26-rly-0-0.sprintlink.net (144.232.20.111) 20.259 ms 21.648 ms
10 sl-bb20-rly-12-0.sprintlink.net (144.232.7.249) 132.302 ms 37.825 ms
11 sl-gw9-rly-8-0.sprintlink.net (144.232.14.22) 23.085 ms 20.082 ms
12 sl-exped4-1-0.sprintlink.net (144.232.248.126) 43.374 ms 42.274 ms
13 * *
14 pcguide.com (209.68.14.80) 41.310 ms 49.455 ms
```

在某些情况下可能会显示额外的“异常”结果。例如，traceroute 程序可能会显示诸如“!H”、“!N”或“!P”之类的代码，以分别指示收到针对主机、网络或协议的意外目标无法到达消息。还可能存在其他错误消息，具体取决于实施方式。

注意：并非所有 traceroute 实用程序实现都使用上述技术。 Microsoft 的 tracert 不是通过发送 UDP 数据包而是通过增加 TTL 值的 ICMP Echo 消息来工作的。当它返回 Echo Reply 消息时，它知道它已经到达最终主机。 1993 年还开发了一种特殊的 ICMP Traceroute 消息，旨在通过消除每次路由跟踪发送许多 UDP 消息的需要来提高 traceroute 的效率。尽管它具有技术优势，但由于它是在 TCP/IP 广泛部署很久之后才引入的，因此它从未成为正式的 Internet 标准，并且不像传统方法那样常见。

<u>**traceroute 选项和参数**</u>

与 ping 一样，traceroute 可以与 IP 地址或主机名一起使用。 如果没有提供参数，关键参数将使用默认值； 在我使用的系统上，每个 TTL 值的默认设置是三个“探测”，最多测试 64 跳，数据包大小为 40 字节。 但是，还支持许多选项和参数，使管理员能够更好地控制实用程序的功能（例如我在表 287 中使用的“-q”参数）。 表 288 描述了 UNIX 系统中的一些典型选项，而 Windows 中存在少量选项，如表 289 所示。


​                                                     **表 288：通用 UNIX traceroute 实用程序选项和参数**

| **Option / Parameters**       | **Description**                                              |
| ----------------------------- | ------------------------------------------------------------ |
| ***-g <host-list>\***         | 指定要用于跟踪的源路由。                                     |
| ***-M <initial-ttl-value>\*** | 覆盖第一个传出探测消息的初始 TTL 值的默认值 1。              |
| ***-m <max-ttl-value>\***     | 设置要使用的最大 TTL 值；这限制了实用程序尝试跟踪的路线的长度。 |
| ***-n\***                     | 仅使用数字地址显示路由，而不是同时显示 IP 地址和主机名。这通过使实用程序不必在路由中的所有设备上执行反向 DNS 查找来加快显示速度（ICMP 消息使用 IP 地址，而不是域名。） |
| ***-p <port-number>\***       | 指定用作探测消息目的地的端口号。                             |
| ***-q <queries>\***           | 告诉实用程序有多少探测发送到路由中的每个设备（默认为 3）。   |
| ***-r\***                     | 告诉程序绕过正常的路由表并直接发送到连接网络上的主机。       |
| ***-s <src-addr>\***          | 在具有多个 IP 接口（地址）的设备上，允许设备在使用另一个接口的跟踪路由上使用来自一个接口的地址。 |
| ***-S\***                     | 指示程序显示未收到回复的探测数量的摘要。                     |
| ***-v\***                     | 设置详细输出模式，通知用户在跟踪期间收到的所有 ICMP 消息。   |
| ***-w <wait-time>\***         | 指定实用程序应等待对每个探测的答复的时间，以秒为单位（典型默认值为 3 到 5）。 |

​                                                            **表 289：常用 Windows tracert 实用程序选项和参数**

| **Option / Parameters**  | **Description**                                              |
| ------------------------ | ------------------------------------------------------------ |
| ***-d\***                | 仅使用数字地址显示路由，而不是同时显示 IP 地址和主机名，以便更快地显示。这与 UNIX 系统上的“-n”选项相同。 |
| ***-h <maximum-hops>\*** | 指定用于跟踪的最大跳数；默认值为 30。                        |
| ***-j <host-list>\***    | 使用指定的松散源路由发送传出探测。                           |
| ***-w <wait-time>\***    | 指定等待对每个探测的答复的时间，以毫秒为单位（默认为 4000，即 4 秒）。 |

<u>**traceroute6 实用程序**</u>
traceroute6 实用程序是 traceroute 的 IPv6 版本，其功能与其 IPv4 前身非常相似。 它显然使用 IPv6 数据报而不是 IPv4 数据报，并且来自被跟踪设备的响应采用 ICMPv6 超时和目标不可达消息的形式，而不是 ICMPv4 对应形式。



#### 4.4.4 TCP/IP 地址解析协议实用程序 (arp)（部分：1 2）

TCP/IP 允许我们通过将各个网络连接在一起来创建非常大的互联网络。当我们在不同网络上的设备之间发送数据时，数据是使用 Internet 协议在网络之间路由的。这使我们甚至可以将全球互联网等巨大的互联网络视为一个单一的大型网络。互联网上的所有设备都被认为是在第三层虚拟连接的，因为路由过程允许任何设备与任何其他设备通信。

但是，远程网络上的设备无法直接通信。第三层的互联网络通信实际上由许多步骤组成，称为跃点，将数据从源传输到目的地。路由中的每一跳都需要在一对硬件设备之间发送数据，并且每次传输都必须使用第二层硬件地址。由于 TCP/IP 使用第三层地址，这意味着每个跃点都需要我们将跃点目标的 IP 地址转换为硬件地址。这称为地址解析；为什么需要它的原因和使用它的方法在地址解析概念一节中有详细解释。

在 TCP/IP 中，地址解析功能由恰当命名的地址解析协议 (ARP) 执行。当设备需要向具有特定 IP 地址的设备传输数据时，它可以使用 ARP 的请求/回复消息协议来找出与该 IP 地址对应的硬件设备。然而，每次这样的消息交换都需要时间和网络带宽，因此为了提高效率，每个设备都维护一个 ARP 缓存，这是一个包含 IP 和硬件地址之间映射的表。 ARP 缓存表可以包含为频繁访问的设备手动插入的静态缓存条目和在完成请求/回复解析时自动输入的动态条目的组合，因此下次需要发送到该设备，可以避免查找过程。

<u>**arp 实用命令**</u>

为了允许管理员管理这个 ARP 缓存表，TCP/IP 设备包含一个 arp 实用程序。它具有三个基本功能，可使用三个不同版本的命令调用（这一次在 UNIX 和 Windows 中是相同的！）：

ARP 缓存表显示（“arp -a”）：当“-a”选项与实用程序一起使用时，它会显示 ARP 缓存表的当前内容。表中的每个条目都显示了一个设备（实际上是接口）的 IP 地址和硬件地址对；通常还会指示每个条目是静态的还是动态的

- 显示的确切格式因一种实现而异；一些程序显示 IP 地址，而另一些程序显示主机名，还有一些程序可能同时显示两者。某些系统默认显示主机名，但也允许使用“-n”选项来强制仅显示 IP 地址而不显示名称。

- ARP 缓存表条目添加（“arp -s <host-name> <hw-addr>”）：此语法允许管理员创建一个新的手动 ARP 缓存表条目，将给定的主机名映射到指定的硬件地址。

- ARP 缓存表条目删除（“arp -d <host-name>”）：此命令从表中删除指定的缓存条目。一些实现允许添加另一个参数来指定应从缓存中删除所有条目。

<u>**额外的 arp 功能**</u>
该软件的某些版本还可以使用附加功能来补充这些基本命令。 UNIX 系统上一个常见的附加选项是能够指定一个可以从中读取缓存表条目的文件，使用“arp -f <file-name>”。与使用“arp -s”手动输入每个条目相比，这节省了大量时间和精力。

另请注意，对导致 ARP 缓存表更改的选项的访问可能会被操作系统限制为仅授权用户。删除函数尤其如此，尤其是允许删除整个 ARP 表的函数更是如此。杰

**关键概念：**管理员使用 TCP/IP arp 实用程序检查或修改主机的 ARP 缓存表，该表包含 TCP/IP 主机名和 IP 地址之间的映射。



#### 4.4.5 TCP/IP DNS 名称解析和信息查找实用程序（nslookup、host 和 dig）（部分：1 2 3 4 5）

域名系统 (DNS) 是 TCP/IP 互联网络的一个极其重要的部分，尤其是现代 Internet，因为它允许使用易于记忆的名称而不是混淆的数字地址来访问主机。 DNS 的运行涉及两种主要类型的设备：存储有关域的信息的 DNS 名称服务器，以及查询 DNS 服务器以将名称转换为地址以及执行其他必要功能的 DNS 解析器。

互联网用户持续使用 DNS 解析器将 DNS 名称转换为地址，但在正常情况下，它们总是被间接调用。每次用户在万维网浏览器或 FTP 客户端等程序中键入 DNS 名称时，甚至在本节中的其他实用程序之一（如 ping 或 traceroute）中使用它时，解析器都会自动执行名称解析，而无需用户不得不问。因此，用户无需手动将 DNS 名称解析为地址。

但是，管理员通常确实需要手动执行 DNS 解析。例如，在解决问题时，管理员可能知道主机名但不知道其地址；在出现安全问题的情况下，地址可能会出现在日志文件中，但主机名可能是未知的。此外，即使用户不需要知道定义 DNS 域的资源记录的细节，管理员通常也需要能够检查这些细节，以确保域设置正确。最后，管理员还需要一些方法来自己诊断 DNS 服务器的问题。

<u>**nslookup 实用程序**</u>

为了支持所有这些需求，现代 TCP/IP 实现配备了一个或多个 DNS 名称解析和信息查找实用程序。最常见的 DNS 诊断实用程序之一是 nslookup（“名称服务器查找”），它已经存在多年。程序如何实现的细节当然取决于操作系统，尽管它们中的大多数在操作和设置上都非常相似。该实用程序通常可以在两种模式下使用：交互式或非交互式。

<u>**nslookup 的非交互式使用**</u>
nslookup 的非交互式版本是最简单的，当管理员想要快速将名称转换为地址时最常使用，反之亦然。它通过使用以下简单语法发出 nslookup 命令来运行：

```
nslookup <host> [<server>]
```

这里的“<host>”可以是DNS域名，此时会进行正常的解析，也可以是IP地址，nslookup会进行反向解析，返回关联的DNS域名。 “<server>”参数是可选的；如果省略，程序将使用发出命令的主机的默认名称服务器。表 290 显示了一个非交互式使用 nslookup 的简单示例。

​                                                    **表 290：使用 nslookup 实用程序的 DNS 名称解析**

```
D:\aa>nslookup www.pcguide.com
Server: ns1-mar.starband.com
Address: 148.78.249.200

Non-authoritative answer:
Name: pcguide.com
Address: 209.68.14.80
Aliases: www.pcguide.com
```

这个例子是在我使用 Starband 卫星互联网服务的家用 PC 上完成的； 它被配置为使用 Starband 的名称服务器（“ns1-mar.starband.com”）。 此处提供的答案被标记为“非权威”，因为它不是来自作为 www.pcguide.com 的 DNS 权威的 DNS 名称服务器之一，而是来自 Starband 名称服务器的 DNS 缓存。

**注意：**也可以指定一个或多个选项来修改非交互模式下的查找行为。 这些选项与表 291 中描述的 nslookup set 命令控制的参数相同； 它们是通过在它们前面加上破折号来指定的。 例如，“nslookup -timeout=10 www.pcguide.com”将执行与表 290 中相同的查找，但超时间隔设置为 10 秒。

<u>**nslookup 的交互式使用**</u>

nslookup 的交互模式是通过简单地发出不带参数的命令名称来选择的。 这将导致程序显示当前默认名称服务器的 DNS 名称和地址，然后提供管理员可以输入命令的提示。 交互模式允许某人轻松地执行多次查找，而不必每次都键入“nslookup”。 更重要的是，它可以更方便地控制可以请求的信息类型以及如何执行查找。

nslookup 实现中可用的确切命令集通常可以通过发出命令“help”或“？”来确定。 在 nslookup 提示符下。 表 291 显示了大多数 nslookup 实现中常见的一些命令。

​                                                                     表 291：典型的 nslookup 实用程序命令

| **Command and Parameters**    | **Description**                                              |
| ----------------------------- | ------------------------------------------------------------ |
| ***<host> [<server>]\***      | 查找指定的主机，可以选择使用指定的 DNS 名称服务器。请注意，这里没有实际的命令，您只需在命令提示符下直接输入名称即可。 |
| ***server <server>\***        | 使用从当前默认服务器获取的信息将默认服务器更改为 <server>。  |
| ***lserver <server>\***       | 将默认服务器更改为 <server>，使用从初始名称服务器获得的信息，即启动 nslookup 命令时系统的默认服务器（在此会话中对当前名称服务器进行任何先前更改之前） . |
| ***root\***                   | 将默认名称服务器更改为 DNS 根名称服务器之一。                |
| ***ls [-t <type>] <name>\***  | 通过进行区域传输，请求可用于指定域名的信息列表。默认情况下，列出与域关联的主机名和地址； “-t”选项可用于将输出限制为特定记录类型。也可以定义其他选项。 大多数服务器将区域传输的使用限制在指定的从属服务器上，因此该命令可能不适用于普通客户端。 |
| ***help\***                   | 显示帮助信息（通常是有效命令和选项的列表）。                 |
| ***?\***                      | 与“帮助”相同（仅在某些系统上）。                             |
| ***set all\***                | 显示所有 nslookup 选项的当前设置                             |
| ***set <option>[=<value>]\*** | 设置一个选项来控制实用程序的行为。大多数实现包括相当多的选项，其中一些选项仅通过指定关键字来控制，而其他选项则需要选项的值。例如，“set recurse”告诉程序使用递归解析，而“set norecurse”将其关闭； “set retry=3”将重试次数设置为 3。 |
| ***exit\***                   | 退出程序。                                                   |

<u>**nslookup 的问题**</u>
nslookup 实用程序广泛部署在 UNIX 和 Windows 系统上，但该程序并非没有批评者。对它的抱怨主要集中在它使用非标准方法获取信息，而不是标准的解决程序。我还读过一些报告，说它在某些情况下会产生虚假结果。该命令的一个重大问题示例是，如果它无法对其自身的 IP 地址执行反向查找，它将中止。这可能会导致混淆，因为用户会将该错误误认为是试图查找他们正在查找的名称的错误。

由于这个和其他原因，UNIX 圈子中的许多人认为 nslookup 是某种“hack”，因此，在一些较新的 UNIX 中，nslookup 已被弃用。这仅仅意味着它仍然包含在操作系统中以实现兼容性，但不推荐，将来可能会被删除。相反，提供了一对较新的实用程序：host 和 dig。

<u>**主机实用程序**</u>

nslookup 的第一个替代方法，主机，最常用于简单的查询，例如通常使用 nslookup 的非交互模式执行的查询。 它的调用方式与非交互式 nslookup 相同：

```
host <host> [<server>]
```

输出也类似于非交互式 nslookup 的输出，但不那么冗长。 表 292 中显示了一个示例。


​                                                           表 292：使用主机实用程序的 DNS 名称解析

```
%host www.pcguide.com
www.pcguide.com is an alias for pcguide.com.
pcguide.com has address 209.68.14.80
```

尽管主机不以交互方式运行，但它包含许多选项，可以让管理员获得与使用 nslookup 的交互模式获得的信息相同的信息。 表 293 中显示了一些更常见的选项。


​                                                          表 293：典型的主机实用程序选项和参数

| **Option / Parameters** | **Description**                                              |
| ----------------------- | ------------------------------------------------------------ |
| ***-d\***               | 开启调试模式。                                               |
| ***-l\***               | 提供域的完整信息列表；这类似于交互式 nslookup 中的“ls”命令。这可以与“-t”选项一起使用，以便仅为域选择特定类型的资源记录。 |
| ***-r\***               | 在请求中禁用递归。指定时，只有直接查询的服务器才会返回任何信息；它不会查询其他服务器。 |
| ***-t <querytype>\***   | 指定对特定资源记录类型的查询，允许检索任何类型的 DNS 信息。  |
| ***-v\***               | 使用详细模式进行输出（提供了其他详细信息）。                 |
| ***-w\***               | 等待响应所需的时间（无超时）。                               |

<u>**dig 实用程序**</u>

nslookup 的第二个替代品是 dig，它代表“Domain Information Groper”（可能是对名称“ping”的假定来源的一种游戏）。它与主机命令的不同之处在于它提供了关于域的更多信息，即使以最简单的方式调用也是如此。它也相当复杂，有大量的选项，以及用于获取有关许多域的信息的批处理模式等功能。

dig 命令的基本语法与 nslookup 或 host 不同，因为如果指定了非默认名称服务器，它会在要查找的主机之前加上一个 at 符号（“@”）作为前缀。还可以指定特定类型的资源记录，如下所示：

```
dig [@<server>] <host> [<type>]
```

表 294 显示了在我用作 nslookup 和主机示例的同一域 (www.pcguide.com) 上运行 dig 的输出。您可以看到它提供了有关域的更多信息。


​                                                表 294：使用 dig 实用程序的 DNS 名称解析

```
%dig www.pcguide.com
; <<>> DiG 9.2.1 <<>> www.pcguide.com
;; global options: printcmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 15912
;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 2, ADDITIONAL: 0

;; QUESTION SECTION:
;www.pcguide.com. IN A

;; ANSWER SECTION:
www.pcguide.com. 3600 IN CNAME pcguide.com.
pcguide.com. 3600 IN A 209.68.14.80

;; AUTHORITY SECTION:
pcguide.com. 3600 IN NS ns0.ns0.com.
pcguide.com. 3600 IN NS ns23.pair.com.

;; Query time: 1840 msec
;; SERVER: 209.68.1.87#53(209.68.1.87)
;; WHEN: Tue Nov 18 16:05:08 2003
;; MSG SIZE rcvd: 109Server: ns1-mar.starband.com
```

dig 命令还允许查找特定类型的资源记录，并包括许多选项和设置。由于这个主题已经很长了，而且 dig 是迄今为止三个实用程序中最先进的，所以我就到此为止；有关 dig 如何工作的完整说明及其参数列表，请参阅系统文档。

**关键概念：**大多数 TCP/IP 实现都提供一个或多个实用程序，管理员可以使用这些实用程序手动将 DNS 域名解析为 IP 地址或执行相关的 DNS 信息搜索。最常见的一种是 nslookup，它允许将主机名转换为地址，反之亦然；它具有交互和非交互模式。在某些操作系统上，nslookup 已被用于简单 DNS 查找的主机实用程序和用于更详细地检查 DNS 资源信息的 dig 程序所取代。


internet：dig 实用程序非常有用，但在某些系统上仍未实现。幸运的是，您可以使用浏览器在 Internet 上访问在线挖掘实用程序。在 http://www.gont.com.ar/tools/dig 找到它。

#### 4.4.6 TCP/IP DNS 注册数据库查找实用程序（whois/nicname）（部分：1 2 3）

nslookup 和 host 等实用程序允许管理员将 DNS 域名解析为地址，还可以查看有关域资源记录的详细信息。然而，在某些情况下，我们需要知道的不是关于域的技术信息，而是它的 DNS 注册信息。这包括诸如哪个组织拥有该域、其注册何时到期以及谁是管理它的指定联系人等详细信息。

在 DNS 的早期，所有域名都由一个称为 Internet 网络信息中心（InterNIC 或简称为 NIC）的机构集中注册。为了让互联网用户可以查询域名和联系人的信息，该中心设立了一个专门的服务器。创建了一个协议以允许用户从此服务器检索信息，称为 nicname 和 whois。它最初在 RFC 812 (1982) 中描述，后来在 RFC 943 (1985) 中描述。随着时间的推移，“whois”这个名称已成为两者中的首选名称，并且是今天用于允许管理员查找 DNS 注册数据的实用程序的名称。 （它也可用于查找有关 IP 地址的信息，但很少用于此目的。）

随着 Internet 的发展壮大，它当然不再拥有单一的中央集权机构。现代 Internet 具有层次结构的授权机构，负责在 DNS 名称空间的不同部分注册域名。近年来，放松管制的过程使情况变得更加复杂，该过程允许对通用顶级域（例如 .COM、.NET 和 .ORG）进行多个注册。所有这些都意味着需要做更多的工作来查找域注册信息，因为它分布在不同服务器上的许多数据库中。

<u>**whois 实用程序的语法和使用**</u>
为了使管理员更容易在这个大型分布式数据库中找到有关域的信息，现代 TCP/IP 实现通常带有智能版本的 whois 实用程序。它能够接受域名称作为输入，并自动找到该域信息所在的适当注册表。该实用程序通常使用如下：

```
whois [-h <whois-host>] <domain>
```

在此语法中，“<domain>”表示请求注册信息的名称。管理员可以使用“-h”参数强制程序查询特定的 whois 服务器，但同样，这通常不是必需的。一些实现还包括可用于将查询定向到特定注册表的其他选项。

<u>**whois 输出示例**</u>

表 295 显示了 whois 命令在 FreeBSD UNIX 机器上的示例输出（我已经删除了一些初步的一般信息和法律免责声明以保持表格的大小）。

​                                           表 295：使用 whois 程序查找 DNS 域注册表

![image-20221123011722294](C:\Users\zy\AppData\Roaming\Typora\typora-user-images\image-20221123011722294.png)

在这种情况下，域“pcguide.com”的注册商是 pairNIC，pair Networks 的 DNS 注册部门，我多年来一直使用这家公司进行网络托管（自 1997 年以来，如您所见）。 此输出是公共信息，无论出于何种原因，任何对 pcguide.com 感兴趣的人都可以确定我拥有该域并了解如何与我联系。 （当然，这显然不是我的真实电话号码。）它还告诉他们 pair Networks 运行包含我域的域信息的名称服务器。

<u>**第三方 whois 工具**</u>

包括 Windows 在内的许多操作系统都没有 whois 命令实现，但有第三方程序可以支持该功能。近年来，许多不同的组织也设立了实施whois功能的网站，这对于那些更习惯于Windows等图形操作系统的人来说更加方便和用户友好。这些站点中的许多站点都由 DNS 注册商提供免费服务，因此客户可以检查他们感兴趣的名称是否已被占用，如果是，被谁占用。

其中一些系统的一个缺点是它们通常没有智能来检查存储域名记录的所有不同注册管理机构。在大多数情况下，注册商提供的 whois 服务只会搜索注册商运营的特定顶级域 (TLD) 中的名称。因此，如果注册商处理 .COM、.ORG 和 .NET，它可能只支持对这些 TLD 的 whois 查询。要检查更模糊的 TLD 中域的注册信息，例如一些不太常见的地缘政治（国家代码）域，可能需要进行大量搜索。

关键概念：TCP/IP whois 实用程序允许显示 DNS 域的注册信息，例如其所有者、联系信息和注册到期日期。该程序最常在 UNIX 操作系统上找到，它具有智能，可以自动查询正确的服务器以查找大多数域的信息。较新的基于 Web 的 whois 实用程序现在也存在，但通常仅限于显示有关顶级域的特定子集中域的信息。



#### 4.4.7 TCP/IP 网络状态实用程序 (netstat)（部分：1 2 3 4 5 6）

TCP/IP 是一个非常复杂的协议族，我相信您在仔细阅读本指南的内容后会同意这一点。令人惊讶的是，大多数时候，所有不同的协议、服务和程序都能高效而安静地执行它们的工作。我们大多数人甚至都没有意识到后台发生了多少事情，而这本该如此。  另一方面，当 TCP/IP 网络确实出现问题时，负责修复问题的管理员需要获得尽可能多的信息，了解套件的所有细节在幕后所做的工作。网络状态实用程序 netstat 就是为此目的而提供的。

netstat 程序在概念上非常简单，仅用于一个目的：显示有关设备上 TCP/IP 操作的信息。然而，前面提到的 TCP/IP 的复杂性导致 netstat 本身相当复杂：该程序可以提供大量不同的信息。与往常一样，netstat 的选项和输出取决于特定的操作系统类型和版本。它在 UNIX 和 Windows 机器上有些不同，所以我将分别描述每个平台。

<u>**UNIX 网络统计**</u>

在大多数 UNIX 系统上，netstat 实用程序功能非常全面，典型的实现包括许多可用于控制显示哪些信息的选项。 这些选项可能不会同时使用； 相反，它们被安排到选项组中，每个选项组代表一类信息。 在每一组中，一个选项是强制性的； 它标识组，因此标识将显示的一般信息类型。 每个组中也可能有其他选项，这些选项是可选的，可以修改命令以更好地控制输出的确切内容。 那么，从本质上讲，netstat 真的就像许多相关的实用程序合二为一。

<u>**UNIX netstat 选项组、选项和参数**</u>
表 296 提供了典型 UNIX netstat 实现的选项组的简化摘要，在本例中为 FreeBSD。


​                                                           **表 296：典型的 UNIX netstat 选项组、选项和参数**

| **Option Group, Options and Parameters**                     | **Description**                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ***netstat [-AaLSW] [-f <family>] [-p <protocol>] [-n]\***   | 这是 netstat 的默认调用，没有强制选项。它提示实用程序显示主机上的活动套接字列表。显示的其他选项可用于控制精确输出的内容；例如，“-a”也会显示服务器进程。 |
| ***netstat -i [-abdt] [-f <family>] [-n] netstat -I <interface> [-abdt] [-f <family>] [-n]\*** | 告诉 netstat 提供有关所有网络接口（“-i”）或特定网络接口（“-I <interface>”）的信息。 “-a”选项也会显示多播地址，“-b”显示接口上进出的数据字节，“-d”显示丢弃的数据包数，“-t”显示看门狗定时器。 |
| ***netstat -w <interval> -d [-I <interface>]\***             | 每“<interval>”秒显示所有接口上的数据包流量信息，如果包含“-I <interface>”，则仅显示指定接口上的数据包流量信息。如果包含“-d”，则还表示丢弃的数据包数。 |
| ***netstat -s [-s] [-z] [-f <family>] [-p <protocol>]\***    | 显示系统上每个协议的系统范围统计信息（可以修改以仅显示特定地址系列或协议的信息）。如果重复“-s”选项，则抑制值为零的计数器； “-z”选项在显示后重置统计信息。 |
| ***netstat -i -s [-f <family>] [-p <protocol>] netstat -I <interface> -s [-f <family>] [-p <protocol>]\*** | 显示上面“netstat -s”的统计信息，但基于每个接口而不是为整个系统聚合。 |
| ***netstat -m\***                                            | 输出内存管理例程统计信息。                                   |
| **netstat -r [-Aa] [-f <family>] [-n] [-W]**                 | 显示主机路由表的内容。选项“-A”和“-a”提供有关路由的附加信息。 |
| **netstat -rs [-s]**                                         | 显示路由统计信息； “-s”禁止具有零值的计数器。                |
| **netstat -g [-W] [-f <family>]**                            | 显示组播路由信息。                                           |
| **netstat -gs [-s] [-f <family>]**                           | 显示组播路由统计信息； “-s”禁止具有零值的计数器。            |

<u>**UNIX netstat 通用选项和参数**</u>

这些选项组中显示的大多数选项都是特定于这些组的； 例如，在发出命令“netstat -i”时不能使用“-s”。 但是，还有许多通用选项可以与这些组中的多个一起使用，以一致的方式修改 netstat 变体的行为。 表 297 中描述了这些选项。


​                                                                          **表 297：典型的 UNIX netstat 通用选项和参数**

| **Option / Parameters** | **Description**                                              |
| ----------------------- | ------------------------------------------------------------ |
| ***-f <family>\***      | 对于运行多个协议套件的主机，将命令的输出限制为有关特定协议地址系列的信息。例如，常规 TCP/IP 的地址族是“inet”，而 IPv6 的地址族是“inet6”。也可以支持其他人。 |
| ***-p <protocol>\***    | 将输出限制为仅与特定协议相关的数据，例如 IP、TCP、UDP 或 ICMP。 |
| ***-n\***               | 以数字形式显示网络地址，而不是将它们显示为符号名称。还将端口显示为数字，而不是将众所周知的 UDP 和 TCP 端口号转换为使用它们的协议名称（例如，“23”而不是“telnet”）。 |
| ***-W\***               | 抑制地址的自动截断（有时是为了显示格式）。                   |

<u>**示例 UNIX netstat 输出**</u>

netstat 命令可以产生数量惊人的输出，尤其是如果您不使用表 297 中的某些选项来限制它。对于 netstat 本身和“-s”选项尤其如此。 在表 298 中，我展示了运行“普通”netstat 的示例输出，但我已经截断了连接列表以使其不会太长（我还重新格式化了表格以使其显示效果更好）。 请注意最后一列，它显示了 TCP 连接的当前状态（请参阅，TCP 有限状态机的东西毕竟很有用！J）表 299 显示了“netstat -s”的输出示例； 在这里，我通过使用“-p ip”告诉程序只显示 Internet 协议的统计信息来缩短输出的大小。


​                                                     **表 298：来自 UNIX netstat 实用程序的示例连接列表**

```
%netstat
Active Internet connections
Prot Rcv Snd Local Address Foreign Address (state)
tcp4 0 0 pcguide.com.http c-24-118-141-124.3384 ESTABLISHED
tcp4 0 827 pcguide.com.http webcacheB03a.cac.46075 ESTABLISHED
tcp4 0 0 qs36.smtp MV1-24.171.17.64.1339 ESTABLISHED
tcp4 0 0 pcguide.com.http 1Cust234.tnt1.le.1338 ESTABLISHED
tcp4 0 0 pcguide.com.http 1Cust234.tnt1.le.1337 FIN_WAIT_1
tcp4 0 84 pcguide.com.http dial81-131-97-70.2902 FIN_WAIT_1
tcp4 0 0 pcguide.com.http 216.76.14.221.9954 FIN_WAIT_2
tcp4 0 0 pcguide.com.http 216.76.14.221.9945 FIN_WAIT_2
tcp4 0 0 pcguide.com.http 1Cust234.tnt1.le.1326 TIME_WAIT
```

​                                                   **表 299：来自 UNIX netstat 实用程序的示例 IP 统计信息**

```
%netstat -s -p ip
ip:
57156204 total packets received
0 bad header checksums
4 with size smaller than minimum
0 with data size < data length
0 with ip length > max ip packet size
0 with header length < data size
0 with data length < header length
0 with bad options
0 with incorrect version number
138 fragments received
6 fragments dropped (dup or out of space)
128 fragments dropped after timeout
2 packets reassembled ok
57085912 packets for this host
24736 packets for unknown/unsupported protocol
0 packets forwarded (0 packets fast forwarded)
44957 packets not forwardable
4 packets received for unknown multicast group
0 redirects sent
66183465 packets sent from this host
177 packets sent with fabricated ip header
0 output packets dropped due to no bufs, etc.
0 output packets discarded due to no route
0 output datagrams fragmented
0 fragments created
0 datagrams that can't be fragmented
0 tunneling packets that can't find gif
22 datagrams with bad address in header
```

<u>**Windows 网络统计**</u>

Windows netstat 实用程序比 UNIX 实用程序简单得多，因为它的选项少得多。 这对我们这些学习该程序的人来说是件好事，但对于那些希望在使用它时获得最大功能和灵活性的人来说就不是那么好了。

<u>**Windows netstat 选项组、选项和参数**</u>
与 UNIX netstat 一样，Windows 有一组选项组，这些选项组规定了显示的一般信息类型，以及一些可以与多个组一起使用的通用选项。 选项组和通用选项显示在表 300 和表 301 中。

​                                                             **表 300：典型的 Windows netstat 选项组、选项和参数**

| **Option Group, Options and Parameters**                | **Description**                                              |
| ------------------------------------------------------- | ------------------------------------------------------------ |
| ***netstat [-n] [-o] [<interval>]\***                   | 在没有强制选项的情况下调用时，netstat 显示有关活动 TCP 连接的信息。 |
| ***netstat -a [-n] [-o] [-p <protocol> [<interval>]\*** | 显示所有活动的 TCP 连接，以及主机正在侦听的 TCP 和 UDP 端口。 |
| ***netstat -e [<interval>]\***                          | 显示以太网接口的统计信息。                                   |
| ***netstat -r [<interval>]\***                          | 显示设备的当前路由表。                                       |
| ***netstat -s [-p <protocol>] [<interval>]\***          | 按协议显示系统的 TCP/IP 统计信息。                           |

​                                                                       **表 301：典型的 Windows netstat 通用选项和参数**

| **Option / Parameters** | **Description**                                              |
| ----------------------- | ------------------------------------------------------------ |
| ***-n\***               | 以数字形式而不是符号名称形式显示网络地址。还以数字形式显示端口，而不是显示与众所周知的 UDP 或 TCP 端口号关联的标准进程名称。 |
| ***-o\***               | 显示与每个连接关联的进程 ID。                                |
| ***-p <protocol>\***    | 将显示限制为仅显示与指定协议关联的信息。                     |
| ***<interval>\***       | 使 netstat 命令每隔“<interval>”秒重复一次，而不是只显示一次其信息。这可以与任何 netstat 选项组一起使用。例如，“netstat -s 5”将每五秒显示一次 TCP/IP 统计信息。 |

<u>**示例 Windows netstat 输出**</u>

当给出相同或相似的选项时，Windows netstat 程序的输出与 UNIX 实用程序的输出非常相似，但 UNIX 版本通常提供更多详细信息。 我在表 302 中展示了一个示例，说明了我家用 Windows XP 机器上的 TCP/IP 统计信息，使用“-p icmp”将输出限制为仅 ICMP 统计信息。 表 303 显示了 netstat 的路由表显示（我对其进行了轻微修改以适应表的大小限制。）您将获得与 UNIX“netstat -s -p icmp”或“netstat -r”命令类似的输出， 但会提供更多信息。


​                                                        **表 302：来自 Windows netstat 实用程序的示例 ICMP 统计信息**

```
D:\aa>netstat -s -p icmp
ICMPv4 Statistics

Received Sent
Messages 243 248
Errors 0 0
Destination Unreachable 9 4
Time Exceeded 7 0
Parameter Problems 0 0
Source Quenches 0 0
Redirects 0 0
Echos 224 20
Echo Replies 3 224
Timestamps 0 0
Timestamp Replies 0 0
Address Masks 0 0
Address Mask Replies 0 0
```

​                                                    **表 303：来自 Windows netstat 实用程序的示例路由表显示**

```
D:\aa>netstat -r
Route Table
=================================================================
Interface List
0x1 ........................... MS TCP Loopback interface
0x2 ...00 04 76 4e 75 3f ...... 3Com 10/100 Mini PCI Ethernet
=================================================================
=================================================================
Active Routes:
Network Dest Netmask Gateway Interface Met
0.0.0.0 0.0.0.0 148.64.128.1 148.64.133.73 30
127.0.0.0 255.0.0.0 127.0.0.1 127.0.0.1 1
148.64.128.0 255.255.192.0 148.64.133.73 148.64.133.73 30
148.64.133.73 255.255.255.255 127.0.0.1 127.0.0.1 30
148.64.255.255 255.255.255.255 148.64.133.73 148.64.133.73 30
224.0.0.0 240.0.0.0 148.64.133.73 148.64.133.73 30
255.255.255.255 255.255.255.255 148.64.133.73 148.64.133.73 1
Default Gateway: 148.64.128.1
=================================================================
Persistent Routes:
None
```

**关键概念：**TCP/IP 实现包括 netstat 实用程序，以允许显示有关网络状态的信息。 在 UNIX 系统上，netstat 是一个功能齐全的程序，其中有许多选项排列成选项组，每个选项显示有关 TCP/IP 协议操作的特定类型的信息。 在 Windows 系统上，netstat 的功能稍有限制，但仍允许显示大量信息。

#### 4.4.8 TCP/IP 配置实用程序（ipconfig、winipcfg 和 ifconfig）（部分：1 2 3 4 5）

任何网络管理员工作的一个重要部分是设置和维护使 TCP/IP 网络正常运行的设备，这个过程通常称为配置。网络主机由硬件和软件组成，它们协同工作以实现协议栈的所有层和功能。管理员使用硬件工具来配置物理设备，执行诸如安装网络接口卡、连接电缆以及操纵开关和其他硬件设置等任务。同样，需要工具来配置运行 TCP/IP 接口的软件并控制网络主机上更高层协议的操作。

<u>**ifconfig 实用程序**</u>
在 UNIX 系统上，接口配置实用程序 ifconfig 用于查看和修改控制 TCP/IP 如何在主机上运行的软件设置。它是一个非常强大的程序，允许管理员设置和管理范围广泛的网络设置。 ifconfig 的实现即使在不同的 UNIX 之间也有很大差异——虽然大多数在一般意义上是相似的，但它们可能有相当不同的选项和语法。

ifconfig 程序可用于多种目的：创建或删除网络接口、更改其设置或简单地检查现有配置。因此，就像 netstat 实用程序一样，ifconfig 实际上就像几个相关的程序组合成一个程序，使用程序的特定模式取决于调用它的语法。并且与 netstat 一样，ifconfig 有许多通用选项，可以应用于它的许多不同用途。

<u>**ifconfig 语法、选项和参数**</u>

表 304 提供了 ifconfig 可以执行的不同功能的简化摘要，以及用于在典型 UNIX 实现（在本例中为 NetBSD）中指定每个功能的语法。 表 305 描述了可用于其中许多不同模式的常用选项和参数。 当 ifconfig 用于修改接口的配置时，这是通过设置几十个配置参数中的任何一个来完成的，使用表 304 最后一行所示的语法； 我在表 306 中提供了一些示例参数的简要说明（有关完整列表，请参阅您的 ifconfig 文档）。


​                                                    **表 304：典型的 UNIX ifconfig 语法、选项和参数**

| **Syntax, Options and Parameters**                           | **Description**                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ***ifconfig [-L] [-m] <interface>\***                        | 当 ifconfig 仅使用接口规范而没有其他选项（除了可能的“-L”和“-m”）被调用时，它会显示该网络接口的配置信息。注意在没有界面的情况下单独输入“ifconfig”只会显示该参数的帮助信息；要查看所有接口，应使用“-a”参数。 |
| ***ifconfig -a [-L] [-m] [-b] [-d] [-u] [-s] [<family>]\***  | 显示有关主机上所有接口的信息。可以使用显示的通用参数或指定地址族来限制输出（参见表 305）。 |
| ***ifconfig -l [-b] [-d] [-u] [-s]\***                       | 列出系统上所有可用的接口。                                   |
| ***ifconfig <interface> create\***                           | 在主机上创建指定的逻辑网络接口，然后使用此表最后一行中显示的语法对其进行配置。请注意，UNIX 的某些变体允许在创建时设置某些参数。 |
| ***ifconfig <interface> destroy\***                          | 销毁指定的逻辑接口。                                         |
| ***ifconfig <interface> [<family>] [<address> [<dest_address>]] [<parameters>]\*** | 为主机上的特定接口配置参数。如果正在设置地址，则它是指定的第一个参数，在可选地址族之后（如果存在）。 “<dest_address>”用于指定点对点链路的目标地址。在此之后，可以为接口指定几十个参数中的任何一个，其中一些参数显示在表 306 中。 |

​                                                    **表 305：典型的 UNIX ifconfig 通用选项和参数**

| **Option / Parameter** | **Description**                                              |
| ---------------------- | ------------------------------------------------------------ |
| ***-L\***              | 显示 IPv6 地址的地址生命周期。                               |
| ***-m\***              | 显示接口所有支持的媒体。                                     |
| ***-b\***              | 将接口信息的显示限制为广播接口。                             |
|                        | 仅显示当前关闭（禁用）的接口。                               |
| ***-u\***              | 仅显示当前启动（运行）的接口。                               |
| ***-s\***              | 仅显示可能连接的接口。                                       |
| ***<family>\***        | 指定一个特定的地址系列，以限制输出或指示正在配置的地址类型。值“inet”用于 IPv4，“inet6”用于 IPv6。 |

​                                                       **表 306：典型的 UNIX ifconfig 接口配置参数**

| **Parameters**        | **Description**                                            |
| --------------------- | ---------------------------------------------------------- |
| ***alias / -alias\*** | 建立或删除网络地址别名。                                   |
| ***arp / -arp\***     | 在此接口上启用/禁用 ARP。                                  |
| ***delete\***         | 删除指定的网络地址。                                       |
| ***down\***           | 将接口标记为“关闭”，将其禁用。                             |
| ***media <type>\***   | 将接口的媒体类型设置为特定值。                             |
| ***mtu <n>\***        | 设置接口的最大传输单元 (MTU)。                             |
| ***netmask <mask>\*** | 为接口地址设置网络或子网掩码。                             |
| ***prefixlen <n>\***  | 与“网络掩码”相同，但允许使用 CIDR 样式的前缀长度指定掩码。 |
| ***up\***             | 设置一个接口“up”，启用它。                                 |

注意：由于创建、销毁或修改接口会导致主机停止正常工作，因此大多数系统通常需要管理（超级用户）权限才能使用 ifconfig 执行除检查现有配置之外的任何操作。

<u>**ifconfig 示例输出**</u>
在表 307 中，我提供了在我经常使用的一台 UNIX 机器上执行“ifconfig -a”命令的示例输出，显示了其接口的设置。

​                                                        **表 307：来自 Windows netstat 实用程序的示例路由表显示**

```
%ifconfig -a
fxp0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500
address: 00:a0:c9:8c:f4:a1
media: Ethernet autoselect (100baseTX full-duplex)
status: active
inet 166.84.1.3 netmask 0xffffffe0 broadcast 166.84.1.31
inet alias 166.84.1.13 netmask 0xffffffff broadcast 166.84.1.13
lo0: flags=8009<UP,LOOPBACK,MULTICAST> mtu 33228
inet 127.0.0.1 netmask 0xff000000
```

<u>**ipconfig 实用程序**</u>

Windows 采用与 UNIX 不同的网络配置方法。正如我们所见，UNIX ifconfig 程序可用于查看和修改范围广泛的配置参数。然而，在 Windows 中，大多数设置和参数修改都是使用 Windows 控制面板完成的。 Windows 确实包含一个有点类似于 UNIX 的 ifconfig 的实用程序，但它的功能要少得多，并且主要用于检查现有配置，而不是更改它。它还允许管理员轻松地在主机上执行一些简单的功能。

<u>**ipconfig 选项和参数**</u>
在大多数较新版本的 Windows 上，与 ifconfig 等效的是一个名为 ipconfig 的命令行实用程序。与 ifconfig 一样，Windows 实用程序是使用提供给程序的选项来控制的。但是，因为它比 ifconfig 简单得多，所以只有几个不同的选项可以使用。这些总结在表 308 中。


​                                                                 表 308：典型的 Windows ipconfig 选项和参数

| **Option / Parameters**                  | **Description**                                              |
| ---------------------------------------- | ------------------------------------------------------------ |
| ***(none)\***                            | 当不带任何选项或参数调用时，ipconfig 显示主机上每个接口的 IP 地址、子网掩码和默认网关。 |
| ***/all\***                              | 类似于调用不带选项的 ipconfig，但显示有关主机接口的更详细的配置信息。 |
| ***/release [<adapter>]\***              | 释放（终止）指定适配器（接口）或所有接口（如果未提供）上的 DHCP 租约。 |
| ***/renew [<adapter>]\***                | 手动续订指定适配器（接口）或所有适配器（如果未提及）的 DHCP 租约。 |
| ***/displaydns\***                       | 显示主机的 DNS 解析器缓存的内容。                            |
| ***/flushdns\***                         | 清除主机的 DNS 解析器缓存。                                  |
| ***/registerdns\***                      | 刷新（更新）所有 DHCP 租约并重新注册与主机关联的任何 DNS 名称。 |
| ***/showclassid <adapter>\***            | 显示与此适配器关联的 DHCP 类 ID（这些 ID 用于将客户端安排到 DHCP 服务器给予不同处理的组中。）必须指定适配器，即使只有一个适配器。 |
| ***/setclassid <adapter> [<classid>]\*** | 修改指定适配器的 DHCP 类 ID。                                |

如前所述，ipconfig 最常用于检查现有配置。 当需要简化的信息时，它被调用时没有任何选项； 表 309 中显示了此命令的输出示例。有关接口的详细信息，使用“/all”选项； 表 310 中有一个示例（略有修改以便于阅读）。

<u>**ipconfig 示例输出**</u>

从表 308 中的选项列表可以看出，ipconfig 的大多数非查看用途实际上与配置主机无关，而是控制 DNS 和 DHCP 等协议的运行。 ipconfig 的一个常见用途是强制主机寻找新的 DHCP 租约，可以使用“ipconfig /release”后跟“ipconfig /renew”来完成。


​                                                         **表 309：来自 Windows ipconfig 实用程序的简化配置信息**

```
D:\aa>ipconfig
Windows IP Configuration

Ethernet adapter Local Area Connection 2:

Connection-specific DNS Suffix . :
IP Address. . . . . . . . . . . . : 148.64.133.73
Subnet Mask . . . . . . . . . . . : 255.255.192.0
Default Gateway . . . . . . . . . : 148.64.128.1
```

​                                                        **表 310：来自 Windows ipconfig 实用程序的详细配置信息**

```
D:\aa>ipconfig /all
Windows IP Configuration

Host Name . . . . . . . . . . . . : ixl
Primary Dns Suffix . . . . . . . :
Node Type . . . . . . . . . . . . : Hybrid
IP Routing Enabled. . . . . . . . : No
WINS Proxy Enabled. . . . . . . . : No

Ethernet adapter Local Area Connection 2:

Connection-specific DNS Suffix . :
Description . . . . . . . . . . . : 3Com PCI Ethernet Adapter
Physical Address. . . . . . . . . : 00-04-76-4E-75-3F
Dhcp Enabled. . . . . . . . . . . : Yes
Autoconfiguration Enabled . . . . : Yes
IP Address. . . . . . . . . . . . : 148.64.133.73
Subnet Mask . . . . . . . . . . . : 255.255.192.0
Default Gateway . . . . . . . . . : 148.64.128.1
DHCP Server . . . . . . . . . . . : 148.64.128.1
DNS Servers . . . . . . . . . . . : 148.78.249.200
148.78.249.201
Lease Obtained. . . . . . . . . . : April 19, 2003 11:51:37 AM
Lease Expires . . . . . . . . . . : April 19, 2003 12:21:37 PM
```

<u>**winipcfg 实用程序**</u>

在早期版本的 Windows 中，提供了一个名为 winipcfg 的图形工具（代替 ipconfig 命令行实用程序，或者作为其补充）。该程序允许以与 ipconfig 大致相同的方式检查配置参数，还允许释放和更新 DHCP 租约，但不支持 ipconfig 的其他选项（例如显示主机的 DNS 缓存）。主 winipcfg 屏幕的示例如图 322 所示。

![](D:\网络\网络相关文章\网络分析架构与设计\The-TCP-IP-Guide-master\TCP-IP 指南整理文档\image\winipcfg.gif)


​                                                           图 322：Windows 95/98/ME winipcfg 实用程序

winipcfg 实用程序可用于较早的面向消费者的 Windows 版本，以检查主机的配置并释放/更新 DHCP 租约。

**关键概念：**在 UNIX 系统上，ifconfig 实用程序可用于显示或修改大量 TCP/IP 配置设置。 Windows 系统提供命令行实用程序 ipconfig 或图形工具 winipcfg。两者都允许管理员查看主机的基本 TCP/IP 配置信息，并允许执行更新 DHCP 租约等任务，但与 UNIX ifconfig 程序相比，它们在其他方面非常有限。



#### 4.4.9 Miscellaneous TCP/IP Troubleshooting Protocols: Echo, Discard, Character Generator, Quote Of The Day, Active Users, Daytime, Time

一句老话说，生命中唯一的保证就是死亡和税收。说到网络，你可以再补充几个，包括这个：一旦你建立了一个网络，它很快就会出现问题，你需要解决。认识到 TCP/IP 互联网络的复杂性会使诊断某些问题变得困难，该套件的架构师定义了许多有助于测试和排除网络故障的杂项实用程序协议。尽管已经存在了 20 多年，但这些协议有些晦涩难懂并且很少受到关注。我也不会花太多时间在它们上面（因为它们不再在许多系统上实现）但我确实觉得它们值得快速浏览一下。

这些简单的协议旨在实现为在 TCP/IP 服务器上运行的服务。每个都在专用的众所周知的端口号上侦听请求，然后以特定类型的信息进行响应。这些协议可以与 TCP 和 UDP 一起使用，从而可以测试每个传输协议。在 UDP 的情况下，服务器将发送给它的每个 UDP 都计为一个请求，并向它发送一个响应。当与 TCP 一起使用时，当然首先由客户端与服务器建立连接。在某些协议中，此连接用于在客户端和服务器之间连续发送数据；在其他情况下，连接的建立被认为是对服务器的隐含请求，服务器将立即发送响应，然后关闭连接。

表 311 简要描述了 UDP 和 TCP 下的每种故障排除协议/服务。如果您需要更多信息，我已经为每个服务显示了服务使用的端口号，以及定义它的 RFC。

​                                                                      **表 311：其他 TCP/IP 故障排除协议**

| **Protocol**                 | **Well-Known Port Number** | **Defining RFC** | **Description**                                              |
| ---------------------------- | -------------------------- | ---------------- | ------------------------------------------------------------ |
| Echo Protocol                | 7                          | 862              | 回声接收到的数据返回给它的发起者。当在 UDP 上使用时，每条消息的有效负载被简单地打包成返回 UDP 数据报并发回。对于 TCP，客户端发送的每个字节都会被服务器回显，直到连接关闭。 |
| Discard Protocol             | 9                          | 863              | 丢弃所有发送给它的数据。我觉得这应该叫“黑洞协议”。           |
| Character Generator Protocol | 19                         | 864              | 生成数据的随机字符并将它们发送到设备。当与 UDP 一起使用时，发送到服务器的每个 UDP 消息都会导致服务器发回包含随机数（0 到 512 字节）数据的 UDP 消息。当与 TCP 一起使用时，服务器会在客户端建立连接后立即开始发送字符，并一直持续到客户端终止连接为止。 |
| Quote of the Day Protocol    | 17                         | 865              | 向客户端设备发送一条短消息（由服务器管理员选择）。对于 UDP，为每个传入的 UDP 消息发送消息；对于TCP，消息在建立连接时由服务器发送一次，然后关闭。 |
| Active Users                 | 11                         | 866              | 将活动用户列表发送到设备。对于 UDP，列表是为每个传入的 UDP 消息发送的；如果它超过 512 字节，它将在多个消息中发送。对于 TCP，当连接到服务器时自动发送列表，然后连接终止。 |
| Daytime Protocol             | 13                         | 867              | 以人类可读的形式返回服务器上的当前时间，以响应收到的 UDP 消息或传入的 TCP 连接。 |
| Time Protocol                | 37                         | 868              | 以机器可读的形式返回当前时间——特别是自格林威治标准时间 1900 年 1 月 1 日午夜以来的秒数。时间是为服务器收到的每个 UDP 消息发送的，或者在建立 TCP 连接时发送的。请注意，此协议不能用于服务器的时间同步，因为它不会补偿通过互联网传输消息所需时间的可变性。 |





​														                    **------- END  -------** 

------

作者:郑岳  日期:2022
